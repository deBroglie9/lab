
SLAVES_CM4.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08100000  08100000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000105e0  081002a0  081002a0  000012a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000b5c  08110880  08110880  00011880  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  081113dc  081113dc  000123dc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  081113e4  081113e4  000123e4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  081113e8  081113e8  000123e8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000598  10000000  081113ec  00013000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          00005198  10000598  08111984  00013598  2**2
                  ALLOC
  8 ._user_heap_stack 00000600  10005730  08111984  00013730  2**0
                  ALLOC
  9 .openamp_section 0000008c  38000000  08111984  00014000  2**2
                  ALLOC
 10 .ARM.attributes 00000030  00000000  00000000  00013598  2**0
                  CONTENTS, READONLY
 11 .debug_info   0002ce21  00000000  00000000  000135c8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_abbrev 000073b9  00000000  00000000  000403e9  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_aranges 00002340  00000000  00000000  000477a8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_rnglists 00001b04  00000000  00000000  00049ae8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_macro  0004507e  00000000  00000000  0004b5ec  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_line   00031295  00000000  00000000  0009066a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_str    0019bcd0  00000000  00000000  000c18ff  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .comment      00000043  00000000  00000000  0025d5cf  2**0
                  CONTENTS, READONLY
 19 .debug_frame  00009904  00000000  00000000  0025d614  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .debug_line_str 0000005a  00000000  00000000  00266f18  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

081002a0 <__do_global_dtors_aux>:
 81002a0:	b510      	push	{r4, lr}
 81002a2:	4c05      	ldr	r4, [pc, #20]	@ (81002b8 <__do_global_dtors_aux+0x18>)
 81002a4:	7823      	ldrb	r3, [r4, #0]
 81002a6:	b933      	cbnz	r3, 81002b6 <__do_global_dtors_aux+0x16>
 81002a8:	4b04      	ldr	r3, [pc, #16]	@ (81002bc <__do_global_dtors_aux+0x1c>)
 81002aa:	b113      	cbz	r3, 81002b2 <__do_global_dtors_aux+0x12>
 81002ac:	4804      	ldr	r0, [pc, #16]	@ (81002c0 <__do_global_dtors_aux+0x20>)
 81002ae:	f3af 8000 	nop.w
 81002b2:	2301      	movs	r3, #1
 81002b4:	7023      	strb	r3, [r4, #0]
 81002b6:	bd10      	pop	{r4, pc}
 81002b8:	10000598 	.word	0x10000598
 81002bc:	00000000 	.word	0x00000000
 81002c0:	08110868 	.word	0x08110868

081002c4 <frame_dummy>:
 81002c4:	b508      	push	{r3, lr}
 81002c6:	4b03      	ldr	r3, [pc, #12]	@ (81002d4 <frame_dummy+0x10>)
 81002c8:	b11b      	cbz	r3, 81002d2 <frame_dummy+0xe>
 81002ca:	4903      	ldr	r1, [pc, #12]	@ (81002d8 <frame_dummy+0x14>)
 81002cc:	4803      	ldr	r0, [pc, #12]	@ (81002dc <frame_dummy+0x18>)
 81002ce:	f3af 8000 	nop.w
 81002d2:	bd08      	pop	{r3, pc}
 81002d4:	00000000 	.word	0x00000000
 81002d8:	1000059c 	.word	0x1000059c
 81002dc:	08110868 	.word	0x08110868

081002e0 <strcmp>:
 81002e0:	f810 2b01 	ldrb.w	r2, [r0], #1
 81002e4:	f811 3b01 	ldrb.w	r3, [r1], #1
 81002e8:	2a01      	cmp	r2, #1
 81002ea:	bf28      	it	cs
 81002ec:	429a      	cmpcs	r2, r3
 81002ee:	d0f7      	beq.n	81002e0 <strcmp>
 81002f0:	1ad0      	subs	r0, r2, r3
 81002f2:	4770      	bx	lr

081002f4 <strlen>:
 81002f4:	4603      	mov	r3, r0
 81002f6:	f813 2b01 	ldrb.w	r2, [r3], #1
 81002fa:	2a00      	cmp	r2, #0
 81002fc:	d1fb      	bne.n	81002f6 <strlen+0x2>
 81002fe:	1a18      	subs	r0, r3, r0
 8100300:	3801      	subs	r0, #1
 8100302:	4770      	bx	lr
	...

08100310 <memchr>:
 8100310:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 8100314:	2a10      	cmp	r2, #16
 8100316:	db2b      	blt.n	8100370 <memchr+0x60>
 8100318:	f010 0f07 	tst.w	r0, #7
 810031c:	d008      	beq.n	8100330 <memchr+0x20>
 810031e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8100322:	3a01      	subs	r2, #1
 8100324:	428b      	cmp	r3, r1
 8100326:	d02d      	beq.n	8100384 <memchr+0x74>
 8100328:	f010 0f07 	tst.w	r0, #7
 810032c:	b342      	cbz	r2, 8100380 <memchr+0x70>
 810032e:	d1f6      	bne.n	810031e <memchr+0xe>
 8100330:	b4f0      	push	{r4, r5, r6, r7}
 8100332:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8100336:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 810033a:	f022 0407 	bic.w	r4, r2, #7
 810033e:	f07f 0700 	mvns.w	r7, #0
 8100342:	2300      	movs	r3, #0
 8100344:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8100348:	3c08      	subs	r4, #8
 810034a:	ea85 0501 	eor.w	r5, r5, r1
 810034e:	ea86 0601 	eor.w	r6, r6, r1
 8100352:	fa85 f547 	uadd8	r5, r5, r7
 8100356:	faa3 f587 	sel	r5, r3, r7
 810035a:	fa86 f647 	uadd8	r6, r6, r7
 810035e:	faa5 f687 	sel	r6, r5, r7
 8100362:	b98e      	cbnz	r6, 8100388 <memchr+0x78>
 8100364:	d1ee      	bne.n	8100344 <memchr+0x34>
 8100366:	bcf0      	pop	{r4, r5, r6, r7}
 8100368:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
 810036c:	f002 0207 	and.w	r2, r2, #7
 8100370:	b132      	cbz	r2, 8100380 <memchr+0x70>
 8100372:	f810 3b01 	ldrb.w	r3, [r0], #1
 8100376:	3a01      	subs	r2, #1
 8100378:	ea83 0301 	eor.w	r3, r3, r1
 810037c:	b113      	cbz	r3, 8100384 <memchr+0x74>
 810037e:	d1f8      	bne.n	8100372 <memchr+0x62>
 8100380:	2000      	movs	r0, #0
 8100382:	4770      	bx	lr
 8100384:	3801      	subs	r0, #1
 8100386:	4770      	bx	lr
 8100388:	2d00      	cmp	r5, #0
 810038a:	bf06      	itte	eq
 810038c:	4635      	moveq	r5, r6
 810038e:	3803      	subeq	r0, #3
 8100390:	3807      	subne	r0, #7
 8100392:	f015 0f01 	tst.w	r5, #1
 8100396:	d107      	bne.n	81003a8 <memchr+0x98>
 8100398:	3001      	adds	r0, #1
 810039a:	f415 7f80 	tst.w	r5, #256	@ 0x100
 810039e:	bf02      	ittt	eq
 81003a0:	3001      	addeq	r0, #1
 81003a2:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
 81003a6:	3001      	addeq	r0, #1
 81003a8:	bcf0      	pop	{r4, r5, r6, r7}
 81003aa:	3801      	subs	r0, #1
 81003ac:	4770      	bx	lr
 81003ae:	bf00      	nop

081003b0 <SystemInit>:
  *         configuration.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 81003b0:	b480      	push	{r7}
 81003b2:	af00      	add	r7, sp, #0
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 81003b4:	4b09      	ldr	r3, [pc, #36]	@ (81003dc <SystemInit+0x2c>)
 81003b6:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 81003ba:	4a08      	ldr	r2, [pc, #32]	@ (81003dc <SystemInit+0x2c>)
 81003bc:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 81003c0:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
  #endif

    /*SEVONPEND enabled so that an interrupt coming from the CPU(n) interrupt signal is
     detectable by the CPU after a WFI/WFE instruction.*/
 SCB->SCR |= SCB_SCR_SEVONPEND_Msk;
 81003c4:	4b05      	ldr	r3, [pc, #20]	@ (81003dc <SystemInit+0x2c>)
 81003c6:	691b      	ldr	r3, [r3, #16]
 81003c8:	4a04      	ldr	r2, [pc, #16]	@ (81003dc <SystemInit+0x2c>)
 81003ca:	f043 0310 	orr.w	r3, r3, #16
 81003ce:	6113      	str	r3, [r2, #16]
#endif /* USER_VECT_TAB_ADDRESS */

#else
#error Please #define CORE_CM4 or CORE_CM7
#endif /* CORE_CM4 */
}
 81003d0:	bf00      	nop
 81003d2:	46bd      	mov	sp, r7
 81003d4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81003d8:	4770      	bx	lr
 81003da:	bf00      	nop
 81003dc:	e000ed00 	.word	0xe000ed00

081003e0 <rpmsg_recv_callback>:
double c5;
double c6;
double c7;

static int rpmsg_recv_callback(struct rpmsg_endpoint *ept, void *data, size_t len, uint32_t src, void *priv)
{
 81003e0:	b580      	push	{r7, lr}
 81003e2:	b084      	sub	sp, #16
 81003e4:	af00      	add	r7, sp, #0
 81003e6:	60f8      	str	r0, [r7, #12]
 81003e8:	60b9      	str	r1, [r7, #8]
 81003ea:	607a      	str	r2, [r7, #4]
 81003ec:	603b      	str	r3, [r7, #0]
//	received_data = *((unsigned int *) data);
	received_data_str = (char *) data;
 81003ee:	4a09      	ldr	r2, [pc, #36]	@ (8100414 <rpmsg_recv_callback+0x34>)
 81003f0:	68bb      	ldr	r3, [r7, #8]
 81003f2:	6013      	str	r3, [r2, #0]
//	length_data=sizeof(received_data_str);
	memcpy(received_data,received_data_str,LENGTH_DATA);
 81003f4:	4b07      	ldr	r3, [pc, #28]	@ (8100414 <rpmsg_recv_callback+0x34>)
 81003f6:	681b      	ldr	r3, [r3, #0]
 81003f8:	2220      	movs	r2, #32
 81003fa:	4619      	mov	r1, r3
 81003fc:	4806      	ldr	r0, [pc, #24]	@ (8100418 <rpmsg_recv_callback+0x38>)
 81003fe:	f00f fcfc 	bl	810fdfa <memcpy>
	message_received=1;
 8100402:	4b06      	ldr	r3, [pc, #24]	@ (810041c <rpmsg_recv_callback+0x3c>)
 8100404:	2201      	movs	r2, #1
 8100406:	601a      	str	r2, [r3, #0]
	return 0;
 8100408:	2300      	movs	r3, #0
}
 810040a:	4618      	mov	r0, r3
 810040c:	3710      	adds	r7, #16
 810040e:	46bd      	mov	sp, r7
 8100410:	bd80      	pop	{r7, pc}
 8100412:	bf00      	nop
 8100414:	100005b8 	.word	0x100005b8
 8100418:	100005bc 	.word	0x100005bc
 810041c:	100005b4 	.word	0x100005b4

08100420 <receive_message>:

unsigned int receive_message(void)
{
 8100420:	b580      	push	{r7, lr}
 8100422:	af00      	add	r7, sp, #0
	while (message_received == 0)
 8100424:	e001      	b.n	810042a <receive_message+0xa>
	{
		OPENAMP_check_for_message();
 8100426:	f00f fa1d 	bl	810f864 <OPENAMP_check_for_message>
	while (message_received == 0)
 810042a:	4b05      	ldr	r3, [pc, #20]	@ (8100440 <receive_message+0x20>)
 810042c:	681b      	ldr	r3, [r3, #0]
 810042e:	2b00      	cmp	r3, #0
 8100430:	d0f9      	beq.n	8100426 <receive_message+0x6>
	}
	message_received = 0;
 8100432:	4b03      	ldr	r3, [pc, #12]	@ (8100440 <receive_message+0x20>)
 8100434:	2200      	movs	r2, #0
 8100436:	601a      	str	r2, [r3, #0]

	return 0;
 8100438:	2300      	movs	r3, #0
}
 810043a:	4618      	mov	r0, r3
 810043c:	bd80      	pop	{r7, pc}
 810043e:	bf00      	nop
 8100440:	100005b4 	.word	0x100005b4

08100444 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
 8100444:	b580      	push	{r7, lr}
 8100446:	b084      	sub	sp, #16
 8100448:	af02      	add	r7, sp, #8

  /* USER CODE END 1 */

/* USER CODE BEGIN Boot_Mode_Sequence_1 */
  /*HW semaphore Clock enable*/
  __HAL_RCC_HSEM_CLK_ENABLE();
 810044a:	4b3e      	ldr	r3, [pc, #248]	@ (8100544 <main+0x100>)
 810044c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8100450:	4a3c      	ldr	r2, [pc, #240]	@ (8100544 <main+0x100>)
 8100452:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 8100456:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 810045a:	4b3a      	ldr	r3, [pc, #232]	@ (8100544 <main+0x100>)
 810045c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8100460:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 8100464:	603b      	str	r3, [r7, #0]
 8100466:	683b      	ldr	r3, [r7, #0]
  /* Activate HSEM notification for Cortex-M4*/
  HAL_HSEM_ActivateNotification(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));
 8100468:	2001      	movs	r0, #1
 810046a:	f001 fcf5 	bl	8101e58 <HAL_HSEM_ActivateNotification>
  /*
  Domain D2 goes to STOP mode (Cortex-M4 in deep-sleep) waiting for Cortex-M7 to
  perform system initialization (system clock config, external memory configuration.. )
  */
  HAL_PWREx_ClearPendingEvent();
 810046e:	f001 fd99 	bl	8101fa4 <HAL_PWREx_ClearPendingEvent>
  HAL_PWREx_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE, PWR_D2_DOMAIN);
 8100472:	2201      	movs	r2, #1
 8100474:	2102      	movs	r1, #2
 8100476:	2000      	movs	r0, #0
 8100478:	f001 fd1a 	bl	8101eb0 <HAL_PWREx_EnterSTOPMode>
  /* Clear HSEM flag */
  __HAL_HSEM_CLEAR_FLAG(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));
 810047c:	4b32      	ldr	r3, [pc, #200]	@ (8100548 <main+0x104>)
 810047e:	681b      	ldr	r3, [r3, #0]
 8100480:	091b      	lsrs	r3, r3, #4
 8100482:	f003 030f 	and.w	r3, r3, #15
 8100486:	2b07      	cmp	r3, #7
 8100488:	d108      	bne.n	810049c <main+0x58>
 810048a:	4b30      	ldr	r3, [pc, #192]	@ (810054c <main+0x108>)
 810048c:	f8d3 3104 	ldr.w	r3, [r3, #260]	@ 0x104
 8100490:	4a2e      	ldr	r2, [pc, #184]	@ (810054c <main+0x108>)
 8100492:	f043 0301 	orr.w	r3, r3, #1
 8100496:	f8c2 3104 	str.w	r3, [r2, #260]	@ 0x104
 810049a:	e007      	b.n	81004ac <main+0x68>
 810049c:	4b2b      	ldr	r3, [pc, #172]	@ (810054c <main+0x108>)
 810049e:	f8d3 3114 	ldr.w	r3, [r3, #276]	@ 0x114
 81004a2:	4a2a      	ldr	r2, [pc, #168]	@ (810054c <main+0x108>)
 81004a4:	f043 0301 	orr.w	r3, r3, #1
 81004a8:	f8c2 3114 	str.w	r3, [r2, #276]	@ 0x114

/* USER CODE END Boot_Mode_Sequence_1 */
  /* MCU Configuration--------------------------------------------------------*/

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
 81004ac:	f001 f91e 	bl	81016ec <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
 81004b0:	f000 f910 	bl	81006d4 <MX_GPIO_Init>
  MX_TIM2_Init();
 81004b4:	f000 f8c0 	bl	8100638 <MX_TIM2_Init>
  MX_SPI3_Init();
 81004b8:	f000 f866 	bl	8100588 <MX_SPI3_Init>
  /* USER CODE BEGIN 2 */
  HW_Init();
 81004bc:	f000 fda2 	bl	8101004 <HW_Init>
	 int32_t status = 0;
 81004c0:	2300      	movs	r3, #0
 81004c2:	607b      	str	r3, [r7, #4]

	  /* Initialize the mailbox use notify the other core on new message */
	  MAILBOX_Init();
 81004c4:	f00f f818 	bl	810f4f8 <MAILBOX_Init>

	  /* Initialize OpenAmp and libmetal libraries */
	  if (MX_OPENAMP_Init(RPMSG_REMOTE, NULL)!= HAL_OK)
 81004c8:	2100      	movs	r1, #0
 81004ca:	2001      	movs	r0, #1
 81004cc:	f00f f916 	bl	810f6fc <MX_OPENAMP_Init>
 81004d0:	4603      	mov	r3, r0
 81004d2:	2b00      	cmp	r3, #0
 81004d4:	d001      	beq.n	81004da <main+0x96>
	    Error_Handler();
 81004d6:	f000 fa19 	bl	810090c <Error_Handler>

	  /* Create an endpoint for rmpsg communication */
	  status = OPENAMP_create_endpoint(&rp_endpoint, RPMSG_SERVICE_NAME, RPMSG_ADDR_ANY, rpmsg_recv_callback, NULL);
 81004da:	2300      	movs	r3, #0
 81004dc:	9300      	str	r3, [sp, #0]
 81004de:	4b1c      	ldr	r3, [pc, #112]	@ (8100550 <main+0x10c>)
 81004e0:	f04f 32ff 	mov.w	r2, #4294967295
 81004e4:	491b      	ldr	r1, [pc, #108]	@ (8100554 <main+0x110>)
 81004e6:	481c      	ldr	r0, [pc, #112]	@ (8100558 <main+0x114>)
 81004e8:	f00f f99e 	bl	810f828 <OPENAMP_create_endpoint>
 81004ec:	6078      	str	r0, [r7, #4]
	  if (status < 0)
 81004ee:	687b      	ldr	r3, [r7, #4]
 81004f0:	2b00      	cmp	r3, #0
 81004f2:	da01      	bge.n	81004f8 <main+0xb4>
	  {
	    Error_Handler();
 81004f4:	f000 fa0a 	bl	810090c <Error_Handler>
 //OPENAMP_DeInit();

  /* USER CODE END 2 */

  /* Init scheduler */
  osKernelInitialize();
 81004f8:	f009 ffe4 	bl	810a4c4 <osKernelInitialize>
  /* add mutexes, ... */
  /* USER CODE END RTOS_MUTEX */

  /* Create the semaphores(s) */
  /* creation of txSem */
  txSemHandle = osSemaphoreNew(1, 0, &txSem_attributes);
 81004fc:	4a17      	ldr	r2, [pc, #92]	@ (810055c <main+0x118>)
 81004fe:	2100      	movs	r1, #0
 8100500:	2001      	movs	r0, #1
 8100502:	f00a f8d6 	bl	810a6b2 <osSemaphoreNew>
 8100506:	4603      	mov	r3, r0
 8100508:	4a15      	ldr	r2, [pc, #84]	@ (8100560 <main+0x11c>)
 810050a:	6013      	str	r3, [r2, #0]
  /* add queues, ... */
  /* USER CODE END RTOS_QUEUES */

  /* Create the thread(s) */
  /* creation of rxTask */
  rxTaskHandle = osThreadNew(rxTaskFun, NULL, &rxTask_attributes);
 810050c:	4a15      	ldr	r2, [pc, #84]	@ (8100564 <main+0x120>)
 810050e:	2100      	movs	r1, #0
 8100510:	4815      	ldr	r0, [pc, #84]	@ (8100568 <main+0x124>)
 8100512:	f00a f821 	bl	810a558 <osThreadNew>
 8100516:	4603      	mov	r3, r0
 8100518:	4a14      	ldr	r2, [pc, #80]	@ (810056c <main+0x128>)
 810051a:	6013      	str	r3, [r2, #0]

  /* creation of txTask */
  txTaskHandle = osThreadNew(txTaskFun, NULL, &txTask_attributes);
 810051c:	4a14      	ldr	r2, [pc, #80]	@ (8100570 <main+0x12c>)
 810051e:	2100      	movs	r1, #0
 8100520:	4814      	ldr	r0, [pc, #80]	@ (8100574 <main+0x130>)
 8100522:	f00a f819 	bl	810a558 <osThreadNew>
 8100526:	4603      	mov	r3, r0
 8100528:	4a13      	ldr	r2, [pc, #76]	@ (8100578 <main+0x134>)
 810052a:	6013      	str	r3, [r2, #0]

  /* creation of TestTask */
  TestTaskHandle = osThreadNew(TestTaskFun, NULL, &TestTask_attributes);
 810052c:	4a13      	ldr	r2, [pc, #76]	@ (810057c <main+0x138>)
 810052e:	2100      	movs	r1, #0
 8100530:	4813      	ldr	r0, [pc, #76]	@ (8100580 <main+0x13c>)
 8100532:	f00a f811 	bl	810a558 <osThreadNew>
 8100536:	4603      	mov	r3, r0
 8100538:	4a12      	ldr	r2, [pc, #72]	@ (8100584 <main+0x140>)
 810053a:	6013      	str	r3, [r2, #0]
  /* USER CODE BEGIN RTOS_EVENTS */
  /* add events, ... */
  /* USER CODE END RTOS_EVENTS */

  /* Start scheduler */
  osKernelStart();
 810053c:	f009 ffe6 	bl	810a50c <osKernelStart>

  /* We should never get here as control is now taken by the scheduler */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  while (1)
 8100540:	bf00      	nop
 8100542:	e7fd      	b.n	8100540 <main+0xfc>
 8100544:	58024400 	.word	0x58024400
 8100548:	e000ed00 	.word	0xe000ed00
 810054c:	58026400 	.word	0x58026400
 8100550:	081003e1 	.word	0x081003e1
 8100554:	081108a4 	.word	0x081108a4
 8100558:	100005dc 	.word	0x100005dc
 810055c:	08110b04 	.word	0x08110b04
 8100560:	1000071c 	.word	0x1000071c
 8100564:	08110a98 	.word	0x08110a98
 8100568:	08100875 	.word	0x08100875
 810056c:	10000710 	.word	0x10000710
 8100570:	08110abc 	.word	0x08110abc
 8100574:	081008a9 	.word	0x081008a9
 8100578:	10000714 	.word	0x10000714
 810057c:	08110ae0 	.word	0x08110ae0
 8100580:	081008b9 	.word	0x081008b9
 8100584:	10000718 	.word	0x10000718

08100588 <MX_SPI3_Init>:
  * @brief SPI3 Initialization Function
  * @param None
  * @retval None
  */
static void MX_SPI3_Init(void)
{
 8100588:	b580      	push	{r7, lr}
 810058a:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN SPI3_Init 1 */

  /* USER CODE END SPI3_Init 1 */
  /* SPI3 parameter configuration*/
  hspi3.Instance = SPI3;
 810058c:	4b28      	ldr	r3, [pc, #160]	@ (8100630 <MX_SPI3_Init+0xa8>)
 810058e:	4a29      	ldr	r2, [pc, #164]	@ (8100634 <MX_SPI3_Init+0xac>)
 8100590:	601a      	str	r2, [r3, #0]
  hspi3.Init.Mode = SPI_MODE_MASTER;
 8100592:	4b27      	ldr	r3, [pc, #156]	@ (8100630 <MX_SPI3_Init+0xa8>)
 8100594:	f44f 0280 	mov.w	r2, #4194304	@ 0x400000
 8100598:	605a      	str	r2, [r3, #4]
  hspi3.Init.Direction = SPI_DIRECTION_2LINES;
 810059a:	4b25      	ldr	r3, [pc, #148]	@ (8100630 <MX_SPI3_Init+0xa8>)
 810059c:	2200      	movs	r2, #0
 810059e:	609a      	str	r2, [r3, #8]
  hspi3.Init.DataSize = SPI_DATASIZE_8BIT;
 81005a0:	4b23      	ldr	r3, [pc, #140]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005a2:	2207      	movs	r2, #7
 81005a4:	60da      	str	r2, [r3, #12]
  hspi3.Init.CLKPolarity = SPI_POLARITY_HIGH;
 81005a6:	4b22      	ldr	r3, [pc, #136]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005a8:	f04f 7200 	mov.w	r2, #33554432	@ 0x2000000
 81005ac:	611a      	str	r2, [r3, #16]
  hspi3.Init.CLKPhase = SPI_PHASE_2EDGE;
 81005ae:	4b20      	ldr	r3, [pc, #128]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005b0:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 81005b4:	615a      	str	r2, [r3, #20]
  hspi3.Init.NSS = SPI_NSS_SOFT;
 81005b6:	4b1e      	ldr	r3, [pc, #120]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005b8:	f04f 6280 	mov.w	r2, #67108864	@ 0x4000000
 81005bc:	619a      	str	r2, [r3, #24]
  hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
 81005be:	4b1c      	ldr	r3, [pc, #112]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005c0:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
 81005c4:	61da      	str	r2, [r3, #28]
  hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
 81005c6:	4b1a      	ldr	r3, [pc, #104]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005c8:	2200      	movs	r2, #0
 81005ca:	621a      	str	r2, [r3, #32]
  hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
 81005cc:	4b18      	ldr	r3, [pc, #96]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005ce:	2200      	movs	r2, #0
 81005d0:	625a      	str	r2, [r3, #36]	@ 0x24
  hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 81005d2:	4b17      	ldr	r3, [pc, #92]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005d4:	2200      	movs	r2, #0
 81005d6:	629a      	str	r2, [r3, #40]	@ 0x28
  hspi3.Init.CRCPolynomial = 0x0;
 81005d8:	4b15      	ldr	r3, [pc, #84]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005da:	2200      	movs	r2, #0
 81005dc:	62da      	str	r2, [r3, #44]	@ 0x2c
  hspi3.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 81005de:	4b14      	ldr	r3, [pc, #80]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005e0:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 81005e4:	635a      	str	r2, [r3, #52]	@ 0x34
  hspi3.Init.NSSPolarity = SPI_NSS_POLARITY_LOW;
 81005e6:	4b12      	ldr	r3, [pc, #72]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005e8:	2200      	movs	r2, #0
 81005ea:	639a      	str	r2, [r3, #56]	@ 0x38
  hspi3.Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;
 81005ec:	4b10      	ldr	r3, [pc, #64]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005ee:	2200      	movs	r2, #0
 81005f0:	63da      	str	r2, [r3, #60]	@ 0x3c
  hspi3.Init.TxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
 81005f2:	4b0f      	ldr	r3, [pc, #60]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005f4:	2200      	movs	r2, #0
 81005f6:	641a      	str	r2, [r3, #64]	@ 0x40
  hspi3.Init.RxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
 81005f8:	4b0d      	ldr	r3, [pc, #52]	@ (8100630 <MX_SPI3_Init+0xa8>)
 81005fa:	2200      	movs	r2, #0
 81005fc:	645a      	str	r2, [r3, #68]	@ 0x44
  hspi3.Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;
 81005fe:	4b0c      	ldr	r3, [pc, #48]	@ (8100630 <MX_SPI3_Init+0xa8>)
 8100600:	2200      	movs	r2, #0
 8100602:	649a      	str	r2, [r3, #72]	@ 0x48
  hspi3.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
 8100604:	4b0a      	ldr	r3, [pc, #40]	@ (8100630 <MX_SPI3_Init+0xa8>)
 8100606:	2200      	movs	r2, #0
 8100608:	64da      	str	r2, [r3, #76]	@ 0x4c
  hspi3.Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;
 810060a:	4b09      	ldr	r3, [pc, #36]	@ (8100630 <MX_SPI3_Init+0xa8>)
 810060c:	2200      	movs	r2, #0
 810060e:	651a      	str	r2, [r3, #80]	@ 0x50
  hspi3.Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_DISABLE;
 8100610:	4b07      	ldr	r3, [pc, #28]	@ (8100630 <MX_SPI3_Init+0xa8>)
 8100612:	2200      	movs	r2, #0
 8100614:	655a      	str	r2, [r3, #84]	@ 0x54
  hspi3.Init.IOSwap = SPI_IO_SWAP_DISABLE;
 8100616:	4b06      	ldr	r3, [pc, #24]	@ (8100630 <MX_SPI3_Init+0xa8>)
 8100618:	2200      	movs	r2, #0
 810061a:	659a      	str	r2, [r3, #88]	@ 0x58
  if (HAL_SPI_Init(&hspi3) != HAL_OK)
 810061c:	4804      	ldr	r0, [pc, #16]	@ (8100630 <MX_SPI3_Init+0xa8>)
 810061e:	f003 fa41 	bl	8103aa4 <HAL_SPI_Init>
 8100622:	4603      	mov	r3, r0
 8100624:	2b00      	cmp	r3, #0
 8100626:	d001      	beq.n	810062c <MX_SPI3_Init+0xa4>
  {
    Error_Handler();
 8100628:	f000 f970 	bl	810090c <Error_Handler>
  }
  /* USER CODE BEGIN SPI3_Init 2 */

  /* USER CODE END SPI3_Init 2 */

}
 810062c:	bf00      	nop
 810062e:	bd80      	pop	{r7, pc}
 8100630:	1000063c 	.word	0x1000063c
 8100634:	40003c00 	.word	0x40003c00

08100638 <MX_TIM2_Init>:
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{
 8100638:	b580      	push	{r7, lr}
 810063a:	b088      	sub	sp, #32
 810063c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 810063e:	f107 0310 	add.w	r3, r7, #16
 8100642:	2200      	movs	r2, #0
 8100644:	601a      	str	r2, [r3, #0]
 8100646:	605a      	str	r2, [r3, #4]
 8100648:	609a      	str	r2, [r3, #8]
 810064a:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 810064c:	1d3b      	adds	r3, r7, #4
 810064e:	2200      	movs	r2, #0
 8100650:	601a      	str	r2, [r3, #0]
 8100652:	605a      	str	r2, [r3, #4]
 8100654:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
 8100656:	4b1e      	ldr	r3, [pc, #120]	@ (81006d0 <MX_TIM2_Init+0x98>)
 8100658:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 810065c:	601a      	str	r2, [r3, #0]
  htim2.Init.Prescaler = 1000;
 810065e:	4b1c      	ldr	r3, [pc, #112]	@ (81006d0 <MX_TIM2_Init+0x98>)
 8100660:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8100664:	605a      	str	r2, [r3, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8100666:	4b1a      	ldr	r3, [pc, #104]	@ (81006d0 <MX_TIM2_Init+0x98>)
 8100668:	2200      	movs	r2, #0
 810066a:	609a      	str	r2, [r3, #8]
  htim2.Init.Period = 199;
 810066c:	4b18      	ldr	r3, [pc, #96]	@ (81006d0 <MX_TIM2_Init+0x98>)
 810066e:	22c7      	movs	r2, #199	@ 0xc7
 8100670:	60da      	str	r2, [r3, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8100672:	4b17      	ldr	r3, [pc, #92]	@ (81006d0 <MX_TIM2_Init+0x98>)
 8100674:	2200      	movs	r2, #0
 8100676:	611a      	str	r2, [r3, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8100678:	4b15      	ldr	r3, [pc, #84]	@ (81006d0 <MX_TIM2_Init+0x98>)
 810067a:	2200      	movs	r2, #0
 810067c:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 810067e:	4814      	ldr	r0, [pc, #80]	@ (81006d0 <MX_TIM2_Init+0x98>)
 8100680:	f003 ff55 	bl	810452e <HAL_TIM_Base_Init>
 8100684:	4603      	mov	r3, r0
 8100686:	2b00      	cmp	r3, #0
 8100688:	d001      	beq.n	810068e <MX_TIM2_Init+0x56>
  {
    Error_Handler();
 810068a:	f000 f93f 	bl	810090c <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 810068e:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8100692:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 8100694:	f107 0310 	add.w	r3, r7, #16
 8100698:	4619      	mov	r1, r3
 810069a:	480d      	ldr	r0, [pc, #52]	@ (81006d0 <MX_TIM2_Init+0x98>)
 810069c:	f004 f91e 	bl	81048dc <HAL_TIM_ConfigClockSource>
 81006a0:	4603      	mov	r3, r0
 81006a2:	2b00      	cmp	r3, #0
 81006a4:	d001      	beq.n	81006aa <MX_TIM2_Init+0x72>
  {
    Error_Handler();
 81006a6:	f000 f931 	bl	810090c <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 81006aa:	2300      	movs	r3, #0
 81006ac:	607b      	str	r3, [r7, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 81006ae:	2300      	movs	r3, #0
 81006b0:	60fb      	str	r3, [r7, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 81006b2:	1d3b      	adds	r3, r7, #4
 81006b4:	4619      	mov	r1, r3
 81006b6:	4806      	ldr	r0, [pc, #24]	@ (81006d0 <MX_TIM2_Init+0x98>)
 81006b8:	f004 fb72 	bl	8104da0 <HAL_TIMEx_MasterConfigSynchronization>
 81006bc:	4603      	mov	r3, r0
 81006be:	2b00      	cmp	r3, #0
 81006c0:	d001      	beq.n	81006c6 <MX_TIM2_Init+0x8e>
  {
    Error_Handler();
 81006c2:	f000 f923 	bl	810090c <Error_Handler>
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}
 81006c6:	bf00      	nop
 81006c8:	3720      	adds	r7, #32
 81006ca:	46bd      	mov	sp, r7
 81006cc:	bd80      	pop	{r7, pc}
 81006ce:	bf00      	nop
 81006d0:	100006c4 	.word	0x100006c4

081006d4 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 81006d4:	b580      	push	{r7, lr}
 81006d6:	b088      	sub	sp, #32
 81006d8:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 81006da:	f107 030c 	add.w	r3, r7, #12
 81006de:	2200      	movs	r2, #0
 81006e0:	601a      	str	r2, [r3, #0]
 81006e2:	605a      	str	r2, [r3, #4]
 81006e4:	609a      	str	r2, [r3, #8]
 81006e6:	60da      	str	r2, [r3, #12]
 81006e8:	611a      	str	r2, [r3, #16]
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
 81006ea:	4b31      	ldr	r3, [pc, #196]	@ (81007b0 <MX_GPIO_Init+0xdc>)
 81006ec:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 81006f0:	4a2f      	ldr	r2, [pc, #188]	@ (81007b0 <MX_GPIO_Init+0xdc>)
 81006f2:	f043 0310 	orr.w	r3, r3, #16
 81006f6:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 81006fa:	4b2d      	ldr	r3, [pc, #180]	@ (81007b0 <MX_GPIO_Init+0xdc>)
 81006fc:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8100700:	f003 0310 	and.w	r3, r3, #16
 8100704:	60bb      	str	r3, [r7, #8]
 8100706:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8100708:	4b29      	ldr	r3, [pc, #164]	@ (81007b0 <MX_GPIO_Init+0xdc>)
 810070a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810070e:	4a28      	ldr	r2, [pc, #160]	@ (81007b0 <MX_GPIO_Init+0xdc>)
 8100710:	f043 0304 	orr.w	r3, r3, #4
 8100714:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8100718:	4b25      	ldr	r3, [pc, #148]	@ (81007b0 <MX_GPIO_Init+0xdc>)
 810071a:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810071e:	f003 0304 	and.w	r3, r3, #4
 8100722:	607b      	str	r3, [r7, #4]
 8100724:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 8100726:	4b22      	ldr	r3, [pc, #136]	@ (81007b0 <MX_GPIO_Init+0xdc>)
 8100728:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810072c:	4a20      	ldr	r2, [pc, #128]	@ (81007b0 <MX_GPIO_Init+0xdc>)
 810072e:	f043 0308 	orr.w	r3, r3, #8
 8100732:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 8100736:	4b1e      	ldr	r3, [pc, #120]	@ (81007b0 <MX_GPIO_Init+0xdc>)
 8100738:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810073c:	f003 0308 	and.w	r3, r3, #8
 8100740:	603b      	str	r3, [r7, #0]
 8100742:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(SPI3_NSS_GPIO_Port, SPI3_NSS_Pin, GPIO_PIN_RESET);
 8100744:	2200      	movs	r2, #0
 8100746:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 810074a:	481a      	ldr	r0, [pc, #104]	@ (81007b4 <MX_GPIO_Init+0xe0>)
 810074c:	f001 fb22 	bl	8101d94 <HAL_GPIO_WritePin>

  /*Configure GPIO pin : SPI3_NSS_Pin */
  GPIO_InitStruct.Pin = SPI3_NSS_Pin;
 8100750:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 8100754:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8100756:	2301      	movs	r3, #1
 8100758:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 810075a:	2300      	movs	r3, #0
 810075c:	617b      	str	r3, [r7, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 810075e:	2303      	movs	r3, #3
 8100760:	61bb      	str	r3, [r7, #24]
  HAL_GPIO_Init(SPI3_NSS_GPIO_Port, &GPIO_InitStruct);
 8100762:	f107 030c 	add.w	r3, r7, #12
 8100766:	4619      	mov	r1, r3
 8100768:	4812      	ldr	r0, [pc, #72]	@ (81007b4 <MX_GPIO_Init+0xe0>)
 810076a:	f001 f963 	bl	8101a34 <HAL_GPIO_Init>

  /*Configure GPIO pins : SPI3_IRQ_Pin SYNC_L0_Pin SYNC_L1_Pin */
  GPIO_InitStruct.Pin = SPI3_IRQ_Pin|SYNC_L0_Pin|SYNC_L1_Pin;
 810076e:	2370      	movs	r3, #112	@ 0x70
 8100770:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8100772:	f44f 1304 	mov.w	r3, #2162688	@ 0x210000
 8100776:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8100778:	2301      	movs	r3, #1
 810077a:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 810077c:	f107 030c 	add.w	r3, r7, #12
 8100780:	4619      	mov	r1, r3
 8100782:	480d      	ldr	r0, [pc, #52]	@ (81007b8 <MX_GPIO_Init+0xe4>)
 8100784:	f001 f956 	bl	8101a34 <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI4_IRQn, 5, 0);
 8100788:	2200      	movs	r2, #0
 810078a:	2105      	movs	r1, #5
 810078c:	200a      	movs	r0, #10
 810078e:	f001 f907 	bl	81019a0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI4_IRQn);
 8100792:	200a      	movs	r0, #10
 8100794:	f001 f91e 	bl	81019d4 <HAL_NVIC_EnableIRQ>

  HAL_NVIC_SetPriority(EXTI9_5_IRQn, 5, 0);
 8100798:	2200      	movs	r2, #0
 810079a:	2105      	movs	r1, #5
 810079c:	2017      	movs	r0, #23
 810079e:	f001 f8ff 	bl	81019a0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
 81007a2:	2017      	movs	r0, #23
 81007a4:	f001 f916 	bl	81019d4 <HAL_NVIC_EnableIRQ>

/* USER CODE BEGIN MX_GPIO_Init_2 */
/* USER CODE END MX_GPIO_Init_2 */
}
 81007a8:	bf00      	nop
 81007aa:	3720      	adds	r7, #32
 81007ac:	46bd      	mov	sp, r7
 81007ae:	bd80      	pop	{r7, pc}
 81007b0:	58024400 	.word	0x58024400
 81007b4:	58021000 	.word	0x58021000
 81007b8:	58020c00 	.word	0x58020c00

081007bc <HAL_GPIO_EXTI_Callback>:

/* USER CODE BEGIN 4 */

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin){
 81007bc:	b480      	push	{r7}
 81007be:	b083      	sub	sp, #12
 81007c0:	af00      	add	r7, sp, #0
 81007c2:	4603      	mov	r3, r0
 81007c4:	80fb      	strh	r3, [r7, #6]

}
 81007c6:	bf00      	nop
 81007c8:	370c      	adds	r7, #12
 81007ca:	46bd      	mov	sp, r7
 81007cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 81007d0:	4770      	bx	lr
	...

081007d4 <WR_CMD>:
uint8_t WR_CMD (uint8_t tx)
{
 81007d4:	b580      	push	{r7, lr}
 81007d6:	b086      	sub	sp, #24
 81007d8:	af02      	add	r7, sp, #8
 81007da:	4603      	mov	r3, r0
 81007dc:	71fb      	strb	r3, [r7, #7]
	uint8_t rx = 0;
 81007de:	2300      	movs	r3, #0
 81007e0:	72fb      	strb	r3, [r7, #11]
	int r;

	r = HAL_SPI_TransmitReceive(&hspi3, &tx, &rx, 1, 0xffffffff);
 81007e2:	f107 020b 	add.w	r2, r7, #11
 81007e6:	1df9      	adds	r1, r7, #7
 81007e8:	f04f 33ff 	mov.w	r3, #4294967295
 81007ec:	9300      	str	r3, [sp, #0]
 81007ee:	2301      	movs	r3, #1
 81007f0:	4807      	ldr	r0, [pc, #28]	@ (8100810 <WR_CMD+0x3c>)
 81007f2:	f003 fa7b 	bl	8103cec <HAL_SPI_TransmitReceive>
 81007f6:	4603      	mov	r3, r0
 81007f8:	60fb      	str	r3, [r7, #12]

	if (r != HAL_OK)
 81007fa:	68fb      	ldr	r3, [r7, #12]
 81007fc:	2b00      	cmp	r3, #0
 81007fe:	d001      	beq.n	8100804 <WR_CMD+0x30>
		Error_Handler();
 8100800:	f000 f884 	bl	810090c <Error_Handler>
	return rx;
 8100804:	7afb      	ldrb	r3, [r7, #11]

}
 8100806:	4618      	mov	r0, r3
 8100808:	3710      	adds	r7, #16
 810080a:	46bd      	mov	sp, r7
 810080c:	bd80      	pop	{r7, pc}
 810080e:	bf00      	nop
 8100810:	1000063c 	.word	0x1000063c

08100814 <EXTI3_Configuration>:
void EXTI3_Configuration(){
 8100814:	b580      	push	{r7, lr}
 8100816:	b086      	sub	sp, #24
 8100818:	af00      	add	r7, sp, #0
	GPIO_InitTypeDef GPIO_InitStruct;
    __HAL_RCC_GPIOA_CLK_ENABLE();
 810081a:	4b14      	ldr	r3, [pc, #80]	@ (810086c <EXTI3_Configuration+0x58>)
 810081c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8100820:	4a12      	ldr	r2, [pc, #72]	@ (810086c <EXTI3_Configuration+0x58>)
 8100822:	f043 0301 	orr.w	r3, r3, #1
 8100826:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 810082a:	4b10      	ldr	r3, [pc, #64]	@ (810086c <EXTI3_Configuration+0x58>)
 810082c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8100830:	f003 0301 	and.w	r3, r3, #1
 8100834:	603b      	str	r3, [r7, #0]
 8100836:	683b      	ldr	r3, [r7, #0]

	 GPIO_InitStruct.Pin = SPI3_IRQ_Pin;
 8100838:	2310      	movs	r3, #16
 810083a:	607b      	str	r3, [r7, #4]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 810083c:	f44f 1304 	mov.w	r3, #2162688	@ 0x210000
 8100840:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Pull = GPIO_PULLUP;
 8100842:	2301      	movs	r3, #1
 8100844:	60fb      	str	r3, [r7, #12]
	 GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8100846:	2303      	movs	r3, #3
 8100848:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(SPI3_IRQ_GPIO_Port, &GPIO_InitStruct);
 810084a:	1d3b      	adds	r3, r7, #4
 810084c:	4619      	mov	r1, r3
 810084e:	4808      	ldr	r0, [pc, #32]	@ (8100870 <EXTI3_Configuration+0x5c>)
 8100850:	f001 f8f0 	bl	8101a34 <HAL_GPIO_Init>

    HAL_NVIC_SetPriority(EXTI3_IRQn, 2, 0);
 8100854:	2200      	movs	r2, #0
 8100856:	2102      	movs	r1, #2
 8100858:	2009      	movs	r0, #9
 810085a:	f001 f8a1 	bl	81019a0 <HAL_NVIC_SetPriority>
		HAL_NVIC_EnableIRQ(EXTI3_IRQn);
 810085e:	2009      	movs	r0, #9
 8100860:	f001 f8b8 	bl	81019d4 <HAL_NVIC_EnableIRQ>

}
 8100864:	bf00      	nop
 8100866:	3718      	adds	r7, #24
 8100868:	46bd      	mov	sp, r7
 810086a:	bd80      	pop	{r7, pc}
 810086c:	58024400 	.word	0x58024400
 8100870:	58020c00 	.word	0x58020c00

08100874 <rxTaskFun>:
  * @param  argument: Not used
  * @retval None
  */
/* USER CODE END Header_rxTaskFun */
void rxTaskFun(void *argument)
{
 8100874:	b5b0      	push	{r4, r5, r7, lr}
 8100876:	b082      	sub	sp, #8
 8100878:	af00      	add	r7, sp, #0
 810087a:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN 5 */
  /* Infinite loop */
  for(;;)
  {
  	  receive_message();
 810087c:	f7ff fdd0 	bl	8100420 <receive_message>
//  	  data_pointer=received_data;
  	  memcpy(angle_all, received_data, sizeof(received_data));
 8100880:	4a07      	ldr	r2, [pc, #28]	@ (81008a0 <rxTaskFun+0x2c>)
 8100882:	4b08      	ldr	r3, [pc, #32]	@ (81008a4 <rxTaskFun+0x30>)
 8100884:	4614      	mov	r4, r2
 8100886:	461d      	mov	r5, r3
 8100888:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 810088a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 810088c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
 8100890:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
//  	  sprintf(data,"%u\n\r",received_data);
  	  osDelay(1);
 8100894:	2001      	movs	r0, #1
 8100896:	f009 fef1 	bl	810a67c <osDelay>
  	  receive_message();
 810089a:	bf00      	nop
 810089c:	e7ee      	b.n	810087c <rxTaskFun+0x8>
 810089e:	bf00      	nop
 81008a0:	1000061c 	.word	0x1000061c
 81008a4:	100005bc 	.word	0x100005bc

081008a8 <txTaskFun>:
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_txTaskFun */
void txTaskFun(void *argument)
{
 81008a8:	b580      	push	{r7, lr}
 81008aa:	b082      	sub	sp, #8
 81008ac:	af00      	add	r7, sp, #0
 81008ae:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN txTaskFun */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
 81008b0:	2001      	movs	r0, #1
 81008b2:	f009 fee3 	bl	810a67c <osDelay>
 81008b6:	e7fb      	b.n	81008b0 <txTaskFun+0x8>

081008b8 <TestTaskFun>:
* @param argument: Not used
* @retval None
*/
/* USER CODE END Header_TestTaskFun */
void TestTaskFun(void *argument)
{
 81008b8:	b580      	push	{r7, lr}
 81008ba:	b082      	sub	sp, #8
 81008bc:	af00      	add	r7, sp, #0
 81008be:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN TestTaskFun */
  /* Infinite loop */
	   MainInit();
 81008c0:	f004 fd5a 	bl	8105378 <MainInit>

	    bRunApplication = TRUE;
 81008c4:	4b07      	ldr	r3, [pc, #28]	@ (81008e4 <TestTaskFun+0x2c>)
 81008c6:	2201      	movs	r2, #1
 81008c8:	701a      	strb	r2, [r3, #0]
	    do
	    {
	        MainLoop();
 81008ca:	f004 fd77 	bl	81053bc <MainLoop>

	    } while (bRunApplication == TRUE);
 81008ce:	4b05      	ldr	r3, [pc, #20]	@ (81008e4 <TestTaskFun+0x2c>)
 81008d0:	781b      	ldrb	r3, [r3, #0]
 81008d2:	2b01      	cmp	r3, #1
 81008d4:	d0f9      	beq.n	81008ca <TestTaskFun+0x12>

	    HW_Release();
 81008d6:	f000 fbd5 	bl	8101084 <HW_Release>
//	  }
//	}
//	osDelay(1);
//	}
  /* USER CODE END TestTaskFun */
}
 81008da:	bf00      	nop
 81008dc:	3708      	adds	r7, #8
 81008de:	46bd      	mov	sp, r7
 81008e0:	bd80      	pop	{r7, pc}
 81008e2:	bf00      	nop
 81008e4:	1000078c 	.word	0x1000078c

081008e8 <HAL_TIM_PeriodElapsedCallback>:
  * a global variable "uwTick" used as application time base.
  * @param  htim : TIM handle
  * @retval None
  */
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
 81008e8:	b580      	push	{r7, lr}
 81008ea:	b082      	sub	sp, #8
 81008ec:	af00      	add	r7, sp, #0
 81008ee:	6078      	str	r0, [r7, #4]
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM7) {
 81008f0:	687b      	ldr	r3, [r7, #4]
 81008f2:	681b      	ldr	r3, [r3, #0]
 81008f4:	4a04      	ldr	r2, [pc, #16]	@ (8100908 <HAL_TIM_PeriodElapsedCallback+0x20>)
 81008f6:	4293      	cmp	r3, r2
 81008f8:	d101      	bne.n	81008fe <HAL_TIM_PeriodElapsedCallback+0x16>
    HAL_IncTick();
 81008fa:	f000 ff55 	bl	81017a8 <HAL_IncTick>
  /* USER CODE BEGIN Callback 1 */
  else if(htim->Instance==TIM2){

  	}
  /* USER CODE END Callback 1 */
}
 81008fe:	bf00      	nop
 8100900:	3708      	adds	r7, #8
 8100902:	46bd      	mov	sp, r7
 8100904:	bd80      	pop	{r7, pc}
 8100906:	bf00      	nop
 8100908:	40001400 	.word	0x40001400

0810090c <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
 810090c:	b480      	push	{r7}
 810090e:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8100910:	b672      	cpsid	i
}
 8100912:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8100914:	bf00      	nop
 8100916:	e7fd      	b.n	8100914 <Error_Handler+0x8>

08100918 <APPL_AckErrorInd>:
 \brief    The function is called when an error state was acknowledged by the master

*////////////////////////////////////////////////////////////////////////////////////////

void    APPL_AckErrorInd(UINT16 stateTrans)
{
 8100918:	b480      	push	{r7}
 810091a:	b083      	sub	sp, #12
 810091c:	af00      	add	r7, sp, #0
 810091e:	4603      	mov	r3, r0
 8100920:	80fb      	strh	r3, [r7, #6]

}
 8100922:	bf00      	nop
 8100924:	370c      	adds	r7, #12
 8100926:	46bd      	mov	sp, r7
 8100928:	f85d 7b04 	ldr.w	r7, [sp], #4
 810092c:	4770      	bx	lr

0810092e <APPL_StartMailboxHandler>:
            until a value unequal NOERROR_INWORK is returned

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartMailboxHandler(void)
{
 810092e:	b480      	push	{r7}
 8100930:	af00      	add	r7, sp, #0
    return ALSTATUSCODE_NOERROR;
 8100932:	2300      	movs	r3, #0
}
 8100934:	4618      	mov	r0, r3
 8100936:	46bd      	mov	sp, r7
 8100938:	f85d 7b04 	ldr.w	r7, [sp], #4
 810093c:	4770      	bx	lr

0810093e <APPL_StopMailboxHandler>:
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopMailboxHandler(void)
{
 810093e:	b480      	push	{r7}
 8100940:	af00      	add	r7, sp, #0
    return ALSTATUSCODE_NOERROR;
 8100942:	2300      	movs	r3, #0
}
 8100944:	4618      	mov	r0, r3
 8100946:	46bd      	mov	sp, r7
 8100948:	f85d 7b04 	ldr.w	r7, [sp], #4
 810094c:	4770      	bx	lr

0810094e <APPL_StartInputHandler>:
           the state transition immediately, in that case the application need to be complete 
           the transition by calling ECAT_StateChange.
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartInputHandler(UINT16 *pIntMask)
{
 810094e:	b480      	push	{r7}
 8100950:	b083      	sub	sp, #12
 8100952:	af00      	add	r7, sp, #0
 8100954:	6078      	str	r0, [r7, #4]
    return ALSTATUSCODE_NOERROR;
 8100956:	2300      	movs	r3, #0
}
 8100958:	4618      	mov	r0, r3
 810095a:	370c      	adds	r7, #12
 810095c:	46bd      	mov	sp, r7
 810095e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100962:	4770      	bx	lr

08100964 <APPL_StopInputHandler>:
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopInputHandler(void)
{
 8100964:	b480      	push	{r7}
 8100966:	af00      	add	r7, sp, #0
    return ALSTATUSCODE_NOERROR;
 8100968:	2300      	movs	r3, #0
}
 810096a:	4618      	mov	r0, r3
 810096c:	46bd      	mov	sp, r7
 810096e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100972:	4770      	bx	lr

08100974 <APPL_StartOutputHandler>:
           the state transition immediately, in that case the application need to be complete 
           the transition by calling ECAT_StateChange.
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StartOutputHandler(void)
{
 8100974:	b480      	push	{r7}
 8100976:	af00      	add	r7, sp, #0
    return ALSTATUSCODE_NOERROR;
 8100978:	2300      	movs	r3, #0
}
 810097a:	4618      	mov	r0, r3
 810097c:	46bd      	mov	sp, r7
 810097e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100982:	4770      	bx	lr

08100984 <APPL_StopOutputHandler>:
             the state transition.

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 APPL_StopOutputHandler(void)
{
 8100984:	b480      	push	{r7}
 8100986:	af00      	add	r7, sp, #0
    return ALSTATUSCODE_NOERROR;
 8100988:	2300      	movs	r3, #0
}
 810098a:	4618      	mov	r0, r3
 810098c:	46bd      	mov	sp, r7
 810098e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100992:	4770      	bx	lr

08100994 <APPL_GenerateMapping>:

\brief    This function calculates the process data sizes from the actual SM-PDO-Assign
            and PDO mapping
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 APPL_GenerateMapping(UINT16 *pInputSize,UINT16 *pOutputSize)
{
 8100994:	b590      	push	{r4, r7, lr}
 8100996:	b089      	sub	sp, #36	@ 0x24
 8100998:	af00      	add	r7, sp, #0
 810099a:	6078      	str	r0, [r7, #4]
 810099c:	6039      	str	r1, [r7, #0]
    UINT16 result = ALSTATUSCODE_NOERROR;
 810099e:	2300      	movs	r3, #0
 81009a0:	83fb      	strh	r3, [r7, #30]
    UINT16 InputSize = 0;
 81009a2:	2300      	movs	r3, #0
 81009a4:	83bb      	strh	r3, [r7, #28]
    UINT16 OutputSize = 0;
 81009a6:	2300      	movs	r3, #0
 81009a8:	837b      	strh	r3, [r7, #26]

#if COE_SUPPORTED
    UINT16 PDOAssignEntryCnt = 0;
 81009aa:	2300      	movs	r3, #0
 81009ac:	833b      	strh	r3, [r7, #24]
    OBJCONST TOBJECT OBJMEM * pPDO = NULL;
 81009ae:	2300      	movs	r3, #0
 81009b0:	613b      	str	r3, [r7, #16]
    UINT16 PDOSubindex0 = 0;
 81009b2:	2300      	movs	r3, #0
 81009b4:	81fb      	strh	r3, [r7, #14]
    UINT32 *pPDOEntry = NULL;
 81009b6:	2300      	movs	r3, #0
 81009b8:	60bb      	str	r3, [r7, #8]
    UINT16 PDOEntryCnt = 0;
 81009ba:	2300      	movs	r3, #0
 81009bc:	82fb      	strh	r3, [r7, #22]
   
    /*Scan object 0x1C12 RXPDO assign*/
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
 81009be:	2300      	movs	r3, #0
 81009c0:	833b      	strh	r3, [r7, #24]
 81009c2:	e039      	b.n	8100a38 <APPL_GenerateMapping+0xa4>
    {
        pPDO = OBJ_GetObjectHandle(sRxPDOassign.aEntries[PDOAssignEntryCnt]);
 81009c4:	8b3b      	ldrh	r3, [r7, #24]
 81009c6:	4a4b      	ldr	r2, [pc, #300]	@ (8100af4 <APPL_GenerateMapping+0x160>)
 81009c8:	005b      	lsls	r3, r3, #1
 81009ca:	4413      	add	r3, r2
 81009cc:	885b      	ldrh	r3, [r3, #2]
 81009ce:	4618      	mov	r0, r3
 81009d0:	f007 f93a 	bl	8107c48 <OBJ_GetObjectHandle>
 81009d4:	6138      	str	r0, [r7, #16]
        if(pPDO != NULL)
 81009d6:	693b      	ldr	r3, [r7, #16]
 81009d8:	2b00      	cmp	r3, #0
 81009da:	d025      	beq.n	8100a28 <APPL_GenerateMapping+0x94>
        {
            PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
 81009dc:	693b      	ldr	r3, [r7, #16]
 81009de:	699b      	ldr	r3, [r3, #24]
 81009e0:	881b      	ldrh	r3, [r3, #0]
 81009e2:	81fb      	strh	r3, [r7, #14]
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
 81009e4:	2300      	movs	r3, #0
 81009e6:	82fb      	strh	r3, [r7, #22]
 81009e8:	e019      	b.n	8100a1e <APPL_GenerateMapping+0x8a>
            {
                pPDOEntry = (UINT32 *)((UINT8 *)pPDO->pVarPtr + (OBJ_GetEntryOffset((PDOEntryCnt+1),pPDO)>>3));    //goto PDO entry
 81009ea:	693b      	ldr	r3, [r7, #16]
 81009ec:	699c      	ldr	r4, [r3, #24]
 81009ee:	8afb      	ldrh	r3, [r7, #22]
 81009f0:	b2db      	uxtb	r3, r3
 81009f2:	3301      	adds	r3, #1
 81009f4:	b2db      	uxtb	r3, r3
 81009f6:	6939      	ldr	r1, [r7, #16]
 81009f8:	4618      	mov	r0, r3
 81009fa:	f007 fba7 	bl	810814c <OBJ_GetEntryOffset>
 81009fe:	4603      	mov	r3, r0
 8100a00:	08db      	lsrs	r3, r3, #3
 8100a02:	b29b      	uxth	r3, r3
 8100a04:	4423      	add	r3, r4
 8100a06:	60bb      	str	r3, [r7, #8]
                // we increment the expected output size depending on the mapped Entry
                OutputSize += (UINT16) ((*pPDOEntry) & 0xFF);
 8100a08:	68bb      	ldr	r3, [r7, #8]
 8100a0a:	681b      	ldr	r3, [r3, #0]
 8100a0c:	b29b      	uxth	r3, r3
 8100a0e:	b2db      	uxtb	r3, r3
 8100a10:	b29a      	uxth	r2, r3
 8100a12:	8b7b      	ldrh	r3, [r7, #26]
 8100a14:	4413      	add	r3, r2
 8100a16:	837b      	strh	r3, [r7, #26]
            for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
 8100a18:	8afb      	ldrh	r3, [r7, #22]
 8100a1a:	3301      	adds	r3, #1
 8100a1c:	82fb      	strh	r3, [r7, #22]
 8100a1e:	8afa      	ldrh	r2, [r7, #22]
 8100a20:	89fb      	ldrh	r3, [r7, #14]
 8100a22:	429a      	cmp	r2, r3
 8100a24:	d3e1      	bcc.n	81009ea <APPL_GenerateMapping+0x56>
 8100a26:	e004      	b.n	8100a32 <APPL_GenerateMapping+0x9e>
            }
        }
        else
        {
            /*assigned PDO was not found in object dictionary. return invalid mapping*/
            OutputSize = 0;
 8100a28:	2300      	movs	r3, #0
 8100a2a:	837b      	strh	r3, [r7, #26]
            result = ALSTATUSCODE_INVALIDOUTPUTMAPPING;
 8100a2c:	2325      	movs	r3, #37	@ 0x25
 8100a2e:	83fb      	strh	r3, [r7, #30]
            break;
 8100a30:	e007      	b.n	8100a42 <APPL_GenerateMapping+0xae>
    for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sRxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
 8100a32:	8b3b      	ldrh	r3, [r7, #24]
 8100a34:	3301      	adds	r3, #1
 8100a36:	833b      	strh	r3, [r7, #24]
 8100a38:	4b2e      	ldr	r3, [pc, #184]	@ (8100af4 <APPL_GenerateMapping+0x160>)
 8100a3a:	881b      	ldrh	r3, [r3, #0]
 8100a3c:	8b3a      	ldrh	r2, [r7, #24]
 8100a3e:	429a      	cmp	r2, r3
 8100a40:	d3c0      	bcc.n	81009c4 <APPL_GenerateMapping+0x30>
        }
    }

    OutputSize = (OutputSize + 7) >> 3;
 8100a42:	8b7b      	ldrh	r3, [r7, #26]
 8100a44:	3307      	adds	r3, #7
 8100a46:	10db      	asrs	r3, r3, #3
 8100a48:	837b      	strh	r3, [r7, #26]

    if(result == 0)
 8100a4a:	8bfb      	ldrh	r3, [r7, #30]
 8100a4c:	2b00      	cmp	r3, #0
 8100a4e:	d141      	bne.n	8100ad4 <APPL_GenerateMapping+0x140>
    {
        /*Scan Object 0x1C13 TXPDO assign*/
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
 8100a50:	2300      	movs	r3, #0
 8100a52:	833b      	strh	r3, [r7, #24]
 8100a54:	e039      	b.n	8100aca <APPL_GenerateMapping+0x136>
        {
            pPDO = OBJ_GetObjectHandle(sTxPDOassign.aEntries[PDOAssignEntryCnt]);
 8100a56:	8b3b      	ldrh	r3, [r7, #24]
 8100a58:	4a27      	ldr	r2, [pc, #156]	@ (8100af8 <APPL_GenerateMapping+0x164>)
 8100a5a:	005b      	lsls	r3, r3, #1
 8100a5c:	4413      	add	r3, r2
 8100a5e:	885b      	ldrh	r3, [r3, #2]
 8100a60:	4618      	mov	r0, r3
 8100a62:	f007 f8f1 	bl	8107c48 <OBJ_GetObjectHandle>
 8100a66:	6138      	str	r0, [r7, #16]
            if(pPDO != NULL)
 8100a68:	693b      	ldr	r3, [r7, #16]
 8100a6a:	2b00      	cmp	r3, #0
 8100a6c:	d025      	beq.n	8100aba <APPL_GenerateMapping+0x126>
            {
                PDOSubindex0 = *((UINT16 *)pPDO->pVarPtr);
 8100a6e:	693b      	ldr	r3, [r7, #16]
 8100a70:	699b      	ldr	r3, [r3, #24]
 8100a72:	881b      	ldrh	r3, [r3, #0]
 8100a74:	81fb      	strh	r3, [r7, #14]
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
 8100a76:	2300      	movs	r3, #0
 8100a78:	82fb      	strh	r3, [r7, #22]
 8100a7a:	e019      	b.n	8100ab0 <APPL_GenerateMapping+0x11c>
                {
                    pPDOEntry = (UINT32 *)((UINT8 *)pPDO->pVarPtr + (OBJ_GetEntryOffset((PDOEntryCnt+1),pPDO)>>3));    //goto PDO entry
 8100a7c:	693b      	ldr	r3, [r7, #16]
 8100a7e:	699c      	ldr	r4, [r3, #24]
 8100a80:	8afb      	ldrh	r3, [r7, #22]
 8100a82:	b2db      	uxtb	r3, r3
 8100a84:	3301      	adds	r3, #1
 8100a86:	b2db      	uxtb	r3, r3
 8100a88:	6939      	ldr	r1, [r7, #16]
 8100a8a:	4618      	mov	r0, r3
 8100a8c:	f007 fb5e 	bl	810814c <OBJ_GetEntryOffset>
 8100a90:	4603      	mov	r3, r0
 8100a92:	08db      	lsrs	r3, r3, #3
 8100a94:	b29b      	uxth	r3, r3
 8100a96:	4423      	add	r3, r4
 8100a98:	60bb      	str	r3, [r7, #8]
                    // we increment the expected output size depending on the mapped Entry
                    InputSize += (UINT16) ((*pPDOEntry) & 0xFF);
 8100a9a:	68bb      	ldr	r3, [r7, #8]
 8100a9c:	681b      	ldr	r3, [r3, #0]
 8100a9e:	b29b      	uxth	r3, r3
 8100aa0:	b2db      	uxtb	r3, r3
 8100aa2:	b29a      	uxth	r2, r3
 8100aa4:	8bbb      	ldrh	r3, [r7, #28]
 8100aa6:	4413      	add	r3, r2
 8100aa8:	83bb      	strh	r3, [r7, #28]
                for(PDOEntryCnt = 0; PDOEntryCnt < PDOSubindex0; PDOEntryCnt++)
 8100aaa:	8afb      	ldrh	r3, [r7, #22]
 8100aac:	3301      	adds	r3, #1
 8100aae:	82fb      	strh	r3, [r7, #22]
 8100ab0:	8afa      	ldrh	r2, [r7, #22]
 8100ab2:	89fb      	ldrh	r3, [r7, #14]
 8100ab4:	429a      	cmp	r2, r3
 8100ab6:	d3e1      	bcc.n	8100a7c <APPL_GenerateMapping+0xe8>
 8100ab8:	e004      	b.n	8100ac4 <APPL_GenerateMapping+0x130>
                }
            }
            else
            {
                /*assigned PDO was not found in object dictionary. return invalid mapping*/
                InputSize = 0;
 8100aba:	2300      	movs	r3, #0
 8100abc:	83bb      	strh	r3, [r7, #28]
                result = ALSTATUSCODE_INVALIDINPUTMAPPING;
 8100abe:	2324      	movs	r3, #36	@ 0x24
 8100ac0:	83fb      	strh	r3, [r7, #30]
                break;
 8100ac2:	e007      	b.n	8100ad4 <APPL_GenerateMapping+0x140>
        for(PDOAssignEntryCnt = 0; PDOAssignEntryCnt < sTxPDOassign.u16SubIndex0; PDOAssignEntryCnt++)
 8100ac4:	8b3b      	ldrh	r3, [r7, #24]
 8100ac6:	3301      	adds	r3, #1
 8100ac8:	833b      	strh	r3, [r7, #24]
 8100aca:	4b0b      	ldr	r3, [pc, #44]	@ (8100af8 <APPL_GenerateMapping+0x164>)
 8100acc:	881b      	ldrh	r3, [r3, #0]
 8100ace:	8b3a      	ldrh	r2, [r7, #24]
 8100ad0:	429a      	cmp	r2, r3
 8100ad2:	d3c0      	bcc.n	8100a56 <APPL_GenerateMapping+0xc2>
            }
        }
    }
    InputSize = (InputSize + 7) >> 3;
 8100ad4:	8bbb      	ldrh	r3, [r7, #28]
 8100ad6:	3307      	adds	r3, #7
 8100ad8:	10db      	asrs	r3, r3, #3
 8100ada:	83bb      	strh	r3, [r7, #28]
#else
    #warning "Define 'InputSize' and 'OutputSize'."
#endif
#endif

    *pInputSize = InputSize;
 8100adc:	687b      	ldr	r3, [r7, #4]
 8100ade:	8bba      	ldrh	r2, [r7, #28]
 8100ae0:	801a      	strh	r2, [r3, #0]
    *pOutputSize = OutputSize;
 8100ae2:	683b      	ldr	r3, [r7, #0]
 8100ae4:	8b7a      	ldrh	r2, [r7, #26]
 8100ae6:	801a      	strh	r2, [r3, #0]
    return result;
 8100ae8:	8bfb      	ldrh	r3, [r7, #30]
}
 8100aea:	4618      	mov	r0, r3
 8100aec:	3724      	adds	r7, #36	@ 0x24
 8100aee:	46bd      	mov	sp, r7
 8100af0:	bd90      	pop	{r4, r7, pc}
 8100af2:	bf00      	nop
 8100af4:	10000064 	.word	0x10000064
 8100af8:	1000006c 	.word	0x1000006c

08100afc <APPL_InputMapping>:

\brief      This function will copies the inputs from the local memory to the ESC memory
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_InputMapping(UINT16* pData)
{
 8100afc:	b480      	push	{r7}
 8100afe:	b085      	sub	sp, #20
 8100b00:	af00      	add	r7, sp, #0
 8100b02:	6078      	str	r0, [r7, #4]
    UINT16 j = 0;
 8100b04:	2300      	movs	r3, #0
 8100b06:	81fb      	strh	r3, [r7, #14]
    UINT16 *pTmpData = (UINT16 *)pData;
 8100b08:	687b      	ldr	r3, [r7, #4]
 8100b0a:	60bb      	str	r3, [r7, #8]

    /* we go through all entries of the TxPDO Assign object to get the assigned TxPDOs */
   for (j = 0; j < sTxPDOassign.u16SubIndex0; j++)
 8100b0c:	2300      	movs	r3, #0
 8100b0e:	81fb      	strh	r3, [r7, #14]
 8100b10:	e0a1      	b.n	8100c56 <APPL_InputMapping+0x15a>
   {
      switch (sTxPDOassign.aEntries[j])
 8100b12:	89fb      	ldrh	r3, [r7, #14]
 8100b14:	4a56      	ldr	r2, [pc, #344]	@ (8100c70 <APPL_InputMapping+0x174>)
 8100b16:	005b      	lsls	r3, r3, #1
 8100b18:	4413      	add	r3, r2
 8100b1a:	885b      	ldrh	r3, [r3, #2]
 8100b1c:	f5b3 5fd0 	cmp.w	r3, #6656	@ 0x1a00
 8100b20:	d004      	beq.n	8100b2c <APPL_InputMapping+0x30>
 8100b22:	f641 2205 	movw	r2, #6661	@ 0x1a05
 8100b26:	4293      	cmp	r3, r2
 8100b28:	d061      	beq.n	8100bee <APPL_InputMapping+0xf2>
 8100b2a:	e091      	b.n	8100c50 <APPL_InputMapping+0x154>
      {
      /* TxPDO 1 */
      case 0x1A00:
		*pTmpData++ = (((UINT16 *) &SSIData0x6000)[2]);
 8100b2c:	68bb      	ldr	r3, [r7, #8]
 8100b2e:	1c9a      	adds	r2, r3, #2
 8100b30:	60ba      	str	r2, [r7, #8]
 8100b32:	4a50      	ldr	r2, [pc, #320]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100b34:	8892      	ldrh	r2, [r2, #4]
 8100b36:	801a      	strh	r2, [r3, #0]
        *pTmpData++ = (((UINT16 *) &SSIData0x6000)[3]);
 8100b38:	68bb      	ldr	r3, [r7, #8]
 8100b3a:	1c9a      	adds	r2, r3, #2
 8100b3c:	60ba      	str	r2, [r7, #8]
 8100b3e:	4a4d      	ldr	r2, [pc, #308]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100b40:	88d2      	ldrh	r2, [r2, #6]
 8100b42:	801a      	strh	r2, [r3, #0]
		*pTmpData++ = (((UINT16 *) &SSIData0x6000)[4]);
 8100b44:	68bb      	ldr	r3, [r7, #8]
 8100b46:	1c9a      	adds	r2, r3, #2
 8100b48:	60ba      	str	r2, [r7, #8]
 8100b4a:	4a4a      	ldr	r2, [pc, #296]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100b4c:	8912      	ldrh	r2, [r2, #8]
 8100b4e:	801a      	strh	r2, [r3, #0]
        *pTmpData++ = (((UINT16 *) &SSIData0x6000)[5]);
 8100b50:	68bb      	ldr	r3, [r7, #8]
 8100b52:	1c9a      	adds	r2, r3, #2
 8100b54:	60ba      	str	r2, [r7, #8]
 8100b56:	4a47      	ldr	r2, [pc, #284]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100b58:	8952      	ldrh	r2, [r2, #10]
 8100b5a:	801a      	strh	r2, [r3, #0]
		*pTmpData++ = (((UINT16 *) &SSIData0x6000)[6]);
 8100b5c:	68bb      	ldr	r3, [r7, #8]
 8100b5e:	1c9a      	adds	r2, r3, #2
 8100b60:	60ba      	str	r2, [r7, #8]
 8100b62:	4a44      	ldr	r2, [pc, #272]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100b64:	8992      	ldrh	r2, [r2, #12]
 8100b66:	801a      	strh	r2, [r3, #0]
        *pTmpData++ = (((UINT16 *) &SSIData0x6000)[7]);
 8100b68:	68bb      	ldr	r3, [r7, #8]
 8100b6a:	1c9a      	adds	r2, r3, #2
 8100b6c:	60ba      	str	r2, [r7, #8]
 8100b6e:	4a41      	ldr	r2, [pc, #260]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100b70:	89d2      	ldrh	r2, [r2, #14]
 8100b72:	801a      	strh	r2, [r3, #0]
		*pTmpData++ = (((UINT16 *) &SSIData0x6000)[8]);
 8100b74:	68bb      	ldr	r3, [r7, #8]
 8100b76:	1c9a      	adds	r2, r3, #2
 8100b78:	60ba      	str	r2, [r7, #8]
 8100b7a:	4a3e      	ldr	r2, [pc, #248]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100b7c:	8a12      	ldrh	r2, [r2, #16]
 8100b7e:	801a      	strh	r2, [r3, #0]
        *pTmpData++ = (((UINT16 *) &SSIData0x6000)[9]);
 8100b80:	68bb      	ldr	r3, [r7, #8]
 8100b82:	1c9a      	adds	r2, r3, #2
 8100b84:	60ba      	str	r2, [r7, #8]
 8100b86:	4a3b      	ldr	r2, [pc, #236]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100b88:	8a52      	ldrh	r2, [r2, #18]
 8100b8a:	801a      	strh	r2, [r3, #0]
		*pTmpData++ = (((UINT16 *) &SSIData0x6000)[10]);
 8100b8c:	68bb      	ldr	r3, [r7, #8]
 8100b8e:	1c9a      	adds	r2, r3, #2
 8100b90:	60ba      	str	r2, [r7, #8]
 8100b92:	4a38      	ldr	r2, [pc, #224]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100b94:	8a92      	ldrh	r2, [r2, #20]
 8100b96:	801a      	strh	r2, [r3, #0]
        *pTmpData++ = (((UINT16 *) &SSIData0x6000)[11]);
 8100b98:	68bb      	ldr	r3, [r7, #8]
 8100b9a:	1c9a      	adds	r2, r3, #2
 8100b9c:	60ba      	str	r2, [r7, #8]
 8100b9e:	4a35      	ldr	r2, [pc, #212]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100ba0:	8ad2      	ldrh	r2, [r2, #22]
 8100ba2:	801a      	strh	r2, [r3, #0]
		*pTmpData++ = (((UINT16 *) &SSIData0x6000)[12]);
 8100ba4:	68bb      	ldr	r3, [r7, #8]
 8100ba6:	1c9a      	adds	r2, r3, #2
 8100ba8:	60ba      	str	r2, [r7, #8]
 8100baa:	4a32      	ldr	r2, [pc, #200]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100bac:	8b12      	ldrh	r2, [r2, #24]
 8100bae:	801a      	strh	r2, [r3, #0]
        *pTmpData++ = (((UINT16 *) &SSIData0x6000)[13]);
 8100bb0:	68bb      	ldr	r3, [r7, #8]
 8100bb2:	1c9a      	adds	r2, r3, #2
 8100bb4:	60ba      	str	r2, [r7, #8]
 8100bb6:	4a2f      	ldr	r2, [pc, #188]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100bb8:	8b52      	ldrh	r2, [r2, #26]
 8100bba:	801a      	strh	r2, [r3, #0]
		*pTmpData++ = (((UINT16 *) &SSIData0x6000)[14]);
 8100bbc:	68bb      	ldr	r3, [r7, #8]
 8100bbe:	1c9a      	adds	r2, r3, #2
 8100bc0:	60ba      	str	r2, [r7, #8]
 8100bc2:	4a2c      	ldr	r2, [pc, #176]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100bc4:	8b92      	ldrh	r2, [r2, #28]
 8100bc6:	801a      	strh	r2, [r3, #0]
        *pTmpData++ = (((UINT16 *) &SSIData0x6000)[15]);
 8100bc8:	68bb      	ldr	r3, [r7, #8]
 8100bca:	1c9a      	adds	r2, r3, #2
 8100bcc:	60ba      	str	r2, [r7, #8]
 8100bce:	4a29      	ldr	r2, [pc, #164]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100bd0:	8bd2      	ldrh	r2, [r2, #30]
 8100bd2:	801a      	strh	r2, [r3, #0]
		*pTmpData++ = (((UINT16 *) &SSIData0x6000)[16]);
 8100bd4:	68bb      	ldr	r3, [r7, #8]
 8100bd6:	1c9a      	adds	r2, r3, #2
 8100bd8:	60ba      	str	r2, [r7, #8]
 8100bda:	4a26      	ldr	r2, [pc, #152]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100bdc:	8c12      	ldrh	r2, [r2, #32]
 8100bde:	801a      	strh	r2, [r3, #0]
        *pTmpData++ = (((UINT16 *) &SSIData0x6000)[17]);
 8100be0:	68bb      	ldr	r3, [r7, #8]
 8100be2:	1c9a      	adds	r2, r3, #2
 8100be4:	60ba      	str	r2, [r7, #8]
 8100be6:	4a23      	ldr	r2, [pc, #140]	@ (8100c74 <APPL_InputMapping+0x178>)
 8100be8:	8c52      	ldrh	r2, [r2, #34]	@ 0x22
 8100bea:	801a      	strh	r2, [r3, #0]

         break;
 8100bec:	e030      	b.n	8100c50 <APPL_InputMapping+0x154>
	  case 0x1A05:
		*pTmpData++ = (((UINT16 *) &AINData0x6010)[1]);
 8100bee:	68bb      	ldr	r3, [r7, #8]
 8100bf0:	1c9a      	adds	r2, r3, #2
 8100bf2:	60ba      	str	r2, [r7, #8]
 8100bf4:	4a20      	ldr	r2, [pc, #128]	@ (8100c78 <APPL_InputMapping+0x17c>)
 8100bf6:	8852      	ldrh	r2, [r2, #2]
 8100bf8:	801a      	strh	r2, [r3, #0]
        *pTmpData++ = (((UINT16 *) &AINData0x6010)[2]);
 8100bfa:	68bb      	ldr	r3, [r7, #8]
 8100bfc:	1c9a      	adds	r2, r3, #2
 8100bfe:	60ba      	str	r2, [r7, #8]
 8100c00:	4a1d      	ldr	r2, [pc, #116]	@ (8100c78 <APPL_InputMapping+0x17c>)
 8100c02:	8892      	ldrh	r2, [r2, #4]
 8100c04:	801a      	strh	r2, [r3, #0]
		*pTmpData++ = (((UINT16 *) &AINData0x6010)[3]);
 8100c06:	68bb      	ldr	r3, [r7, #8]
 8100c08:	1c9a      	adds	r2, r3, #2
 8100c0a:	60ba      	str	r2, [r7, #8]
 8100c0c:	4a1a      	ldr	r2, [pc, #104]	@ (8100c78 <APPL_InputMapping+0x17c>)
 8100c0e:	88d2      	ldrh	r2, [r2, #6]
 8100c10:	801a      	strh	r2, [r3, #0]
		*pTmpData++ = (((UINT16 *) &AINData0x6010)[4]);
 8100c12:	68bb      	ldr	r3, [r7, #8]
 8100c14:	1c9a      	adds	r2, r3, #2
 8100c16:	60ba      	str	r2, [r7, #8]
 8100c18:	4a17      	ldr	r2, [pc, #92]	@ (8100c78 <APPL_InputMapping+0x17c>)
 8100c1a:	8912      	ldrh	r2, [r2, #8]
 8100c1c:	801a      	strh	r2, [r3, #0]
        *pTmpData++ = (((UINT16 *) &AINData0x6010)[5]);
 8100c1e:	68bb      	ldr	r3, [r7, #8]
 8100c20:	1c9a      	adds	r2, r3, #2
 8100c22:	60ba      	str	r2, [r7, #8]
 8100c24:	4a14      	ldr	r2, [pc, #80]	@ (8100c78 <APPL_InputMapping+0x17c>)
 8100c26:	8952      	ldrh	r2, [r2, #10]
 8100c28:	801a      	strh	r2, [r3, #0]
		*pTmpData++ = (((UINT16 *) &AINData0x6010)[6]);
 8100c2a:	68bb      	ldr	r3, [r7, #8]
 8100c2c:	1c9a      	adds	r2, r3, #2
 8100c2e:	60ba      	str	r2, [r7, #8]
 8100c30:	4a11      	ldr	r2, [pc, #68]	@ (8100c78 <APPL_InputMapping+0x17c>)
 8100c32:	8992      	ldrh	r2, [r2, #12]
 8100c34:	801a      	strh	r2, [r3, #0]
		*pTmpData++ = (((UINT16 *) &AINData0x6010)[7]);
 8100c36:	68bb      	ldr	r3, [r7, #8]
 8100c38:	1c9a      	adds	r2, r3, #2
 8100c3a:	60ba      	str	r2, [r7, #8]
 8100c3c:	4a0e      	ldr	r2, [pc, #56]	@ (8100c78 <APPL_InputMapping+0x17c>)
 8100c3e:	89d2      	ldrh	r2, [r2, #14]
 8100c40:	801a      	strh	r2, [r3, #0]
        *pTmpData++ = (((UINT16 *) &AINData0x6010)[8]);
 8100c42:	68bb      	ldr	r3, [r7, #8]
 8100c44:	1c9a      	adds	r2, r3, #2
 8100c46:	60ba      	str	r2, [r7, #8]
 8100c48:	4a0b      	ldr	r2, [pc, #44]	@ (8100c78 <APPL_InputMapping+0x17c>)
 8100c4a:	8a12      	ldrh	r2, [r2, #16]
 8100c4c:	801a      	strh	r2, [r3, #0]
			break;
 8100c4e:	bf00      	nop
   for (j = 0; j < sTxPDOassign.u16SubIndex0; j++)
 8100c50:	89fb      	ldrh	r3, [r7, #14]
 8100c52:	3301      	adds	r3, #1
 8100c54:	81fb      	strh	r3, [r7, #14]
 8100c56:	4b06      	ldr	r3, [pc, #24]	@ (8100c70 <APPL_InputMapping+0x174>)
 8100c58:	881b      	ldrh	r3, [r3, #0]
 8100c5a:	89fa      	ldrh	r2, [r7, #14]
 8100c5c:	429a      	cmp	r2, r3
 8100c5e:	f4ff af58 	bcc.w	8100b12 <APPL_InputMapping+0x16>
					
      /* TxPDO 3 */
      }
   }
}
 8100c62:	bf00      	nop
 8100c64:	bf00      	nop
 8100c66:	3714      	adds	r7, #20
 8100c68:	46bd      	mov	sp, r7
 8100c6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100c6e:	4770      	bx	lr
 8100c70:	1000006c 	.word	0x1000006c
 8100c74:	10000074 	.word	0x10000074
 8100c78:	10000098 	.word	0x10000098

08100c7c <APPL_OutputMapping>:

\brief    This function will copies the outputs from the ESC memory to the local memory
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_OutputMapping(UINT16* pData)
{
 8100c7c:	b480      	push	{r7}
 8100c7e:	b085      	sub	sp, #20
 8100c80:	af00      	add	r7, sp, #0
 8100c82:	6078      	str	r0, [r7, #4]
    UINT16 j = 0;
 8100c84:	2300      	movs	r3, #0
 8100c86:	81fb      	strh	r3, [r7, #14]
    UINT16 *pTmpData = (UINT16 *)pData;
 8100c88:	687b      	ldr	r3, [r7, #4]
 8100c8a:	60bb      	str	r3, [r7, #8]

    /* we go through all entries of the RxPDO Assign object to get the assigned RxPDOs */
    for (j = 0; j < sRxPDOassign.u16SubIndex0; j++)
 8100c8c:	2300      	movs	r3, #0
 8100c8e:	81fb      	strh	r3, [r7, #14]
 8100c90:	e024      	b.n	8100cdc <APPL_OutputMapping+0x60>
    {
        switch (sRxPDOassign.aEntries[j])
 8100c92:	89fb      	ldrh	r3, [r7, #14]
 8100c94:	4a17      	ldr	r2, [pc, #92]	@ (8100cf4 <APPL_OutputMapping+0x78>)
 8100c96:	005b      	lsls	r3, r3, #1
 8100c98:	4413      	add	r3, r2
 8100c9a:	885b      	ldrh	r3, [r3, #2]
 8100c9c:	f241 6201 	movw	r2, #5633	@ 0x1601
 8100ca0:	4293      	cmp	r3, r2
 8100ca2:	d004      	beq.n	8100cae <APPL_OutputMapping+0x32>
 8100ca4:	f241 6202 	movw	r2, #5634	@ 0x1602
 8100ca8:	4293      	cmp	r3, r2
 8100caa:	d007      	beq.n	8100cbc <APPL_OutputMapping+0x40>
 8100cac:	e013      	b.n	8100cd6 <APPL_OutputMapping+0x5a>
        {
        /* RxPDO 2 */
        case 0x1601:
        	((UINT16 *) &CommondOfMoudule0x7020)[1] = SWAPWORD(*pTmpData++);
 8100cae:	68bb      	ldr	r3, [r7, #8]
 8100cb0:	1c9a      	adds	r2, r3, #2
 8100cb2:	60ba      	str	r2, [r7, #8]
 8100cb4:	4a10      	ldr	r2, [pc, #64]	@ (8100cf8 <APPL_OutputMapping+0x7c>)
 8100cb6:	881b      	ldrh	r3, [r3, #0]
 8100cb8:	8013      	strh	r3, [r2, #0]
            break;
 8100cba:	e00c      	b.n	8100cd6 <APPL_OutputMapping+0x5a>
		case 0x1602:
            ((UINT16 *) &Target0x7030)[1] = SWAPWORD(*pTmpData++);
 8100cbc:	68bb      	ldr	r3, [r7, #8]
 8100cbe:	1c9a      	adds	r2, r3, #2
 8100cc0:	60ba      	str	r2, [r7, #8]
 8100cc2:	4a0e      	ldr	r2, [pc, #56]	@ (8100cfc <APPL_OutputMapping+0x80>)
 8100cc4:	881b      	ldrh	r3, [r3, #0]
 8100cc6:	8013      	strh	r3, [r2, #0]
			((UINT16 *) &Target0x7030)[2] = SWAPWORD(*pTmpData++);
 8100cc8:	68bb      	ldr	r3, [r7, #8]
 8100cca:	1c9a      	adds	r2, r3, #2
 8100ccc:	60ba      	str	r2, [r7, #8]
 8100cce:	4a0c      	ldr	r2, [pc, #48]	@ (8100d00 <APPL_OutputMapping+0x84>)
 8100cd0:	881b      	ldrh	r3, [r3, #0]
 8100cd2:	8013      	strh	r3, [r2, #0]
            break;
 8100cd4:	bf00      	nop
    for (j = 0; j < sRxPDOassign.u16SubIndex0; j++)
 8100cd6:	89fb      	ldrh	r3, [r7, #14]
 8100cd8:	3301      	adds	r3, #1
 8100cda:	81fb      	strh	r3, [r7, #14]
 8100cdc:	4b05      	ldr	r3, [pc, #20]	@ (8100cf4 <APPL_OutputMapping+0x78>)
 8100cde:	881b      	ldrh	r3, [r3, #0]
 8100ce0:	89fa      	ldrh	r2, [r7, #14]
 8100ce2:	429a      	cmp	r2, r3
 8100ce4:	d3d5      	bcc.n	8100c92 <APPL_OutputMapping+0x16>
        }
    }
}
 8100ce6:	bf00      	nop
 8100ce8:	bf00      	nop
 8100cea:	3714      	adds	r7, #20
 8100cec:	46bd      	mov	sp, r7
 8100cee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100cf2:	4770      	bx	lr
 8100cf4:	10000064 	.word	0x10000064
 8100cf8:	100000ae 	.word	0x100000ae
 8100cfc:	100000b2 	.word	0x100000b2
 8100d00:	100000b4 	.word	0x100000b4

08100d04 <APPL_Application>:
/**
\brief    This function will called from the synchronisation ISR 
            or from the mainloop if no synchronisation is supported
*////////////////////////////////////////////////////////////////////////////////////////
void APPL_Application(void)
{
 8100d04:	b480      	push	{r7}
 8100d06:	af00      	add	r7, sp, #0
	count++;
 8100d08:	4b56      	ldr	r3, [pc, #344]	@ (8100e64 <APPL_Application+0x160>)
 8100d0a:	681b      	ldr	r3, [r3, #0]
 8100d0c:	3301      	adds	r3, #1
 8100d0e:	4a55      	ldr	r2, [pc, #340]	@ (8100e64 <APPL_Application+0x160>)
 8100d10:	6013      	str	r3, [r2, #0]
//	SSIData0x6000.Ssi=angle_all[0];
	ang_float[0]=angle_all[0];
 8100d12:	4b55      	ldr	r3, [pc, #340]	@ (8100e68 <APPL_Application+0x164>)
 8100d14:	681b      	ldr	r3, [r3, #0]
 8100d16:	4a55      	ldr	r2, [pc, #340]	@ (8100e6c <APPL_Application+0x168>)
 8100d18:	6013      	str	r3, [r2, #0]
	MEMCPY(ang_int, ang_float, sizeof(ang_float));
 8100d1a:	4b54      	ldr	r3, [pc, #336]	@ (8100e6c <APPL_Application+0x168>)
 8100d1c:	681b      	ldr	r3, [r3, #0]
 8100d1e:	4a54      	ldr	r2, [pc, #336]	@ (8100e70 <APPL_Application+0x16c>)
 8100d20:	6013      	str	r3, [r2, #0]
	SSIData0x6000.Ssi=ang_int[0];
 8100d22:	4b53      	ldr	r3, [pc, #332]	@ (8100e70 <APPL_Application+0x16c>)
 8100d24:	681b      	ldr	r3, [r3, #0]
 8100d26:	4a53      	ldr	r2, [pc, #332]	@ (8100e74 <APPL_Application+0x170>)
 8100d28:	6053      	str	r3, [r2, #4]

	ang_float[0]=angle_all[1];
 8100d2a:	4b4f      	ldr	r3, [pc, #316]	@ (8100e68 <APPL_Application+0x164>)
 8100d2c:	685b      	ldr	r3, [r3, #4]
 8100d2e:	4a4f      	ldr	r2, [pc, #316]	@ (8100e6c <APPL_Application+0x168>)
 8100d30:	6013      	str	r3, [r2, #0]
	MEMCPY(ang_int, ang_float, sizeof(ang_float));
 8100d32:	4b4e      	ldr	r3, [pc, #312]	@ (8100e6c <APPL_Application+0x168>)
 8100d34:	681b      	ldr	r3, [r3, #0]
 8100d36:	4a4e      	ldr	r2, [pc, #312]	@ (8100e70 <APPL_Application+0x16c>)
 8100d38:	6013      	str	r3, [r2, #0]
	SSIData0x6000.Ssi2=ang_int[0];
 8100d3a:	4b4d      	ldr	r3, [pc, #308]	@ (8100e70 <APPL_Application+0x16c>)
 8100d3c:	681b      	ldr	r3, [r3, #0]
 8100d3e:	4a4d      	ldr	r2, [pc, #308]	@ (8100e74 <APPL_Application+0x170>)
 8100d40:	6093      	str	r3, [r2, #8]

	ang_float[0]=angle_all[2];
 8100d42:	4b49      	ldr	r3, [pc, #292]	@ (8100e68 <APPL_Application+0x164>)
 8100d44:	689b      	ldr	r3, [r3, #8]
 8100d46:	4a49      	ldr	r2, [pc, #292]	@ (8100e6c <APPL_Application+0x168>)
 8100d48:	6013      	str	r3, [r2, #0]
	MEMCPY(ang_int, ang_float, sizeof(ang_float));
 8100d4a:	4b48      	ldr	r3, [pc, #288]	@ (8100e6c <APPL_Application+0x168>)
 8100d4c:	681b      	ldr	r3, [r3, #0]
 8100d4e:	4a48      	ldr	r2, [pc, #288]	@ (8100e70 <APPL_Application+0x16c>)
 8100d50:	6013      	str	r3, [r2, #0]
	SSIData0x6000.Ssi3=ang_int[0];
 8100d52:	4b47      	ldr	r3, [pc, #284]	@ (8100e70 <APPL_Application+0x16c>)
 8100d54:	681b      	ldr	r3, [r3, #0]
 8100d56:	4a47      	ldr	r2, [pc, #284]	@ (8100e74 <APPL_Application+0x170>)
 8100d58:	60d3      	str	r3, [r2, #12]

	ang_float[0]=angle_all[3];
 8100d5a:	4b43      	ldr	r3, [pc, #268]	@ (8100e68 <APPL_Application+0x164>)
 8100d5c:	68db      	ldr	r3, [r3, #12]
 8100d5e:	4a43      	ldr	r2, [pc, #268]	@ (8100e6c <APPL_Application+0x168>)
 8100d60:	6013      	str	r3, [r2, #0]
	MEMCPY(ang_int, ang_float, sizeof(ang_float));
 8100d62:	4b42      	ldr	r3, [pc, #264]	@ (8100e6c <APPL_Application+0x168>)
 8100d64:	681b      	ldr	r3, [r3, #0]
 8100d66:	4a42      	ldr	r2, [pc, #264]	@ (8100e70 <APPL_Application+0x16c>)
 8100d68:	6013      	str	r3, [r2, #0]
	SSIData0x6000.Ssi4=ang_int[0];
 8100d6a:	4b41      	ldr	r3, [pc, #260]	@ (8100e70 <APPL_Application+0x16c>)
 8100d6c:	681b      	ldr	r3, [r3, #0]
 8100d6e:	4a41      	ldr	r2, [pc, #260]	@ (8100e74 <APPL_Application+0x170>)
 8100d70:	6113      	str	r3, [r2, #16]

	ang_float[0]=angle_all[5];
 8100d72:	4b3d      	ldr	r3, [pc, #244]	@ (8100e68 <APPL_Application+0x164>)
 8100d74:	695b      	ldr	r3, [r3, #20]
 8100d76:	4a3d      	ldr	r2, [pc, #244]	@ (8100e6c <APPL_Application+0x168>)
 8100d78:	6013      	str	r3, [r2, #0]
	MEMCPY(ang_int, ang_float, sizeof(ang_float));
 8100d7a:	4b3c      	ldr	r3, [pc, #240]	@ (8100e6c <APPL_Application+0x168>)
 8100d7c:	681b      	ldr	r3, [r3, #0]
 8100d7e:	4a3c      	ldr	r2, [pc, #240]	@ (8100e70 <APPL_Application+0x16c>)
 8100d80:	6013      	str	r3, [r2, #0]
	SSIData0x6000.Ssi5=ang_int[0];
 8100d82:	4b3b      	ldr	r3, [pc, #236]	@ (8100e70 <APPL_Application+0x16c>)
 8100d84:	681b      	ldr	r3, [r3, #0]
 8100d86:	4a3b      	ldr	r2, [pc, #236]	@ (8100e74 <APPL_Application+0x170>)
 8100d88:	6153      	str	r3, [r2, #20]

	ang_float[0]=angle_all[6];
 8100d8a:	4b37      	ldr	r3, [pc, #220]	@ (8100e68 <APPL_Application+0x164>)
 8100d8c:	699b      	ldr	r3, [r3, #24]
 8100d8e:	4a37      	ldr	r2, [pc, #220]	@ (8100e6c <APPL_Application+0x168>)
 8100d90:	6013      	str	r3, [r2, #0]
	MEMCPY(ang_int, ang_float, sizeof(ang_float));
 8100d92:	4b36      	ldr	r3, [pc, #216]	@ (8100e6c <APPL_Application+0x168>)
 8100d94:	681b      	ldr	r3, [r3, #0]
 8100d96:	4a36      	ldr	r2, [pc, #216]	@ (8100e70 <APPL_Application+0x16c>)
 8100d98:	6013      	str	r3, [r2, #0]
	SSIData0x6000.Ssi6=ang_int[0];
 8100d9a:	4b35      	ldr	r3, [pc, #212]	@ (8100e70 <APPL_Application+0x16c>)
 8100d9c:	681b      	ldr	r3, [r3, #0]
 8100d9e:	4a35      	ldr	r2, [pc, #212]	@ (8100e74 <APPL_Application+0x170>)
 8100da0:	6193      	str	r3, [r2, #24]

	ang_float[0]=angle_all[7];
 8100da2:	4b31      	ldr	r3, [pc, #196]	@ (8100e68 <APPL_Application+0x164>)
 8100da4:	69db      	ldr	r3, [r3, #28]
 8100da6:	4a31      	ldr	r2, [pc, #196]	@ (8100e6c <APPL_Application+0x168>)
 8100da8:	6013      	str	r3, [r2, #0]
	MEMCPY(ang_int, ang_float, sizeof(ang_float));
 8100daa:	4b30      	ldr	r3, [pc, #192]	@ (8100e6c <APPL_Application+0x168>)
 8100dac:	681b      	ldr	r3, [r3, #0]
 8100dae:	4a30      	ldr	r2, [pc, #192]	@ (8100e70 <APPL_Application+0x16c>)
 8100db0:	6013      	str	r3, [r2, #0]
	SSIData0x6000.Ssi7=ang_int[0];
 8100db2:	4b2f      	ldr	r3, [pc, #188]	@ (8100e70 <APPL_Application+0x16c>)
 8100db4:	681b      	ldr	r3, [r3, #0]
 8100db6:	4a2f      	ldr	r2, [pc, #188]	@ (8100e74 <APPL_Application+0x170>)
 8100db8:	61d3      	str	r3, [r2, #28]

//	ang_float[0]=angle_all[7];
//	MEMCPY(ang_int, ang_float, sizeof(ang_float));
	SSIData0x6000.Ssi8=12568;
 8100dba:	4b2e      	ldr	r3, [pc, #184]	@ (8100e74 <APPL_Application+0x170>)
 8100dbc:	f243 1218 	movw	r2, #12568	@ 0x3118
 8100dc0:	621a      	str	r2, [r3, #32]

//	SSIData0x6000.Ssi=Target0x7030.TargetAngle;
	AINData0x6010.Ain1=count;
 8100dc2:	4b28      	ldr	r3, [pc, #160]	@ (8100e64 <APPL_Application+0x160>)
 8100dc4:	681b      	ldr	r3, [r3, #0]
 8100dc6:	b29a      	uxth	r2, r3
 8100dc8:	4b2b      	ldr	r3, [pc, #172]	@ (8100e78 <APPL_Application+0x174>)
 8100dca:	805a      	strh	r2, [r3, #2]
	AINData0x6010.Ain2=angle_all[1];
 8100dcc:	4b26      	ldr	r3, [pc, #152]	@ (8100e68 <APPL_Application+0x164>)
 8100dce:	edd3 7a01 	vldr	s15, [r3, #4]
 8100dd2:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8100dd6:	ee17 3a90 	vmov	r3, s15
 8100dda:	b29a      	uxth	r2, r3
 8100ddc:	4b26      	ldr	r3, [pc, #152]	@ (8100e78 <APPL_Application+0x174>)
 8100dde:	809a      	strh	r2, [r3, #4]
	AINData0x6010.Ain3=angle_all[2];
 8100de0:	4b21      	ldr	r3, [pc, #132]	@ (8100e68 <APPL_Application+0x164>)
 8100de2:	edd3 7a02 	vldr	s15, [r3, #8]
 8100de6:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8100dea:	ee17 3a90 	vmov	r3, s15
 8100dee:	b29a      	uxth	r2, r3
 8100df0:	4b21      	ldr	r3, [pc, #132]	@ (8100e78 <APPL_Application+0x174>)
 8100df2:	80da      	strh	r2, [r3, #6]
	AINData0x6010.Ain4=angle_all[3];
 8100df4:	4b1c      	ldr	r3, [pc, #112]	@ (8100e68 <APPL_Application+0x164>)
 8100df6:	edd3 7a03 	vldr	s15, [r3, #12]
 8100dfa:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8100dfe:	ee17 3a90 	vmov	r3, s15
 8100e02:	b29a      	uxth	r2, r3
 8100e04:	4b1c      	ldr	r3, [pc, #112]	@ (8100e78 <APPL_Application+0x174>)
 8100e06:	811a      	strh	r2, [r3, #8]
	AINData0x6010.Ain5=angle_all[4];
 8100e08:	4b17      	ldr	r3, [pc, #92]	@ (8100e68 <APPL_Application+0x164>)
 8100e0a:	edd3 7a04 	vldr	s15, [r3, #16]
 8100e0e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8100e12:	ee17 3a90 	vmov	r3, s15
 8100e16:	b29a      	uxth	r2, r3
 8100e18:	4b17      	ldr	r3, [pc, #92]	@ (8100e78 <APPL_Application+0x174>)
 8100e1a:	815a      	strh	r2, [r3, #10]
	AINData0x6010.Ain6=angle_all[5];
 8100e1c:	4b12      	ldr	r3, [pc, #72]	@ (8100e68 <APPL_Application+0x164>)
 8100e1e:	edd3 7a05 	vldr	s15, [r3, #20]
 8100e22:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8100e26:	ee17 3a90 	vmov	r3, s15
 8100e2a:	b29a      	uxth	r2, r3
 8100e2c:	4b12      	ldr	r3, [pc, #72]	@ (8100e78 <APPL_Application+0x174>)
 8100e2e:	819a      	strh	r2, [r3, #12]
	AINData0x6010.Ain7=angle_all[6];
 8100e30:	4b0d      	ldr	r3, [pc, #52]	@ (8100e68 <APPL_Application+0x164>)
 8100e32:	edd3 7a06 	vldr	s15, [r3, #24]
 8100e36:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8100e3a:	ee17 3a90 	vmov	r3, s15
 8100e3e:	b29a      	uxth	r2, r3
 8100e40:	4b0d      	ldr	r3, [pc, #52]	@ (8100e78 <APPL_Application+0x174>)
 8100e42:	81da      	strh	r2, [r3, #14]
	AINData0x6010.Ain8=angle_all[7];
 8100e44:	4b08      	ldr	r3, [pc, #32]	@ (8100e68 <APPL_Application+0x164>)
 8100e46:	edd3 7a07 	vldr	s15, [r3, #28]
 8100e4a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8100e4e:	ee17 3a90 	vmov	r3, s15
 8100e52:	b29a      	uxth	r2, r3
 8100e54:	4b08      	ldr	r3, [pc, #32]	@ (8100e78 <APPL_Application+0x174>)
 8100e56:	821a      	strh	r2, [r3, #16]
//	
//	input++;
//	if(input%1000){
//		(Obj0x6000.BSwitch4==1)?(Obj0x6000.BSwitch4=0): (Obj0x6000.BSwitch4 = 1	);
//	}
}
 8100e58:	bf00      	nop
 8100e5a:	46bd      	mov	sp, r7
 8100e5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8100e60:	4770      	bx	lr
 8100e62:	bf00      	nop
 8100e64:	10000720 	.word	0x10000720
 8100e68:	1000061c 	.word	0x1000061c
 8100e6c:	10000724 	.word	0x10000724
 8100e70:	10000728 	.word	0x10000728
 8100e74:	10000074 	.word	0x10000074
 8100e78:	10000098 	.word	0x10000098

08100e7c <GetInterruptRegister>:

        The first two bytes of an access to the EtherCAT ASIC always deliver the AL_Event register (0x220).
        It will be saved in the global "EscALEvent"
*////////////////////////////////////////////////////////////////////////////////////////
static void GetInterruptRegister(void)
{
 8100e7c:	b580      	push	{r7, lr}
 8100e7e:	af00      	add	r7, sp, #0
  __ASM volatile ("cpsid i" : : : "memory");
 8100e80:	b672      	cpsid	i
}
 8100e82:	bf00      	nop
    #if AL_EVENT_ENABLED
    DISABLE_AL_EVENT_INT;
#endif
	
    /* select the SPI */
    SELECT_SPI;
 8100e84:	2200      	movs	r2, #0
 8100e86:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8100e8a:	4809      	ldr	r0, [pc, #36]	@ (8100eb0 <GetInterruptRegister+0x34>)
 8100e8c:	f000 ff82 	bl	8101d94 <HAL_GPIO_WritePin>
	
	 HW_EscReadIsr((MEM_ADDR *)&EscALEvent.Word, 0x220, 2);
 8100e90:	2202      	movs	r2, #2
 8100e92:	f44f 7108 	mov.w	r1, #544	@ 0x220
 8100e96:	4807      	ldr	r0, [pc, #28]	@ (8100eb4 <GetInterruptRegister+0x38>)
 8100e98:	f000 f93a 	bl	8101110 <HW_EscReadIsr>
	/* if the SPI transmission rate is higher than 15 MBaud, the Busy detection shall be
       done here */
	
  DESELECT_SPI;
 8100e9c:	2201      	movs	r2, #1
 8100e9e:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8100ea2:	4803      	ldr	r0, [pc, #12]	@ (8100eb0 <GetInterruptRegister+0x34>)
 8100ea4:	f000 ff76 	bl	8101d94 <HAL_GPIO_WritePin>
  __ASM volatile ("cpsie i" : : : "memory");
 8100ea8:	b662      	cpsie	i
}
 8100eaa:	bf00      	nop
 #if AL_EVENT_ENABLED
    ENABLE_AL_EVENT_INT;
#endif
}
 8100eac:	bf00      	nop
 8100eae:	bd80      	pop	{r7, pc}
 8100eb0:	58021000 	.word	0x58021000
 8100eb4:	1000072c 	.word	0x1000072c

08100eb8 <AddressingEsc>:
/////////////////////////////////////////////////////////////////////////////////////////
/**
 \brief The function addresses the EtherCAT ASIC via SPI for a following SPI access.
*////////////////////////////////////////////////////////////////////////////////////////
static void AddressingEsc( UINT16 Address, UINT8 Command )
{
 8100eb8:	b580      	push	{r7, lr}
 8100eba:	b084      	sub	sp, #16
 8100ebc:	af00      	add	r7, sp, #0
 8100ebe:	4603      	mov	r3, r0
 8100ec0:	460a      	mov	r2, r1
 8100ec2:	80fb      	strh	r3, [r7, #6]
 8100ec4:	4613      	mov	r3, r2
 8100ec6:	717b      	strb	r3, [r7, #5]
    UBYTETOWORD tmp;
    VARVOLATILE UINT8 dummy;
    tmp.Word = ( Address << 3 ) | Command;
 8100ec8:	88fb      	ldrh	r3, [r7, #6]
 8100eca:	00db      	lsls	r3, r3, #3
 8100ecc:	b21a      	sxth	r2, r3
 8100ece:	797b      	ldrb	r3, [r7, #5]
 8100ed0:	b21b      	sxth	r3, r3
 8100ed2:	4313      	orrs	r3, r2
 8100ed4:	b21b      	sxth	r3, r3
 8100ed6:	b29b      	uxth	r3, r3
 8100ed8:	81bb      	strh	r3, [r7, #12]
    /* select the SPI */
    SELECT_SPI;
 8100eda:	2200      	movs	r2, #0
 8100edc:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8100ee0:	480a      	ldr	r0, [pc, #40]	@ (8100f0c <AddressingEsc+0x54>)
 8100ee2:	f000 ff57 	bl	8101d94 <HAL_GPIO_WritePin>

   /* there have to be at least 15 ns after the SPI1_SEL signal was active (0) before
       the transmission shall be started */
    /* send the first address/command byte to the ESC */
	
		dummy = 	WR_CMD(tmp.Byte[1]);
 8100ee6:	7b7b      	ldrb	r3, [r7, #13]
 8100ee8:	4618      	mov	r0, r3
 8100eea:	f7ff fc73 	bl	81007d4 <WR_CMD>
 8100eee:	4603      	mov	r3, r0
 8100ef0:	b2db      	uxtb	r3, r3
 8100ef2:	72fb      	strb	r3, [r7, #11]
	
    /* send the second address/command byte to the ESC */
 
		dummy =	WR_CMD(tmp.Byte[0]);
 8100ef4:	7b3b      	ldrb	r3, [r7, #12]
 8100ef6:	4618      	mov	r0, r3
 8100ef8:	f7ff fc6c 	bl	81007d4 <WR_CMD>
 8100efc:	4603      	mov	r3, r0
 8100efe:	b2db      	uxtb	r3, r3
 8100f00:	72fb      	strb	r3, [r7, #11]
	
    /* if the SPI transmission rate is higher than 15 MBaud, the Busy detection shall be
       done here */
}
 8100f02:	bf00      	nop
 8100f04:	3710      	adds	r7, #16
 8100f06:	46bd      	mov	sp, r7
 8100f08:	bd80      	pop	{r7, pc}
 8100f0a:	bf00      	nop
 8100f0c:	58021000 	.word	0x58021000

08100f10 <ISR_AddressingEsc>:

#if !INTERRUPTS_SUPPORTED
#define ISR_AddressingEsc AddressingEsc
#else
static void ISR_AddressingEsc( UINT16 Address, UINT8 Command )
{
 8100f10:	b580      	push	{r7, lr}
 8100f12:	b084      	sub	sp, #16
 8100f14:	af00      	add	r7, sp, #0
 8100f16:	4603      	mov	r3, r0
 8100f18:	460a      	mov	r2, r1
 8100f1a:	80fb      	strh	r3, [r7, #6]
 8100f1c:	4613      	mov	r3, r2
 8100f1e:	717b      	strb	r3, [r7, #5]
    VARVOLATILE UINT8 dummy;
    UBYTETOWORD tmp;
    tmp.Word = ( Address << 3 ) | Command;
 8100f20:	88fb      	ldrh	r3, [r7, #6]
 8100f22:	00db      	lsls	r3, r3, #3
 8100f24:	b21a      	sxth	r2, r3
 8100f26:	797b      	ldrb	r3, [r7, #5]
 8100f28:	b21b      	sxth	r3, r3
 8100f2a:	4313      	orrs	r3, r2
 8100f2c:	b21b      	sxth	r3, r3
 8100f2e:	b29b      	uxth	r3, r3
 8100f30:	81bb      	strh	r3, [r7, #12]

    /* select the SPI */
    SELECT_SPI;
 8100f32:	2200      	movs	r2, #0
 8100f34:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8100f38:	480a      	ldr	r0, [pc, #40]	@ (8100f64 <ISR_AddressingEsc+0x54>)
 8100f3a:	f000 ff2b 	bl	8101d94 <HAL_GPIO_WritePin>

    /* there have to be at least 15 ns after the SPI1_SEL signal was active (0) before
      the transmission shall be started */
	
    /* send the first address/command byte to the ESC */
	dummy= WR_CMD(tmp.Byte[1]);
 8100f3e:	7b7b      	ldrb	r3, [r7, #13]
 8100f40:	4618      	mov	r0, r3
 8100f42:	f7ff fc47 	bl	81007d4 <WR_CMD>
 8100f46:	4603      	mov	r3, r0
 8100f48:	b2db      	uxtb	r3, r3
 8100f4a:	73fb      	strb	r3, [r7, #15]
	
   /* send the second address/command byte to the ESC */

	dummy= WR_CMD(tmp.Byte[0]);
 8100f4c:	7b3b      	ldrb	r3, [r7, #12]
 8100f4e:	4618      	mov	r0, r3
 8100f50:	f7ff fc40 	bl	81007d4 <WR_CMD>
 8100f54:	4603      	mov	r3, r0
 8100f56:	b2db      	uxtb	r3, r3
 8100f58:	73fb      	strb	r3, [r7, #15]
    /* if the SPI transmission rate is higher than 15 MBaud, the Busy detection shall be
       done here */
}
 8100f5a:	bf00      	nop
 8100f5c:	3710      	adds	r7, #16
 8100f5e:	46bd      	mov	sp, r7
 8100f60:	bd80      	pop	{r7, pc}
 8100f62:	bf00      	nop
 8100f64:	58021000 	.word	0x58021000

08100f68 <MX_TIM2_Init>:
  * @brief TIM2 Initialization Function
  * @param None
  * @retval None
  */
static void MX_TIM2_Init(void)
{
 8100f68:	b580      	push	{r7, lr}
 8100f6a:	b088      	sub	sp, #32
 8100f6c:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN TIM2_Init 0 */

  /* USER CODE END TIM2_Init 0 */

  TIM_ClockConfigTypeDef sClockSourceConfig = {0};
 8100f6e:	f107 0310 	add.w	r3, r7, #16
 8100f72:	2200      	movs	r2, #0
 8100f74:	601a      	str	r2, [r3, #0]
 8100f76:	605a      	str	r2, [r3, #4]
 8100f78:	609a      	str	r2, [r3, #8]
 8100f7a:	60da      	str	r2, [r3, #12]
  TIM_MasterConfigTypeDef sMasterConfig = {0};
 8100f7c:	1d3b      	adds	r3, r7, #4
 8100f7e:	2200      	movs	r2, #0
 8100f80:	601a      	str	r2, [r3, #0]
 8100f82:	605a      	str	r2, [r3, #4]
 8100f84:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN TIM2_Init 1 */

  /* USER CODE END TIM2_Init 1 */
  htim2.Instance = TIM2;
 8100f86:	4b1e      	ldr	r3, [pc, #120]	@ (8101000 <MX_TIM2_Init+0x98>)
 8100f88:	f04f 4280 	mov.w	r2, #1073741824	@ 0x40000000
 8100f8c:	601a      	str	r2, [r3, #0]
  htim2.Init.Prescaler = 1000;
 8100f8e:	4b1c      	ldr	r3, [pc, #112]	@ (8101000 <MX_TIM2_Init+0x98>)
 8100f90:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8100f94:	605a      	str	r2, [r3, #4]
  htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
 8100f96:	4b1a      	ldr	r3, [pc, #104]	@ (8101000 <MX_TIM2_Init+0x98>)
 8100f98:	2200      	movs	r2, #0
 8100f9a:	609a      	str	r2, [r3, #8]
  htim2.Init.Period = 199;
 8100f9c:	4b18      	ldr	r3, [pc, #96]	@ (8101000 <MX_TIM2_Init+0x98>)
 8100f9e:	22c7      	movs	r2, #199	@ 0xc7
 8100fa0:	60da      	str	r2, [r3, #12]
  htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
 8100fa2:	4b17      	ldr	r3, [pc, #92]	@ (8101000 <MX_TIM2_Init+0x98>)
 8100fa4:	2200      	movs	r2, #0
 8100fa6:	611a      	str	r2, [r3, #16]
  htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8100fa8:	4b15      	ldr	r3, [pc, #84]	@ (8101000 <MX_TIM2_Init+0x98>)
 8100faa:	2200      	movs	r2, #0
 8100fac:	619a      	str	r2, [r3, #24]
  if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
 8100fae:	4814      	ldr	r0, [pc, #80]	@ (8101000 <MX_TIM2_Init+0x98>)
 8100fb0:	f003 fabd 	bl	810452e <HAL_TIM_Base_Init>
 8100fb4:	4603      	mov	r3, r0
 8100fb6:	2b00      	cmp	r3, #0
 8100fb8:	d001      	beq.n	8100fbe <MX_TIM2_Init+0x56>
  {
    Error_Handler();
 8100fba:	f7ff fca7 	bl	810090c <Error_Handler>
  }
  sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
 8100fbe:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 8100fc2:	613b      	str	r3, [r7, #16]
  if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
 8100fc4:	f107 0310 	add.w	r3, r7, #16
 8100fc8:	4619      	mov	r1, r3
 8100fca:	480d      	ldr	r0, [pc, #52]	@ (8101000 <MX_TIM2_Init+0x98>)
 8100fcc:	f003 fc86 	bl	81048dc <HAL_TIM_ConfigClockSource>
 8100fd0:	4603      	mov	r3, r0
 8100fd2:	2b00      	cmp	r3, #0
 8100fd4:	d001      	beq.n	8100fda <MX_TIM2_Init+0x72>
  {
    Error_Handler();
 8100fd6:	f7ff fc99 	bl	810090c <Error_Handler>
  }
  sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
 8100fda:	2300      	movs	r3, #0
 8100fdc:	607b      	str	r3, [r7, #4]
  sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
 8100fde:	2300      	movs	r3, #0
 8100fe0:	60fb      	str	r3, [r7, #12]
  if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
 8100fe2:	1d3b      	adds	r3, r7, #4
 8100fe4:	4619      	mov	r1, r3
 8100fe6:	4806      	ldr	r0, [pc, #24]	@ (8101000 <MX_TIM2_Init+0x98>)
 8100fe8:	f003 feda 	bl	8104da0 <HAL_TIMEx_MasterConfigSynchronization>
 8100fec:	4603      	mov	r3, r0
 8100fee:	2b00      	cmp	r3, #0
 8100ff0:	d001      	beq.n	8100ff6 <MX_TIM2_Init+0x8e>
  {
    Error_Handler();
 8100ff2:	f7ff fc8b 	bl	810090c <Error_Handler>
  }
  /* USER CODE BEGIN TIM2_Init 2 */

  /* USER CODE END TIM2_Init 2 */

}
 8100ff6:	bf00      	nop
 8100ff8:	3720      	adds	r7, #32
 8100ffa:	46bd      	mov	sp, r7
 8100ffc:	bd80      	pop	{r7, pc}
 8100ffe:	bf00      	nop
 8101000:	100006c4 	.word	0x100006c4

08101004 <HW_Init>:
\return     0 if initialization was successful

 \brief    This function intialize the Process Data Interface (PDI) and the host controller.
*////////////////////////////////////////////////////////////////////////////////////////
UINT8 HW_Init(void)
{
 8101004:	b580      	push	{r7, lr}
 8101006:	b082      	sub	sp, #8
 8101008:	af00      	add	r7, sp, #0
		//MX_DAC_Init();

		//MX_USART2_UART_Init();
		//MX_I2C1_Init();
		//MX_SPI1_Init();
		MX_TIM2_Init();
 810100a:	f7ff ffad 	bl	8100f68 <MX_TIM2_Init>
//	  MX_ADC1_Init();
//		MX_ADC2_Init();

	do
    {
        intMask = 0x93;
 810100e:	2393      	movs	r3, #147	@ 0x93
 8101010:	80fb      	strh	r3, [r7, #6]
        HW_EscWriteWord(intMask, ESC_AL_EVENTMASK_OFFSET);
 8101012:	1dbb      	adds	r3, r7, #6
 8101014:	2202      	movs	r2, #2
 8101016:	f44f 7101 	mov.w	r1, #516	@ 0x204
 810101a:	4618      	mov	r0, r3
 810101c:	f000 f8ac 	bl	8101178 <HW_EscWrite>
        intMask = 0;
 8101020:	2300      	movs	r3, #0
 8101022:	80fb      	strh	r3, [r7, #6]
        HW_EscReadWord(intMask, ESC_AL_EVENTMASK_OFFSET);
 8101024:	1dbb      	adds	r3, r7, #6
 8101026:	2202      	movs	r2, #2
 8101028:	f44f 7101 	mov.w	r1, #516	@ 0x204
 810102c:	4618      	mov	r0, r3
 810102e:	f000 f83b 	bl	81010a8 <HW_EscRead>
    } while (intMask != 0x93);
 8101032:	88fb      	ldrh	r3, [r7, #6]
 8101034:	2b93      	cmp	r3, #147	@ 0x93
 8101036:	d1ea      	bne.n	810100e <HW_Init+0xa>
		
		

		intMask = 0x00;
 8101038:	2300      	movs	r3, #0
 810103a:	80fb      	strh	r3, [r7, #6]
	  
    HW_EscWriteDWord(intMask, ESC_AL_EVENTMASK_OFFSET);
 810103c:	1dbb      	adds	r3, r7, #6
 810103e:	2204      	movs	r2, #4
 8101040:	f44f 7101 	mov.w	r1, #516	@ 0x204
 8101044:	4618      	mov	r0, r3
 8101046:	f000 f897 	bl	8101178 <HW_EscWrite>

#if AL_EVENT_ENABLED
    INIT_ESC_INT;
 810104a:	f7ff fbe3 	bl	8100814 <EXTI3_Configuration>
    ENABLE_ESC_INT();
 810104e:	200a      	movs	r0, #10
 8101050:	f000 fcc0 	bl	81019d4 <HAL_NVIC_EnableIRQ>

#if DC_SUPPORTED&& _STM32_IO8
    INIT_SYNC0_INT
    INIT_SYNC1_INT

    ENABLE_SYNC0_INT;
 8101054:	2017      	movs	r0, #23
 8101056:	f000 fcbd 	bl	81019d4 <HAL_NVIC_EnableIRQ>
    ENABLE_SYNC1_INT;
 810105a:	2017      	movs	r0, #23
 810105c:	f000 fcba 	bl	81019d4 <HAL_NVIC_EnableIRQ>
#endif

    INIT_ECAT_TIMER;
 8101060:	f7ff ff82 	bl	8100f68 <MX_TIM2_Init>
    START_ECAT_TIMER;
 8101064:	201c      	movs	r0, #28
 8101066:	f000 fcb5 	bl	81019d4 <HAL_NVIC_EnableIRQ>
		HAL_TIM_Base_Start_IT(&htim2);
 810106a:	4805      	ldr	r0, [pc, #20]	@ (8101080 <HW_Init+0x7c>)
 810106c:	f003 fab6 	bl	81045dc <HAL_TIM_Base_Start_IT>
  __ASM volatile ("cpsie i" : : : "memory");
 8101070:	b662      	cpsie	i
}
 8101072:	bf00      	nop
    ENABLE_GLOBAL_INT;
#endif



    return 0;
 8101074:	2300      	movs	r3, #0
}
 8101076:	4618      	mov	r0, r3
 8101078:	3708      	adds	r7, #8
 810107a:	46bd      	mov	sp, r7
 810107c:	bd80      	pop	{r7, pc}
 810107e:	bf00      	nop
 8101080:	100006c4 	.word	0x100006c4

08101084 <HW_Release>:
/**
 \brief    This function shall be implemented if hardware resources need to be release
        when the sample application stops
*////////////////////////////////////////////////////////////////////////////////////////
void HW_Release(void)
{
 8101084:	b480      	push	{r7}
 8101086:	af00      	add	r7, sp, #0

}
 8101088:	bf00      	nop
 810108a:	46bd      	mov	sp, r7
 810108c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101090:	4770      	bx	lr
	...

08101094 <HW_GetALEventRegister>:
 \return    first two Bytes of ALEvent register (0x220)

 \brief  This function gets the current content of ALEvent register
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 HW_GetALEventRegister(void)
{
 8101094:	b580      	push	{r7, lr}
 8101096:	af00      	add	r7, sp, #0
    GetInterruptRegister();
 8101098:	f7ff fef0 	bl	8100e7c <GetInterruptRegister>
    return EscALEvent.Word;
 810109c:	4b01      	ldr	r3, [pc, #4]	@ (81010a4 <HW_GetALEventRegister+0x10>)
 810109e:	881b      	ldrh	r3, [r3, #0]
}
 81010a0:	4618      	mov	r0, r3
 81010a2:	bd80      	pop	{r7, pc}
 81010a4:	1000072c 	.word	0x1000072c

081010a8 <HW_EscRead>:
 \param Len            Access size in Bytes.

 \brief  This function operates the SPI read access to the EtherCAT ASIC.
*////////////////////////////////////////////////////////////////////////////////////////
void HW_EscRead( MEM_ADDR *pData, UINT16 Address, UINT16 Len )
{
 81010a8:	b580      	push	{r7, lr}
 81010aa:	b084      	sub	sp, #16
 81010ac:	af00      	add	r7, sp, #0
 81010ae:	6078      	str	r0, [r7, #4]
 81010b0:	460b      	mov	r3, r1
 81010b2:	807b      	strh	r3, [r7, #2]
 81010b4:	4613      	mov	r3, r2
 81010b6:	803b      	strh	r3, [r7, #0]
    /* HBu 24.01.06: if the SPI will be read by an interrupt routine too the
                     mailbox reading may be interrupted but an interrupted
                     reading will remain in a SPI transmission fault that will
                     reset the internal Sync Manager status. Therefore the reading
                     will be divided in 1-byte reads with disabled interrupt */
    UINT16 i = Len;
 81010b8:	883b      	ldrh	r3, [r7, #0]
 81010ba:	81fb      	strh	r3, [r7, #14]
    UINT8 *pTmpData = (UINT8 *)pData;
 81010bc:	687b      	ldr	r3, [r7, #4]
 81010be:	60bb      	str	r3, [r7, #8]

    /* loop for all bytes to be read */
    while ( i-- > 0 )
 81010c0:	e01a      	b.n	81010f8 <HW_EscRead+0x50>
  __ASM volatile ("cpsid i" : : : "memory");
 81010c2:	b672      	cpsid	i
}
 81010c4:	bf00      	nop
           in that case the status flag will indicate an error because
           the reading operation was interrupted without setting the last
           sent byte to 0xFF */
        DISABLE_AL_EVENT_INT;
#endif
         AddressingEsc( Address, ESC_RD );
 81010c6:	887b      	ldrh	r3, [r7, #2]
 81010c8:	2102      	movs	r1, #2
 81010ca:	4618      	mov	r0, r3
 81010cc:	f7ff fef4 	bl	8100eb8 <AddressingEsc>

        /* when reading the last byte the DI pin shall be 1 */
			*pTmpData++= WR_CMD(0xFF);
 81010d0:	20ff      	movs	r0, #255	@ 0xff
 81010d2:	f7ff fb7f 	bl	81007d4 <WR_CMD>
 81010d6:	4601      	mov	r1, r0
 81010d8:	68bb      	ldr	r3, [r7, #8]
 81010da:	1c5a      	adds	r2, r3, #1
 81010dc:	60ba      	str	r2, [r7, #8]
 81010de:	b2ca      	uxtb	r2, r1
 81010e0:	701a      	strb	r2, [r3, #0]
  __ASM volatile ("cpsie i" : : : "memory");
 81010e2:	b662      	cpsie	i
}
 81010e4:	bf00      	nop
   #if AL_EVENT_ENABLED
        ENABLE_AL_EVENT_INT;
#endif
        /* there has to be at least 15 ns + CLK/2 after the transmission is finished
           before the SPI1_SEL signal shall be 1 */
        DESELECT_SPI;
 81010e6:	2201      	movs	r2, #1
 81010e8:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 81010ec:	4807      	ldr	r0, [pc, #28]	@ (810110c <HW_EscRead+0x64>)
 81010ee:	f000 fe51 	bl	8101d94 <HAL_GPIO_WritePin>
        /* next address */
        Address++;
 81010f2:	887b      	ldrh	r3, [r7, #2]
 81010f4:	3301      	adds	r3, #1
 81010f6:	807b      	strh	r3, [r7, #2]
    while ( i-- > 0 )
 81010f8:	89fb      	ldrh	r3, [r7, #14]
 81010fa:	1e5a      	subs	r2, r3, #1
 81010fc:	81fa      	strh	r2, [r7, #14]
 81010fe:	2b00      	cmp	r3, #0
 8101100:	d1df      	bne.n	81010c2 <HW_EscRead+0x1a>
//        /* reset transmission flag */
//        SPI1_IF = 0;
    }
}
 8101102:	bf00      	nop
 8101104:	bf00      	nop
 8101106:	3710      	adds	r7, #16
 8101108:	46bd      	mov	sp, r7
 810110a:	bd80      	pop	{r7, pc}
 810110c:	58021000 	.word	0x58021000

08101110 <HW_EscReadIsr>:
/* the pragma interrupt_level is used to tell the compiler that these functions will not
   be called at the same time from the main function and the interrupt routine */
//#pragma interrupt_level 1
#endif
void HW_EscReadIsr( MEM_ADDR *pData, UINT16 Address, UINT16 Len )
{
 8101110:	b580      	push	{r7, lr}
 8101112:	b084      	sub	sp, #16
 8101114:	af00      	add	r7, sp, #0
 8101116:	6078      	str	r0, [r7, #4]
 8101118:	460b      	mov	r3, r1
 810111a:	807b      	strh	r3, [r7, #2]
 810111c:	4613      	mov	r3, r2
 810111e:	803b      	strh	r3, [r7, #0]
    UINT16 i = Len;
 8101120:	883b      	ldrh	r3, [r7, #0]
 8101122:	81fb      	strh	r3, [r7, #14]
    UINT8 data = 0;
 8101124:	2300      	movs	r3, #0
 8101126:	737b      	strb	r3, [r7, #13]

   UINT8 *pTmpData = (UINT8 *)pData;
 8101128:	687b      	ldr	r3, [r7, #4]
 810112a:	60bb      	str	r3, [r7, #8]

    /* send the address and command to the ESC */
     ISR_AddressingEsc( Address, ESC_RD );
 810112c:	887b      	ldrh	r3, [r7, #2]
 810112e:	2102      	movs	r1, #2
 8101130:	4618      	mov	r0, r3
 8101132:	f7ff feed 	bl	8100f10 <ISR_AddressingEsc>
    /* loop for all bytes to be read */
    while ( i-- > 0 )
 8101136:	e00e      	b.n	8101156 <HW_EscReadIsr+0x46>
    {
        if ( i == 0 )
 8101138:	89fb      	ldrh	r3, [r7, #14]
 810113a:	2b00      	cmp	r3, #0
 810113c:	d101      	bne.n	8101142 <HW_EscReadIsr+0x32>
        {
            /* when reading the last byte the DI pin shall be 1 */
            data = 0xFF;
 810113e:	23ff      	movs	r3, #255	@ 0xff
 8101140:	737b      	strb	r3, [r7, #13]
        }

		*pTmpData++= WR_CMD(data);
 8101142:	7b7b      	ldrb	r3, [r7, #13]
 8101144:	4618      	mov	r0, r3
 8101146:	f7ff fb45 	bl	81007d4 <WR_CMD>
 810114a:	4601      	mov	r1, r0
 810114c:	68bb      	ldr	r3, [r7, #8]
 810114e:	1c5a      	adds	r2, r3, #1
 8101150:	60ba      	str	r2, [r7, #8]
 8101152:	b2ca      	uxtb	r2, r1
 8101154:	701a      	strb	r2, [r3, #0]
    while ( i-- > 0 )
 8101156:	89fb      	ldrh	r3, [r7, #14]
 8101158:	1e5a      	subs	r2, r3, #1
 810115a:	81fa      	strh	r2, [r7, #14]
 810115c:	2b00      	cmp	r3, #0
 810115e:	d1eb      	bne.n	8101138 <HW_EscReadIsr+0x28>
    }

    /* there has to be at least 15 ns + CLK/2 after the transmission is finished
       before the SPI1_SEL signal shall be 1 */
    DESELECT_SPI;
 8101160:	2201      	movs	r2, #1
 8101162:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8101166:	4803      	ldr	r0, [pc, #12]	@ (8101174 <HW_EscReadIsr+0x64>)
 8101168:	f000 fe14 	bl	8101d94 <HAL_GPIO_WritePin>
}
 810116c:	bf00      	nop
 810116e:	3710      	adds	r7, #16
 8101170:	46bd      	mov	sp, r7
 8101172:	bd80      	pop	{r7, pc}
 8101174:	58021000 	.word	0x58021000

08101178 <HW_EscWrite>:
 \param Len            Access size in Bytes.

  \brief  This function operates the SPI write access to the EtherCAT ASIC.
*////////////////////////////////////////////////////////////////////////////////////////
void HW_EscWrite( MEM_ADDR *pData, UINT16 Address, UINT16 Len )
{
 8101178:	b580      	push	{r7, lr}
 810117a:	b086      	sub	sp, #24
 810117c:	af00      	add	r7, sp, #0
 810117e:	6078      	str	r0, [r7, #4]
 8101180:	460b      	mov	r3, r1
 8101182:	807b      	strh	r3, [r7, #2]
 8101184:	4613      	mov	r3, r2
 8101186:	803b      	strh	r3, [r7, #0]
    UINT16 i = Len;
 8101188:	883b      	ldrh	r3, [r7, #0]
 810118a:	82fb      	strh	r3, [r7, #22]
    VARVOLATILE UINT8 dummy;

    UINT8 *pTmpData = (UINT8 *)pData;
 810118c:	687b      	ldr	r3, [r7, #4]
 810118e:	613b      	str	r3, [r7, #16]

    /* loop for all bytes to be written */
    while ( i-- > 0 )
 8101190:	e01b      	b.n	81011ca <HW_EscWrite+0x52>
  __ASM volatile ("cpsid i" : : : "memory");
 8101192:	b672      	cpsid	i
}
 8101194:	bf00      	nop
        /* the reading of data from the ESC can be interrupted by the
           AL Event ISR, so every byte will be written separate */
        DISABLE_AL_EVENT_INT;
#endif
        /* HBu 24.01.06: wrong parameter ESC_RD */
         AddressingEsc( Address, ESC_WR );
 8101196:	887b      	ldrh	r3, [r7, #2]
 8101198:	2104      	movs	r1, #4
 810119a:	4618      	mov	r0, r3
 810119c:	f7ff fe8c 	bl	8100eb8 <AddressingEsc>

        /* enable the ESC interrupt to get the AL Event ISR the chance to interrupt */
        /* SPI1_BUF must be read, otherwise the module will not transfer the next received data from SPIxSR to SPIxRXB.*/
			dummy= WR_CMD(*pTmpData++);
 81011a0:	693b      	ldr	r3, [r7, #16]
 81011a2:	1c5a      	adds	r2, r3, #1
 81011a4:	613a      	str	r2, [r7, #16]
 81011a6:	781b      	ldrb	r3, [r3, #0]
 81011a8:	4618      	mov	r0, r3
 81011aa:	f7ff fb13 	bl	81007d4 <WR_CMD>
 81011ae:	4603      	mov	r3, r0
 81011b0:	b2db      	uxtb	r3, r3
 81011b2:	73fb      	strb	r3, [r7, #15]
  __ASM volatile ("cpsie i" : : : "memory");
 81011b4:	b662      	cpsie	i
}
 81011b6:	bf00      	nop
			
    #if AL_EVENT_ENABLED
        ENABLE_AL_EVENT_INT;
#endif

        DESELECT_SPI;
 81011b8:	2201      	movs	r2, #1
 81011ba:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 81011be:	4808      	ldr	r0, [pc, #32]	@ (81011e0 <HW_EscWrite+0x68>)
 81011c0:	f000 fde8 	bl	8101d94 <HAL_GPIO_WritePin>
        /* next address */
        Address++;
 81011c4:	887b      	ldrh	r3, [r7, #2]
 81011c6:	3301      	adds	r3, #1
 81011c8:	807b      	strh	r3, [r7, #2]
    while ( i-- > 0 )
 81011ca:	8afb      	ldrh	r3, [r7, #22]
 81011cc:	1e5a      	subs	r2, r3, #1
 81011ce:	82fa      	strh	r2, [r7, #22]
 81011d0:	2b00      	cmp	r3, #0
 81011d2:	d1de      	bne.n	8101192 <HW_EscWrite+0x1a>
    }
}
 81011d4:	bf00      	nop
 81011d6:	bf00      	nop
 81011d8:	3718      	adds	r7, #24
 81011da:	46bd      	mov	sp, r7
 81011dc:	bd80      	pop	{r7, pc}
 81011de:	bf00      	nop
 81011e0:	58021000 	.word	0x58021000

081011e4 <HW_EscWriteIsr>:
/* the pragma interrupt_level is used to tell the compiler that these functions will not
   be called at the same time from the main function and the interrupt routine */
//#pragma interrupt_level 1
#endif
void HW_EscWriteIsr( MEM_ADDR *pData, UINT16 Address, UINT16 Len )
{
 81011e4:	b580      	push	{r7, lr}
 81011e6:	b086      	sub	sp, #24
 81011e8:	af00      	add	r7, sp, #0
 81011ea:	6078      	str	r0, [r7, #4]
 81011ec:	460b      	mov	r3, r1
 81011ee:	807b      	strh	r3, [r7, #2]
 81011f0:	4613      	mov	r3, r2
 81011f2:	803b      	strh	r3, [r7, #0]
    UINT16 i = Len;
 81011f4:	883b      	ldrh	r3, [r7, #0]
 81011f6:	82fb      	strh	r3, [r7, #22]
    VARVOLATILE UINT16 dummy;
    UINT8 *pTmpData = (UINT8 *)pData;
 81011f8:	687b      	ldr	r3, [r7, #4]
 81011fa:	613b      	str	r3, [r7, #16]

    /* send the address and command to the ESC */
     ISR_AddressingEsc( Address, ESC_WR );
 81011fc:	887b      	ldrh	r3, [r7, #2]
 81011fe:	2104      	movs	r1, #4
 8101200:	4618      	mov	r0, r3
 8101202:	f7ff fe85 	bl	8100f10 <ISR_AddressingEsc>
    /* loop for all bytes to be written */
    while ( i-- > 0 )
 8101206:	e00a      	b.n	810121e <HW_EscWriteIsr+0x3a>
    {
        /* start transmission */
			dummy= WR_CMD(*pTmpData);
 8101208:	693b      	ldr	r3, [r7, #16]
 810120a:	781b      	ldrb	r3, [r3, #0]
 810120c:	4618      	mov	r0, r3
 810120e:	f7ff fae1 	bl	81007d4 <WR_CMD>
 8101212:	4603      	mov	r3, r0
 8101214:	b29b      	uxth	r3, r3
 8101216:	81fb      	strh	r3, [r7, #14]
      /* increment data pointer */
        pTmpData++;
 8101218:	693b      	ldr	r3, [r7, #16]
 810121a:	3301      	adds	r3, #1
 810121c:	613b      	str	r3, [r7, #16]
    while ( i-- > 0 )
 810121e:	8afb      	ldrh	r3, [r7, #22]
 8101220:	1e5a      	subs	r2, r3, #1
 8101222:	82fa      	strh	r2, [r7, #22]
 8101224:	2b00      	cmp	r3, #0
 8101226:	d1ef      	bne.n	8101208 <HW_EscWriteIsr+0x24>
    }

    /* there has to be at least 15 ns + CLK/2 after the transmission is finished
       before the SPI1_SEL signal shall be 1 */
    DESELECT_SPI;
 8101228:	2201      	movs	r2, #1
 810122a:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 810122e:	4803      	ldr	r0, [pc, #12]	@ (810123c <HW_EscWriteIsr+0x58>)
 8101230:	f000 fdb0 	bl	8101d94 <HAL_GPIO_WritePin>
}
 8101234:	bf00      	nop
 8101236:	3718      	adds	r7, #24
 8101238:	46bd      	mov	sp, r7
 810123a:	bd80      	pop	{r7, pc}
 810123c:	58021000 	.word	0x58021000

08101240 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8101240:	b580      	push	{r7, lr}
 8101242:	b082      	sub	sp, #8
 8101244:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8101246:	4b10      	ldr	r3, [pc, #64]	@ (8101288 <HAL_MspInit+0x48>)
 8101248:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 810124c:	4a0e      	ldr	r2, [pc, #56]	@ (8101288 <HAL_MspInit+0x48>)
 810124e:	f043 0302 	orr.w	r3, r3, #2
 8101252:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
 8101256:	4b0c      	ldr	r3, [pc, #48]	@ (8101288 <HAL_MspInit+0x48>)
 8101258:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 810125c:	f003 0302 	and.w	r3, r3, #2
 8101260:	607b      	str	r3, [r7, #4]
 8101262:	687b      	ldr	r3, [r7, #4]

  /* System interrupt init*/
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 8101264:	2200      	movs	r2, #0
 8101266:	210f      	movs	r1, #15
 8101268:	f06f 0001 	mvn.w	r0, #1
 810126c:	f000 fb98 	bl	81019a0 <HAL_NVIC_SetPriority>

  /* Peripheral interrupt init */
  /* HSEM2_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(HSEM2_IRQn, 5, 0);
 8101270:	2200      	movs	r2, #0
 8101272:	2105      	movs	r1, #5
 8101274:	207e      	movs	r0, #126	@ 0x7e
 8101276:	f000 fb93 	bl	81019a0 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(HSEM2_IRQn);
 810127a:	207e      	movs	r0, #126	@ 0x7e
 810127c:	f000 fbaa 	bl	81019d4 <HAL_NVIC_EnableIRQ>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8101280:	bf00      	nop
 8101282:	3708      	adds	r7, #8
 8101284:	46bd      	mov	sp, r7
 8101286:	bd80      	pop	{r7, pc}
 8101288:	58024400 	.word	0x58024400

0810128c <HAL_SPI_MspInit>:
* This function configures the hardware resources used in this example
* @param hspi: SPI handle pointer
* @retval None
*/
void HAL_SPI_MspInit(SPI_HandleTypeDef* hspi)
{
 810128c:	b580      	push	{r7, lr}
 810128e:	b0ba      	sub	sp, #232	@ 0xe8
 8101290:	af00      	add	r7, sp, #0
 8101292:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8101294:	f107 03d4 	add.w	r3, r7, #212	@ 0xd4
 8101298:	2200      	movs	r2, #0
 810129a:	601a      	str	r2, [r3, #0]
 810129c:	605a      	str	r2, [r3, #4]
 810129e:	609a      	str	r2, [r3, #8]
 81012a0:	60da      	str	r2, [r3, #12]
 81012a2:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
 81012a4:	f107 0310 	add.w	r3, r7, #16
 81012a8:	22c0      	movs	r2, #192	@ 0xc0
 81012aa:	2100      	movs	r1, #0
 81012ac:	4618      	mov	r0, r3
 81012ae:	f00e fcf4 	bl	810fc9a <memset>
  if(hspi->Instance==SPI3)
 81012b2:	687b      	ldr	r3, [r7, #4]
 81012b4:	681b      	ldr	r3, [r3, #0]
 81012b6:	4a26      	ldr	r2, [pc, #152]	@ (8101350 <HAL_SPI_MspInit+0xc4>)
 81012b8:	4293      	cmp	r3, r2
 81012ba:	d145      	bne.n	8101348 <HAL_SPI_MspInit+0xbc>

  /* USER CODE END SPI3_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPI3;
 81012bc:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 81012c0:	f04f 0300 	mov.w	r3, #0
 81012c4:	e9c7 2304 	strd	r2, r3, [r7, #16]
    PeriphClkInitStruct.Spi123ClockSelection = RCC_SPI123CLKSOURCE_PLL;
 81012c8:	2300      	movs	r3, #0
 81012ca:	673b      	str	r3, [r7, #112]	@ 0x70
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
 81012cc:	f107 0310 	add.w	r3, r7, #16
 81012d0:	4618      	mov	r0, r3
 81012d2:	f001 f879 	bl	81023c8 <HAL_RCCEx_PeriphCLKConfig>
 81012d6:	4603      	mov	r3, r0
 81012d8:	2b00      	cmp	r3, #0
 81012da:	d001      	beq.n	81012e0 <HAL_SPI_MspInit+0x54>
    {
      Error_Handler();
 81012dc:	f7ff fb16 	bl	810090c <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_SPI3_CLK_ENABLE();
 81012e0:	4b1c      	ldr	r3, [pc, #112]	@ (8101354 <HAL_SPI_MspInit+0xc8>)
 81012e2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 81012e6:	4a1b      	ldr	r2, [pc, #108]	@ (8101354 <HAL_SPI_MspInit+0xc8>)
 81012e8:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
 81012ec:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 81012f0:	4b18      	ldr	r3, [pc, #96]	@ (8101354 <HAL_SPI_MspInit+0xc8>)
 81012f2:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 81012f6:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 81012fa:	60fb      	str	r3, [r7, #12]
 81012fc:	68fb      	ldr	r3, [r7, #12]

    __HAL_RCC_GPIOC_CLK_ENABLE();
 81012fe:	4b15      	ldr	r3, [pc, #84]	@ (8101354 <HAL_SPI_MspInit+0xc8>)
 8101300:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8101304:	4a13      	ldr	r2, [pc, #76]	@ (8101354 <HAL_SPI_MspInit+0xc8>)
 8101306:	f043 0304 	orr.w	r3, r3, #4
 810130a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 810130e:	4b11      	ldr	r3, [pc, #68]	@ (8101354 <HAL_SPI_MspInit+0xc8>)
 8101310:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 8101314:	f003 0304 	and.w	r3, r3, #4
 8101318:	60bb      	str	r3, [r7, #8]
 810131a:	68bb      	ldr	r3, [r7, #8]
    /**SPI3 GPIO Configuration
    PC10     ------> SPI3_SCK
    PC11     ------> SPI3_MISO
    PC12     ------> SPI3_MOSI
    */
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12;
 810131c:	f44f 53e0 	mov.w	r3, #7168	@ 0x1c00
 8101320:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8101324:	2302      	movs	r3, #2
 8101326:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 810132a:	2300      	movs	r3, #0
 810132c:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8101330:	2300      	movs	r3, #0
 8101332:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
    GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
 8101336:	2306      	movs	r3, #6
 8101338:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 810133c:	f107 03d4 	add.w	r3, r7, #212	@ 0xd4
 8101340:	4619      	mov	r1, r3
 8101342:	4805      	ldr	r0, [pc, #20]	@ (8101358 <HAL_SPI_MspInit+0xcc>)
 8101344:	f000 fb76 	bl	8101a34 <HAL_GPIO_Init>

  /* USER CODE END SPI3_MspInit 1 */

  }

}
 8101348:	bf00      	nop
 810134a:	37e8      	adds	r7, #232	@ 0xe8
 810134c:	46bd      	mov	sp, r7
 810134e:	bd80      	pop	{r7, pc}
 8101350:	40003c00 	.word	0x40003c00
 8101354:	58024400 	.word	0x58024400
 8101358:	58020800 	.word	0x58020800

0810135c <HAL_TIM_Base_MspInit>:
* This function configures the hardware resources used in this example
* @param htim_base: TIM_Base handle pointer
* @retval None
*/
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base)
{
 810135c:	b580      	push	{r7, lr}
 810135e:	b084      	sub	sp, #16
 8101360:	af00      	add	r7, sp, #0
 8101362:	6078      	str	r0, [r7, #4]
  if(htim_base->Instance==TIM2)
 8101364:	687b      	ldr	r3, [r7, #4]
 8101366:	681b      	ldr	r3, [r3, #0]
 8101368:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 810136c:	d116      	bne.n	810139c <HAL_TIM_Base_MspInit+0x40>
  {
  /* USER CODE BEGIN TIM2_MspInit 0 */

  /* USER CODE END TIM2_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_TIM2_CLK_ENABLE();
 810136e:	4b0d      	ldr	r3, [pc, #52]	@ (81013a4 <HAL_TIM_Base_MspInit+0x48>)
 8101370:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8101374:	4a0b      	ldr	r2, [pc, #44]	@ (81013a4 <HAL_TIM_Base_MspInit+0x48>)
 8101376:	f043 0301 	orr.w	r3, r3, #1
 810137a:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 810137e:	4b09      	ldr	r3, [pc, #36]	@ (81013a4 <HAL_TIM_Base_MspInit+0x48>)
 8101380:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 8101384:	f003 0301 	and.w	r3, r3, #1
 8101388:	60fb      	str	r3, [r7, #12]
 810138a:	68fb      	ldr	r3, [r7, #12]
    /* TIM2 interrupt Init */
    HAL_NVIC_SetPriority(TIM2_IRQn, 5, 0);
 810138c:	2200      	movs	r2, #0
 810138e:	2105      	movs	r1, #5
 8101390:	201c      	movs	r0, #28
 8101392:	f000 fb05 	bl	81019a0 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(TIM2_IRQn);
 8101396:	201c      	movs	r0, #28
 8101398:	f000 fb1c 	bl	81019d4 <HAL_NVIC_EnableIRQ>

  /* USER CODE END TIM2_MspInit 1 */

  }

}
 810139c:	bf00      	nop
 810139e:	3710      	adds	r7, #16
 81013a0:	46bd      	mov	sp, r7
 81013a2:	bd80      	pop	{r7, pc}
 81013a4:	58024400 	.word	0x58024400

081013a8 <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig().
  * @param  TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 81013a8:	b580      	push	{r7, lr}
 81013aa:	b090      	sub	sp, #64	@ 0x40
 81013ac:	af00      	add	r7, sp, #0
 81013ae:	6078      	str	r0, [r7, #4]
  uint32_t              uwTimclock, uwAPB1Prescaler;

  uint32_t              uwPrescalerValue;
  uint32_t              pFLatency;
  /*Configure the TIM7 IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 81013b0:	687b      	ldr	r3, [r7, #4]
 81013b2:	2b0f      	cmp	r3, #15
 81013b4:	d827      	bhi.n	8101406 <HAL_InitTick+0x5e>
   {
     HAL_NVIC_SetPriority(TIM7_IRQn, TickPriority ,0);
 81013b6:	2200      	movs	r2, #0
 81013b8:	6879      	ldr	r1, [r7, #4]
 81013ba:	2037      	movs	r0, #55	@ 0x37
 81013bc:	f000 faf0 	bl	81019a0 <HAL_NVIC_SetPriority>

     /* Enable the TIM7 global Interrupt */
     HAL_NVIC_EnableIRQ(TIM7_IRQn);
 81013c0:	2037      	movs	r0, #55	@ 0x37
 81013c2:	f000 fb07 	bl	81019d4 <HAL_NVIC_EnableIRQ>
     uwTickPrio = TickPriority;
 81013c6:	4a29      	ldr	r2, [pc, #164]	@ (810146c <HAL_InitTick+0xc4>)
 81013c8:	687b      	ldr	r3, [r7, #4]
 81013ca:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Enable TIM7 clock */
  __HAL_RCC_TIM7_CLK_ENABLE();
 81013cc:	4b28      	ldr	r3, [pc, #160]	@ (8101470 <HAL_InitTick+0xc8>)
 81013ce:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 81013d2:	4a27      	ldr	r2, [pc, #156]	@ (8101470 <HAL_InitTick+0xc8>)
 81013d4:	f043 0320 	orr.w	r3, r3, #32
 81013d8:	f8c2 30e8 	str.w	r3, [r2, #232]	@ 0xe8
 81013dc:	4b24      	ldr	r3, [pc, #144]	@ (8101470 <HAL_InitTick+0xc8>)
 81013de:	f8d3 30e8 	ldr.w	r3, [r3, #232]	@ 0xe8
 81013e2:	f003 0320 	and.w	r3, r3, #32
 81013e6:	60fb      	str	r3, [r7, #12]
 81013e8:	68fb      	ldr	r3, [r7, #12]
  /* Get clock configuration */
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 81013ea:	f107 0210 	add.w	r2, r7, #16
 81013ee:	f107 0314 	add.w	r3, r7, #20
 81013f2:	4611      	mov	r1, r2
 81013f4:	4618      	mov	r0, r3
 81013f6:	f000 ffa5 	bl	8102344 <HAL_RCC_GetClockConfig>
  /* Get APB1 prescaler */
  uwAPB1Prescaler = clkconfig.APB1CLKDivider;
 81013fa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 81013fc:	63bb      	str	r3, [r7, #56]	@ 0x38
  /* Compute TIM7 clock */
  if (uwAPB1Prescaler == RCC_HCLK_DIV1)
 81013fe:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8101400:	2b00      	cmp	r3, #0
 8101402:	d106      	bne.n	8101412 <HAL_InitTick+0x6a>
 8101404:	e001      	b.n	810140a <HAL_InitTick+0x62>
    return HAL_ERROR;
 8101406:	2301      	movs	r3, #1
 8101408:	e02b      	b.n	8101462 <HAL_InitTick+0xba>
  {
    uwTimclock = HAL_RCC_GetPCLK1Freq();
 810140a:	f000 ff85 	bl	8102318 <HAL_RCC_GetPCLK1Freq>
 810140e:	63f8      	str	r0, [r7, #60]	@ 0x3c
 8101410:	e004      	b.n	810141c <HAL_InitTick+0x74>
  }
  else
  {
    uwTimclock = 2UL * HAL_RCC_GetPCLK1Freq();
 8101412:	f000 ff81 	bl	8102318 <HAL_RCC_GetPCLK1Freq>
 8101416:	4603      	mov	r3, r0
 8101418:	005b      	lsls	r3, r3, #1
 810141a:	63fb      	str	r3, [r7, #60]	@ 0x3c
  }

  /* Compute the prescaler value to have TIM7 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000U) - 1U);
 810141c:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 810141e:	4a15      	ldr	r2, [pc, #84]	@ (8101474 <HAL_InitTick+0xcc>)
 8101420:	fba2 2303 	umull	r2, r3, r2, r3
 8101424:	0c9b      	lsrs	r3, r3, #18
 8101426:	3b01      	subs	r3, #1
 8101428:	637b      	str	r3, [r7, #52]	@ 0x34

  /* Initialize TIM7 */
  htim7.Instance = TIM7;
 810142a:	4b13      	ldr	r3, [pc, #76]	@ (8101478 <HAL_InitTick+0xd0>)
 810142c:	4a13      	ldr	r2, [pc, #76]	@ (810147c <HAL_InitTick+0xd4>)
 810142e:	601a      	str	r2, [r3, #0]
  + Period = [(TIM7CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim7.Init.Period = (1000000U / 1000U) - 1U;
 8101430:	4b11      	ldr	r3, [pc, #68]	@ (8101478 <HAL_InitTick+0xd0>)
 8101432:	f240 32e7 	movw	r2, #999	@ 0x3e7
 8101436:	60da      	str	r2, [r3, #12]
  htim7.Init.Prescaler = uwPrescalerValue;
 8101438:	4a0f      	ldr	r2, [pc, #60]	@ (8101478 <HAL_InitTick+0xd0>)
 810143a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810143c:	6053      	str	r3, [r2, #4]
  htim7.Init.ClockDivision = 0;
 810143e:	4b0e      	ldr	r3, [pc, #56]	@ (8101478 <HAL_InitTick+0xd0>)
 8101440:	2200      	movs	r2, #0
 8101442:	611a      	str	r2, [r3, #16]
  htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
 8101444:	4b0c      	ldr	r3, [pc, #48]	@ (8101478 <HAL_InitTick+0xd0>)
 8101446:	2200      	movs	r2, #0
 8101448:	609a      	str	r2, [r3, #8]

  if(HAL_TIM_Base_Init(&htim7) == HAL_OK)
 810144a:	480b      	ldr	r0, [pc, #44]	@ (8101478 <HAL_InitTick+0xd0>)
 810144c:	f003 f86f 	bl	810452e <HAL_TIM_Base_Init>
 8101450:	4603      	mov	r3, r0
 8101452:	2b00      	cmp	r3, #0
 8101454:	d104      	bne.n	8101460 <HAL_InitTick+0xb8>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim7);
 8101456:	4808      	ldr	r0, [pc, #32]	@ (8101478 <HAL_InitTick+0xd0>)
 8101458:	f003 f8c0 	bl	81045dc <HAL_TIM_Base_Start_IT>
 810145c:	4603      	mov	r3, r0
 810145e:	e000      	b.n	8101462 <HAL_InitTick+0xba>
  }

  /* Return function status */
  return HAL_ERROR;
 8101460:	2301      	movs	r3, #1
}
 8101462:	4618      	mov	r0, r3
 8101464:	3740      	adds	r7, #64	@ 0x40
 8101466:	46bd      	mov	sp, r7
 8101468:	bd80      	pop	{r7, pc}
 810146a:	bf00      	nop
 810146c:	100000b8 	.word	0x100000b8
 8101470:	58024400 	.word	0x58024400
 8101474:	431bde83 	.word	0x431bde83
 8101478:	10000730 	.word	0x10000730
 810147c:	40001400 	.word	0x40001400

08101480 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8101480:	b480      	push	{r7}
 8101482:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
 8101484:	bf00      	nop
 8101486:	e7fd      	b.n	8101484 <NMI_Handler+0x4>

08101488 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8101488:	b480      	push	{r7}
 810148a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 810148c:	bf00      	nop
 810148e:	e7fd      	b.n	810148c <HardFault_Handler+0x4>

08101490 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8101490:	b480      	push	{r7}
 8101492:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8101494:	bf00      	nop
 8101496:	e7fd      	b.n	8101494 <MemManage_Handler+0x4>

08101498 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8101498:	b480      	push	{r7}
 810149a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 810149c:	bf00      	nop
 810149e:	e7fd      	b.n	810149c <BusFault_Handler+0x4>

081014a0 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 81014a0:	b480      	push	{r7}
 81014a2:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 81014a4:	bf00      	nop
 81014a6:	e7fd      	b.n	81014a4 <UsageFault_Handler+0x4>

081014a8 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 81014a8:	b480      	push	{r7}
 81014aa:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 81014ac:	bf00      	nop
 81014ae:	46bd      	mov	sp, r7
 81014b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81014b4:	4770      	bx	lr

081014b6 <EXTI4_IRQHandler>:

/**
  * @brief This function handles EXTI line4 interrupt.
  */
void EXTI4_IRQHandler(void)
{
 81014b6:	b580      	push	{r7, lr}
 81014b8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI4_IRQn 0 */

  /* USER CODE END EXTI4_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_4);
 81014ba:	2010      	movs	r0, #16
 81014bc:	f000 fc83 	bl	8101dc6 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI4_IRQn 1 */

  /* USER CODE END EXTI4_IRQn 1 */
}
 81014c0:	bf00      	nop
 81014c2:	bd80      	pop	{r7, pc}

081014c4 <EXTI9_5_IRQHandler>:

/**
  * @brief This function handles EXTI line[9:5] interrupts.
  */
void EXTI9_5_IRQHandler(void)
{
 81014c4:	b580      	push	{r7, lr}
 81014c6:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI9_5_IRQn 0 */

  /* USER CODE END EXTI9_5_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_5);
 81014c8:	2020      	movs	r0, #32
 81014ca:	f000 fc7c 	bl	8101dc6 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_6);
 81014ce:	2040      	movs	r0, #64	@ 0x40
 81014d0:	f000 fc79 	bl	8101dc6 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI9_5_IRQn 1 */

  /* USER CODE END EXTI9_5_IRQn 1 */
}
 81014d4:	bf00      	nop
 81014d6:	bd80      	pop	{r7, pc}

081014d8 <TIM2_IRQHandler>:

/**
  * @brief This function handles TIM2 global interrupt.
  */
void TIM2_IRQHandler(void)
{
 81014d8:	b580      	push	{r7, lr}
 81014da:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM2_IRQn 0 */

  /* USER CODE END TIM2_IRQn 0 */
  HAL_TIM_IRQHandler(&htim2);
 81014dc:	4802      	ldr	r0, [pc, #8]	@ (81014e8 <TIM2_IRQHandler+0x10>)
 81014de:	f003 f8f5 	bl	81046cc <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM2_IRQn 1 */

  /* USER CODE END TIM2_IRQn 1 */
}
 81014e2:	bf00      	nop
 81014e4:	bd80      	pop	{r7, pc}
 81014e6:	bf00      	nop
 81014e8:	100006c4 	.word	0x100006c4

081014ec <TIM7_IRQHandler>:

/**
  * @brief This function handles TIM7 global interrupt.
  */
void TIM7_IRQHandler(void)
{
 81014ec:	b580      	push	{r7, lr}
 81014ee:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN TIM7_IRQn 0 */

  /* USER CODE END TIM7_IRQn 0 */
  HAL_TIM_IRQHandler(&htim7);
 81014f0:	4802      	ldr	r0, [pc, #8]	@ (81014fc <TIM7_IRQHandler+0x10>)
 81014f2:	f003 f8eb 	bl	81046cc <HAL_TIM_IRQHandler>
  /* USER CODE BEGIN TIM7_IRQn 1 */

  /* USER CODE END TIM7_IRQn 1 */
}
 81014f6:	bf00      	nop
 81014f8:	bd80      	pop	{r7, pc}
 81014fa:	bf00      	nop
 81014fc:	10000730 	.word	0x10000730

08101500 <HSEM2_IRQHandler>:

/**
  * @brief This function handles HSEM2 global interrupt.
  */
void HSEM2_IRQHandler(void)
{
 8101500:	b580      	push	{r7, lr}
 8101502:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HSEM2_IRQn 0 */

  /* USER CODE END HSEM2_IRQn 0 */
  HAL_HSEM_IRQHandler();
 8101504:	f000 fcba 	bl	8101e7c <HAL_HSEM_IRQHandler>
  /* USER CODE BEGIN HSEM2_IRQn 1 */

  /* USER CODE END HSEM2_IRQn 1 */
}
 8101508:	bf00      	nop
 810150a:	bd80      	pop	{r7, pc}

0810150c <_getpid>:
void initialise_monitor_handles()
{
}

int _getpid(void)
{
 810150c:	b480      	push	{r7}
 810150e:	af00      	add	r7, sp, #0
  return 1;
 8101510:	2301      	movs	r3, #1
}
 8101512:	4618      	mov	r0, r3
 8101514:	46bd      	mov	sp, r7
 8101516:	f85d 7b04 	ldr.w	r7, [sp], #4
 810151a:	4770      	bx	lr

0810151c <_kill>:

int _kill(int pid, int sig)
{
 810151c:	b580      	push	{r7, lr}
 810151e:	b082      	sub	sp, #8
 8101520:	af00      	add	r7, sp, #0
 8101522:	6078      	str	r0, [r7, #4]
 8101524:	6039      	str	r1, [r7, #0]
  (void)pid;
  (void)sig;
  errno = EINVAL;
 8101526:	f00e fc3b 	bl	810fda0 <__errno>
 810152a:	4603      	mov	r3, r0
 810152c:	2216      	movs	r2, #22
 810152e:	601a      	str	r2, [r3, #0]
  return -1;
 8101530:	f04f 33ff 	mov.w	r3, #4294967295
}
 8101534:	4618      	mov	r0, r3
 8101536:	3708      	adds	r7, #8
 8101538:	46bd      	mov	sp, r7
 810153a:	bd80      	pop	{r7, pc}

0810153c <_exit>:

void _exit (int status)
{
 810153c:	b580      	push	{r7, lr}
 810153e:	b082      	sub	sp, #8
 8101540:	af00      	add	r7, sp, #0
 8101542:	6078      	str	r0, [r7, #4]
  _kill(status, -1);
 8101544:	f04f 31ff 	mov.w	r1, #4294967295
 8101548:	6878      	ldr	r0, [r7, #4]
 810154a:	f7ff ffe7 	bl	810151c <_kill>
  while (1) {}    /* Make sure we hang here */
 810154e:	bf00      	nop
 8101550:	e7fd      	b.n	810154e <_exit+0x12>

08101552 <_read>:
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 8101552:	b580      	push	{r7, lr}
 8101554:	b086      	sub	sp, #24
 8101556:	af00      	add	r7, sp, #0
 8101558:	60f8      	str	r0, [r7, #12]
 810155a:	60b9      	str	r1, [r7, #8]
 810155c:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 810155e:	2300      	movs	r3, #0
 8101560:	617b      	str	r3, [r7, #20]
 8101562:	e00a      	b.n	810157a <_read+0x28>
  {
    *ptr++ = __io_getchar();
 8101564:	f3af 8000 	nop.w
 8101568:	4601      	mov	r1, r0
 810156a:	68bb      	ldr	r3, [r7, #8]
 810156c:	1c5a      	adds	r2, r3, #1
 810156e:	60ba      	str	r2, [r7, #8]
 8101570:	b2ca      	uxtb	r2, r1
 8101572:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8101574:	697b      	ldr	r3, [r7, #20]
 8101576:	3301      	adds	r3, #1
 8101578:	617b      	str	r3, [r7, #20]
 810157a:	697a      	ldr	r2, [r7, #20]
 810157c:	687b      	ldr	r3, [r7, #4]
 810157e:	429a      	cmp	r2, r3
 8101580:	dbf0      	blt.n	8101564 <_read+0x12>
  }

  return len;
 8101582:	687b      	ldr	r3, [r7, #4]
}
 8101584:	4618      	mov	r0, r3
 8101586:	3718      	adds	r7, #24
 8101588:	46bd      	mov	sp, r7
 810158a:	bd80      	pop	{r7, pc}

0810158c <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 810158c:	b580      	push	{r7, lr}
 810158e:	b086      	sub	sp, #24
 8101590:	af00      	add	r7, sp, #0
 8101592:	60f8      	str	r0, [r7, #12]
 8101594:	60b9      	str	r1, [r7, #8]
 8101596:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
 8101598:	2300      	movs	r3, #0
 810159a:	617b      	str	r3, [r7, #20]
 810159c:	e009      	b.n	81015b2 <_write+0x26>
  {
    __io_putchar(*ptr++);
 810159e:	68bb      	ldr	r3, [r7, #8]
 81015a0:	1c5a      	adds	r2, r3, #1
 81015a2:	60ba      	str	r2, [r7, #8]
 81015a4:	781b      	ldrb	r3, [r3, #0]
 81015a6:	4618      	mov	r0, r3
 81015a8:	f3af 8000 	nop.w
  for (DataIdx = 0; DataIdx < len; DataIdx++)
 81015ac:	697b      	ldr	r3, [r7, #20]
 81015ae:	3301      	adds	r3, #1
 81015b0:	617b      	str	r3, [r7, #20]
 81015b2:	697a      	ldr	r2, [r7, #20]
 81015b4:	687b      	ldr	r3, [r7, #4]
 81015b6:	429a      	cmp	r2, r3
 81015b8:	dbf1      	blt.n	810159e <_write+0x12>
  }
  return len;
 81015ba:	687b      	ldr	r3, [r7, #4]
}
 81015bc:	4618      	mov	r0, r3
 81015be:	3718      	adds	r7, #24
 81015c0:	46bd      	mov	sp, r7
 81015c2:	bd80      	pop	{r7, pc}

081015c4 <_close>:

int _close(int file)
{
 81015c4:	b480      	push	{r7}
 81015c6:	b083      	sub	sp, #12
 81015c8:	af00      	add	r7, sp, #0
 81015ca:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
 81015cc:	f04f 33ff 	mov.w	r3, #4294967295
}
 81015d0:	4618      	mov	r0, r3
 81015d2:	370c      	adds	r7, #12
 81015d4:	46bd      	mov	sp, r7
 81015d6:	f85d 7b04 	ldr.w	r7, [sp], #4
 81015da:	4770      	bx	lr

081015dc <_fstat>:


int _fstat(int file, struct stat *st)
{
 81015dc:	b480      	push	{r7}
 81015de:	b083      	sub	sp, #12
 81015e0:	af00      	add	r7, sp, #0
 81015e2:	6078      	str	r0, [r7, #4]
 81015e4:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
 81015e6:	683b      	ldr	r3, [r7, #0]
 81015e8:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
 81015ec:	605a      	str	r2, [r3, #4]
  return 0;
 81015ee:	2300      	movs	r3, #0
}
 81015f0:	4618      	mov	r0, r3
 81015f2:	370c      	adds	r7, #12
 81015f4:	46bd      	mov	sp, r7
 81015f6:	f85d 7b04 	ldr.w	r7, [sp], #4
 81015fa:	4770      	bx	lr

081015fc <_isatty>:

int _isatty(int file)
{
 81015fc:	b480      	push	{r7}
 81015fe:	b083      	sub	sp, #12
 8101600:	af00      	add	r7, sp, #0
 8101602:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
 8101604:	2301      	movs	r3, #1
}
 8101606:	4618      	mov	r0, r3
 8101608:	370c      	adds	r7, #12
 810160a:	46bd      	mov	sp, r7
 810160c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101610:	4770      	bx	lr

08101612 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
 8101612:	b480      	push	{r7}
 8101614:	b085      	sub	sp, #20
 8101616:	af00      	add	r7, sp, #0
 8101618:	60f8      	str	r0, [r7, #12]
 810161a:	60b9      	str	r1, [r7, #8]
 810161c:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
 810161e:	2300      	movs	r3, #0
}
 8101620:	4618      	mov	r0, r3
 8101622:	3714      	adds	r7, #20
 8101624:	46bd      	mov	sp, r7
 8101626:	f85d 7b04 	ldr.w	r7, [sp], #4
 810162a:	4770      	bx	lr

0810162c <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
 810162c:	b580      	push	{r7, lr}
 810162e:	b086      	sub	sp, #24
 8101630:	af00      	add	r7, sp, #0
 8101632:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
 8101634:	4a14      	ldr	r2, [pc, #80]	@ (8101688 <_sbrk+0x5c>)
 8101636:	4b15      	ldr	r3, [pc, #84]	@ (810168c <_sbrk+0x60>)
 8101638:	1ad3      	subs	r3, r2, r3
 810163a:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
 810163c:	697b      	ldr	r3, [r7, #20]
 810163e:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
 8101640:	4b13      	ldr	r3, [pc, #76]	@ (8101690 <_sbrk+0x64>)
 8101642:	681b      	ldr	r3, [r3, #0]
 8101644:	2b00      	cmp	r3, #0
 8101646:	d102      	bne.n	810164e <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
 8101648:	4b11      	ldr	r3, [pc, #68]	@ (8101690 <_sbrk+0x64>)
 810164a:	4a12      	ldr	r2, [pc, #72]	@ (8101694 <_sbrk+0x68>)
 810164c:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
 810164e:	4b10      	ldr	r3, [pc, #64]	@ (8101690 <_sbrk+0x64>)
 8101650:	681a      	ldr	r2, [r3, #0]
 8101652:	687b      	ldr	r3, [r7, #4]
 8101654:	4413      	add	r3, r2
 8101656:	693a      	ldr	r2, [r7, #16]
 8101658:	429a      	cmp	r2, r3
 810165a:	d207      	bcs.n	810166c <_sbrk+0x40>
  {
    errno = ENOMEM;
 810165c:	f00e fba0 	bl	810fda0 <__errno>
 8101660:	4603      	mov	r3, r0
 8101662:	220c      	movs	r2, #12
 8101664:	601a      	str	r2, [r3, #0]
    return (void *)-1;
 8101666:	f04f 33ff 	mov.w	r3, #4294967295
 810166a:	e009      	b.n	8101680 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
 810166c:	4b08      	ldr	r3, [pc, #32]	@ (8101690 <_sbrk+0x64>)
 810166e:	681b      	ldr	r3, [r3, #0]
 8101670:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
 8101672:	4b07      	ldr	r3, [pc, #28]	@ (8101690 <_sbrk+0x64>)
 8101674:	681a      	ldr	r2, [r3, #0]
 8101676:	687b      	ldr	r3, [r7, #4]
 8101678:	4413      	add	r3, r2
 810167a:	4a05      	ldr	r2, [pc, #20]	@ (8101690 <_sbrk+0x64>)
 810167c:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
 810167e:	68fb      	ldr	r3, [r7, #12]
}
 8101680:	4618      	mov	r0, r3
 8101682:	3718      	adds	r7, #24
 8101684:	46bd      	mov	sp, r7
 8101686:	bd80      	pop	{r7, pc}
 8101688:	10048000 	.word	0x10048000
 810168c:	00000400 	.word	0x00000400
 8101690:	1000077c 	.word	0x1000077c
 8101694:	10005730 	.word	0x10005730

08101698 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack      /* set stack pointer */
 8101698:	f8df d034 	ldr.w	sp, [pc, #52]	@ 81016d0 <LoopFillZerobss+0xe>

/* Call the clock system initialization function.*/
  bl  SystemInit
 810169c:	f7fe fe88 	bl	81003b0 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 81016a0:	480c      	ldr	r0, [pc, #48]	@ (81016d4 <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 81016a2:	490d      	ldr	r1, [pc, #52]	@ (81016d8 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 81016a4:	4a0d      	ldr	r2, [pc, #52]	@ (81016dc <LoopFillZerobss+0x1a>)
  movs r3, #0
 81016a6:	2300      	movs	r3, #0
  b LoopCopyDataInit
 81016a8:	e002      	b.n	81016b0 <LoopCopyDataInit>

081016aa <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 81016aa:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 81016ac:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 81016ae:	3304      	adds	r3, #4

081016b0 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 81016b0:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 81016b2:	428c      	cmp	r4, r1
  bcc CopyDataInit
 81016b4:	d3f9      	bcc.n	81016aa <CopyDataInit>
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 81016b6:	4a0a      	ldr	r2, [pc, #40]	@ (81016e0 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 81016b8:	4c0a      	ldr	r4, [pc, #40]	@ (81016e4 <LoopFillZerobss+0x22>)
  movs r3, #0
 81016ba:	2300      	movs	r3, #0
  b LoopFillZerobss
 81016bc:	e001      	b.n	81016c2 <LoopFillZerobss>

081016be <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 81016be:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 81016c0:	3204      	adds	r2, #4

081016c2 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 81016c2:	42a2      	cmp	r2, r4
  bcc FillZerobss
 81016c4:	d3fb      	bcc.n	81016be <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
 81016c6:	f00e fb71 	bl	810fdac <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 81016ca:	f7fe febb 	bl	8100444 <main>
  bx  lr
 81016ce:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 81016d0:	10048000 	.word	0x10048000
  ldr r0, =_sdata
 81016d4:	10000000 	.word	0x10000000
  ldr r1, =_edata
 81016d8:	10000598 	.word	0x10000598
  ldr r2, =_sidata
 81016dc:	081113ec 	.word	0x081113ec
  ldr r2, =_sbss
 81016e0:	10000598 	.word	0x10000598
  ldr r4, =_ebss
 81016e4:	10005730 	.word	0x10005730

081016e8 <ADC3_IRQHandler>:
 * @retval None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 81016e8:	e7fe      	b.n	81016e8 <ADC3_IRQHandler>
	...

081016ec <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 81016ec:	b580      	push	{r7, lr}
 81016ee:	b082      	sub	sp, #8
 81016f0:	af00      	add	r7, sp, #0

uint32_t common_system_clock;

#if defined(DUAL_CORE) && defined(CORE_CM4)
   /* Configure Cortex-M4 Instruction cache through ART accelerator */
   __HAL_RCC_ART_CLK_ENABLE();                   /* Enable the Cortex-M4 ART Clock */
 81016f2:	4b28      	ldr	r3, [pc, #160]	@ (8101794 <HAL_Init+0xa8>)
 81016f4:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 81016f8:	4a26      	ldr	r2, [pc, #152]	@ (8101794 <HAL_Init+0xa8>)
 81016fa:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 81016fe:	f8c2 30d8 	str.w	r3, [r2, #216]	@ 0xd8
 8101702:	4b24      	ldr	r3, [pc, #144]	@ (8101794 <HAL_Init+0xa8>)
 8101704:	f8d3 30d8 	ldr.w	r3, [r3, #216]	@ 0xd8
 8101708:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
 810170c:	603b      	str	r3, [r7, #0]
 810170e:	683b      	ldr	r3, [r7, #0]
   __HAL_ART_CONFIG_BASE_ADDRESS(0x08100000UL);  /* Configure the Cortex-M4 ART Base address to the Flash Bank 2 : */
 8101710:	4b21      	ldr	r3, [pc, #132]	@ (8101798 <HAL_Init+0xac>)
 8101712:	681b      	ldr	r3, [r3, #0]
 8101714:	f423 237f 	bic.w	r3, r3, #1044480	@ 0xff000
 8101718:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 810171c:	4a1e      	ldr	r2, [pc, #120]	@ (8101798 <HAL_Init+0xac>)
 810171e:	f443 4301 	orr.w	r3, r3, #33024	@ 0x8100
 8101722:	6013      	str	r3, [r2, #0]
   __HAL_ART_ENABLE();                           /* Enable the Cortex-M4 ART */
 8101724:	4b1c      	ldr	r3, [pc, #112]	@ (8101798 <HAL_Init+0xac>)
 8101726:	681b      	ldr	r3, [r3, #0]
 8101728:	4a1b      	ldr	r2, [pc, #108]	@ (8101798 <HAL_Init+0xac>)
 810172a:	f043 0301 	orr.w	r3, r3, #1
 810172e:	6013      	str	r3, [r2, #0]
#endif /* DUAL_CORE &&  CORE_CM4 */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8101730:	2003      	movs	r0, #3
 8101732:	f000 f92a 	bl	810198a <HAL_NVIC_SetPriorityGrouping>

  /* Update the SystemCoreClock global variable */
#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8101736:	f000 fc43 	bl	8101fc0 <HAL_RCC_GetSysClockFreq>
 810173a:	4602      	mov	r2, r0
 810173c:	4b15      	ldr	r3, [pc, #84]	@ (8101794 <HAL_Init+0xa8>)
 810173e:	699b      	ldr	r3, [r3, #24]
 8101740:	0a1b      	lsrs	r3, r3, #8
 8101742:	f003 030f 	and.w	r3, r3, #15
 8101746:	4915      	ldr	r1, [pc, #84]	@ (810179c <HAL_Init+0xb0>)
 8101748:	5ccb      	ldrb	r3, [r1, r3]
 810174a:	f003 031f 	and.w	r3, r3, #31
 810174e:	fa22 f303 	lsr.w	r3, r2, r3
 8101752:	607b      	str	r3, [r7, #4]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE)>> RCC_CDCFGR1_CDCPRE_Pos]) & 0x1FU);
#endif

  /* Update the SystemD2Clock global variable */
#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8101754:	4b0f      	ldr	r3, [pc, #60]	@ (8101794 <HAL_Init+0xa8>)
 8101756:	699b      	ldr	r3, [r3, #24]
 8101758:	f003 030f 	and.w	r3, r3, #15
 810175c:	4a0f      	ldr	r2, [pc, #60]	@ (810179c <HAL_Init+0xb0>)
 810175e:	5cd3      	ldrb	r3, [r2, r3]
 8101760:	f003 031f 	and.w	r3, r3, #31
 8101764:	687a      	ldr	r2, [r7, #4]
 8101766:	fa22 f303 	lsr.w	r3, r2, r3
 810176a:	4a0d      	ldr	r2, [pc, #52]	@ (81017a0 <HAL_Init+0xb4>)
 810176c:	6013      	str	r3, [r2, #0]
#else
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE)>> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
 810176e:	4b0c      	ldr	r3, [pc, #48]	@ (81017a0 <HAL_Init+0xb4>)
 8101770:	681b      	ldr	r3, [r3, #0]
 8101772:	4a0c      	ldr	r2, [pc, #48]	@ (81017a4 <HAL_Init+0xb8>)
 8101774:	6013      	str	r3, [r2, #0]
#else
  SystemCoreClock = common_system_clock;
#endif /* DUAL_CORE && CORE_CM4 */

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8101776:	200f      	movs	r0, #15
 8101778:	f7ff fe16 	bl	81013a8 <HAL_InitTick>
 810177c:	4603      	mov	r3, r0
 810177e:	2b00      	cmp	r3, #0
 8101780:	d001      	beq.n	8101786 <HAL_Init+0x9a>
  {
    return HAL_ERROR;
 8101782:	2301      	movs	r3, #1
 8101784:	e002      	b.n	810178c <HAL_Init+0xa0>
  }

  /* Init the low level hardware */
  HAL_MspInit();
 8101786:	f7ff fd5b 	bl	8101240 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 810178a:	2300      	movs	r3, #0
}
 810178c:	4618      	mov	r0, r3
 810178e:	3708      	adds	r7, #8
 8101790:	46bd      	mov	sp, r7
 8101792:	bd80      	pop	{r7, pc}
 8101794:	58024400 	.word	0x58024400
 8101798:	40024400 	.word	0x40024400
 810179c:	08110a88 	.word	0x08110a88
 81017a0:	10000004 	.word	0x10000004
 81017a4:	10000000 	.word	0x10000000

081017a8 <HAL_IncTick>:
 * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 81017a8:	b480      	push	{r7}
 81017aa:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
 81017ac:	4b06      	ldr	r3, [pc, #24]	@ (81017c8 <HAL_IncTick+0x20>)
 81017ae:	781b      	ldrb	r3, [r3, #0]
 81017b0:	461a      	mov	r2, r3
 81017b2:	4b06      	ldr	r3, [pc, #24]	@ (81017cc <HAL_IncTick+0x24>)
 81017b4:	681b      	ldr	r3, [r3, #0]
 81017b6:	4413      	add	r3, r2
 81017b8:	4a04      	ldr	r2, [pc, #16]	@ (81017cc <HAL_IncTick+0x24>)
 81017ba:	6013      	str	r3, [r2, #0]
}
 81017bc:	bf00      	nop
 81017be:	46bd      	mov	sp, r7
 81017c0:	f85d 7b04 	ldr.w	r7, [sp], #4
 81017c4:	4770      	bx	lr
 81017c6:	bf00      	nop
 81017c8:	100000bc 	.word	0x100000bc
 81017cc:	10000780 	.word	0x10000780

081017d0 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 81017d0:	b480      	push	{r7}
 81017d2:	af00      	add	r7, sp, #0
  return uwTick;
 81017d4:	4b03      	ldr	r3, [pc, #12]	@ (81017e4 <HAL_GetTick+0x14>)
 81017d6:	681b      	ldr	r3, [r3, #0]
}
 81017d8:	4618      	mov	r0, r3
 81017da:	46bd      	mov	sp, r7
 81017dc:	f85d 7b04 	ldr.w	r7, [sp], #4
 81017e0:	4770      	bx	lr
 81017e2:	bf00      	nop
 81017e4:	10000780 	.word	0x10000780

081017e8 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 81017e8:	b480      	push	{r7}
 81017ea:	b085      	sub	sp, #20
 81017ec:	af00      	add	r7, sp, #0
 81017ee:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 81017f0:	687b      	ldr	r3, [r7, #4]
 81017f2:	f003 0307 	and.w	r3, r3, #7
 81017f6:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 81017f8:	4b0c      	ldr	r3, [pc, #48]	@ (810182c <__NVIC_SetPriorityGrouping+0x44>)
 81017fa:	68db      	ldr	r3, [r3, #12]
 81017fc:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 81017fe:	68ba      	ldr	r2, [r7, #8]
 8101800:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
 8101804:	4013      	ands	r3, r2
 8101806:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8101808:	68fb      	ldr	r3, [r7, #12]
 810180a:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 810180c:	68bb      	ldr	r3, [r7, #8]
 810180e:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8101810:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 8101814:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8101818:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 810181a:	4a04      	ldr	r2, [pc, #16]	@ (810182c <__NVIC_SetPriorityGrouping+0x44>)
 810181c:	68bb      	ldr	r3, [r7, #8]
 810181e:	60d3      	str	r3, [r2, #12]
}
 8101820:	bf00      	nop
 8101822:	3714      	adds	r7, #20
 8101824:	46bd      	mov	sp, r7
 8101826:	f85d 7b04 	ldr.w	r7, [sp], #4
 810182a:	4770      	bx	lr
 810182c:	e000ed00 	.word	0xe000ed00

08101830 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8101830:	b480      	push	{r7}
 8101832:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8101834:	4b04      	ldr	r3, [pc, #16]	@ (8101848 <__NVIC_GetPriorityGrouping+0x18>)
 8101836:	68db      	ldr	r3, [r3, #12]
 8101838:	0a1b      	lsrs	r3, r3, #8
 810183a:	f003 0307 	and.w	r3, r3, #7
}
 810183e:	4618      	mov	r0, r3
 8101840:	46bd      	mov	sp, r7
 8101842:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101846:	4770      	bx	lr
 8101848:	e000ed00 	.word	0xe000ed00

0810184c <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 810184c:	b480      	push	{r7}
 810184e:	b083      	sub	sp, #12
 8101850:	af00      	add	r7, sp, #0
 8101852:	4603      	mov	r3, r0
 8101854:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8101856:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 810185a:	2b00      	cmp	r3, #0
 810185c:	db0b      	blt.n	8101876 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 810185e:	88fb      	ldrh	r3, [r7, #6]
 8101860:	f003 021f 	and.w	r2, r3, #31
 8101864:	4907      	ldr	r1, [pc, #28]	@ (8101884 <__NVIC_EnableIRQ+0x38>)
 8101866:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 810186a:	095b      	lsrs	r3, r3, #5
 810186c:	2001      	movs	r0, #1
 810186e:	fa00 f202 	lsl.w	r2, r0, r2
 8101872:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
 8101876:	bf00      	nop
 8101878:	370c      	adds	r7, #12
 810187a:	46bd      	mov	sp, r7
 810187c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101880:	4770      	bx	lr
 8101882:	bf00      	nop
 8101884:	e000e100 	.word	0xe000e100

08101888 <__NVIC_DisableIRQ>:
  \details Disables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
 8101888:	b480      	push	{r7}
 810188a:	b083      	sub	sp, #12
 810188c:	af00      	add	r7, sp, #0
 810188e:	4603      	mov	r3, r0
 8101890:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 8101892:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 8101896:	2b00      	cmp	r3, #0
 8101898:	db12      	blt.n	81018c0 <__NVIC_DisableIRQ+0x38>
  {
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 810189a:	88fb      	ldrh	r3, [r7, #6]
 810189c:	f003 021f 	and.w	r2, r3, #31
 81018a0:	490a      	ldr	r1, [pc, #40]	@ (81018cc <__NVIC_DisableIRQ+0x44>)
 81018a2:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 81018a6:	095b      	lsrs	r3, r3, #5
 81018a8:	2001      	movs	r0, #1
 81018aa:	fa00 f202 	lsl.w	r2, r0, r2
 81018ae:	3320      	adds	r3, #32
 81018b0:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 81018b4:	f3bf 8f4f 	dsb	sy
}
 81018b8:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 81018ba:	f3bf 8f6f 	isb	sy
}
 81018be:	bf00      	nop
    __DSB();
    __ISB();
  }
}
 81018c0:	bf00      	nop
 81018c2:	370c      	adds	r7, #12
 81018c4:	46bd      	mov	sp, r7
 81018c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 81018ca:	4770      	bx	lr
 81018cc:	e000e100 	.word	0xe000e100

081018d0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 81018d0:	b480      	push	{r7}
 81018d2:	b083      	sub	sp, #12
 81018d4:	af00      	add	r7, sp, #0
 81018d6:	4603      	mov	r3, r0
 81018d8:	6039      	str	r1, [r7, #0]
 81018da:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 81018dc:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 81018e0:	2b00      	cmp	r3, #0
 81018e2:	db0a      	blt.n	81018fa <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 81018e4:	683b      	ldr	r3, [r7, #0]
 81018e6:	b2da      	uxtb	r2, r3
 81018e8:	490c      	ldr	r1, [pc, #48]	@ (810191c <__NVIC_SetPriority+0x4c>)
 81018ea:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 81018ee:	0112      	lsls	r2, r2, #4
 81018f0:	b2d2      	uxtb	r2, r2
 81018f2:	440b      	add	r3, r1
 81018f4:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 81018f8:	e00a      	b.n	8101910 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 81018fa:	683b      	ldr	r3, [r7, #0]
 81018fc:	b2da      	uxtb	r2, r3
 81018fe:	4908      	ldr	r1, [pc, #32]	@ (8101920 <__NVIC_SetPriority+0x50>)
 8101900:	88fb      	ldrh	r3, [r7, #6]
 8101902:	f003 030f 	and.w	r3, r3, #15
 8101906:	3b04      	subs	r3, #4
 8101908:	0112      	lsls	r2, r2, #4
 810190a:	b2d2      	uxtb	r2, r2
 810190c:	440b      	add	r3, r1
 810190e:	761a      	strb	r2, [r3, #24]
}
 8101910:	bf00      	nop
 8101912:	370c      	adds	r7, #12
 8101914:	46bd      	mov	sp, r7
 8101916:	f85d 7b04 	ldr.w	r7, [sp], #4
 810191a:	4770      	bx	lr
 810191c:	e000e100 	.word	0xe000e100
 8101920:	e000ed00 	.word	0xe000ed00

08101924 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8101924:	b480      	push	{r7}
 8101926:	b089      	sub	sp, #36	@ 0x24
 8101928:	af00      	add	r7, sp, #0
 810192a:	60f8      	str	r0, [r7, #12]
 810192c:	60b9      	str	r1, [r7, #8]
 810192e:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8101930:	68fb      	ldr	r3, [r7, #12]
 8101932:	f003 0307 	and.w	r3, r3, #7
 8101936:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8101938:	69fb      	ldr	r3, [r7, #28]
 810193a:	f1c3 0307 	rsb	r3, r3, #7
 810193e:	2b04      	cmp	r3, #4
 8101940:	bf28      	it	cs
 8101942:	2304      	movcs	r3, #4
 8101944:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8101946:	69fb      	ldr	r3, [r7, #28]
 8101948:	3304      	adds	r3, #4
 810194a:	2b06      	cmp	r3, #6
 810194c:	d902      	bls.n	8101954 <NVIC_EncodePriority+0x30>
 810194e:	69fb      	ldr	r3, [r7, #28]
 8101950:	3b03      	subs	r3, #3
 8101952:	e000      	b.n	8101956 <NVIC_EncodePriority+0x32>
 8101954:	2300      	movs	r3, #0
 8101956:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8101958:	f04f 32ff 	mov.w	r2, #4294967295
 810195c:	69bb      	ldr	r3, [r7, #24]
 810195e:	fa02 f303 	lsl.w	r3, r2, r3
 8101962:	43da      	mvns	r2, r3
 8101964:	68bb      	ldr	r3, [r7, #8]
 8101966:	401a      	ands	r2, r3
 8101968:	697b      	ldr	r3, [r7, #20]
 810196a:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 810196c:	f04f 31ff 	mov.w	r1, #4294967295
 8101970:	697b      	ldr	r3, [r7, #20]
 8101972:	fa01 f303 	lsl.w	r3, r1, r3
 8101976:	43d9      	mvns	r1, r3
 8101978:	687b      	ldr	r3, [r7, #4]
 810197a:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 810197c:	4313      	orrs	r3, r2
         );
}
 810197e:	4618      	mov	r0, r3
 8101980:	3724      	adds	r7, #36	@ 0x24
 8101982:	46bd      	mov	sp, r7
 8101984:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101988:	4770      	bx	lr

0810198a <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 810198a:	b580      	push	{r7, lr}
 810198c:	b082      	sub	sp, #8
 810198e:	af00      	add	r7, sp, #0
 8101990:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8101992:	6878      	ldr	r0, [r7, #4]
 8101994:	f7ff ff28 	bl	81017e8 <__NVIC_SetPriorityGrouping>
}
 8101998:	bf00      	nop
 810199a:	3708      	adds	r7, #8
 810199c:	46bd      	mov	sp, r7
 810199e:	bd80      	pop	{r7, pc}

081019a0 <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 81019a0:	b580      	push	{r7, lr}
 81019a2:	b086      	sub	sp, #24
 81019a4:	af00      	add	r7, sp, #0
 81019a6:	4603      	mov	r3, r0
 81019a8:	60b9      	str	r1, [r7, #8]
 81019aa:	607a      	str	r2, [r7, #4]
 81019ac:	81fb      	strh	r3, [r7, #14]

  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();
 81019ae:	f7ff ff3f 	bl	8101830 <__NVIC_GetPriorityGrouping>
 81019b2:	6178      	str	r0, [r7, #20]

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 81019b4:	687a      	ldr	r2, [r7, #4]
 81019b6:	68b9      	ldr	r1, [r7, #8]
 81019b8:	6978      	ldr	r0, [r7, #20]
 81019ba:	f7ff ffb3 	bl	8101924 <NVIC_EncodePriority>
 81019be:	4602      	mov	r2, r0
 81019c0:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
 81019c4:	4611      	mov	r1, r2
 81019c6:	4618      	mov	r0, r3
 81019c8:	f7ff ff82 	bl	81018d0 <__NVIC_SetPriority>
}
 81019cc:	bf00      	nop
 81019ce:	3718      	adds	r7, #24
 81019d0:	46bd      	mov	sp, r7
 81019d2:	bd80      	pop	{r7, pc}

081019d4 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 81019d4:	b580      	push	{r7, lr}
 81019d6:	b082      	sub	sp, #8
 81019d8:	af00      	add	r7, sp, #0
 81019da:	4603      	mov	r3, r0
 81019dc:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 81019de:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 81019e2:	4618      	mov	r0, r3
 81019e4:	f7ff ff32 	bl	810184c <__NVIC_EnableIRQ>
}
 81019e8:	bf00      	nop
 81019ea:	3708      	adds	r7, #8
 81019ec:	46bd      	mov	sp, r7
 81019ee:	bd80      	pop	{r7, pc}

081019f0 <HAL_NVIC_DisableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32h7xxxx.h))
  * @retval None
  */
void HAL_NVIC_DisableIRQ(IRQn_Type IRQn)
{
 81019f0:	b580      	push	{r7, lr}
 81019f2:	b082      	sub	sp, #8
 81019f4:	af00      	add	r7, sp, #0
 81019f6:	4603      	mov	r3, r0
 81019f8:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Disable interrupt */
  NVIC_DisableIRQ(IRQn);
 81019fa:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 81019fe:	4618      	mov	r0, r3
 8101a00:	f7ff ff42 	bl	8101888 <__NVIC_DisableIRQ>
}
 8101a04:	bf00      	nop
 8101a06:	3708      	adds	r7, #8
 8101a08:	46bd      	mov	sp, r7
 8101a0a:	bd80      	pop	{r7, pc}

08101a0c <HAL_GetCurrentCPUID>:
/**
  * @brief  Returns the current CPU ID.
  * @retval CPU identifier
  */
uint32_t HAL_GetCurrentCPUID(void)
{
 8101a0c:	b480      	push	{r7}
 8101a0e:	af00      	add	r7, sp, #0
  if (((SCB->CPUID & 0x000000F0U) >> 4 )== 0x7U)
 8101a10:	4b07      	ldr	r3, [pc, #28]	@ (8101a30 <HAL_GetCurrentCPUID+0x24>)
 8101a12:	681b      	ldr	r3, [r3, #0]
 8101a14:	091b      	lsrs	r3, r3, #4
 8101a16:	f003 030f 	and.w	r3, r3, #15
 8101a1a:	2b07      	cmp	r3, #7
 8101a1c:	d101      	bne.n	8101a22 <HAL_GetCurrentCPUID+0x16>
  {
    return  CM7_CPUID;
 8101a1e:	2303      	movs	r3, #3
 8101a20:	e000      	b.n	8101a24 <HAL_GetCurrentCPUID+0x18>
  }
  else
  {
    return CM4_CPUID;
 8101a22:	2301      	movs	r3, #1
  }
}
 8101a24:	4618      	mov	r0, r3
 8101a26:	46bd      	mov	sp, r7
 8101a28:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101a2c:	4770      	bx	lr
 8101a2e:	bf00      	nop
 8101a30:	e000ed00 	.word	0xe000ed00

08101a34 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8101a34:	b480      	push	{r7}
 8101a36:	b089      	sub	sp, #36	@ 0x24
 8101a38:	af00      	add	r7, sp, #0
 8101a3a:	6078      	str	r0, [r7, #4]
 8101a3c:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
 8101a3e:	2300      	movs	r3, #0
 8101a40:	61fb      	str	r3, [r7, #28]
  uint32_t iocurrent;
  uint32_t temp;
  EXTI_Core_TypeDef *EXTI_CurrentCPU;

#if defined(DUAL_CORE) && defined(CORE_CM4)
  EXTI_CurrentCPU = EXTI_D2; /* EXTI for CM4 CPU */
 8101a42:	4b89      	ldr	r3, [pc, #548]	@ (8101c68 <HAL_GPIO_Init+0x234>)
 8101a44:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8101a46:	e194      	b.n	8101d72 <HAL_GPIO_Init+0x33e>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8101a48:	683b      	ldr	r3, [r7, #0]
 8101a4a:	681a      	ldr	r2, [r3, #0]
 8101a4c:	2101      	movs	r1, #1
 8101a4e:	69fb      	ldr	r3, [r7, #28]
 8101a50:	fa01 f303 	lsl.w	r3, r1, r3
 8101a54:	4013      	ands	r3, r2
 8101a56:	613b      	str	r3, [r7, #16]

    if (iocurrent != 0x00U)
 8101a58:	693b      	ldr	r3, [r7, #16]
 8101a5a:	2b00      	cmp	r3, #0
 8101a5c:	f000 8186 	beq.w	8101d6c <HAL_GPIO_Init+0x338>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8101a60:	683b      	ldr	r3, [r7, #0]
 8101a62:	685b      	ldr	r3, [r3, #4]
 8101a64:	f003 0303 	and.w	r3, r3, #3
 8101a68:	2b01      	cmp	r3, #1
 8101a6a:	d005      	beq.n	8101a78 <HAL_GPIO_Init+0x44>
 8101a6c:	683b      	ldr	r3, [r7, #0]
 8101a6e:	685b      	ldr	r3, [r3, #4]
 8101a70:	f003 0303 	and.w	r3, r3, #3
 8101a74:	2b02      	cmp	r3, #2
 8101a76:	d130      	bne.n	8101ada <HAL_GPIO_Init+0xa6>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
 8101a78:	687b      	ldr	r3, [r7, #4]
 8101a7a:	689b      	ldr	r3, [r3, #8]
 8101a7c:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8101a7e:	69fb      	ldr	r3, [r7, #28]
 8101a80:	005b      	lsls	r3, r3, #1
 8101a82:	2203      	movs	r2, #3
 8101a84:	fa02 f303 	lsl.w	r3, r2, r3
 8101a88:	43db      	mvns	r3, r3
 8101a8a:	69ba      	ldr	r2, [r7, #24]
 8101a8c:	4013      	ands	r3, r2
 8101a8e:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8101a90:	683b      	ldr	r3, [r7, #0]
 8101a92:	68da      	ldr	r2, [r3, #12]
 8101a94:	69fb      	ldr	r3, [r7, #28]
 8101a96:	005b      	lsls	r3, r3, #1
 8101a98:	fa02 f303 	lsl.w	r3, r2, r3
 8101a9c:	69ba      	ldr	r2, [r7, #24]
 8101a9e:	4313      	orrs	r3, r2
 8101aa0:	61bb      	str	r3, [r7, #24]
        GPIOx->OSPEEDR = temp;
 8101aa2:	687b      	ldr	r3, [r7, #4]
 8101aa4:	69ba      	ldr	r2, [r7, #24]
 8101aa6:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
 8101aa8:	687b      	ldr	r3, [r7, #4]
 8101aaa:	685b      	ldr	r3, [r3, #4]
 8101aac:	61bb      	str	r3, [r7, #24]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8101aae:	2201      	movs	r2, #1
 8101ab0:	69fb      	ldr	r3, [r7, #28]
 8101ab2:	fa02 f303 	lsl.w	r3, r2, r3
 8101ab6:	43db      	mvns	r3, r3
 8101ab8:	69ba      	ldr	r2, [r7, #24]
 8101aba:	4013      	ands	r3, r2
 8101abc:	61bb      	str	r3, [r7, #24]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8101abe:	683b      	ldr	r3, [r7, #0]
 8101ac0:	685b      	ldr	r3, [r3, #4]
 8101ac2:	091b      	lsrs	r3, r3, #4
 8101ac4:	f003 0201 	and.w	r2, r3, #1
 8101ac8:	69fb      	ldr	r3, [r7, #28]
 8101aca:	fa02 f303 	lsl.w	r3, r2, r3
 8101ace:	69ba      	ldr	r2, [r7, #24]
 8101ad0:	4313      	orrs	r3, r2
 8101ad2:	61bb      	str	r3, [r7, #24]
        GPIOx->OTYPER = temp;
 8101ad4:	687b      	ldr	r3, [r7, #4]
 8101ad6:	69ba      	ldr	r2, [r7, #24]
 8101ad8:	605a      	str	r2, [r3, #4]
      }

      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8101ada:	683b      	ldr	r3, [r7, #0]
 8101adc:	685b      	ldr	r3, [r3, #4]
 8101ade:	f003 0303 	and.w	r3, r3, #3
 8101ae2:	2b03      	cmp	r3, #3
 8101ae4:	d017      	beq.n	8101b16 <HAL_GPIO_Init+0xe2>
      {
       /* Check the Pull parameter */
       assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
 8101ae6:	687b      	ldr	r3, [r7, #4]
 8101ae8:	68db      	ldr	r3, [r3, #12]
 8101aea:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8101aec:	69fb      	ldr	r3, [r7, #28]
 8101aee:	005b      	lsls	r3, r3, #1
 8101af0:	2203      	movs	r2, #3
 8101af2:	fa02 f303 	lsl.w	r3, r2, r3
 8101af6:	43db      	mvns	r3, r3
 8101af8:	69ba      	ldr	r2, [r7, #24]
 8101afa:	4013      	ands	r3, r2
 8101afc:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8101afe:	683b      	ldr	r3, [r7, #0]
 8101b00:	689a      	ldr	r2, [r3, #8]
 8101b02:	69fb      	ldr	r3, [r7, #28]
 8101b04:	005b      	lsls	r3, r3, #1
 8101b06:	fa02 f303 	lsl.w	r3, r2, r3
 8101b0a:	69ba      	ldr	r2, [r7, #24]
 8101b0c:	4313      	orrs	r3, r2
 8101b0e:	61bb      	str	r3, [r7, #24]
      GPIOx->PUPDR = temp;
 8101b10:	687b      	ldr	r3, [r7, #4]
 8101b12:	69ba      	ldr	r2, [r7, #24]
 8101b14:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8101b16:	683b      	ldr	r3, [r7, #0]
 8101b18:	685b      	ldr	r3, [r3, #4]
 8101b1a:	f003 0303 	and.w	r3, r3, #3
 8101b1e:	2b02      	cmp	r3, #2
 8101b20:	d123      	bne.n	8101b6a <HAL_GPIO_Init+0x136>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
 8101b22:	69fb      	ldr	r3, [r7, #28]
 8101b24:	08da      	lsrs	r2, r3, #3
 8101b26:	687b      	ldr	r3, [r7, #4]
 8101b28:	3208      	adds	r2, #8
 8101b2a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8101b2e:	61bb      	str	r3, [r7, #24]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8101b30:	69fb      	ldr	r3, [r7, #28]
 8101b32:	f003 0307 	and.w	r3, r3, #7
 8101b36:	009b      	lsls	r3, r3, #2
 8101b38:	220f      	movs	r2, #15
 8101b3a:	fa02 f303 	lsl.w	r3, r2, r3
 8101b3e:	43db      	mvns	r3, r3
 8101b40:	69ba      	ldr	r2, [r7, #24]
 8101b42:	4013      	ands	r3, r2
 8101b44:	61bb      	str	r3, [r7, #24]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8101b46:	683b      	ldr	r3, [r7, #0]
 8101b48:	691a      	ldr	r2, [r3, #16]
 8101b4a:	69fb      	ldr	r3, [r7, #28]
 8101b4c:	f003 0307 	and.w	r3, r3, #7
 8101b50:	009b      	lsls	r3, r3, #2
 8101b52:	fa02 f303 	lsl.w	r3, r2, r3
 8101b56:	69ba      	ldr	r2, [r7, #24]
 8101b58:	4313      	orrs	r3, r2
 8101b5a:	61bb      	str	r3, [r7, #24]
        GPIOx->AFR[position >> 3U] = temp;
 8101b5c:	69fb      	ldr	r3, [r7, #28]
 8101b5e:	08da      	lsrs	r2, r3, #3
 8101b60:	687b      	ldr	r3, [r7, #4]
 8101b62:	3208      	adds	r2, #8
 8101b64:	69b9      	ldr	r1, [r7, #24]
 8101b66:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 8101b6a:	687b      	ldr	r3, [r7, #4]
 8101b6c:	681b      	ldr	r3, [r3, #0]
 8101b6e:	61bb      	str	r3, [r7, #24]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8101b70:	69fb      	ldr	r3, [r7, #28]
 8101b72:	005b      	lsls	r3, r3, #1
 8101b74:	2203      	movs	r2, #3
 8101b76:	fa02 f303 	lsl.w	r3, r2, r3
 8101b7a:	43db      	mvns	r3, r3
 8101b7c:	69ba      	ldr	r2, [r7, #24]
 8101b7e:	4013      	ands	r3, r2
 8101b80:	61bb      	str	r3, [r7, #24]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8101b82:	683b      	ldr	r3, [r7, #0]
 8101b84:	685b      	ldr	r3, [r3, #4]
 8101b86:	f003 0203 	and.w	r2, r3, #3
 8101b8a:	69fb      	ldr	r3, [r7, #28]
 8101b8c:	005b      	lsls	r3, r3, #1
 8101b8e:	fa02 f303 	lsl.w	r3, r2, r3
 8101b92:	69ba      	ldr	r2, [r7, #24]
 8101b94:	4313      	orrs	r3, r2
 8101b96:	61bb      	str	r3, [r7, #24]
      GPIOx->MODER = temp;
 8101b98:	687b      	ldr	r3, [r7, #4]
 8101b9a:	69ba      	ldr	r2, [r7, #24]
 8101b9c:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8101b9e:	683b      	ldr	r3, [r7, #0]
 8101ba0:	685b      	ldr	r3, [r3, #4]
 8101ba2:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
 8101ba6:	2b00      	cmp	r3, #0
 8101ba8:	f000 80e0 	beq.w	8101d6c <HAL_GPIO_Init+0x338>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8101bac:	4b2f      	ldr	r3, [pc, #188]	@ (8101c6c <HAL_GPIO_Init+0x238>)
 8101bae:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8101bb2:	4a2e      	ldr	r2, [pc, #184]	@ (8101c6c <HAL_GPIO_Init+0x238>)
 8101bb4:	f043 0302 	orr.w	r3, r3, #2
 8101bb8:	f8c2 30f4 	str.w	r3, [r2, #244]	@ 0xf4
 8101bbc:	4b2b      	ldr	r3, [pc, #172]	@ (8101c6c <HAL_GPIO_Init+0x238>)
 8101bbe:	f8d3 30f4 	ldr.w	r3, [r3, #244]	@ 0xf4
 8101bc2:	f003 0302 	and.w	r3, r3, #2
 8101bc6:	60fb      	str	r3, [r7, #12]
 8101bc8:	68fb      	ldr	r3, [r7, #12]

        temp = SYSCFG->EXTICR[position >> 2U];
 8101bca:	4a29      	ldr	r2, [pc, #164]	@ (8101c70 <HAL_GPIO_Init+0x23c>)
 8101bcc:	69fb      	ldr	r3, [r7, #28]
 8101bce:	089b      	lsrs	r3, r3, #2
 8101bd0:	3302      	adds	r3, #2
 8101bd2:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8101bd6:	61bb      	str	r3, [r7, #24]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8101bd8:	69fb      	ldr	r3, [r7, #28]
 8101bda:	f003 0303 	and.w	r3, r3, #3
 8101bde:	009b      	lsls	r3, r3, #2
 8101be0:	220f      	movs	r2, #15
 8101be2:	fa02 f303 	lsl.w	r3, r2, r3
 8101be6:	43db      	mvns	r3, r3
 8101be8:	69ba      	ldr	r2, [r7, #24]
 8101bea:	4013      	ands	r3, r2
 8101bec:	61bb      	str	r3, [r7, #24]
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8101bee:	687b      	ldr	r3, [r7, #4]
 8101bf0:	4a20      	ldr	r2, [pc, #128]	@ (8101c74 <HAL_GPIO_Init+0x240>)
 8101bf2:	4293      	cmp	r3, r2
 8101bf4:	d052      	beq.n	8101c9c <HAL_GPIO_Init+0x268>
 8101bf6:	687b      	ldr	r3, [r7, #4]
 8101bf8:	4a1f      	ldr	r2, [pc, #124]	@ (8101c78 <HAL_GPIO_Init+0x244>)
 8101bfa:	4293      	cmp	r3, r2
 8101bfc:	d031      	beq.n	8101c62 <HAL_GPIO_Init+0x22e>
 8101bfe:	687b      	ldr	r3, [r7, #4]
 8101c00:	4a1e      	ldr	r2, [pc, #120]	@ (8101c7c <HAL_GPIO_Init+0x248>)
 8101c02:	4293      	cmp	r3, r2
 8101c04:	d02b      	beq.n	8101c5e <HAL_GPIO_Init+0x22a>
 8101c06:	687b      	ldr	r3, [r7, #4]
 8101c08:	4a1d      	ldr	r2, [pc, #116]	@ (8101c80 <HAL_GPIO_Init+0x24c>)
 8101c0a:	4293      	cmp	r3, r2
 8101c0c:	d025      	beq.n	8101c5a <HAL_GPIO_Init+0x226>
 8101c0e:	687b      	ldr	r3, [r7, #4]
 8101c10:	4a1c      	ldr	r2, [pc, #112]	@ (8101c84 <HAL_GPIO_Init+0x250>)
 8101c12:	4293      	cmp	r3, r2
 8101c14:	d01f      	beq.n	8101c56 <HAL_GPIO_Init+0x222>
 8101c16:	687b      	ldr	r3, [r7, #4]
 8101c18:	4a1b      	ldr	r2, [pc, #108]	@ (8101c88 <HAL_GPIO_Init+0x254>)
 8101c1a:	4293      	cmp	r3, r2
 8101c1c:	d019      	beq.n	8101c52 <HAL_GPIO_Init+0x21e>
 8101c1e:	687b      	ldr	r3, [r7, #4]
 8101c20:	4a1a      	ldr	r2, [pc, #104]	@ (8101c8c <HAL_GPIO_Init+0x258>)
 8101c22:	4293      	cmp	r3, r2
 8101c24:	d013      	beq.n	8101c4e <HAL_GPIO_Init+0x21a>
 8101c26:	687b      	ldr	r3, [r7, #4]
 8101c28:	4a19      	ldr	r2, [pc, #100]	@ (8101c90 <HAL_GPIO_Init+0x25c>)
 8101c2a:	4293      	cmp	r3, r2
 8101c2c:	d00d      	beq.n	8101c4a <HAL_GPIO_Init+0x216>
 8101c2e:	687b      	ldr	r3, [r7, #4]
 8101c30:	4a18      	ldr	r2, [pc, #96]	@ (8101c94 <HAL_GPIO_Init+0x260>)
 8101c32:	4293      	cmp	r3, r2
 8101c34:	d007      	beq.n	8101c46 <HAL_GPIO_Init+0x212>
 8101c36:	687b      	ldr	r3, [r7, #4]
 8101c38:	4a17      	ldr	r2, [pc, #92]	@ (8101c98 <HAL_GPIO_Init+0x264>)
 8101c3a:	4293      	cmp	r3, r2
 8101c3c:	d101      	bne.n	8101c42 <HAL_GPIO_Init+0x20e>
 8101c3e:	2309      	movs	r3, #9
 8101c40:	e02d      	b.n	8101c9e <HAL_GPIO_Init+0x26a>
 8101c42:	230a      	movs	r3, #10
 8101c44:	e02b      	b.n	8101c9e <HAL_GPIO_Init+0x26a>
 8101c46:	2308      	movs	r3, #8
 8101c48:	e029      	b.n	8101c9e <HAL_GPIO_Init+0x26a>
 8101c4a:	2307      	movs	r3, #7
 8101c4c:	e027      	b.n	8101c9e <HAL_GPIO_Init+0x26a>
 8101c4e:	2306      	movs	r3, #6
 8101c50:	e025      	b.n	8101c9e <HAL_GPIO_Init+0x26a>
 8101c52:	2305      	movs	r3, #5
 8101c54:	e023      	b.n	8101c9e <HAL_GPIO_Init+0x26a>
 8101c56:	2304      	movs	r3, #4
 8101c58:	e021      	b.n	8101c9e <HAL_GPIO_Init+0x26a>
 8101c5a:	2303      	movs	r3, #3
 8101c5c:	e01f      	b.n	8101c9e <HAL_GPIO_Init+0x26a>
 8101c5e:	2302      	movs	r3, #2
 8101c60:	e01d      	b.n	8101c9e <HAL_GPIO_Init+0x26a>
 8101c62:	2301      	movs	r3, #1
 8101c64:	e01b      	b.n	8101c9e <HAL_GPIO_Init+0x26a>
 8101c66:	bf00      	nop
 8101c68:	580000c0 	.word	0x580000c0
 8101c6c:	58024400 	.word	0x58024400
 8101c70:	58000400 	.word	0x58000400
 8101c74:	58020000 	.word	0x58020000
 8101c78:	58020400 	.word	0x58020400
 8101c7c:	58020800 	.word	0x58020800
 8101c80:	58020c00 	.word	0x58020c00
 8101c84:	58021000 	.word	0x58021000
 8101c88:	58021400 	.word	0x58021400
 8101c8c:	58021800 	.word	0x58021800
 8101c90:	58021c00 	.word	0x58021c00
 8101c94:	58022000 	.word	0x58022000
 8101c98:	58022400 	.word	0x58022400
 8101c9c:	2300      	movs	r3, #0
 8101c9e:	69fa      	ldr	r2, [r7, #28]
 8101ca0:	f002 0203 	and.w	r2, r2, #3
 8101ca4:	0092      	lsls	r2, r2, #2
 8101ca6:	4093      	lsls	r3, r2
 8101ca8:	69ba      	ldr	r2, [r7, #24]
 8101caa:	4313      	orrs	r3, r2
 8101cac:	61bb      	str	r3, [r7, #24]
        SYSCFG->EXTICR[position >> 2U] = temp;
 8101cae:	4938      	ldr	r1, [pc, #224]	@ (8101d90 <HAL_GPIO_Init+0x35c>)
 8101cb0:	69fb      	ldr	r3, [r7, #28]
 8101cb2:	089b      	lsrs	r3, r3, #2
 8101cb4:	3302      	adds	r3, #2
 8101cb6:	69ba      	ldr	r2, [r7, #24]
 8101cb8:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8101cbc:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8101cc0:	681b      	ldr	r3, [r3, #0]
 8101cc2:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8101cc4:	693b      	ldr	r3, [r7, #16]
 8101cc6:	43db      	mvns	r3, r3
 8101cc8:	69ba      	ldr	r2, [r7, #24]
 8101cca:	4013      	ands	r3, r2
 8101ccc:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8101cce:	683b      	ldr	r3, [r7, #0]
 8101cd0:	685b      	ldr	r3, [r3, #4]
 8101cd2:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 8101cd6:	2b00      	cmp	r3, #0
 8101cd8:	d003      	beq.n	8101ce2 <HAL_GPIO_Init+0x2ae>
        {
          temp |= iocurrent;
 8101cda:	69ba      	ldr	r2, [r7, #24]
 8101cdc:	693b      	ldr	r3, [r7, #16]
 8101cde:	4313      	orrs	r3, r2
 8101ce0:	61bb      	str	r3, [r7, #24]
        }
        EXTI->RTSR1 = temp;
 8101ce2:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8101ce6:	69bb      	ldr	r3, [r7, #24]
 8101ce8:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
 8101cea:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8101cee:	685b      	ldr	r3, [r3, #4]
 8101cf0:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8101cf2:	693b      	ldr	r3, [r7, #16]
 8101cf4:	43db      	mvns	r3, r3
 8101cf6:	69ba      	ldr	r2, [r7, #24]
 8101cf8:	4013      	ands	r3, r2
 8101cfa:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8101cfc:	683b      	ldr	r3, [r7, #0]
 8101cfe:	685b      	ldr	r3, [r3, #4]
 8101d00:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
 8101d04:	2b00      	cmp	r3, #0
 8101d06:	d003      	beq.n	8101d10 <HAL_GPIO_Init+0x2dc>
        {
          temp |= iocurrent;
 8101d08:	69ba      	ldr	r2, [r7, #24]
 8101d0a:	693b      	ldr	r3, [r7, #16]
 8101d0c:	4313      	orrs	r3, r2
 8101d0e:	61bb      	str	r3, [r7, #24]
        }
        EXTI->FTSR1 = temp;
 8101d10:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8101d14:	69bb      	ldr	r3, [r7, #24]
 8101d16:	6053      	str	r3, [r2, #4]

        temp = EXTI_CurrentCPU->EMR1;
 8101d18:	697b      	ldr	r3, [r7, #20]
 8101d1a:	685b      	ldr	r3, [r3, #4]
 8101d1c:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8101d1e:	693b      	ldr	r3, [r7, #16]
 8101d20:	43db      	mvns	r3, r3
 8101d22:	69ba      	ldr	r2, [r7, #24]
 8101d24:	4013      	ands	r3, r2
 8101d26:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8101d28:	683b      	ldr	r3, [r7, #0]
 8101d2a:	685b      	ldr	r3, [r3, #4]
 8101d2c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
 8101d30:	2b00      	cmp	r3, #0
 8101d32:	d003      	beq.n	8101d3c <HAL_GPIO_Init+0x308>
        {
          temp |= iocurrent;
 8101d34:	69ba      	ldr	r2, [r7, #24]
 8101d36:	693b      	ldr	r3, [r7, #16]
 8101d38:	4313      	orrs	r3, r2
 8101d3a:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->EMR1 = temp;
 8101d3c:	697b      	ldr	r3, [r7, #20]
 8101d3e:	69ba      	ldr	r2, [r7, #24]
 8101d40:	605a      	str	r2, [r3, #4]

        /* Clear EXTI line configuration */
        temp = EXTI_CurrentCPU->IMR1;
 8101d42:	697b      	ldr	r3, [r7, #20]
 8101d44:	681b      	ldr	r3, [r3, #0]
 8101d46:	61bb      	str	r3, [r7, #24]
        temp &= ~(iocurrent);
 8101d48:	693b      	ldr	r3, [r7, #16]
 8101d4a:	43db      	mvns	r3, r3
 8101d4c:	69ba      	ldr	r2, [r7, #24]
 8101d4e:	4013      	ands	r3, r2
 8101d50:	61bb      	str	r3, [r7, #24]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8101d52:	683b      	ldr	r3, [r7, #0]
 8101d54:	685b      	ldr	r3, [r3, #4]
 8101d56:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
 8101d5a:	2b00      	cmp	r3, #0
 8101d5c:	d003      	beq.n	8101d66 <HAL_GPIO_Init+0x332>
        {
          temp |= iocurrent;
 8101d5e:	69ba      	ldr	r2, [r7, #24]
 8101d60:	693b      	ldr	r3, [r7, #16]
 8101d62:	4313      	orrs	r3, r2
 8101d64:	61bb      	str	r3, [r7, #24]
        }
        EXTI_CurrentCPU->IMR1 = temp;
 8101d66:	697b      	ldr	r3, [r7, #20]
 8101d68:	69ba      	ldr	r2, [r7, #24]
 8101d6a:	601a      	str	r2, [r3, #0]
      }
    }

    position++;
 8101d6c:	69fb      	ldr	r3, [r7, #28]
 8101d6e:	3301      	adds	r3, #1
 8101d70:	61fb      	str	r3, [r7, #28]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8101d72:	683b      	ldr	r3, [r7, #0]
 8101d74:	681a      	ldr	r2, [r3, #0]
 8101d76:	69fb      	ldr	r3, [r7, #28]
 8101d78:	fa22 f303 	lsr.w	r3, r2, r3
 8101d7c:	2b00      	cmp	r3, #0
 8101d7e:	f47f ae63 	bne.w	8101a48 <HAL_GPIO_Init+0x14>
  }
}
 8101d82:	bf00      	nop
 8101d84:	bf00      	nop
 8101d86:	3724      	adds	r7, #36	@ 0x24
 8101d88:	46bd      	mov	sp, r7
 8101d8a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101d8e:	4770      	bx	lr
 8101d90:	58000400 	.word	0x58000400

08101d94 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8101d94:	b480      	push	{r7}
 8101d96:	b083      	sub	sp, #12
 8101d98:	af00      	add	r7, sp, #0
 8101d9a:	6078      	str	r0, [r7, #4]
 8101d9c:	460b      	mov	r3, r1
 8101d9e:	807b      	strh	r3, [r7, #2]
 8101da0:	4613      	mov	r3, r2
 8101da2:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8101da4:	787b      	ldrb	r3, [r7, #1]
 8101da6:	2b00      	cmp	r3, #0
 8101da8:	d003      	beq.n	8101db2 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8101daa:	887a      	ldrh	r2, [r7, #2]
 8101dac:	687b      	ldr	r3, [r7, #4]
 8101dae:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
  }
}
 8101db0:	e003      	b.n	8101dba <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << GPIO_NUMBER;
 8101db2:	887b      	ldrh	r3, [r7, #2]
 8101db4:	041a      	lsls	r2, r3, #16
 8101db6:	687b      	ldr	r3, [r7, #4]
 8101db8:	619a      	str	r2, [r3, #24]
}
 8101dba:	bf00      	nop
 8101dbc:	370c      	adds	r7, #12
 8101dbe:	46bd      	mov	sp, r7
 8101dc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101dc4:	4770      	bx	lr

08101dc6 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the port pin connected to corresponding EXTI line.
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8101dc6:	b580      	push	{r7, lr}
 8101dc8:	b082      	sub	sp, #8
 8101dca:	af00      	add	r7, sp, #0
 8101dcc:	4603      	mov	r3, r0
 8101dce:	80fb      	strh	r3, [r7, #6]
#if defined(DUAL_CORE) && defined(CORE_CM4)
  if (__HAL_GPIO_EXTID2_GET_IT(GPIO_Pin) != 0x00U)
 8101dd0:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
 8101dd4:	f8d3 20c8 	ldr.w	r2, [r3, #200]	@ 0xc8
 8101dd8:	88fb      	ldrh	r3, [r7, #6]
 8101dda:	4013      	ands	r3, r2
 8101ddc:	2b00      	cmp	r3, #0
 8101dde:	d008      	beq.n	8101df2 <HAL_GPIO_EXTI_IRQHandler+0x2c>
  {
    __HAL_GPIO_EXTID2_CLEAR_IT(GPIO_Pin);
 8101de0:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
 8101de4:	88fb      	ldrh	r3, [r7, #6]
 8101de6:	f8c2 30c8 	str.w	r3, [r2, #200]	@ 0xc8
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8101dea:	88fb      	ldrh	r3, [r7, #6]
 8101dec:	4618      	mov	r0, r3
 8101dee:	f7fe fce5 	bl	81007bc <HAL_GPIO_EXTI_Callback>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
  }
#endif
}
 8101df2:	bf00      	nop
 8101df4:	3708      	adds	r7, #8
 8101df6:	46bd      	mov	sp, r7
 8101df8:	bd80      	pop	{r7, pc}
	...

08101dfc <HAL_HSEM_FastTake>:
  * @brief  Fast Take a semaphore with 1 Step mode.
  * @param  SemID: semaphore ID from 0 to 31
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_HSEM_FastTake(uint32_t SemID)
{
 8101dfc:	b480      	push	{r7}
 8101dfe:	b083      	sub	sp, #12
 8101e00:	af00      	add	r7, sp, #0
 8101e02:	6078      	str	r0, [r7, #4]
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
  }
#else  
  /* Read the RLR register to take the semaphore */
  if (HSEM->RLR[SemID] == (HSEM_CR_COREID_CURRENT | HSEM_RLR_LOCK))
 8101e04:	4a08      	ldr	r2, [pc, #32]	@ (8101e28 <HAL_HSEM_FastTake+0x2c>)
 8101e06:	687b      	ldr	r3, [r7, #4]
 8101e08:	3320      	adds	r3, #32
 8101e0a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8101e0e:	4a07      	ldr	r2, [pc, #28]	@ (8101e2c <HAL_HSEM_FastTake+0x30>)
 8101e10:	4293      	cmp	r3, r2
 8101e12:	d101      	bne.n	8101e18 <HAL_HSEM_FastTake+0x1c>
  {
    /*take success when MasterID match and take bit set*/
    return HAL_OK;
 8101e14:	2300      	movs	r3, #0
 8101e16:	e000      	b.n	8101e1a <HAL_HSEM_FastTake+0x1e>
  }
#endif

  /* Semaphore take fails */
  return HAL_ERROR;
 8101e18:	2301      	movs	r3, #1
}
 8101e1a:	4618      	mov	r0, r3
 8101e1c:	370c      	adds	r7, #12
 8101e1e:	46bd      	mov	sp, r7
 8101e20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101e24:	4770      	bx	lr
 8101e26:	bf00      	nop
 8101e28:	58026400 	.word	0x58026400
 8101e2c:	80000100 	.word	0x80000100

08101e30 <HAL_HSEM_Release>:
  * @param  SemID: semaphore ID from 0 to 31
  * @param  ProcessID: Process ID from 0 to 255
  * @retval None
  */
void  HAL_HSEM_Release(uint32_t SemID, uint32_t ProcessID)
{
 8101e30:	b480      	push	{r7}
 8101e32:	b083      	sub	sp, #12
 8101e34:	af00      	add	r7, sp, #0
 8101e36:	6078      	str	r0, [r7, #4]
 8101e38:	6039      	str	r1, [r7, #0]

  /* Clear the semaphore by writing to the R register : the MasterID , the processID and take bit = 0  */
#if  USE_MULTI_CORE_SHARED_CODE != 0U
  HSEM->R[SemID] = (ProcessID | ((HAL_GetCurrentCPUID() << POSITION_VAL(HSEM_R_MASTERID)) & HSEM_R_MASTERID));
#else
  HSEM->R[SemID] = (ProcessID | HSEM_CR_COREID_CURRENT);
 8101e3a:	4906      	ldr	r1, [pc, #24]	@ (8101e54 <HAL_HSEM_Release+0x24>)
 8101e3c:	683b      	ldr	r3, [r7, #0]
 8101e3e:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
 8101e42:	687b      	ldr	r3, [r7, #4]
 8101e44:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#endif

}
 8101e48:	bf00      	nop
 8101e4a:	370c      	adds	r7, #12
 8101e4c:	46bd      	mov	sp, r7
 8101e4e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101e52:	4770      	bx	lr
 8101e54:	58026400 	.word	0x58026400

08101e58 <HAL_HSEM_ActivateNotification>:
  * @brief  Activate Semaphore release Notification for a given Semaphores Mask .
  * @param  SemMask: Mask of Released semaphores
  * @retval Semaphore Key
  */
void HAL_HSEM_ActivateNotification(uint32_t SemMask)
{
 8101e58:	b480      	push	{r7}
 8101e5a:	b083      	sub	sp, #12
 8101e5c:	af00      	add	r7, sp, #0
 8101e5e:	6078      	str	r0, [r7, #4]
  {
    /*Use interrupt line 1 for CPU2 Master*/
    HSEM->C2IER |= SemMask;
  }
#else
  HSEM_COMMON->IER |= SemMask;
 8101e60:	4b05      	ldr	r3, [pc, #20]	@ (8101e78 <HAL_HSEM_ActivateNotification+0x20>)
 8101e62:	681a      	ldr	r2, [r3, #0]
 8101e64:	4904      	ldr	r1, [pc, #16]	@ (8101e78 <HAL_HSEM_ActivateNotification+0x20>)
 8101e66:	687b      	ldr	r3, [r7, #4]
 8101e68:	4313      	orrs	r3, r2
 8101e6a:	600b      	str	r3, [r1, #0]
#endif
}
 8101e6c:	bf00      	nop
 8101e6e:	370c      	adds	r7, #12
 8101e70:	46bd      	mov	sp, r7
 8101e72:	f85d 7b04 	ldr.w	r7, [sp], #4
 8101e76:	4770      	bx	lr
 8101e78:	58026510 	.word	0x58026510

08101e7c <HAL_HSEM_IRQHandler>:
/**
  * @brief  This function handles HSEM interrupt request
  * @retval None
  */
void HAL_HSEM_IRQHandler(void)
{
 8101e7c:	b580      	push	{r7, lr}
 8101e7e:	b082      	sub	sp, #8
 8101e80:	af00      	add	r7, sp, #0
    /*Clear Flags*/
    HSEM->C2ICR = ((uint32_t)statusreg);
  }
#else
  /* Get the list of masked freed semaphores*/
  statusreg = HSEM_COMMON->MISR;
 8101e82:	4b0a      	ldr	r3, [pc, #40]	@ (8101eac <HAL_HSEM_IRQHandler+0x30>)
 8101e84:	68db      	ldr	r3, [r3, #12]
 8101e86:	607b      	str	r3, [r7, #4]

  /*Disable Interrupts*/
  HSEM_COMMON->IER &= ~((uint32_t)statusreg);
 8101e88:	4b08      	ldr	r3, [pc, #32]	@ (8101eac <HAL_HSEM_IRQHandler+0x30>)
 8101e8a:	681a      	ldr	r2, [r3, #0]
 8101e8c:	687b      	ldr	r3, [r7, #4]
 8101e8e:	43db      	mvns	r3, r3
 8101e90:	4906      	ldr	r1, [pc, #24]	@ (8101eac <HAL_HSEM_IRQHandler+0x30>)
 8101e92:	4013      	ands	r3, r2
 8101e94:	600b      	str	r3, [r1, #0]

  /*Clear Flags*/
  HSEM_COMMON->ICR = ((uint32_t)statusreg);
 8101e96:	4a05      	ldr	r2, [pc, #20]	@ (8101eac <HAL_HSEM_IRQHandler+0x30>)
 8101e98:	687b      	ldr	r3, [r7, #4]
 8101e9a:	6053      	str	r3, [r2, #4]

#endif
  /* Call FreeCallback */
  HAL_HSEM_FreeCallback(statusreg);
 8101e9c:	6878      	ldr	r0, [r7, #4]
 8101e9e:	f00d fb1b 	bl	810f4d8 <HAL_HSEM_FreeCallback>
}
 8101ea2:	bf00      	nop
 8101ea4:	3708      	adds	r7, #8
 8101ea6:	46bd      	mov	sp, r7
 8101ea8:	bd80      	pop	{r7, pc}
 8101eaa:	bf00      	nop
 8101eac:	58026510 	.word	0x58026510

08101eb0 <HAL_PWREx_EnterSTOPMode>:
  *            @arg PWR_D2_DOMAIN : Enter D2 Domain to DSTOP mode.
  *            @arg PWR_D3_DOMAIN : Enter D3/SRD Domain to DSTOP mode.
  * @retval None.
  */
void HAL_PWREx_EnterSTOPMode (uint32_t Regulator, uint8_t STOPEntry, uint32_t Domain)
{
 8101eb0:	b580      	push	{r7, lr}
 8101eb2:	b084      	sub	sp, #16
 8101eb4:	af00      	add	r7, sp, #0
 8101eb6:	60f8      	str	r0, [r7, #12]
 8101eb8:	460b      	mov	r3, r1
 8101eba:	607a      	str	r2, [r7, #4]
 8101ebc:	72fb      	strb	r3, [r7, #11]
  assert_param (IS_PWR_REGULATOR (Regulator));
  assert_param (IS_PWR_STOP_ENTRY (STOPEntry));
  assert_param (IS_PWR_DOMAIN (Domain));

  /* Select the regulator state in Stop mode */
  MODIFY_REG (PWR->CR1, PWR_CR1_LPDS, Regulator);
 8101ebe:	4b37      	ldr	r3, [pc, #220]	@ (8101f9c <HAL_PWREx_EnterSTOPMode+0xec>)
 8101ec0:	681b      	ldr	r3, [r3, #0]
 8101ec2:	f023 0201 	bic.w	r2, r3, #1
 8101ec6:	4935      	ldr	r1, [pc, #212]	@ (8101f9c <HAL_PWREx_EnterSTOPMode+0xec>)
 8101ec8:	68fb      	ldr	r3, [r7, #12]
 8101eca:	4313      	orrs	r3, r2
 8101ecc:	600b      	str	r3, [r1, #0]

  /* Select the domain Power Down DeepSleep */
  if (Domain == PWR_D1_DOMAIN)
 8101ece:	687b      	ldr	r3, [r7, #4]
 8101ed0:	2b00      	cmp	r3, #0
 8101ed2:	d123      	bne.n	8101f1c <HAL_PWREx_EnterSTOPMode+0x6c>
  {
#if defined (DUAL_CORE)
    /* Check current core */
    if (HAL_GetCurrentCPUID () != CM7_CPUID)
 8101ed4:	f7ff fd9a 	bl	8101a0c <HAL_GetCurrentCPUID>
 8101ed8:	4603      	mov	r3, r0
 8101eda:	2b03      	cmp	r3, #3
 8101edc:	d158      	bne.n	8101f90 <HAL_PWREx_EnterSTOPMode+0xe0>
      return;
    }
#endif /* defined (DUAL_CORE) */

    /* Keep DSTOP mode when D1/CD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D1);
 8101ede:	4b2f      	ldr	r3, [pc, #188]	@ (8101f9c <HAL_PWREx_EnterSTOPMode+0xec>)
 8101ee0:	691b      	ldr	r3, [r3, #16]
 8101ee2:	4a2e      	ldr	r2, [pc, #184]	@ (8101f9c <HAL_PWREx_EnterSTOPMode+0xec>)
 8101ee4:	f023 0301 	bic.w	r3, r3, #1
 8101ee8:	6113      	str	r3, [r2, #16]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8101eea:	4b2d      	ldr	r3, [pc, #180]	@ (8101fa0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8101eec:	691b      	ldr	r3, [r3, #16]
 8101eee:	4a2c      	ldr	r2, [pc, #176]	@ (8101fa0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8101ef0:	f043 0304 	orr.w	r3, r3, #4
 8101ef4:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 8101ef6:	f3bf 8f4f 	dsb	sy
}
 8101efa:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8101efc:	f3bf 8f6f 	isb	sy
}
 8101f00:	bf00      	nop
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
 8101f02:	7afb      	ldrb	r3, [r7, #11]
 8101f04:	2b01      	cmp	r3, #1
 8101f06:	d101      	bne.n	8101f0c <HAL_PWREx_EnterSTOPMode+0x5c>
    {
      /* Request Wait For Interrupt */
      __WFI ();
 8101f08:	bf30      	wfi
 8101f0a:	e000      	b.n	8101f0e <HAL_PWREx_EnterSTOPMode+0x5e>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
 8101f0c:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8101f0e:	4b24      	ldr	r3, [pc, #144]	@ (8101fa0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8101f10:	691b      	ldr	r3, [r3, #16]
 8101f12:	4a23      	ldr	r2, [pc, #140]	@ (8101fa0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8101f14:	f023 0304 	bic.w	r3, r3, #4
 8101f18:	6113      	str	r3, [r2, #16]
 8101f1a:	e03c      	b.n	8101f96 <HAL_PWREx_EnterSTOPMode+0xe6>
  }
#if defined (PWR_CPUCR_PDDS_D2)
  else if (Domain == PWR_D2_DOMAIN)
 8101f1c:	687b      	ldr	r3, [r7, #4]
 8101f1e:	2b01      	cmp	r3, #1
 8101f20:	d123      	bne.n	8101f6a <HAL_PWREx_EnterSTOPMode+0xba>
  {
#if defined (DUAL_CORE)
    /* Check current core */
    if (HAL_GetCurrentCPUID () != CM4_CPUID)
 8101f22:	f7ff fd73 	bl	8101a0c <HAL_GetCurrentCPUID>
 8101f26:	4603      	mov	r3, r0
 8101f28:	2b01      	cmp	r3, #1
 8101f2a:	d133      	bne.n	8101f94 <HAL_PWREx_EnterSTOPMode+0xe4>
      */
      return;
    }

    /* Keep DSTOP mode when D2 domain enters Deepsleep */
    CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D2);
 8101f2c:	4b1b      	ldr	r3, [pc, #108]	@ (8101f9c <HAL_PWREx_EnterSTOPMode+0xec>)
 8101f2e:	695b      	ldr	r3, [r3, #20]
 8101f30:	4a1a      	ldr	r2, [pc, #104]	@ (8101f9c <HAL_PWREx_EnterSTOPMode+0xec>)
 8101f32:	f023 0302 	bic.w	r3, r3, #2
 8101f36:	6153      	str	r3, [r2, #20]

    /* Set SLEEPDEEP bit of Cortex System Control Register */
    SET_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8101f38:	4b19      	ldr	r3, [pc, #100]	@ (8101fa0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8101f3a:	691b      	ldr	r3, [r3, #16]
 8101f3c:	4a18      	ldr	r2, [pc, #96]	@ (8101fa0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8101f3e:	f043 0304 	orr.w	r3, r3, #4
 8101f42:	6113      	str	r3, [r2, #16]
  __ASM volatile ("dsb 0xF":::"memory");
 8101f44:	f3bf 8f4f 	dsb	sy
}
 8101f48:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
 8101f4a:	f3bf 8f6f 	isb	sy
}
 8101f4e:	bf00      	nop
    /* Ensure that all instructions are done before entering STOP mode */
    __DSB ();
    __ISB ();

    /* Select Stop mode entry */
    if (STOPEntry == PWR_STOPENTRY_WFI)
 8101f50:	7afb      	ldrb	r3, [r7, #11]
 8101f52:	2b01      	cmp	r3, #1
 8101f54:	d101      	bne.n	8101f5a <HAL_PWREx_EnterSTOPMode+0xaa>
    {
      /* Request Wait For Interrupt */
      __WFI ();
 8101f56:	bf30      	wfi
 8101f58:	e000      	b.n	8101f5c <HAL_PWREx_EnterSTOPMode+0xac>
    }
    else
    {
      /* Request Wait For Event */
      __WFE ();
 8101f5a:	bf20      	wfe
    }

    /* Clear SLEEPDEEP bit of Cortex-Mx in the System Control Register */
    CLEAR_BIT (SCB->SCR, SCB_SCR_SLEEPDEEP_Msk);
 8101f5c:	4b10      	ldr	r3, [pc, #64]	@ (8101fa0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8101f5e:	691b      	ldr	r3, [r3, #16]
 8101f60:	4a0f      	ldr	r2, [pc, #60]	@ (8101fa0 <HAL_PWREx_EnterSTOPMode+0xf0>)
 8101f62:	f023 0304 	bic.w	r3, r3, #4
 8101f66:	6113      	str	r3, [r2, #16]
 8101f68:	e015      	b.n	8101f96 <HAL_PWREx_EnterSTOPMode+0xe6>
#endif /* defined (PWR_CPUCR_PDDS_D2) */
  else
  {
#if defined (DUAL_CORE)
    /* Check current core */
    if (HAL_GetCurrentCPUID () == CM7_CPUID)
 8101f6a:	f7ff fd4f 	bl	8101a0c <HAL_GetCurrentCPUID>
 8101f6e:	4603      	mov	r3, r0
 8101f70:	2b03      	cmp	r3, #3
 8101f72:	d106      	bne.n	8101f82 <HAL_PWREx_EnterSTOPMode+0xd2>
    {
      /* Keep DSTOP mode when D3 domain enters Deepsleep */
      CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
 8101f74:	4b09      	ldr	r3, [pc, #36]	@ (8101f9c <HAL_PWREx_EnterSTOPMode+0xec>)
 8101f76:	691b      	ldr	r3, [r3, #16]
 8101f78:	4a08      	ldr	r2, [pc, #32]	@ (8101f9c <HAL_PWREx_EnterSTOPMode+0xec>)
 8101f7a:	f023 0304 	bic.w	r3, r3, #4
 8101f7e:	6113      	str	r3, [r2, #16]
 8101f80:	e009      	b.n	8101f96 <HAL_PWREx_EnterSTOPMode+0xe6>
    }
    else
    {
      /* Keep DSTOP mode when D3 domain enters Deepsleep */
      CLEAR_BIT (PWR->CPU2CR, PWR_CPU2CR_PDDS_D3);
 8101f82:	4b06      	ldr	r3, [pc, #24]	@ (8101f9c <HAL_PWREx_EnterSTOPMode+0xec>)
 8101f84:	695b      	ldr	r3, [r3, #20]
 8101f86:	4a05      	ldr	r2, [pc, #20]	@ (8101f9c <HAL_PWREx_EnterSTOPMode+0xec>)
 8101f88:	f023 0304 	bic.w	r3, r3, #4
 8101f8c:	6153      	str	r3, [r2, #20]
 8101f8e:	e002      	b.n	8101f96 <HAL_PWREx_EnterSTOPMode+0xe6>
      return;
 8101f90:	bf00      	nop
 8101f92:	e000      	b.n	8101f96 <HAL_PWREx_EnterSTOPMode+0xe6>
      return;
 8101f94:	bf00      	nop
#else
    /* Keep DSTOP mode when D3/SRD domain enters Deepsleep */
    CLEAR_BIT (PWR->CPUCR, PWR_CPUCR_PDDS_D3);
#endif  /* defined (DUAL_CORE) */
  }
}
 8101f96:	3710      	adds	r7, #16
 8101f98:	46bd      	mov	sp, r7
 8101f9a:	bd80      	pop	{r7, pc}
 8101f9c:	58024800 	.word	0x58024800
 8101fa0:	e000ed00 	.word	0xe000ed00

08101fa4 <HAL_PWREx_ClearPendingEvent>:
  *         enter low power mode using Wait For Event request.
  * @note   Cortex-M7 must be in CRUN mode when calling this API by Cortex-M4.
  * @retval None.
  */
void HAL_PWREx_ClearPendingEvent (void)
{
 8101fa4:	b580      	push	{r7, lr}
 8101fa6:	af00      	add	r7, sp, #0
#if defined (DUAL_CORE)
  /* Check the current Core */
  if (HAL_GetCurrentCPUID () == CM7_CPUID)
 8101fa8:	f7ff fd30 	bl	8101a0c <HAL_GetCurrentCPUID>
 8101fac:	4603      	mov	r3, r0
 8101fae:	2b03      	cmp	r3, #3
 8101fb0:	d101      	bne.n	8101fb6 <HAL_PWREx_ClearPendingEvent+0x12>
  {
    __WFE ();
 8101fb2:	bf20      	wfe
    __WFE ();
  }
#else
  __WFE ();
#endif /* defined (DUAL_CORE) */
}
 8101fb4:	e001      	b.n	8101fba <HAL_PWREx_ClearPendingEvent+0x16>
    __SEV ();
 8101fb6:	bf40      	sev
    __WFE ();
 8101fb8:	bf20      	wfe
}
 8101fba:	bf00      	nop
 8101fbc:	bd80      	pop	{r7, pc}
	...

08101fc0 <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
 8101fc0:	b480      	push	{r7}
 8101fc2:	b089      	sub	sp, #36	@ 0x24
 8101fc4:	af00      	add	r7, sp, #0
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 8101fc6:	4bb3      	ldr	r3, [pc, #716]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8101fc8:	691b      	ldr	r3, [r3, #16]
 8101fca:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8101fce:	2b18      	cmp	r3, #24
 8101fd0:	f200 8155 	bhi.w	810227e <HAL_RCC_GetSysClockFreq+0x2be>
 8101fd4:	a201      	add	r2, pc, #4	@ (adr r2, 8101fdc <HAL_RCC_GetSysClockFreq+0x1c>)
 8101fd6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8101fda:	bf00      	nop
 8101fdc:	08102041 	.word	0x08102041
 8101fe0:	0810227f 	.word	0x0810227f
 8101fe4:	0810227f 	.word	0x0810227f
 8101fe8:	0810227f 	.word	0x0810227f
 8101fec:	0810227f 	.word	0x0810227f
 8101ff0:	0810227f 	.word	0x0810227f
 8101ff4:	0810227f 	.word	0x0810227f
 8101ff8:	0810227f 	.word	0x0810227f
 8101ffc:	08102067 	.word	0x08102067
 8102000:	0810227f 	.word	0x0810227f
 8102004:	0810227f 	.word	0x0810227f
 8102008:	0810227f 	.word	0x0810227f
 810200c:	0810227f 	.word	0x0810227f
 8102010:	0810227f 	.word	0x0810227f
 8102014:	0810227f 	.word	0x0810227f
 8102018:	0810227f 	.word	0x0810227f
 810201c:	0810206d 	.word	0x0810206d
 8102020:	0810227f 	.word	0x0810227f
 8102024:	0810227f 	.word	0x0810227f
 8102028:	0810227f 	.word	0x0810227f
 810202c:	0810227f 	.word	0x0810227f
 8102030:	0810227f 	.word	0x0810227f
 8102034:	0810227f 	.word	0x0810227f
 8102038:	0810227f 	.word	0x0810227f
 810203c:	08102073 	.word	0x08102073
  {
    case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

      if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 8102040:	4b94      	ldr	r3, [pc, #592]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8102042:	681b      	ldr	r3, [r3, #0]
 8102044:	f003 0320 	and.w	r3, r3, #32
 8102048:	2b00      	cmp	r3, #0
 810204a:	d009      	beq.n	8102060 <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 810204c:	4b91      	ldr	r3, [pc, #580]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 810204e:	681b      	ldr	r3, [r3, #0]
 8102050:	08db      	lsrs	r3, r3, #3
 8102052:	f003 0303 	and.w	r3, r3, #3
 8102056:	4a90      	ldr	r2, [pc, #576]	@ (8102298 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8102058:	fa22 f303 	lsr.w	r3, r2, r3
 810205c:	61bb      	str	r3, [r7, #24]
      else
      {
        sysclockfreq = (uint32_t) HSI_VALUE;
      }

      break;
 810205e:	e111      	b.n	8102284 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = (uint32_t) HSI_VALUE;
 8102060:	4b8d      	ldr	r3, [pc, #564]	@ (8102298 <HAL_RCC_GetSysClockFreq+0x2d8>)
 8102062:	61bb      	str	r3, [r7, #24]
      break;
 8102064:	e10e      	b.n	8102284 <HAL_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_CSI:  /* CSI used as system clock  source */
      sysclockfreq = CSI_VALUE;
 8102066:	4b8d      	ldr	r3, [pc, #564]	@ (810229c <HAL_RCC_GetSysClockFreq+0x2dc>)
 8102068:	61bb      	str	r3, [r7, #24]
      break;
 810206a:	e10b      	b.n	8102284 <HAL_RCC_GetSysClockFreq+0x2c4>

    case RCC_CFGR_SWS_HSE:  /* HSE used as system clock  source */
      sysclockfreq = HSE_VALUE;
 810206c:	4b8c      	ldr	r3, [pc, #560]	@ (81022a0 <HAL_RCC_GetSysClockFreq+0x2e0>)
 810206e:	61bb      	str	r3, [r7, #24]
      break;
 8102070:	e108      	b.n	8102284 <HAL_RCC_GetSysClockFreq+0x2c4>
    case RCC_CFGR_SWS_PLL1:  /* PLL1 used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLR
      */
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 8102072:	4b88      	ldr	r3, [pc, #544]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8102074:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8102076:	f003 0303 	and.w	r3, r3, #3
 810207a:	617b      	str	r3, [r7, #20]
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> 4)  ;
 810207c:	4b85      	ldr	r3, [pc, #532]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 810207e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8102080:	091b      	lsrs	r3, r3, #4
 8102082:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
 8102086:	613b      	str	r3, [r7, #16]
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
 8102088:	4b82      	ldr	r3, [pc, #520]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 810208a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810208c:	f003 0301 	and.w	r3, r3, #1
 8102090:	60fb      	str	r3, [r7, #12]
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1) >> 3));
 8102092:	4b80      	ldr	r3, [pc, #512]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8102094:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
 8102096:	08db      	lsrs	r3, r3, #3
 8102098:	f3c3 030c 	ubfx	r3, r3, #0, #13
 810209c:	68fa      	ldr	r2, [r7, #12]
 810209e:	fb02 f303 	mul.w	r3, r2, r3
 81020a2:	ee07 3a90 	vmov	s15, r3
 81020a6:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81020aa:	edc7 7a02 	vstr	s15, [r7, #8]

      if (pllm != 0U)
 81020ae:	693b      	ldr	r3, [r7, #16]
 81020b0:	2b00      	cmp	r3, #0
 81020b2:	f000 80e1 	beq.w	8102278 <HAL_RCC_GetSysClockFreq+0x2b8>
 81020b6:	697b      	ldr	r3, [r7, #20]
 81020b8:	2b02      	cmp	r3, #2
 81020ba:	f000 8083 	beq.w	81021c4 <HAL_RCC_GetSysClockFreq+0x204>
 81020be:	697b      	ldr	r3, [r7, #20]
 81020c0:	2b02      	cmp	r3, #2
 81020c2:	f200 80a1 	bhi.w	8102208 <HAL_RCC_GetSysClockFreq+0x248>
 81020c6:	697b      	ldr	r3, [r7, #20]
 81020c8:	2b00      	cmp	r3, #0
 81020ca:	d003      	beq.n	81020d4 <HAL_RCC_GetSysClockFreq+0x114>
 81020cc:	697b      	ldr	r3, [r7, #20]
 81020ce:	2b01      	cmp	r3, #1
 81020d0:	d056      	beq.n	8102180 <HAL_RCC_GetSysClockFreq+0x1c0>
 81020d2:	e099      	b.n	8102208 <HAL_RCC_GetSysClockFreq+0x248>
      {
        switch (pllsource)
        {
          case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

            if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 81020d4:	4b6f      	ldr	r3, [pc, #444]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 81020d6:	681b      	ldr	r3, [r3, #0]
 81020d8:	f003 0320 	and.w	r3, r3, #32
 81020dc:	2b00      	cmp	r3, #0
 81020de:	d02d      	beq.n	810213c <HAL_RCC_GetSysClockFreq+0x17c>
            {
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3));
 81020e0:	4b6c      	ldr	r3, [pc, #432]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 81020e2:	681b      	ldr	r3, [r3, #0]
 81020e4:	08db      	lsrs	r3, r3, #3
 81020e6:	f003 0303 	and.w	r3, r3, #3
 81020ea:	4a6b      	ldr	r2, [pc, #428]	@ (8102298 <HAL_RCC_GetSysClockFreq+0x2d8>)
 81020ec:	fa22 f303 	lsr.w	r3, r2, r3
 81020f0:	607b      	str	r3, [r7, #4]
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 81020f2:	687b      	ldr	r3, [r7, #4]
 81020f4:	ee07 3a90 	vmov	s15, r3
 81020f8:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81020fc:	693b      	ldr	r3, [r7, #16]
 81020fe:	ee07 3a90 	vmov	s15, r3
 8102102:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8102106:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 810210a:	4b62      	ldr	r3, [pc, #392]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 810210c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 810210e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8102112:	ee07 3a90 	vmov	s15, r3
 8102116:	eef8 6a67 	vcvt.f32.u32	s13, s15
 810211a:	ed97 6a02 	vldr	s12, [r7, #8]
 810211e:	eddf 5a61 	vldr	s11, [pc, #388]	@ 81022a4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8102122:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8102126:	ee76 7aa7 	vadd.f32	s15, s13, s15
 810212a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 810212e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8102132:	ee67 7a27 	vmul.f32	s15, s14, s15
 8102136:	edc7 7a07 	vstr	s15, [r7, #28]
            }
            else
            {
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
            }
            break;
 810213a:	e087      	b.n	810224c <HAL_RCC_GetSysClockFreq+0x28c>
              pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 810213c:	693b      	ldr	r3, [r7, #16]
 810213e:	ee07 3a90 	vmov	s15, r3
 8102142:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8102146:	eddf 6a58 	vldr	s13, [pc, #352]	@ 81022a8 <HAL_RCC_GetSysClockFreq+0x2e8>
 810214a:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 810214e:	4b51      	ldr	r3, [pc, #324]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8102150:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8102152:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8102156:	ee07 3a90 	vmov	s15, r3
 810215a:	eef8 6a67 	vcvt.f32.u32	s13, s15
 810215e:	ed97 6a02 	vldr	s12, [r7, #8]
 8102162:	eddf 5a50 	vldr	s11, [pc, #320]	@ 81022a4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8102166:	eec6 7a25 	vdiv.f32	s15, s12, s11
 810216a:	ee76 7aa7 	vadd.f32	s15, s13, s15
 810216e:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 8102172:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8102176:	ee67 7a27 	vmul.f32	s15, s14, s15
 810217a:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 810217e:	e065      	b.n	810224c <HAL_RCC_GetSysClockFreq+0x28c>

          case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8102180:	693b      	ldr	r3, [r7, #16]
 8102182:	ee07 3a90 	vmov	s15, r3
 8102186:	eef8 7a67 	vcvt.f32.u32	s15, s15
 810218a:	eddf 6a48 	vldr	s13, [pc, #288]	@ 81022ac <HAL_RCC_GetSysClockFreq+0x2ec>
 810218e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 8102192:	4b40      	ldr	r3, [pc, #256]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 8102194:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8102196:	f3c3 0308 	ubfx	r3, r3, #0, #9
 810219a:	ee07 3a90 	vmov	s15, r3
 810219e:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81021a2:	ed97 6a02 	vldr	s12, [r7, #8]
 81021a6:	eddf 5a3f 	vldr	s11, [pc, #252]	@ 81022a4 <HAL_RCC_GetSysClockFreq+0x2e4>
 81021aa:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81021ae:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81021b2:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 81021b6:	ee77 7aa6 	vadd.f32	s15, s15, s13
 81021ba:	ee67 7a27 	vmul.f32	s15, s14, s15
 81021be:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 81021c2:	e043      	b.n	810224c <HAL_RCC_GetSysClockFreq+0x28c>

          case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 81021c4:	693b      	ldr	r3, [r7, #16]
 81021c6:	ee07 3a90 	vmov	s15, r3
 81021ca:	eef8 7a67 	vcvt.f32.u32	s15, s15
 81021ce:	eddf 6a38 	vldr	s13, [pc, #224]	@ 81022b0 <HAL_RCC_GetSysClockFreq+0x2f0>
 81021d2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 81021d6:	4b2f      	ldr	r3, [pc, #188]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 81021d8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 81021da:	f3c3 0308 	ubfx	r3, r3, #0, #9
 81021de:	ee07 3a90 	vmov	s15, r3
 81021e2:	eef8 6a67 	vcvt.f32.u32	s13, s15
 81021e6:	ed97 6a02 	vldr	s12, [r7, #8]
 81021ea:	eddf 5a2e 	vldr	s11, [pc, #184]	@ 81022a4 <HAL_RCC_GetSysClockFreq+0x2e4>
 81021ee:	eec6 7a25 	vdiv.f32	s15, s12, s11
 81021f2:	ee76 7aa7 	vadd.f32	s15, s13, s15
 81021f6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 81021fa:	ee77 7aa6 	vadd.f32	s15, s15, s13
 81021fe:	ee67 7a27 	vmul.f32	s15, s14, s15
 8102202:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 8102206:	e021      	b.n	810224c <HAL_RCC_GetSysClockFreq+0x28c>

          default:
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1 / (float_t)0x2000) + (float_t)1);
 8102208:	693b      	ldr	r3, [r7, #16]
 810220a:	ee07 3a90 	vmov	s15, r3
 810220e:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8102212:	eddf 6a26 	vldr	s13, [pc, #152]	@ 81022ac <HAL_RCC_GetSysClockFreq+0x2ec>
 8102216:	ee86 7aa7 	vdiv.f32	s14, s13, s15
 810221a:	4b1e      	ldr	r3, [pc, #120]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 810221c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 810221e:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8102222:	ee07 3a90 	vmov	s15, r3
 8102226:	eef8 6a67 	vcvt.f32.u32	s13, s15
 810222a:	ed97 6a02 	vldr	s12, [r7, #8]
 810222e:	eddf 5a1d 	vldr	s11, [pc, #116]	@ 81022a4 <HAL_RCC_GetSysClockFreq+0x2e4>
 8102232:	eec6 7a25 	vdiv.f32	s15, s12, s11
 8102236:	ee76 7aa7 	vadd.f32	s15, s13, s15
 810223a:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
 810223e:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8102242:	ee67 7a27 	vmul.f32	s15, s14, s15
 8102246:	edc7 7a07 	vstr	s15, [r7, #28]
            break;
 810224a:	bf00      	nop
        }
        pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >> 9) + 1U) ;
 810224c:	4b11      	ldr	r3, [pc, #68]	@ (8102294 <HAL_RCC_GetSysClockFreq+0x2d4>)
 810224e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 8102250:	0a5b      	lsrs	r3, r3, #9
 8102252:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8102256:	3301      	adds	r3, #1
 8102258:	603b      	str	r3, [r7, #0]
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
 810225a:	683b      	ldr	r3, [r7, #0]
 810225c:	ee07 3a90 	vmov	s15, r3
 8102260:	eeb8 7a67 	vcvt.f32.u32	s14, s15
 8102264:	edd7 6a07 	vldr	s13, [r7, #28]
 8102268:	eec6 7a87 	vdiv.f32	s15, s13, s14
 810226c:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 8102270:	ee17 3a90 	vmov	r3, s15
 8102274:	61bb      	str	r3, [r7, #24]
      }
      else
      {
        sysclockfreq = 0U;
      }
      break;
 8102276:	e005      	b.n	8102284 <HAL_RCC_GetSysClockFreq+0x2c4>
        sysclockfreq = 0U;
 8102278:	2300      	movs	r3, #0
 810227a:	61bb      	str	r3, [r7, #24]
      break;
 810227c:	e002      	b.n	8102284 <HAL_RCC_GetSysClockFreq+0x2c4>

    default:
      sysclockfreq = CSI_VALUE;
 810227e:	4b07      	ldr	r3, [pc, #28]	@ (810229c <HAL_RCC_GetSysClockFreq+0x2dc>)
 8102280:	61bb      	str	r3, [r7, #24]
      break;
 8102282:	bf00      	nop
  }

  return sysclockfreq;
 8102284:	69bb      	ldr	r3, [r7, #24]
}
 8102286:	4618      	mov	r0, r3
 8102288:	3724      	adds	r7, #36	@ 0x24
 810228a:	46bd      	mov	sp, r7
 810228c:	f85d 7b04 	ldr.w	r7, [sp], #4
 8102290:	4770      	bx	lr
 8102292:	bf00      	nop
 8102294:	58024400 	.word	0x58024400
 8102298:	03d09000 	.word	0x03d09000
 810229c:	003d0900 	.word	0x003d0900
 81022a0:	007a1200 	.word	0x007a1200
 81022a4:	46000000 	.word	0x46000000
 81022a8:	4c742400 	.word	0x4c742400
 81022ac:	4a742400 	.word	0x4a742400
 81022b0:	4af42400 	.word	0x4af42400

081022b4 <HAL_RCC_GetHCLKFreq>:
  * @note   The SystemD2Clock CMSIS variable is used to store System domain2 Clock Frequency
  *         and updated within this function
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
 81022b4:	b580      	push	{r7, lr}
 81022b6:	b082      	sub	sp, #8
 81022b8:	af00      	add	r7, sp, #0
  uint32_t common_system_clock;

#if defined(RCC_D1CFGR_D1CPRE)
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE) >> RCC_D1CFGR_D1CPRE_Pos] & 0x1FU);
 81022ba:	f7ff fe81 	bl	8101fc0 <HAL_RCC_GetSysClockFreq>
 81022be:	4602      	mov	r2, r0
 81022c0:	4b11      	ldr	r3, [pc, #68]	@ (8102308 <HAL_RCC_GetHCLKFreq+0x54>)
 81022c2:	699b      	ldr	r3, [r3, #24]
 81022c4:	0a1b      	lsrs	r3, r3, #8
 81022c6:	f003 030f 	and.w	r3, r3, #15
 81022ca:	4910      	ldr	r1, [pc, #64]	@ (810230c <HAL_RCC_GetHCLKFreq+0x58>)
 81022cc:	5ccb      	ldrb	r3, [r1, r3]
 81022ce:	f003 031f 	and.w	r3, r3, #31
 81022d2:	fa22 f303 	lsr.w	r3, r2, r3
 81022d6:	607b      	str	r3, [r7, #4]
#else
  common_system_clock = HAL_RCC_GetSysClockFreq() >> (D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_CDCPRE) >> RCC_CDCFGR1_CDCPRE_Pos] & 0x1FU);
#endif

#if defined(RCC_D1CFGR_HPRE)
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE) >> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 81022d8:	4b0b      	ldr	r3, [pc, #44]	@ (8102308 <HAL_RCC_GetHCLKFreq+0x54>)
 81022da:	699b      	ldr	r3, [r3, #24]
 81022dc:	f003 030f 	and.w	r3, r3, #15
 81022e0:	4a0a      	ldr	r2, [pc, #40]	@ (810230c <HAL_RCC_GetHCLKFreq+0x58>)
 81022e2:	5cd3      	ldrb	r3, [r2, r3]
 81022e4:	f003 031f 	and.w	r3, r3, #31
 81022e8:	687a      	ldr	r2, [r7, #4]
 81022ea:	fa22 f303 	lsr.w	r3, r2, r3
 81022ee:	4a08      	ldr	r2, [pc, #32]	@ (8102310 <HAL_RCC_GetHCLKFreq+0x5c>)
 81022f0:	6013      	str	r3, [r2, #0]
#else
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->CDCFGR1 & RCC_CDCFGR1_HPRE) >> RCC_CDCFGR1_HPRE_Pos]) & 0x1FU));
#endif

#if defined(DUAL_CORE) && defined(CORE_CM4)
  SystemCoreClock = SystemD2Clock;
 81022f2:	4b07      	ldr	r3, [pc, #28]	@ (8102310 <HAL_RCC_GetHCLKFreq+0x5c>)
 81022f4:	681b      	ldr	r3, [r3, #0]
 81022f6:	4a07      	ldr	r2, [pc, #28]	@ (8102314 <HAL_RCC_GetHCLKFreq+0x60>)
 81022f8:	6013      	str	r3, [r2, #0]
#else
  SystemCoreClock = common_system_clock;
#endif /* DUAL_CORE && CORE_CM4 */

  return SystemD2Clock;
 81022fa:	4b05      	ldr	r3, [pc, #20]	@ (8102310 <HAL_RCC_GetHCLKFreq+0x5c>)
 81022fc:	681b      	ldr	r3, [r3, #0]
}
 81022fe:	4618      	mov	r0, r3
 8102300:	3708      	adds	r7, #8
 8102302:	46bd      	mov	sp, r7
 8102304:	bd80      	pop	{r7, pc}
 8102306:	bf00      	nop
 8102308:	58024400 	.word	0x58024400
 810230c:	08110a88 	.word	0x08110a88
 8102310:	10000004 	.word	0x10000004
 8102314:	10000000 	.word	0x10000000

08102318 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
 8102318:	b580      	push	{r7, lr}
 810231a:	af00      	add	r7, sp, #0
#if defined (RCC_D2CFGR_D2PPRE1)
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1) >> RCC_D2CFGR_D2PPRE1_Pos]) & 0x1FU));
 810231c:	f7ff ffca 	bl	81022b4 <HAL_RCC_GetHCLKFreq>
 8102320:	4602      	mov	r2, r0
 8102322:	4b06      	ldr	r3, [pc, #24]	@ (810233c <HAL_RCC_GetPCLK1Freq+0x24>)
 8102324:	69db      	ldr	r3, [r3, #28]
 8102326:	091b      	lsrs	r3, r3, #4
 8102328:	f003 0307 	and.w	r3, r3, #7
 810232c:	4904      	ldr	r1, [pc, #16]	@ (8102340 <HAL_RCC_GetPCLK1Freq+0x28>)
 810232e:	5ccb      	ldrb	r3, [r1, r3]
 8102330:	f003 031f 	and.w	r3, r3, #31
 8102334:	fa22 f303 	lsr.w	r3, r2, r3
#else
  /* Get HCLK source and Compute PCLK1 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq() >> ((D1CorePrescTable[(RCC->CDCFGR2 & RCC_CDCFGR2_CDPPRE1) >> RCC_CDCFGR2_CDPPRE1_Pos]) & 0x1FU));
#endif
}
 8102338:	4618      	mov	r0, r3
 810233a:	bd80      	pop	{r7, pc}
 810233c:	58024400 	.word	0x58024400
 8102340:	08110a88 	.word	0x08110a88

08102344 <HAL_RCC_GetClockConfig>:
  * will be configured.
  * @param  pFLatency: Pointer on the Flash Latency.
  * @retval None
  */
void HAL_RCC_GetClockConfig(RCC_ClkInitTypeDef  *RCC_ClkInitStruct, uint32_t *pFLatency)
{
 8102344:	b480      	push	{r7}
 8102346:	b083      	sub	sp, #12
 8102348:	af00      	add	r7, sp, #0
 810234a:	6078      	str	r0, [r7, #4]
 810234c:	6039      	str	r1, [r7, #0]
  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 |
 810234e:	687b      	ldr	r3, [r7, #4]
 8102350:	223f      	movs	r2, #63	@ 0x3f
 8102352:	601a      	str	r2, [r3, #0]
                                 RCC_CLOCKTYPE_PCLK2 |  RCC_CLOCKTYPE_D3PCLK1  ;

  /* Get the SYSCLK configuration --------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 8102354:	4b1a      	ldr	r3, [pc, #104]	@ (81023c0 <HAL_RCC_GetClockConfig+0x7c>)
 8102356:	691b      	ldr	r3, [r3, #16]
 8102358:	f003 0207 	and.w	r2, r3, #7
 810235c:	687b      	ldr	r3, [r7, #4]
 810235e:	605a      	str	r2, [r3, #4]

#if defined(RCC_D1CFGR_D1CPRE)
  /* Get the SYSCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->SYSCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1CPRE);
 8102360:	4b17      	ldr	r3, [pc, #92]	@ (81023c0 <HAL_RCC_GetClockConfig+0x7c>)
 8102362:	699b      	ldr	r3, [r3, #24]
 8102364:	f403 6270 	and.w	r2, r3, #3840	@ 0xf00
 8102368:	687b      	ldr	r3, [r7, #4]
 810236a:	609a      	str	r2, [r3, #8]

  /* Get the D1HCLK configuration ----------------------------------------------*/
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_HPRE);
 810236c:	4b14      	ldr	r3, [pc, #80]	@ (81023c0 <HAL_RCC_GetClockConfig+0x7c>)
 810236e:	699b      	ldr	r3, [r3, #24]
 8102370:	f003 020f 	and.w	r2, r3, #15
 8102374:	687b      	ldr	r3, [r7, #4]
 8102376:	60da      	str	r2, [r3, #12]

  /* Get the APB3 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB3CLKDivider = (uint32_t)(RCC->D1CFGR & RCC_D1CFGR_D1PPRE);
 8102378:	4b11      	ldr	r3, [pc, #68]	@ (81023c0 <HAL_RCC_GetClockConfig+0x7c>)
 810237a:	699b      	ldr	r3, [r3, #24]
 810237c:	f003 0270 	and.w	r2, r3, #112	@ 0x70
 8102380:	687b      	ldr	r3, [r7, #4]
 8102382:	611a      	str	r2, [r3, #16]

  /* Get the APB1 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE1);
 8102384:	4b0e      	ldr	r3, [pc, #56]	@ (81023c0 <HAL_RCC_GetClockConfig+0x7c>)
 8102386:	69db      	ldr	r3, [r3, #28]
 8102388:	f003 0270 	and.w	r2, r3, #112	@ 0x70
 810238c:	687b      	ldr	r3, [r7, #4]
 810238e:	615a      	str	r2, [r3, #20]

  /* Get the APB2 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)(RCC->D2CFGR & RCC_D2CFGR_D2PPRE2);
 8102390:	4b0b      	ldr	r3, [pc, #44]	@ (81023c0 <HAL_RCC_GetClockConfig+0x7c>)
 8102392:	69db      	ldr	r3, [r3, #28]
 8102394:	f403 62e0 	and.w	r2, r3, #1792	@ 0x700
 8102398:	687b      	ldr	r3, [r7, #4]
 810239a:	619a      	str	r2, [r3, #24]

  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->D3CFGR & RCC_D3CFGR_D3PPRE);
 810239c:	4b08      	ldr	r3, [pc, #32]	@ (81023c0 <HAL_RCC_GetClockConfig+0x7c>)
 810239e:	6a1b      	ldr	r3, [r3, #32]
 81023a0:	f003 0270 	and.w	r2, r3, #112	@ 0x70
 81023a4:	687b      	ldr	r3, [r7, #4]
 81023a6:	61da      	str	r2, [r3, #28]
  /* Get the APB4 configuration ----------------------------------------------*/
  RCC_ClkInitStruct->APB4CLKDivider = (uint32_t)(RCC->SRDCFGR & RCC_SRDCFGR_SRDPPRE);
#endif

  /* Get the Flash Wait State (Latency) configuration ------------------------*/
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY);
 81023a8:	4b06      	ldr	r3, [pc, #24]	@ (81023c4 <HAL_RCC_GetClockConfig+0x80>)
 81023aa:	681b      	ldr	r3, [r3, #0]
 81023ac:	f003 020f 	and.w	r2, r3, #15
 81023b0:	683b      	ldr	r3, [r7, #0]
 81023b2:	601a      	str	r2, [r3, #0]
}
 81023b4:	bf00      	nop
 81023b6:	370c      	adds	r7, #12
 81023b8:	46bd      	mov	sp, r7
 81023ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 81023be:	4770      	bx	lr
 81023c0:	58024400 	.word	0x58024400
 81023c4:	52002000 	.word	0x52002000

081023c8 <HAL_RCCEx_PeriphCLKConfig>:
  * (*) : Available on some STM32H7 lines only.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 81023c8:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
 81023cc:	b0ca      	sub	sp, #296	@ 0x128
 81023ce:	af00      	add	r7, sp, #0
 81023d0:	f8c7 0114 	str.w	r0, [r7, #276]	@ 0x114
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
 81023d4:	2300      	movs	r3, #0
 81023d6:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 81023da:	2300      	movs	r3, #0
 81023dc:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126

  /*---------------------------- SPDIFRX configuration -------------------------------*/

  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
 81023e0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81023e4:	e9d3 2300 	ldrd	r2, r3, [r3]
 81023e8:	f002 6400 	and.w	r4, r2, #134217728	@ 0x8000000
 81023ec:	2500      	movs	r5, #0
 81023ee:	ea54 0305 	orrs.w	r3, r4, r5
 81023f2:	d049      	beq.n	8102488 <HAL_RCCEx_PeriphCLKConfig+0xc0>
  {

    switch (PeriphClkInit->SpdifrxClockSelection)
 81023f4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81023f8:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 81023fa:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 81023fe:	d02f      	beq.n	8102460 <HAL_RCCEx_PeriphCLKConfig+0x98>
 8102400:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8102404:	d828      	bhi.n	8102458 <HAL_RCCEx_PeriphCLKConfig+0x90>
 8102406:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 810240a:	d01a      	beq.n	8102442 <HAL_RCCEx_PeriphCLKConfig+0x7a>
 810240c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8102410:	d822      	bhi.n	8102458 <HAL_RCCEx_PeriphCLKConfig+0x90>
 8102412:	2b00      	cmp	r3, #0
 8102414:	d003      	beq.n	810241e <HAL_RCCEx_PeriphCLKConfig+0x56>
 8102416:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 810241a:	d007      	beq.n	810242c <HAL_RCCEx_PeriphCLKConfig+0x64>
 810241c:	e01c      	b.n	8102458 <HAL_RCCEx_PeriphCLKConfig+0x90>
    {
      case RCC_SPDIFRXCLKSOURCE_PLL:      /* PLL is used as clock source for SPDIFRX*/
        /* Enable PLL1Q Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 810241e:	4bb8      	ldr	r3, [pc, #736]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8102420:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8102422:	4ab7      	ldr	r2, [pc, #732]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8102424:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8102428:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 810242a:	e01a      	b.n	8102462 <HAL_RCCEx_PeriphCLKConfig+0x9a>

      case RCC_SPDIFRXCLKSOURCE_PLL2: /* PLL2 is used as clock source for SPDIFRX*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 810242c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102430:	3308      	adds	r3, #8
 8102432:	2102      	movs	r1, #2
 8102434:	4618      	mov	r0, r3
 8102436:	f001 f9d1 	bl	81037dc <RCCEx_PLL2_Config>
 810243a:	4603      	mov	r3, r0
 810243c:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 8102440:	e00f      	b.n	8102462 <HAL_RCCEx_PeriphCLKConfig+0x9a>

      case RCC_SPDIFRXCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPDIFRX*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8102442:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102446:	3328      	adds	r3, #40	@ 0x28
 8102448:	2102      	movs	r1, #2
 810244a:	4618      	mov	r0, r3
 810244c:	f001 fa78 	bl	8103940 <RCCEx_PLL3_Config>
 8102450:	4603      	mov	r3, r0
 8102452:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
 8102456:	e004      	b.n	8102462 <HAL_RCCEx_PeriphCLKConfig+0x9a>
        /* Internal OSC clock is used as source of SPDIFRX clock*/
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8102458:	2301      	movs	r3, #1
 810245a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 810245e:	e000      	b.n	8102462 <HAL_RCCEx_PeriphCLKConfig+0x9a>
        break;
 8102460:	bf00      	nop
    }

    if (ret == HAL_OK)
 8102462:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102466:	2b00      	cmp	r3, #0
 8102468:	d10a      	bne.n	8102480 <HAL_RCCEx_PeriphCLKConfig+0xb8>
    {
      /* Set the source of SPDIFRX clock*/
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
 810246a:	4ba5      	ldr	r3, [pc, #660]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 810246c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 810246e:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
 8102472:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102476:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 8102478:	4aa1      	ldr	r2, [pc, #644]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 810247a:	430b      	orrs	r3, r1
 810247c:	6513      	str	r3, [r2, #80]	@ 0x50
 810247e:	e003      	b.n	8102488 <HAL_RCCEx_PeriphCLKConfig+0xc0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8102480:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102484:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- SAI1 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 8102488:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810248c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8102490:	f402 7880 	and.w	r8, r2, #256	@ 0x100
 8102494:	f04f 0900 	mov.w	r9, #0
 8102498:	ea58 0309 	orrs.w	r3, r8, r9
 810249c:	d047      	beq.n	810252e <HAL_RCCEx_PeriphCLKConfig+0x166>
  {
    switch (PeriphClkInit->Sai1ClockSelection)
 810249e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81024a2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 81024a4:	2b04      	cmp	r3, #4
 81024a6:	d82a      	bhi.n	81024fe <HAL_RCCEx_PeriphCLKConfig+0x136>
 81024a8:	a201      	add	r2, pc, #4	@ (adr r2, 81024b0 <HAL_RCCEx_PeriphCLKConfig+0xe8>)
 81024aa:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 81024ae:	bf00      	nop
 81024b0:	081024c5 	.word	0x081024c5
 81024b4:	081024d3 	.word	0x081024d3
 81024b8:	081024e9 	.word	0x081024e9
 81024bc:	08102507 	.word	0x08102507
 81024c0:	08102507 	.word	0x08102507
    {
      case RCC_SAI1CLKSOURCE_PLL:      /* PLL is used as clock source for SAI1*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 81024c4:	4b8e      	ldr	r3, [pc, #568]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 81024c6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81024c8:	4a8d      	ldr	r2, [pc, #564]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 81024ca:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 81024ce:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 81024d0:	e01a      	b.n	8102508 <HAL_RCCEx_PeriphCLKConfig+0x140>

      case RCC_SAI1CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI1*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 81024d2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81024d6:	3308      	adds	r3, #8
 81024d8:	2100      	movs	r1, #0
 81024da:	4618      	mov	r0, r3
 81024dc:	f001 f97e 	bl	81037dc <RCCEx_PLL2_Config>
 81024e0:	4603      	mov	r3, r0
 81024e2:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 81024e6:	e00f      	b.n	8102508 <HAL_RCCEx_PeriphCLKConfig+0x140>

      case RCC_SAI1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI1*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 81024e8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81024ec:	3328      	adds	r3, #40	@ 0x28
 81024ee:	2100      	movs	r1, #0
 81024f0:	4618      	mov	r0, r3
 81024f2:	f001 fa25 	bl	8103940 <RCCEx_PLL3_Config>
 81024f6:	4603      	mov	r3, r0
 81024f8:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 81024fc:	e004      	b.n	8102508 <HAL_RCCEx_PeriphCLKConfig+0x140>
        /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
        /* SAI1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 81024fe:	2301      	movs	r3, #1
 8102500:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8102504:	e000      	b.n	8102508 <HAL_RCCEx_PeriphCLKConfig+0x140>
        break;
 8102506:	bf00      	nop
    }

    if (ret == HAL_OK)
 8102508:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810250c:	2b00      	cmp	r3, #0
 810250e:	d10a      	bne.n	8102526 <HAL_RCCEx_PeriphCLKConfig+0x15e>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8102510:	4b7b      	ldr	r3, [pc, #492]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8102512:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8102514:	f023 0107 	bic.w	r1, r3, #7
 8102518:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810251c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 810251e:	4a78      	ldr	r2, [pc, #480]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8102520:	430b      	orrs	r3, r1
 8102522:	6513      	str	r3, [r2, #80]	@ 0x50
 8102524:	e003      	b.n	810252e <HAL_RCCEx_PeriphCLKConfig+0x166>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8102526:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810252a:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

#if defined(SAI3)
  /*---------------------------- SAI2/3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI23) == RCC_PERIPHCLK_SAI23)
 810252e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102532:	e9d3 2300 	ldrd	r2, r3, [r3]
 8102536:	f402 7a00 	and.w	sl, r2, #512	@ 0x200
 810253a:	f04f 0b00 	mov.w	fp, #0
 810253e:	ea5a 030b 	orrs.w	r3, sl, fp
 8102542:	d04c      	beq.n	81025de <HAL_RCCEx_PeriphCLKConfig+0x216>
  {
    switch (PeriphClkInit->Sai23ClockSelection)
 8102544:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102548:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 810254a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 810254e:	d030      	beq.n	81025b2 <HAL_RCCEx_PeriphCLKConfig+0x1ea>
 8102550:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8102554:	d829      	bhi.n	81025aa <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 8102556:	2bc0      	cmp	r3, #192	@ 0xc0
 8102558:	d02d      	beq.n	81025b6 <HAL_RCCEx_PeriphCLKConfig+0x1ee>
 810255a:	2bc0      	cmp	r3, #192	@ 0xc0
 810255c:	d825      	bhi.n	81025aa <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 810255e:	2b80      	cmp	r3, #128	@ 0x80
 8102560:	d018      	beq.n	8102594 <HAL_RCCEx_PeriphCLKConfig+0x1cc>
 8102562:	2b80      	cmp	r3, #128	@ 0x80
 8102564:	d821      	bhi.n	81025aa <HAL_RCCEx_PeriphCLKConfig+0x1e2>
 8102566:	2b00      	cmp	r3, #0
 8102568:	d002      	beq.n	8102570 <HAL_RCCEx_PeriphCLKConfig+0x1a8>
 810256a:	2b40      	cmp	r3, #64	@ 0x40
 810256c:	d007      	beq.n	810257e <HAL_RCCEx_PeriphCLKConfig+0x1b6>
 810256e:	e01c      	b.n	81025aa <HAL_RCCEx_PeriphCLKConfig+0x1e2>
    {
      case RCC_SAI23CLKSOURCE_PLL:      /* PLL is used as clock source for SAI2/3 */
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8102570:	4b63      	ldr	r3, [pc, #396]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8102572:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8102574:	4a62      	ldr	r2, [pc, #392]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8102576:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 810257a:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
 810257c:	e01c      	b.n	81025b8 <HAL_RCCEx_PeriphCLKConfig+0x1f0>

      case RCC_SAI23CLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2/3 */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 810257e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102582:	3308      	adds	r3, #8
 8102584:	2100      	movs	r1, #0
 8102586:	4618      	mov	r0, r3
 8102588:	f001 f928 	bl	81037dc <RCCEx_PLL2_Config>
 810258c:	4603      	mov	r3, r0
 810258e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
 8102592:	e011      	b.n	81025b8 <HAL_RCCEx_PeriphCLKConfig+0x1f0>

      case RCC_SAI23CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2/3 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8102594:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102598:	3328      	adds	r3, #40	@ 0x28
 810259a:	2100      	movs	r1, #0
 810259c:	4618      	mov	r0, r3
 810259e:	f001 f9cf 	bl	8103940 <RCCEx_PLL3_Config>
 81025a2:	4603      	mov	r3, r0
 81025a4:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI2/3 clock source configuration done later after clock selection check */
        break;
 81025a8:	e006      	b.n	81025b8 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        /* HSI, HSE, or CSI oscillator is used as source of SAI2/3 clock */
        /* SAI2/3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 81025aa:	2301      	movs	r3, #1
 81025ac:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 81025b0:	e002      	b.n	81025b8 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        break;
 81025b2:	bf00      	nop
 81025b4:	e000      	b.n	81025b8 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
        break;
 81025b6:	bf00      	nop
    }

    if (ret == HAL_OK)
 81025b8:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81025bc:	2b00      	cmp	r3, #0
 81025be:	d10a      	bne.n	81025d6 <HAL_RCCEx_PeriphCLKConfig+0x20e>
    {
      /* Set the source of SAI2/3 clock*/
      __HAL_RCC_SAI23_CONFIG(PeriphClkInit->Sai23ClockSelection);
 81025c0:	4b4f      	ldr	r3, [pc, #316]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 81025c2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 81025c4:	f423 71e0 	bic.w	r1, r3, #448	@ 0x1c0
 81025c8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81025cc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 81025ce:	4a4c      	ldr	r2, [pc, #304]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 81025d0:	430b      	orrs	r3, r1
 81025d2:	6513      	str	r3, [r2, #80]	@ 0x50
 81025d4:	e003      	b.n	81025de <HAL_RCCEx_PeriphCLKConfig+0x216>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81025d6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81025da:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
  }
#endif  /*SAI2B*/

#if defined(SAI4)
  /*---------------------------- SAI4A configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4A) == RCC_PERIPHCLK_SAI4A)
 81025de:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81025e2:	e9d3 2300 	ldrd	r2, r3, [r3]
 81025e6:	f402 6380 	and.w	r3, r2, #1024	@ 0x400
 81025ea:	f8c7 3108 	str.w	r3, [r7, #264]	@ 0x108
 81025ee:	2300      	movs	r3, #0
 81025f0:	f8c7 310c 	str.w	r3, [r7, #268]	@ 0x10c
 81025f4:	e9d7 1242 	ldrd	r1, r2, [r7, #264]	@ 0x108
 81025f8:	460b      	mov	r3, r1
 81025fa:	4313      	orrs	r3, r2
 81025fc:	d053      	beq.n	81026a6 <HAL_RCCEx_PeriphCLKConfig+0x2de>
  {
    switch (PeriphClkInit->Sai4AClockSelection)
 81025fe:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102602:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8102606:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 810260a:	d035      	beq.n	8102678 <HAL_RCCEx_PeriphCLKConfig+0x2b0>
 810260c:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
 8102610:	d82e      	bhi.n	8102670 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
 8102612:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 8102616:	d031      	beq.n	810267c <HAL_RCCEx_PeriphCLKConfig+0x2b4>
 8102618:	f5b3 0fc0 	cmp.w	r3, #6291456	@ 0x600000
 810261c:	d828      	bhi.n	8102670 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
 810261e:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8102622:	d01a      	beq.n	810265a <HAL_RCCEx_PeriphCLKConfig+0x292>
 8102624:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8102628:	d822      	bhi.n	8102670 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
 810262a:	2b00      	cmp	r3, #0
 810262c:	d003      	beq.n	8102636 <HAL_RCCEx_PeriphCLKConfig+0x26e>
 810262e:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 8102632:	d007      	beq.n	8102644 <HAL_RCCEx_PeriphCLKConfig+0x27c>
 8102634:	e01c      	b.n	8102670 <HAL_RCCEx_PeriphCLKConfig+0x2a8>
    {
      case RCC_SAI4ACLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8102636:	4b32      	ldr	r3, [pc, #200]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8102638:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810263a:	4a31      	ldr	r2, [pc, #196]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 810263c:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8102640:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 8102642:	e01c      	b.n	810267e <HAL_RCCEx_PeriphCLKConfig+0x2b6>

      case RCC_SAI4ACLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8102644:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102648:	3308      	adds	r3, #8
 810264a:	2100      	movs	r1, #0
 810264c:	4618      	mov	r0, r3
 810264e:	f001 f8c5 	bl	81037dc <RCCEx_PLL2_Config>
 8102652:	4603      	mov	r3, r0
 8102654:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI2 clock source configuration done later after clock selection check */
        break;
 8102658:	e011      	b.n	810267e <HAL_RCCEx_PeriphCLKConfig+0x2b6>

      case RCC_SAI4ACLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 810265a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810265e:	3328      	adds	r3, #40	@ 0x28
 8102660:	2100      	movs	r1, #0
 8102662:	4618      	mov	r0, r3
 8102664:	f001 f96c 	bl	8103940 <RCCEx_PLL3_Config>
 8102668:	4603      	mov	r3, r0
 810266a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 810266e:	e006      	b.n	810267e <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        /* SAI4A clock source configuration done later after clock selection check */
        break;
#endif /* RCC_VER_3_0 */

      default:
        ret = HAL_ERROR;
 8102670:	2301      	movs	r3, #1
 8102672:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8102676:	e002      	b.n	810267e <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        break;
 8102678:	bf00      	nop
 810267a:	e000      	b.n	810267e <HAL_RCCEx_PeriphCLKConfig+0x2b6>
        break;
 810267c:	bf00      	nop
    }

    if (ret == HAL_OK)
 810267e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102682:	2b00      	cmp	r3, #0
 8102684:	d10b      	bne.n	810269e <HAL_RCCEx_PeriphCLKConfig+0x2d6>
    {
      /* Set the source of SAI4A clock*/
      __HAL_RCC_SAI4A_CONFIG(PeriphClkInit->Sai4AClockSelection);
 8102686:	4b1e      	ldr	r3, [pc, #120]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8102688:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 810268a:	f423 0160 	bic.w	r1, r3, #14680064	@ 0xe00000
 810268e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102692:	f8d3 30a8 	ldr.w	r3, [r3, #168]	@ 0xa8
 8102696:	4a1a      	ldr	r2, [pc, #104]	@ (8102700 <HAL_RCCEx_PeriphCLKConfig+0x338>)
 8102698:	430b      	orrs	r3, r1
 810269a:	6593      	str	r3, [r2, #88]	@ 0x58
 810269c:	e003      	b.n	81026a6 <HAL_RCCEx_PeriphCLKConfig+0x2de>
    }
    else
    {
      /* set overall return value */
      status = ret;
 810269e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81026a2:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  /*---------------------------- SAI4B configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI4B) == RCC_PERIPHCLK_SAI4B)
 81026a6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81026aa:	e9d3 2300 	ldrd	r2, r3, [r3]
 81026ae:	f402 6300 	and.w	r3, r2, #2048	@ 0x800
 81026b2:	f8c7 3100 	str.w	r3, [r7, #256]	@ 0x100
 81026b6:	2300      	movs	r3, #0
 81026b8:	f8c7 3104 	str.w	r3, [r7, #260]	@ 0x104
 81026bc:	e9d7 1240 	ldrd	r1, r2, [r7, #256]	@ 0x100
 81026c0:	460b      	mov	r3, r1
 81026c2:	4313      	orrs	r3, r2
 81026c4:	d056      	beq.n	8102774 <HAL_RCCEx_PeriphCLKConfig+0x3ac>
  {
    switch (PeriphClkInit->Sai4BClockSelection)
 81026c6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81026ca:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 81026ce:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 81026d2:	d038      	beq.n	8102746 <HAL_RCCEx_PeriphCLKConfig+0x37e>
 81026d4:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 81026d8:	d831      	bhi.n	810273e <HAL_RCCEx_PeriphCLKConfig+0x376>
 81026da:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 81026de:	d034      	beq.n	810274a <HAL_RCCEx_PeriphCLKConfig+0x382>
 81026e0:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
 81026e4:	d82b      	bhi.n	810273e <HAL_RCCEx_PeriphCLKConfig+0x376>
 81026e6:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 81026ea:	d01d      	beq.n	8102728 <HAL_RCCEx_PeriphCLKConfig+0x360>
 81026ec:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
 81026f0:	d825      	bhi.n	810273e <HAL_RCCEx_PeriphCLKConfig+0x376>
 81026f2:	2b00      	cmp	r3, #0
 81026f4:	d006      	beq.n	8102704 <HAL_RCCEx_PeriphCLKConfig+0x33c>
 81026f6:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
 81026fa:	d00a      	beq.n	8102712 <HAL_RCCEx_PeriphCLKConfig+0x34a>
 81026fc:	e01f      	b.n	810273e <HAL_RCCEx_PeriphCLKConfig+0x376>
 81026fe:	bf00      	nop
 8102700:	58024400 	.word	0x58024400
    {
      case RCC_SAI4BCLKSOURCE_PLL:      /* PLL is used as clock source for SAI2*/
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8102704:	4ba2      	ldr	r3, [pc, #648]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8102706:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8102708:	4aa1      	ldr	r2, [pc, #644]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 810270a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 810270e:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 8102710:	e01c      	b.n	810274c <HAL_RCCEx_PeriphCLKConfig+0x384>

      case RCC_SAI4BCLKSOURCE_PLL2: /* PLL2 is used as clock source for SAI2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8102712:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102716:	3308      	adds	r3, #8
 8102718:	2100      	movs	r1, #0
 810271a:	4618      	mov	r0, r3
 810271c:	f001 f85e 	bl	81037dc <RCCEx_PLL2_Config>
 8102720:	4603      	mov	r3, r0
 8102722:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI2 clock source configuration done later after clock selection check */
        break;
 8102726:	e011      	b.n	810274c <HAL_RCCEx_PeriphCLKConfig+0x384>

      case RCC_SAI4BCLKSOURCE_PLL3:  /* PLL3 is used as clock source for SAI2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8102728:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810272c:	3328      	adds	r3, #40	@ 0x28
 810272e:	2100      	movs	r1, #0
 8102730:	4618      	mov	r0, r3
 8102732:	f001 f905 	bl	8103940 <RCCEx_PLL3_Config>
 8102736:	4603      	mov	r3, r0
 8102738:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SAI1 clock source configuration done later after clock selection check */
        break;
 810273c:	e006      	b.n	810274c <HAL_RCCEx_PeriphCLKConfig+0x384>
        /* SAI4B clock source configuration done later after clock selection check */
        break;
#endif /* RCC_VER_3_0 */

      default:
        ret = HAL_ERROR;
 810273e:	2301      	movs	r3, #1
 8102740:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8102744:	e002      	b.n	810274c <HAL_RCCEx_PeriphCLKConfig+0x384>
        break;
 8102746:	bf00      	nop
 8102748:	e000      	b.n	810274c <HAL_RCCEx_PeriphCLKConfig+0x384>
        break;
 810274a:	bf00      	nop
    }

    if (ret == HAL_OK)
 810274c:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102750:	2b00      	cmp	r3, #0
 8102752:	d10b      	bne.n	810276c <HAL_RCCEx_PeriphCLKConfig+0x3a4>
    {
      /* Set the source of SAI4B clock*/
      __HAL_RCC_SAI4B_CONFIG(PeriphClkInit->Sai4BClockSelection);
 8102754:	4b8e      	ldr	r3, [pc, #568]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8102756:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8102758:	f023 61e0 	bic.w	r1, r3, #117440512	@ 0x7000000
 810275c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102760:	f8d3 30ac 	ldr.w	r3, [r3, #172]	@ 0xac
 8102764:	4a8a      	ldr	r2, [pc, #552]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8102766:	430b      	orrs	r3, r1
 8102768:	6593      	str	r3, [r2, #88]	@ 0x58
 810276a:	e003      	b.n	8102774 <HAL_RCCEx_PeriphCLKConfig+0x3ac>
    }
    else
    {
      /* set overall return value */
      status = ret;
 810276c:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102770:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
  }
#endif  /*SAI4*/

#if defined(QUADSPI)
  /*---------------------------- QSPI configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 8102774:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102778:	e9d3 2300 	ldrd	r2, r3, [r3]
 810277c:	f002 7300 	and.w	r3, r2, #33554432	@ 0x2000000
 8102780:	f8c7 30f8 	str.w	r3, [r7, #248]	@ 0xf8
 8102784:	2300      	movs	r3, #0
 8102786:	f8c7 30fc 	str.w	r3, [r7, #252]	@ 0xfc
 810278a:	e9d7 123e 	ldrd	r1, r2, [r7, #248]	@ 0xf8
 810278e:	460b      	mov	r3, r1
 8102790:	4313      	orrs	r3, r2
 8102792:	d03a      	beq.n	810280a <HAL_RCCEx_PeriphCLKConfig+0x442>
  {
    switch (PeriphClkInit->QspiClockSelection)
 8102794:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102798:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 810279a:	2b30      	cmp	r3, #48	@ 0x30
 810279c:	d01f      	beq.n	81027de <HAL_RCCEx_PeriphCLKConfig+0x416>
 810279e:	2b30      	cmp	r3, #48	@ 0x30
 81027a0:	d819      	bhi.n	81027d6 <HAL_RCCEx_PeriphCLKConfig+0x40e>
 81027a2:	2b20      	cmp	r3, #32
 81027a4:	d00c      	beq.n	81027c0 <HAL_RCCEx_PeriphCLKConfig+0x3f8>
 81027a6:	2b20      	cmp	r3, #32
 81027a8:	d815      	bhi.n	81027d6 <HAL_RCCEx_PeriphCLKConfig+0x40e>
 81027aa:	2b00      	cmp	r3, #0
 81027ac:	d019      	beq.n	81027e2 <HAL_RCCEx_PeriphCLKConfig+0x41a>
 81027ae:	2b10      	cmp	r3, #16
 81027b0:	d111      	bne.n	81027d6 <HAL_RCCEx_PeriphCLKConfig+0x40e>
    {
      case RCC_QSPICLKSOURCE_PLL:      /* PLL is used as clock source for QSPI*/
        /* Enable QSPI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 81027b2:	4b77      	ldr	r3, [pc, #476]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81027b4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81027b6:	4a76      	ldr	r2, [pc, #472]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81027b8:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 81027bc:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* QSPI clock source configuration done later after clock selection check */
        break;
 81027be:	e011      	b.n	81027e4 <HAL_RCCEx_PeriphCLKConfig+0x41c>

      case RCC_QSPICLKSOURCE_PLL2: /* PLL2 is used as clock source for QSPI*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 81027c0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81027c4:	3308      	adds	r3, #8
 81027c6:	2102      	movs	r1, #2
 81027c8:	4618      	mov	r0, r3
 81027ca:	f001 f807 	bl	81037dc <RCCEx_PLL2_Config>
 81027ce:	4603      	mov	r3, r0
 81027d0:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* QSPI clock source configuration done later after clock selection check */
        break;
 81027d4:	e006      	b.n	81027e4 <HAL_RCCEx_PeriphCLKConfig+0x41c>
      case RCC_QSPICLKSOURCE_D1HCLK:
        /* Domain1 HCLK  clock selected as QSPI kernel peripheral clock */
        break;

      default:
        ret = HAL_ERROR;
 81027d6:	2301      	movs	r3, #1
 81027d8:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 81027dc:	e002      	b.n	81027e4 <HAL_RCCEx_PeriphCLKConfig+0x41c>
        break;
 81027de:	bf00      	nop
 81027e0:	e000      	b.n	81027e4 <HAL_RCCEx_PeriphCLKConfig+0x41c>
        break;
 81027e2:	bf00      	nop
    }

    if (ret == HAL_OK)
 81027e4:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81027e8:	2b00      	cmp	r3, #0
 81027ea:	d10a      	bne.n	8102802 <HAL_RCCEx_PeriphCLKConfig+0x43a>
    {
      /* Set the source of QSPI clock*/
      __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 81027ec:	4b68      	ldr	r3, [pc, #416]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81027ee:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 81027f0:	f023 0130 	bic.w	r1, r3, #48	@ 0x30
 81027f4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81027f8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 81027fa:	4a65      	ldr	r2, [pc, #404]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81027fc:	430b      	orrs	r3, r1
 81027fe:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8102800:	e003      	b.n	810280a <HAL_RCCEx_PeriphCLKConfig+0x442>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8102802:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102806:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
#endif  /*OCTOSPI*/

  /*---------------------------- SPI1/2/3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI123) == RCC_PERIPHCLK_SPI123)
 810280a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810280e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8102812:	f402 5380 	and.w	r3, r2, #4096	@ 0x1000
 8102816:	f8c7 30f0 	str.w	r3, [r7, #240]	@ 0xf0
 810281a:	2300      	movs	r3, #0
 810281c:	f8c7 30f4 	str.w	r3, [r7, #244]	@ 0xf4
 8102820:	e9d7 123c 	ldrd	r1, r2, [r7, #240]	@ 0xf0
 8102824:	460b      	mov	r3, r1
 8102826:	4313      	orrs	r3, r2
 8102828:	d051      	beq.n	81028ce <HAL_RCCEx_PeriphCLKConfig+0x506>
  {
    switch (PeriphClkInit->Spi123ClockSelection)
 810282a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810282e:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8102830:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8102834:	d035      	beq.n	81028a2 <HAL_RCCEx_PeriphCLKConfig+0x4da>
 8102836:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 810283a:	d82e      	bhi.n	810289a <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 810283c:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8102840:	d031      	beq.n	81028a6 <HAL_RCCEx_PeriphCLKConfig+0x4de>
 8102842:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8102846:	d828      	bhi.n	810289a <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 8102848:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 810284c:	d01a      	beq.n	8102884 <HAL_RCCEx_PeriphCLKConfig+0x4bc>
 810284e:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8102852:	d822      	bhi.n	810289a <HAL_RCCEx_PeriphCLKConfig+0x4d2>
 8102854:	2b00      	cmp	r3, #0
 8102856:	d003      	beq.n	8102860 <HAL_RCCEx_PeriphCLKConfig+0x498>
 8102858:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 810285c:	d007      	beq.n	810286e <HAL_RCCEx_PeriphCLKConfig+0x4a6>
 810285e:	e01c      	b.n	810289a <HAL_RCCEx_PeriphCLKConfig+0x4d2>
    {
      case RCC_SPI123CLKSOURCE_PLL:      /* PLL is used as clock source for SPI1/2/3 */
        /* Enable SPI Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8102860:	4b4b      	ldr	r3, [pc, #300]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8102862:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8102864:	4a4a      	ldr	r2, [pc, #296]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8102866:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 810286a:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 810286c:	e01c      	b.n	81028a8 <HAL_RCCEx_PeriphCLKConfig+0x4e0>

      case RCC_SPI123CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI1/2/3 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 810286e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102872:	3308      	adds	r3, #8
 8102874:	2100      	movs	r1, #0
 8102876:	4618      	mov	r0, r3
 8102878:	f000 ffb0 	bl	81037dc <RCCEx_PLL2_Config>
 810287c:	4603      	mov	r3, r0
 810287e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 8102882:	e011      	b.n	81028a8 <HAL_RCCEx_PeriphCLKConfig+0x4e0>

      case RCC_SPI123CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI1/2/3 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 8102884:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102888:	3328      	adds	r3, #40	@ 0x28
 810288a:	2100      	movs	r1, #0
 810288c:	4618      	mov	r0, r3
 810288e:	f001 f857 	bl	8103940 <RCCEx_PLL3_Config>
 8102892:	4603      	mov	r3, r0
 8102894:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;
 8102898:	e006      	b.n	81028a8 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        /* HSI, HSE, or CSI oscillator is used as source of SPI1/2/3 clock */
        /* SPI1/2/3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 810289a:	2301      	movs	r3, #1
 810289c:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 81028a0:	e002      	b.n	81028a8 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        break;
 81028a2:	bf00      	nop
 81028a4:	e000      	b.n	81028a8 <HAL_RCCEx_PeriphCLKConfig+0x4e0>
        break;
 81028a6:	bf00      	nop
    }

    if (ret == HAL_OK)
 81028a8:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81028ac:	2b00      	cmp	r3, #0
 81028ae:	d10a      	bne.n	81028c6 <HAL_RCCEx_PeriphCLKConfig+0x4fe>
    {
      /* Set the source of SPI1/2/3 clock*/
      __HAL_RCC_SPI123_CONFIG(PeriphClkInit->Spi123ClockSelection);
 81028b0:	4b37      	ldr	r3, [pc, #220]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81028b2:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 81028b4:	f423 41e0 	bic.w	r1, r3, #28672	@ 0x7000
 81028b8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81028bc:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 81028be:	4a34      	ldr	r2, [pc, #208]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 81028c0:	430b      	orrs	r3, r1
 81028c2:	6513      	str	r3, [r2, #80]	@ 0x50
 81028c4:	e003      	b.n	81028ce <HAL_RCCEx_PeriphCLKConfig+0x506>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81028c6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81028ca:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
 81028ce:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81028d2:	e9d3 2300 	ldrd	r2, r3, [r3]
 81028d6:	f402 5300 	and.w	r3, r2, #8192	@ 0x2000
 81028da:	f8c7 30e8 	str.w	r3, [r7, #232]	@ 0xe8
 81028de:	2300      	movs	r3, #0
 81028e0:	f8c7 30ec 	str.w	r3, [r7, #236]	@ 0xec
 81028e4:	e9d7 123a 	ldrd	r1, r2, [r7, #232]	@ 0xe8
 81028e8:	460b      	mov	r3, r1
 81028ea:	4313      	orrs	r3, r2
 81028ec:	d056      	beq.n	810299c <HAL_RCCEx_PeriphCLKConfig+0x5d4>
  {
    switch (PeriphClkInit->Spi45ClockSelection)
 81028ee:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81028f2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 81028f4:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 81028f8:	d033      	beq.n	8102962 <HAL_RCCEx_PeriphCLKConfig+0x59a>
 81028fa:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 81028fe:	d82c      	bhi.n	810295a <HAL_RCCEx_PeriphCLKConfig+0x592>
 8102900:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 8102904:	d02f      	beq.n	8102966 <HAL_RCCEx_PeriphCLKConfig+0x59e>
 8102906:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
 810290a:	d826      	bhi.n	810295a <HAL_RCCEx_PeriphCLKConfig+0x592>
 810290c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8102910:	d02b      	beq.n	810296a <HAL_RCCEx_PeriphCLKConfig+0x5a2>
 8102912:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
 8102916:	d820      	bhi.n	810295a <HAL_RCCEx_PeriphCLKConfig+0x592>
 8102918:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 810291c:	d012      	beq.n	8102944 <HAL_RCCEx_PeriphCLKConfig+0x57c>
 810291e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 8102922:	d81a      	bhi.n	810295a <HAL_RCCEx_PeriphCLKConfig+0x592>
 8102924:	2b00      	cmp	r3, #0
 8102926:	d022      	beq.n	810296e <HAL_RCCEx_PeriphCLKConfig+0x5a6>
 8102928:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 810292c:	d115      	bne.n	810295a <HAL_RCCEx_PeriphCLKConfig+0x592>
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI45CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI4/5 */

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 810292e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102932:	3308      	adds	r3, #8
 8102934:	2101      	movs	r1, #1
 8102936:	4618      	mov	r0, r3
 8102938:	f000 ff50 	bl	81037dc <RCCEx_PLL2_Config>
 810293c:	4603      	mov	r3, r0
 810293e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPI4/5 clock source configuration done later after clock selection check */
        break;
 8102942:	e015      	b.n	8102970 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
      case RCC_SPI45CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI4/5 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8102944:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102948:	3328      	adds	r3, #40	@ 0x28
 810294a:	2101      	movs	r1, #1
 810294c:	4618      	mov	r0, r3
 810294e:	f000 fff7 	bl	8103940 <RCCEx_PLL3_Config>
 8102952:	4603      	mov	r3, r0
 8102954:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;
 8102958:	e00a      	b.n	8102970 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        /* HSE,  oscillator is used as source of SPI4/5 clock */
        /* SPI4/5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 810295a:	2301      	movs	r3, #1
 810295c:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8102960:	e006      	b.n	8102970 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 8102962:	bf00      	nop
 8102964:	e004      	b.n	8102970 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 8102966:	bf00      	nop
 8102968:	e002      	b.n	8102970 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 810296a:	bf00      	nop
 810296c:	e000      	b.n	8102970 <HAL_RCCEx_PeriphCLKConfig+0x5a8>
        break;
 810296e:	bf00      	nop
    }

    if (ret == HAL_OK)
 8102970:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102974:	2b00      	cmp	r3, #0
 8102976:	d10d      	bne.n	8102994 <HAL_RCCEx_PeriphCLKConfig+0x5cc>
    {
      /* Set the source of SPI4/5 clock*/
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
 8102978:	4b05      	ldr	r3, [pc, #20]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 810297a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 810297c:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
 8102980:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102984:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8102986:	4a02      	ldr	r2, [pc, #8]	@ (8102990 <HAL_RCCEx_PeriphCLKConfig+0x5c8>)
 8102988:	430b      	orrs	r3, r1
 810298a:	6513      	str	r3, [r2, #80]	@ 0x50
 810298c:	e006      	b.n	810299c <HAL_RCCEx_PeriphCLKConfig+0x5d4>
 810298e:	bf00      	nop
 8102990:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 8102994:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102998:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- SPI6 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
 810299c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81029a0:	e9d3 2300 	ldrd	r2, r3, [r3]
 81029a4:	f402 4380 	and.w	r3, r2, #16384	@ 0x4000
 81029a8:	f8c7 30e0 	str.w	r3, [r7, #224]	@ 0xe0
 81029ac:	2300      	movs	r3, #0
 81029ae:	f8c7 30e4 	str.w	r3, [r7, #228]	@ 0xe4
 81029b2:	e9d7 1238 	ldrd	r1, r2, [r7, #224]	@ 0xe0
 81029b6:	460b      	mov	r3, r1
 81029b8:	4313      	orrs	r3, r2
 81029ba:	d055      	beq.n	8102a68 <HAL_RCCEx_PeriphCLKConfig+0x6a0>
  {
    switch (PeriphClkInit->Spi6ClockSelection)
 81029bc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81029c0:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 81029c4:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 81029c8:	d033      	beq.n	8102a32 <HAL_RCCEx_PeriphCLKConfig+0x66a>
 81029ca:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 81029ce:	d82c      	bhi.n	8102a2a <HAL_RCCEx_PeriphCLKConfig+0x662>
 81029d0:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 81029d4:	d02f      	beq.n	8102a36 <HAL_RCCEx_PeriphCLKConfig+0x66e>
 81029d6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 81029da:	d826      	bhi.n	8102a2a <HAL_RCCEx_PeriphCLKConfig+0x662>
 81029dc:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 81029e0:	d02b      	beq.n	8102a3a <HAL_RCCEx_PeriphCLKConfig+0x672>
 81029e2:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 81029e6:	d820      	bhi.n	8102a2a <HAL_RCCEx_PeriphCLKConfig+0x662>
 81029e8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 81029ec:	d012      	beq.n	8102a14 <HAL_RCCEx_PeriphCLKConfig+0x64c>
 81029ee:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 81029f2:	d81a      	bhi.n	8102a2a <HAL_RCCEx_PeriphCLKConfig+0x662>
 81029f4:	2b00      	cmp	r3, #0
 81029f6:	d022      	beq.n	8102a3e <HAL_RCCEx_PeriphCLKConfig+0x676>
 81029f8:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 81029fc:	d115      	bne.n	8102a2a <HAL_RCCEx_PeriphCLKConfig+0x662>
        /* SPI6 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI6CLKSOURCE_PLL2: /* PLL2 is used as clock source for SPI6*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 81029fe:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102a02:	3308      	adds	r3, #8
 8102a04:	2101      	movs	r1, #1
 8102a06:	4618      	mov	r0, r3
 8102a08:	f000 fee8 	bl	81037dc <RCCEx_PLL2_Config>
 8102a0c:	4603      	mov	r3, r0
 8102a0e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SPI6 clock source configuration done later after clock selection check */
        break;
 8102a12:	e015      	b.n	8102a40 <HAL_RCCEx_PeriphCLKConfig+0x678>
      case RCC_SPI6CLKSOURCE_PLL3:  /* PLL3 is used as clock source for SPI6*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8102a14:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102a18:	3328      	adds	r3, #40	@ 0x28
 8102a1a:	2101      	movs	r1, #1
 8102a1c:	4618      	mov	r0, r3
 8102a1e:	f000 ff8f 	bl	8103940 <RCCEx_PLL3_Config>
 8102a22:	4603      	mov	r3, r0
 8102a24:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* SPI6 clock source configuration done later after clock selection check */
        break;
 8102a28:	e00a      	b.n	8102a40 <HAL_RCCEx_PeriphCLKConfig+0x678>
        /* SPI6 clock source configuration done later after clock selection check */
        break;
#endif

      default:
        ret = HAL_ERROR;
 8102a2a:	2301      	movs	r3, #1
 8102a2c:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8102a30:	e006      	b.n	8102a40 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 8102a32:	bf00      	nop
 8102a34:	e004      	b.n	8102a40 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 8102a36:	bf00      	nop
 8102a38:	e002      	b.n	8102a40 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 8102a3a:	bf00      	nop
 8102a3c:	e000      	b.n	8102a40 <HAL_RCCEx_PeriphCLKConfig+0x678>
        break;
 8102a3e:	bf00      	nop
    }

    if (ret == HAL_OK)
 8102a40:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102a44:	2b00      	cmp	r3, #0
 8102a46:	d10b      	bne.n	8102a60 <HAL_RCCEx_PeriphCLKConfig+0x698>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
 8102a48:	4ba4      	ldr	r3, [pc, #656]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102a4a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8102a4c:	f023 41e0 	bic.w	r1, r3, #1879048192	@ 0x70000000
 8102a50:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102a54:	f8d3 30b0 	ldr.w	r3, [r3, #176]	@ 0xb0
 8102a58:	4aa0      	ldr	r2, [pc, #640]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102a5a:	430b      	orrs	r3, r1
 8102a5c:	6593      	str	r3, [r2, #88]	@ 0x58
 8102a5e:	e003      	b.n	8102a68 <HAL_RCCEx_PeriphCLKConfig+0x6a0>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8102a60:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102a64:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
  }
#endif /*DSI*/

#if defined(FDCAN1) || defined(FDCAN2)
  /*---------------------------- FDCAN configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 8102a68:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102a6c:	e9d3 2300 	ldrd	r2, r3, [r3]
 8102a70:	f402 4300 	and.w	r3, r2, #32768	@ 0x8000
 8102a74:	f8c7 30d8 	str.w	r3, [r7, #216]	@ 0xd8
 8102a78:	2300      	movs	r3, #0
 8102a7a:	f8c7 30dc 	str.w	r3, [r7, #220]	@ 0xdc
 8102a7e:	e9d7 1236 	ldrd	r1, r2, [r7, #216]	@ 0xd8
 8102a82:	460b      	mov	r3, r1
 8102a84:	4313      	orrs	r3, r2
 8102a86:	d037      	beq.n	8102af8 <HAL_RCCEx_PeriphCLKConfig+0x730>
  {
    switch (PeriphClkInit->FdcanClockSelection)
 8102a88:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102a8c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8102a8e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8102a92:	d00e      	beq.n	8102ab2 <HAL_RCCEx_PeriphCLKConfig+0x6ea>
 8102a94:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8102a98:	d816      	bhi.n	8102ac8 <HAL_RCCEx_PeriphCLKConfig+0x700>
 8102a9a:	2b00      	cmp	r3, #0
 8102a9c:	d018      	beq.n	8102ad0 <HAL_RCCEx_PeriphCLKConfig+0x708>
 8102a9e:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8102aa2:	d111      	bne.n	8102ac8 <HAL_RCCEx_PeriphCLKConfig+0x700>
    {
      case RCC_FDCANCLKSOURCE_PLL:      /* PLL is used as clock source for FDCAN*/
        /* Enable FDCAN Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8102aa4:	4b8d      	ldr	r3, [pc, #564]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102aa6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8102aa8:	4a8c      	ldr	r2, [pc, #560]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102aaa:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8102aae:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* FDCAN clock source configuration done later after clock selection check */
        break;
 8102ab0:	e00f      	b.n	8102ad2 <HAL_RCCEx_PeriphCLKConfig+0x70a>

      case RCC_FDCANCLKSOURCE_PLL2: /* PLL2 is used as clock source for FDCAN*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8102ab2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102ab6:	3308      	adds	r3, #8
 8102ab8:	2101      	movs	r1, #1
 8102aba:	4618      	mov	r0, r3
 8102abc:	f000 fe8e 	bl	81037dc <RCCEx_PLL2_Config>
 8102ac0:	4603      	mov	r3, r0
 8102ac2:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* FDCAN clock source configuration done later after clock selection check */
        break;
 8102ac6:	e004      	b.n	8102ad2 <HAL_RCCEx_PeriphCLKConfig+0x70a>
        /* HSE is used as clock source for FDCAN*/
        /* FDCAN clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8102ac8:	2301      	movs	r3, #1
 8102aca:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8102ace:	e000      	b.n	8102ad2 <HAL_RCCEx_PeriphCLKConfig+0x70a>
        break;
 8102ad0:	bf00      	nop
    }

    if (ret == HAL_OK)
 8102ad2:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102ad6:	2b00      	cmp	r3, #0
 8102ad8:	d10a      	bne.n	8102af0 <HAL_RCCEx_PeriphCLKConfig+0x728>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 8102ada:	4b80      	ldr	r3, [pc, #512]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102adc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8102ade:	f023 5140 	bic.w	r1, r3, #805306368	@ 0x30000000
 8102ae2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102ae6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8102ae8:	4a7c      	ldr	r2, [pc, #496]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102aea:	430b      	orrs	r3, r1
 8102aec:	6513      	str	r3, [r2, #80]	@ 0x50
 8102aee:	e003      	b.n	8102af8 <HAL_RCCEx_PeriphCLKConfig+0x730>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8102af0:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102af4:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
#endif /*FDCAN1 || FDCAN2*/

  /*---------------------------- FMC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
 8102af8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102afc:	e9d3 2300 	ldrd	r2, r3, [r3]
 8102b00:	f002 7380 	and.w	r3, r2, #16777216	@ 0x1000000
 8102b04:	f8c7 30d0 	str.w	r3, [r7, #208]	@ 0xd0
 8102b08:	2300      	movs	r3, #0
 8102b0a:	f8c7 30d4 	str.w	r3, [r7, #212]	@ 0xd4
 8102b0e:	e9d7 1234 	ldrd	r1, r2, [r7, #208]	@ 0xd0
 8102b12:	460b      	mov	r3, r1
 8102b14:	4313      	orrs	r3, r2
 8102b16:	d039      	beq.n	8102b8c <HAL_RCCEx_PeriphCLKConfig+0x7c4>
  {
    switch (PeriphClkInit->FmcClockSelection)
 8102b18:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102b1c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8102b1e:	2b03      	cmp	r3, #3
 8102b20:	d81c      	bhi.n	8102b5c <HAL_RCCEx_PeriphCLKConfig+0x794>
 8102b22:	a201      	add	r2, pc, #4	@ (adr r2, 8102b28 <HAL_RCCEx_PeriphCLKConfig+0x760>)
 8102b24:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8102b28:	08102b65 	.word	0x08102b65
 8102b2c:	08102b39 	.word	0x08102b39
 8102b30:	08102b47 	.word	0x08102b47
 8102b34:	08102b65 	.word	0x08102b65
    {
      case RCC_FMCCLKSOURCE_PLL:      /* PLL is used as clock source for FMC*/
        /* Enable FMC Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8102b38:	4b68      	ldr	r3, [pc, #416]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102b3a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8102b3c:	4a67      	ldr	r2, [pc, #412]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102b3e:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8102b42:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* FMC clock source configuration done later after clock selection check */
        break;
 8102b44:	e00f      	b.n	8102b66 <HAL_RCCEx_PeriphCLKConfig+0x79e>

      case RCC_FMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for FMC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 8102b46:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102b4a:	3308      	adds	r3, #8
 8102b4c:	2102      	movs	r1, #2
 8102b4e:	4618      	mov	r0, r3
 8102b50:	f000 fe44 	bl	81037dc <RCCEx_PLL2_Config>
 8102b54:	4603      	mov	r3, r0
 8102b56:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* FMC clock source configuration done later after clock selection check */
        break;
 8102b5a:	e004      	b.n	8102b66 <HAL_RCCEx_PeriphCLKConfig+0x79e>
      case RCC_FMCCLKSOURCE_HCLK:
        /* D1/CD HCLK  clock selected as FMC kernel peripheral clock */
        break;

      default:
        ret = HAL_ERROR;
 8102b5c:	2301      	movs	r3, #1
 8102b5e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8102b62:	e000      	b.n	8102b66 <HAL_RCCEx_PeriphCLKConfig+0x79e>
        break;
 8102b64:	bf00      	nop
    }

    if (ret == HAL_OK)
 8102b66:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102b6a:	2b00      	cmp	r3, #0
 8102b6c:	d10a      	bne.n	8102b84 <HAL_RCCEx_PeriphCLKConfig+0x7bc>
    {
      /* Set the source of FMC clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
 8102b6e:	4b5b      	ldr	r3, [pc, #364]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102b70:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8102b72:	f023 0103 	bic.w	r1, r3, #3
 8102b76:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102b7a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8102b7c:	4a57      	ldr	r2, [pc, #348]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102b7e:	430b      	orrs	r3, r1
 8102b80:	64d3      	str	r3, [r2, #76]	@ 0x4c
 8102b82:	e003      	b.n	8102b8c <HAL_RCCEx_PeriphCLKConfig+0x7c4>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8102b84:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102b88:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- RTC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8102b8c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102b90:	e9d3 2300 	ldrd	r2, r3, [r3]
 8102b94:	f402 0380 	and.w	r3, r2, #4194304	@ 0x400000
 8102b98:	f8c7 30c8 	str.w	r3, [r7, #200]	@ 0xc8
 8102b9c:	2300      	movs	r3, #0
 8102b9e:	f8c7 30cc 	str.w	r3, [r7, #204]	@ 0xcc
 8102ba2:	e9d7 1232 	ldrd	r1, r2, [r7, #200]	@ 0xc8
 8102ba6:	460b      	mov	r3, r1
 8102ba8:	4313      	orrs	r3, r2
 8102baa:	f000 809f 	beq.w	8102cec <HAL_RCCEx_PeriphCLKConfig+0x924>
  {
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8102bae:	4b4c      	ldr	r3, [pc, #304]	@ (8102ce0 <HAL_RCCEx_PeriphCLKConfig+0x918>)
 8102bb0:	681b      	ldr	r3, [r3, #0]
 8102bb2:	4a4b      	ldr	r2, [pc, #300]	@ (8102ce0 <HAL_RCCEx_PeriphCLKConfig+0x918>)
 8102bb4:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8102bb8:	6013      	str	r3, [r2, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 8102bba:	f7fe fe09 	bl	81017d0 <HAL_GetTick>
 8102bbe:	f8c7 0120 	str.w	r0, [r7, #288]	@ 0x120

    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8102bc2:	e00b      	b.n	8102bdc <HAL_RCCEx_PeriphCLKConfig+0x814>
    {
      if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8102bc4:	f7fe fe04 	bl	81017d0 <HAL_GetTick>
 8102bc8:	4602      	mov	r2, r0
 8102bca:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8102bce:	1ad3      	subs	r3, r2, r3
 8102bd0:	2b64      	cmp	r3, #100	@ 0x64
 8102bd2:	d903      	bls.n	8102bdc <HAL_RCCEx_PeriphCLKConfig+0x814>
      {
        ret = HAL_TIMEOUT;
 8102bd4:	2303      	movs	r3, #3
 8102bd6:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8102bda:	e005      	b.n	8102be8 <HAL_RCCEx_PeriphCLKConfig+0x820>
    while ((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8102bdc:	4b40      	ldr	r3, [pc, #256]	@ (8102ce0 <HAL_RCCEx_PeriphCLKConfig+0x918>)
 8102bde:	681b      	ldr	r3, [r3, #0]
 8102be0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8102be4:	2b00      	cmp	r3, #0
 8102be6:	d0ed      	beq.n	8102bc4 <HAL_RCCEx_PeriphCLKConfig+0x7fc>
      }
    }

    if (ret == HAL_OK)
 8102be8:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102bec:	2b00      	cmp	r3, #0
 8102bee:	d179      	bne.n	8102ce4 <HAL_RCCEx_PeriphCLKConfig+0x91c>
    {
      /* Reset the Backup domain only if the RTC Clock source selection is modified */
      if ((RCC->BDCR & RCC_BDCR_RTCSEL) != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL))
 8102bf0:	4b3a      	ldr	r3, [pc, #232]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102bf2:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
 8102bf4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102bf8:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8102bfc:	4053      	eors	r3, r2
 8102bfe:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8102c02:	2b00      	cmp	r3, #0
 8102c04:	d015      	beq.n	8102c32 <HAL_RCCEx_PeriphCLKConfig+0x86a>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpreg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8102c06:	4b35      	ldr	r3, [pc, #212]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102c08:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8102c0a:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8102c0e:	f8c7 311c 	str.w	r3, [r7, #284]	@ 0x11c
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 8102c12:	4b32      	ldr	r3, [pc, #200]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102c14:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8102c16:	4a31      	ldr	r2, [pc, #196]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102c18:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8102c1c:	6713      	str	r3, [r2, #112]	@ 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
 8102c1e:	4b2f      	ldr	r3, [pc, #188]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102c20:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8102c22:	4a2e      	ldr	r2, [pc, #184]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102c24:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8102c28:	6713      	str	r3, [r2, #112]	@ 0x70
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpreg;
 8102c2a:	4a2c      	ldr	r2, [pc, #176]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102c2c:	f8d7 311c 	ldr.w	r3, [r7, #284]	@ 0x11c
 8102c30:	6713      	str	r3, [r2, #112]	@ 0x70
      }

      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
 8102c32:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102c36:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8102c3a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8102c3e:	d118      	bne.n	8102c72 <HAL_RCCEx_PeriphCLKConfig+0x8aa>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8102c40:	f7fe fdc6 	bl	81017d0 <HAL_GetTick>
 8102c44:	f8c7 0120 	str.w	r0, [r7, #288]	@ 0x120

        /* Wait till LSE is ready */
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8102c48:	e00d      	b.n	8102c66 <HAL_RCCEx_PeriphCLKConfig+0x89e>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8102c4a:	f7fe fdc1 	bl	81017d0 <HAL_GetTick>
 8102c4e:	4602      	mov	r2, r0
 8102c50:	f8d7 3120 	ldr.w	r3, [r7, #288]	@ 0x120
 8102c54:	1ad2      	subs	r2, r2, r3
 8102c56:	f241 3388 	movw	r3, #5000	@ 0x1388
 8102c5a:	429a      	cmp	r2, r3
 8102c5c:	d903      	bls.n	8102c66 <HAL_RCCEx_PeriphCLKConfig+0x89e>
          {
            ret = HAL_TIMEOUT;
 8102c5e:	2303      	movs	r3, #3
 8102c60:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
            break;
 8102c64:	e005      	b.n	8102c72 <HAL_RCCEx_PeriphCLKConfig+0x8aa>
        while (__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8102c66:	4b1d      	ldr	r3, [pc, #116]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102c68:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 8102c6a:	f003 0302 	and.w	r3, r3, #2
 8102c6e:	2b00      	cmp	r3, #0
 8102c70:	d0eb      	beq.n	8102c4a <HAL_RCCEx_PeriphCLKConfig+0x882>
          }
        }
      }

      if (ret == HAL_OK)
 8102c72:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102c76:	2b00      	cmp	r3, #0
 8102c78:	d12b      	bne.n	8102cd2 <HAL_RCCEx_PeriphCLKConfig+0x90a>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8102c7a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102c7e:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8102c82:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 8102c86:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 8102c8a:	d110      	bne.n	8102cae <HAL_RCCEx_PeriphCLKConfig+0x8e6>
 8102c8c:	4b13      	ldr	r3, [pc, #76]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102c8e:	691b      	ldr	r3, [r3, #16]
 8102c90:	f423 517c 	bic.w	r1, r3, #16128	@ 0x3f00
 8102c94:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102c98:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8102c9c:	091b      	lsrs	r3, r3, #4
 8102c9e:	f023 437f 	bic.w	r3, r3, #4278190080	@ 0xff000000
 8102ca2:	f023 0330 	bic.w	r3, r3, #48	@ 0x30
 8102ca6:	4a0d      	ldr	r2, [pc, #52]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102ca8:	430b      	orrs	r3, r1
 8102caa:	6113      	str	r3, [r2, #16]
 8102cac:	e005      	b.n	8102cba <HAL_RCCEx_PeriphCLKConfig+0x8f2>
 8102cae:	4b0b      	ldr	r3, [pc, #44]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102cb0:	691b      	ldr	r3, [r3, #16]
 8102cb2:	4a0a      	ldr	r2, [pc, #40]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102cb4:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 8102cb8:	6113      	str	r3, [r2, #16]
 8102cba:	4b08      	ldr	r3, [pc, #32]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102cbc:	6f19      	ldr	r1, [r3, #112]	@ 0x70
 8102cbe:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102cc2:	f8d3 30b4 	ldr.w	r3, [r3, #180]	@ 0xb4
 8102cc6:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8102cca:	4a04      	ldr	r2, [pc, #16]	@ (8102cdc <HAL_RCCEx_PeriphCLKConfig+0x914>)
 8102ccc:	430b      	orrs	r3, r1
 8102cce:	6713      	str	r3, [r2, #112]	@ 0x70
 8102cd0:	e00c      	b.n	8102cec <HAL_RCCEx_PeriphCLKConfig+0x924>
      }
      else
      {
        /* set overall return value */
        status = ret;
 8102cd2:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102cd6:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
 8102cda:	e007      	b.n	8102cec <HAL_RCCEx_PeriphCLKConfig+0x924>
 8102cdc:	58024400 	.word	0x58024400
 8102ce0:	58024800 	.word	0x58024800
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
 8102ce4:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102ce8:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }


  /*-------------------------- USART1/6 configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART16) == RCC_PERIPHCLK_USART16)
 8102cec:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102cf0:	e9d3 2300 	ldrd	r2, r3, [r3]
 8102cf4:	f002 0301 	and.w	r3, r2, #1
 8102cf8:	f8c7 30c0 	str.w	r3, [r7, #192]	@ 0xc0
 8102cfc:	2300      	movs	r3, #0
 8102cfe:	f8c7 30c4 	str.w	r3, [r7, #196]	@ 0xc4
 8102d02:	e9d7 1230 	ldrd	r1, r2, [r7, #192]	@ 0xc0
 8102d06:	460b      	mov	r3, r1
 8102d08:	4313      	orrs	r3, r2
 8102d0a:	f000 8089 	beq.w	8102e20 <HAL_RCCEx_PeriphCLKConfig+0xa58>
  {
    switch (PeriphClkInit->Usart16ClockSelection)
 8102d0e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102d12:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 8102d14:	2b28      	cmp	r3, #40	@ 0x28
 8102d16:	d86b      	bhi.n	8102df0 <HAL_RCCEx_PeriphCLKConfig+0xa28>
 8102d18:	a201      	add	r2, pc, #4	@ (adr r2, 8102d20 <HAL_RCCEx_PeriphCLKConfig+0x958>)
 8102d1a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8102d1e:	bf00      	nop
 8102d20:	08102df9 	.word	0x08102df9
 8102d24:	08102df1 	.word	0x08102df1
 8102d28:	08102df1 	.word	0x08102df1
 8102d2c:	08102df1 	.word	0x08102df1
 8102d30:	08102df1 	.word	0x08102df1
 8102d34:	08102df1 	.word	0x08102df1
 8102d38:	08102df1 	.word	0x08102df1
 8102d3c:	08102df1 	.word	0x08102df1
 8102d40:	08102dc5 	.word	0x08102dc5
 8102d44:	08102df1 	.word	0x08102df1
 8102d48:	08102df1 	.word	0x08102df1
 8102d4c:	08102df1 	.word	0x08102df1
 8102d50:	08102df1 	.word	0x08102df1
 8102d54:	08102df1 	.word	0x08102df1
 8102d58:	08102df1 	.word	0x08102df1
 8102d5c:	08102df1 	.word	0x08102df1
 8102d60:	08102ddb 	.word	0x08102ddb
 8102d64:	08102df1 	.word	0x08102df1
 8102d68:	08102df1 	.word	0x08102df1
 8102d6c:	08102df1 	.word	0x08102df1
 8102d70:	08102df1 	.word	0x08102df1
 8102d74:	08102df1 	.word	0x08102df1
 8102d78:	08102df1 	.word	0x08102df1
 8102d7c:	08102df1 	.word	0x08102df1
 8102d80:	08102df9 	.word	0x08102df9
 8102d84:	08102df1 	.word	0x08102df1
 8102d88:	08102df1 	.word	0x08102df1
 8102d8c:	08102df1 	.word	0x08102df1
 8102d90:	08102df1 	.word	0x08102df1
 8102d94:	08102df1 	.word	0x08102df1
 8102d98:	08102df1 	.word	0x08102df1
 8102d9c:	08102df1 	.word	0x08102df1
 8102da0:	08102df9 	.word	0x08102df9
 8102da4:	08102df1 	.word	0x08102df1
 8102da8:	08102df1 	.word	0x08102df1
 8102dac:	08102df1 	.word	0x08102df1
 8102db0:	08102df1 	.word	0x08102df1
 8102db4:	08102df1 	.word	0x08102df1
 8102db8:	08102df1 	.word	0x08102df1
 8102dbc:	08102df1 	.word	0x08102df1
 8102dc0:	08102df9 	.word	0x08102df9
      case RCC_USART16CLKSOURCE_PCLK2: /* CD/D2 PCLK2 as clock source for USART1/6 */
        /* USART1/6 clock source configuration done later after clock selection check */
        break;

      case RCC_USART16CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART1/6 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8102dc4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102dc8:	3308      	adds	r3, #8
 8102dca:	2101      	movs	r1, #1
 8102dcc:	4618      	mov	r0, r3
 8102dce:	f000 fd05 	bl	81037dc <RCCEx_PLL2_Config>
 8102dd2:	4603      	mov	r3, r0
 8102dd4:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* USART1/6 clock source configuration done later after clock selection check */
        break;
 8102dd8:	e00f      	b.n	8102dfa <HAL_RCCEx_PeriphCLKConfig+0xa32>

      case RCC_USART16CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART1/6 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8102dda:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102dde:	3328      	adds	r3, #40	@ 0x28
 8102de0:	2101      	movs	r1, #1
 8102de2:	4618      	mov	r0, r3
 8102de4:	f000 fdac 	bl	8103940 <RCCEx_PLL3_Config>
 8102de8:	4603      	mov	r3, r0
 8102dea:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* USART1/6 clock source configuration done later after clock selection check */
        break;
 8102dee:	e004      	b.n	8102dfa <HAL_RCCEx_PeriphCLKConfig+0xa32>
        /* LSE,  oscillator is used as source of USART1/6 clock */
        /* USART1/6 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8102df0:	2301      	movs	r3, #1
 8102df2:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8102df6:	e000      	b.n	8102dfa <HAL_RCCEx_PeriphCLKConfig+0xa32>
        break;
 8102df8:	bf00      	nop
    }

    if (ret == HAL_OK)
 8102dfa:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102dfe:	2b00      	cmp	r3, #0
 8102e00:	d10a      	bne.n	8102e18 <HAL_RCCEx_PeriphCLKConfig+0xa50>
    {
      /* Set the source of USART1/6 clock */
      __HAL_RCC_USART16_CONFIG(PeriphClkInit->Usart16ClockSelection);
 8102e02:	4bbf      	ldr	r3, [pc, #764]	@ (8103100 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8102e04:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8102e06:	f023 0138 	bic.w	r1, r3, #56	@ 0x38
 8102e0a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102e0e:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
 8102e10:	4abb      	ldr	r2, [pc, #748]	@ (8103100 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8102e12:	430b      	orrs	r3, r1
 8102e14:	6553      	str	r3, [r2, #84]	@ 0x54
 8102e16:	e003      	b.n	8102e20 <HAL_RCCEx_PeriphCLKConfig+0xa58>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8102e18:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102e1c:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*-------------------------- USART2/3/4/5/7/8 Configuration --------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
 8102e20:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102e24:	e9d3 2300 	ldrd	r2, r3, [r3]
 8102e28:	f002 0302 	and.w	r3, r2, #2
 8102e2c:	f8c7 30b8 	str.w	r3, [r7, #184]	@ 0xb8
 8102e30:	2300      	movs	r3, #0
 8102e32:	f8c7 30bc 	str.w	r3, [r7, #188]	@ 0xbc
 8102e36:	e9d7 122e 	ldrd	r1, r2, [r7, #184]	@ 0xb8
 8102e3a:	460b      	mov	r3, r1
 8102e3c:	4313      	orrs	r3, r2
 8102e3e:	d041      	beq.n	8102ec4 <HAL_RCCEx_PeriphCLKConfig+0xafc>
  {
    switch (PeriphClkInit->Usart234578ClockSelection)
 8102e40:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102e44:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8102e46:	2b05      	cmp	r3, #5
 8102e48:	d824      	bhi.n	8102e94 <HAL_RCCEx_PeriphCLKConfig+0xacc>
 8102e4a:	a201      	add	r2, pc, #4	@ (adr r2, 8102e50 <HAL_RCCEx_PeriphCLKConfig+0xa88>)
 8102e4c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8102e50:	08102e9d 	.word	0x08102e9d
 8102e54:	08102e69 	.word	0x08102e69
 8102e58:	08102e7f 	.word	0x08102e7f
 8102e5c:	08102e9d 	.word	0x08102e9d
 8102e60:	08102e9d 	.word	0x08102e9d
 8102e64:	08102e9d 	.word	0x08102e9d
      case RCC_USART234578CLKSOURCE_PCLK1: /* CD/D2 PCLK1 as clock source for USART2/3/4/5/7/8 */
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;

      case RCC_USART234578CLKSOURCE_PLL2: /* PLL2 is used as clock source for USART2/3/4/5/7/8 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8102e68:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102e6c:	3308      	adds	r3, #8
 8102e6e:	2101      	movs	r1, #1
 8102e70:	4618      	mov	r0, r3
 8102e72:	f000 fcb3 	bl	81037dc <RCCEx_PLL2_Config>
 8102e76:	4603      	mov	r3, r0
 8102e78:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;
 8102e7c:	e00f      	b.n	8102e9e <HAL_RCCEx_PeriphCLKConfig+0xad6>

      case RCC_USART234578CLKSOURCE_PLL3: /* PLL3 is used as clock source for USART2/3/4/5/7/8 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8102e7e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102e82:	3328      	adds	r3, #40	@ 0x28
 8102e84:	2101      	movs	r1, #1
 8102e86:	4618      	mov	r0, r3
 8102e88:	f000 fd5a 	bl	8103940 <RCCEx_PLL3_Config>
 8102e8c:	4603      	mov	r3, r0
 8102e8e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;
 8102e92:	e004      	b.n	8102e9e <HAL_RCCEx_PeriphCLKConfig+0xad6>
        /* LSE,  oscillator is used as source of USART2/3/4/5/7/8 clock */
        /* USART2/3/4/5/7/8 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8102e94:	2301      	movs	r3, #1
 8102e96:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8102e9a:	e000      	b.n	8102e9e <HAL_RCCEx_PeriphCLKConfig+0xad6>
        break;
 8102e9c:	bf00      	nop
    }

    if (ret == HAL_OK)
 8102e9e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102ea2:	2b00      	cmp	r3, #0
 8102ea4:	d10a      	bne.n	8102ebc <HAL_RCCEx_PeriphCLKConfig+0xaf4>
    {
      /* Set the source of USART2/3/4/5/7/8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
 8102ea6:	4b96      	ldr	r3, [pc, #600]	@ (8103100 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8102ea8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8102eaa:	f023 0107 	bic.w	r1, r3, #7
 8102eae:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102eb2:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
 8102eb4:	4a92      	ldr	r2, [pc, #584]	@ (8103100 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8102eb6:	430b      	orrs	r3, r1
 8102eb8:	6553      	str	r3, [r2, #84]	@ 0x54
 8102eba:	e003      	b.n	8102ec4 <HAL_RCCEx_PeriphCLKConfig+0xafc>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8102ebc:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102ec0:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8102ec4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102ec8:	e9d3 2300 	ldrd	r2, r3, [r3]
 8102ecc:	f002 0304 	and.w	r3, r2, #4
 8102ed0:	f8c7 30b0 	str.w	r3, [r7, #176]	@ 0xb0
 8102ed4:	2300      	movs	r3, #0
 8102ed6:	f8c7 30b4 	str.w	r3, [r7, #180]	@ 0xb4
 8102eda:	e9d7 122c 	ldrd	r1, r2, [r7, #176]	@ 0xb0
 8102ede:	460b      	mov	r3, r1
 8102ee0:	4313      	orrs	r3, r2
 8102ee2:	d044      	beq.n	8102f6e <HAL_RCCEx_PeriphCLKConfig+0xba6>
  {
    switch (PeriphClkInit->Lpuart1ClockSelection)
 8102ee4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102ee8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8102eec:	2b05      	cmp	r3, #5
 8102eee:	d825      	bhi.n	8102f3c <HAL_RCCEx_PeriphCLKConfig+0xb74>
 8102ef0:	a201      	add	r2, pc, #4	@ (adr r2, 8102ef8 <HAL_RCCEx_PeriphCLKConfig+0xb30>)
 8102ef2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8102ef6:	bf00      	nop
 8102ef8:	08102f45 	.word	0x08102f45
 8102efc:	08102f11 	.word	0x08102f11
 8102f00:	08102f27 	.word	0x08102f27
 8102f04:	08102f45 	.word	0x08102f45
 8102f08:	08102f45 	.word	0x08102f45
 8102f0c:	08102f45 	.word	0x08102f45
      case RCC_LPUART1CLKSOURCE_PCLK4: /* SRD/D3 PCLK1 (PCLK4) as clock source for LPUART1 */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPUART1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPUART1 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 8102f10:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102f14:	3308      	adds	r3, #8
 8102f16:	2101      	movs	r1, #1
 8102f18:	4618      	mov	r0, r3
 8102f1a:	f000 fc5f 	bl	81037dc <RCCEx_PLL2_Config>
 8102f1e:	4603      	mov	r3, r0
 8102f20:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
 8102f24:	e00f      	b.n	8102f46 <HAL_RCCEx_PeriphCLKConfig+0xb7e>

      case RCC_LPUART1CLKSOURCE_PLL3: /* PLL3 is used as clock source for LPUART1 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 8102f26:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102f2a:	3328      	adds	r3, #40	@ 0x28
 8102f2c:	2101      	movs	r1, #1
 8102f2e:	4618      	mov	r0, r3
 8102f30:	f000 fd06 	bl	8103940 <RCCEx_PLL3_Config>
 8102f34:	4603      	mov	r3, r0
 8102f36:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
 8102f3a:	e004      	b.n	8102f46 <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        /* LSE,  oscillator is used as source of LPUART1 clock */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8102f3c:	2301      	movs	r3, #1
 8102f3e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8102f42:	e000      	b.n	8102f46 <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
 8102f44:	bf00      	nop
    }

    if (ret == HAL_OK)
 8102f46:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102f4a:	2b00      	cmp	r3, #0
 8102f4c:	d10b      	bne.n	8102f66 <HAL_RCCEx_PeriphCLKConfig+0xb9e>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8102f4e:	4b6c      	ldr	r3, [pc, #432]	@ (8103100 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8102f50:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8102f52:	f023 0107 	bic.w	r1, r3, #7
 8102f56:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102f5a:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
 8102f5e:	4a68      	ldr	r2, [pc, #416]	@ (8103100 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 8102f60:	430b      	orrs	r3, r1
 8102f62:	6593      	str	r3, [r2, #88]	@ 0x58
 8102f64:	e003      	b.n	8102f6e <HAL_RCCEx_PeriphCLKConfig+0xba6>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8102f66:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8102f6a:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 8102f6e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102f72:	e9d3 2300 	ldrd	r2, r3, [r3]
 8102f76:	f002 0320 	and.w	r3, r2, #32
 8102f7a:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
 8102f7e:	2300      	movs	r3, #0
 8102f80:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
 8102f84:	e9d7 122a 	ldrd	r1, r2, [r7, #168]	@ 0xa8
 8102f88:	460b      	mov	r3, r1
 8102f8a:	4313      	orrs	r3, r2
 8102f8c:	d055      	beq.n	810303a <HAL_RCCEx_PeriphCLKConfig+0xc72>
  {
    switch (PeriphClkInit->Lptim1ClockSelection)
 8102f8e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102f92:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 8102f96:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8102f9a:	d033      	beq.n	8103004 <HAL_RCCEx_PeriphCLKConfig+0xc3c>
 8102f9c:	f1b3 4fa0 	cmp.w	r3, #1342177280	@ 0x50000000
 8102fa0:	d82c      	bhi.n	8102ffc <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8102fa2:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8102fa6:	d02f      	beq.n	8103008 <HAL_RCCEx_PeriphCLKConfig+0xc40>
 8102fa8:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8102fac:	d826      	bhi.n	8102ffc <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8102fae:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8102fb2:	d02b      	beq.n	810300c <HAL_RCCEx_PeriphCLKConfig+0xc44>
 8102fb4:	f1b3 5f40 	cmp.w	r3, #805306368	@ 0x30000000
 8102fb8:	d820      	bhi.n	8102ffc <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8102fba:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8102fbe:	d012      	beq.n	8102fe6 <HAL_RCCEx_PeriphCLKConfig+0xc1e>
 8102fc0:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
 8102fc4:	d81a      	bhi.n	8102ffc <HAL_RCCEx_PeriphCLKConfig+0xc34>
 8102fc6:	2b00      	cmp	r3, #0
 8102fc8:	d022      	beq.n	8103010 <HAL_RCCEx_PeriphCLKConfig+0xc48>
 8102fca:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8102fce:	d115      	bne.n	8102ffc <HAL_RCCEx_PeriphCLKConfig+0xc34>
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM1CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM1*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 8102fd0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102fd4:	3308      	adds	r3, #8
 8102fd6:	2100      	movs	r1, #0
 8102fd8:	4618      	mov	r0, r3
 8102fda:	f000 fbff 	bl	81037dc <RCCEx_PLL2_Config>
 8102fde:	4603      	mov	r3, r0
 8102fe0:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
 8102fe4:	e015      	b.n	8103012 <HAL_RCCEx_PeriphCLKConfig+0xc4a>

      case RCC_LPTIM1CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM1*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8102fe6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8102fea:	3328      	adds	r3, #40	@ 0x28
 8102fec:	2102      	movs	r1, #2
 8102fee:	4618      	mov	r0, r3
 8102ff0:	f000 fca6 	bl	8103940 <RCCEx_PLL3_Config>
 8102ff4:	4603      	mov	r3, r0
 8102ff6:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
 8102ffa:	e00a      	b.n	8103012 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM1 clock */
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8102ffc:	2301      	movs	r3, #1
 8102ffe:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8103002:	e006      	b.n	8103012 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8103004:	bf00      	nop
 8103006:	e004      	b.n	8103012 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8103008:	bf00      	nop
 810300a:	e002      	b.n	8103012 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 810300c:	bf00      	nop
 810300e:	e000      	b.n	8103012 <HAL_RCCEx_PeriphCLKConfig+0xc4a>
        break;
 8103010:	bf00      	nop
    }

    if (ret == HAL_OK)
 8103012:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8103016:	2b00      	cmp	r3, #0
 8103018:	d10b      	bne.n	8103032 <HAL_RCCEx_PeriphCLKConfig+0xc6a>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 810301a:	4b39      	ldr	r3, [pc, #228]	@ (8103100 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 810301c:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 810301e:	f023 41e0 	bic.w	r1, r3, #1879048192	@ 0x70000000
 8103022:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103026:	f8d3 3090 	ldr.w	r3, [r3, #144]	@ 0x90
 810302a:	4a35      	ldr	r2, [pc, #212]	@ (8103100 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 810302c:	430b      	orrs	r3, r1
 810302e:	6553      	str	r3, [r2, #84]	@ 0x54
 8103030:	e003      	b.n	810303a <HAL_RCCEx_PeriphCLKConfig+0xc72>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8103032:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8103036:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- LPTIM2 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == RCC_PERIPHCLK_LPTIM2)
 810303a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810303e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8103042:	f002 0340 	and.w	r3, r2, #64	@ 0x40
 8103046:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
 810304a:	2300      	movs	r3, #0
 810304c:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
 8103050:	e9d7 1228 	ldrd	r1, r2, [r7, #160]	@ 0xa0
 8103054:	460b      	mov	r3, r1
 8103056:	4313      	orrs	r3, r2
 8103058:	d058      	beq.n	810310c <HAL_RCCEx_PeriphCLKConfig+0xd44>
  {
    switch (PeriphClkInit->Lptim2ClockSelection)
 810305a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810305e:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 8103062:	f5b3 5fa0 	cmp.w	r3, #5120	@ 0x1400
 8103066:	d033      	beq.n	81030d0 <HAL_RCCEx_PeriphCLKConfig+0xd08>
 8103068:	f5b3 5fa0 	cmp.w	r3, #5120	@ 0x1400
 810306c:	d82c      	bhi.n	81030c8 <HAL_RCCEx_PeriphCLKConfig+0xd00>
 810306e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8103072:	d02f      	beq.n	81030d4 <HAL_RCCEx_PeriphCLKConfig+0xd0c>
 8103074:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8103078:	d826      	bhi.n	81030c8 <HAL_RCCEx_PeriphCLKConfig+0xd00>
 810307a:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 810307e:	d02b      	beq.n	81030d8 <HAL_RCCEx_PeriphCLKConfig+0xd10>
 8103080:	f5b3 6f40 	cmp.w	r3, #3072	@ 0xc00
 8103084:	d820      	bhi.n	81030c8 <HAL_RCCEx_PeriphCLKConfig+0xd00>
 8103086:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 810308a:	d012      	beq.n	81030b2 <HAL_RCCEx_PeriphCLKConfig+0xcea>
 810308c:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
 8103090:	d81a      	bhi.n	81030c8 <HAL_RCCEx_PeriphCLKConfig+0xd00>
 8103092:	2b00      	cmp	r3, #0
 8103094:	d022      	beq.n	81030dc <HAL_RCCEx_PeriphCLKConfig+0xd14>
 8103096:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
 810309a:	d115      	bne.n	81030c8 <HAL_RCCEx_PeriphCLKConfig+0xd00>
        /* LPTIM2 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM2CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM2*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 810309c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81030a0:	3308      	adds	r3, #8
 81030a2:	2100      	movs	r1, #0
 81030a4:	4618      	mov	r0, r3
 81030a6:	f000 fb99 	bl	81037dc <RCCEx_PLL2_Config>
 81030aa:	4603      	mov	r3, r0
 81030ac:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM2 clock source configuration done later after clock selection check */
        break;
 81030b0:	e015      	b.n	81030de <HAL_RCCEx_PeriphCLKConfig+0xd16>

      case RCC_LPTIM2CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM2*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 81030b2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81030b6:	3328      	adds	r3, #40	@ 0x28
 81030b8:	2102      	movs	r1, #2
 81030ba:	4618      	mov	r0, r3
 81030bc:	f000 fc40 	bl	8103940 <RCCEx_PLL3_Config>
 81030c0:	4603      	mov	r3, r0
 81030c2:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM2 clock source configuration done later after clock selection check */
        break;
 81030c6:	e00a      	b.n	81030de <HAL_RCCEx_PeriphCLKConfig+0xd16>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
        /* LPTIM2 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 81030c8:	2301      	movs	r3, #1
 81030ca:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 81030ce:	e006      	b.n	81030de <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 81030d0:	bf00      	nop
 81030d2:	e004      	b.n	81030de <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 81030d4:	bf00      	nop
 81030d6:	e002      	b.n	81030de <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 81030d8:	bf00      	nop
 81030da:	e000      	b.n	81030de <HAL_RCCEx_PeriphCLKConfig+0xd16>
        break;
 81030dc:	bf00      	nop
    }

    if (ret == HAL_OK)
 81030de:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81030e2:	2b00      	cmp	r3, #0
 81030e4:	d10e      	bne.n	8103104 <HAL_RCCEx_PeriphCLKConfig+0xd3c>
    {
      /* Set the source of LPTIM2 clock*/
      __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 81030e6:	4b06      	ldr	r3, [pc, #24]	@ (8103100 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 81030e8:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 81030ea:	f423 51e0 	bic.w	r1, r3, #7168	@ 0x1c00
 81030ee:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81030f2:	f8d3 309c 	ldr.w	r3, [r3, #156]	@ 0x9c
 81030f6:	4a02      	ldr	r2, [pc, #8]	@ (8103100 <HAL_RCCEx_PeriphCLKConfig+0xd38>)
 81030f8:	430b      	orrs	r3, r1
 81030fa:	6593      	str	r3, [r2, #88]	@ 0x58
 81030fc:	e006      	b.n	810310c <HAL_RCCEx_PeriphCLKConfig+0xd44>
 81030fe:	bf00      	nop
 8103100:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 8103104:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8103108:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*---------------------------- LPTIM345 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM345) == RCC_PERIPHCLK_LPTIM345)
 810310c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103110:	e9d3 2300 	ldrd	r2, r3, [r3]
 8103114:	f002 0380 	and.w	r3, r2, #128	@ 0x80
 8103118:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
 810311c:	2300      	movs	r3, #0
 810311e:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
 8103122:	e9d7 1226 	ldrd	r1, r2, [r7, #152]	@ 0x98
 8103126:	460b      	mov	r3, r1
 8103128:	4313      	orrs	r3, r2
 810312a:	d055      	beq.n	81031d8 <HAL_RCCEx_PeriphCLKConfig+0xe10>
  {
    switch (PeriphClkInit->Lptim345ClockSelection)
 810312c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103130:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 8103134:	f5b3 4f20 	cmp.w	r3, #40960	@ 0xa000
 8103138:	d033      	beq.n	81031a2 <HAL_RCCEx_PeriphCLKConfig+0xdda>
 810313a:	f5b3 4f20 	cmp.w	r3, #40960	@ 0xa000
 810313e:	d82c      	bhi.n	810319a <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8103140:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 8103144:	d02f      	beq.n	81031a6 <HAL_RCCEx_PeriphCLKConfig+0xdde>
 8103146:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
 810314a:	d826      	bhi.n	810319a <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 810314c:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
 8103150:	d02b      	beq.n	81031aa <HAL_RCCEx_PeriphCLKConfig+0xde2>
 8103152:	f5b3 4fc0 	cmp.w	r3, #24576	@ 0x6000
 8103156:	d820      	bhi.n	810319a <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8103158:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 810315c:	d012      	beq.n	8103184 <HAL_RCCEx_PeriphCLKConfig+0xdbc>
 810315e:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
 8103162:	d81a      	bhi.n	810319a <HAL_RCCEx_PeriphCLKConfig+0xdd2>
 8103164:	2b00      	cmp	r3, #0
 8103166:	d022      	beq.n	81031ae <HAL_RCCEx_PeriphCLKConfig+0xde6>
 8103168:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 810316c:	d115      	bne.n	810319a <HAL_RCCEx_PeriphCLKConfig+0xdd2>
      case RCC_LPTIM345CLKSOURCE_PCLK4:      /* SRD/D3 PCLK1 (PCLK4) as clock source for LPTIM3/4/5 */
        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM345CLKSOURCE_PLL2: /* PLL2 is used as clock source for LPTIM3/4/5 */
        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 810316e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103172:	3308      	adds	r3, #8
 8103174:	2100      	movs	r1, #0
 8103176:	4618      	mov	r0, r3
 8103178:	f000 fb30 	bl	81037dc <RCCEx_PLL2_Config>
 810317c:	4603      	mov	r3, r0
 810317e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;
 8103182:	e015      	b.n	81031b0 <HAL_RCCEx_PeriphCLKConfig+0xde8>

      case RCC_LPTIM345CLKSOURCE_PLL3:  /* PLL3 is used as clock source for LPTIM3/4/5 */
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 8103184:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103188:	3328      	adds	r3, #40	@ 0x28
 810318a:	2102      	movs	r1, #2
 810318c:	4618      	mov	r0, r3
 810318e:	f000 fbd7 	bl	8103940 <RCCEx_PLL3_Config>
 8103192:	4603      	mov	r3, r0
 8103194:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;
 8103198:	e00a      	b.n	81031b0 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM3/4/5 clock */
        /* LPTIM3/4/5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 810319a:	2301      	movs	r3, #1
 810319c:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 81031a0:	e006      	b.n	81031b0 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 81031a2:	bf00      	nop
 81031a4:	e004      	b.n	81031b0 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 81031a6:	bf00      	nop
 81031a8:	e002      	b.n	81031b0 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 81031aa:	bf00      	nop
 81031ac:	e000      	b.n	81031b0 <HAL_RCCEx_PeriphCLKConfig+0xde8>
        break;
 81031ae:	bf00      	nop
    }

    if (ret == HAL_OK)
 81031b0:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81031b4:	2b00      	cmp	r3, #0
 81031b6:	d10b      	bne.n	81031d0 <HAL_RCCEx_PeriphCLKConfig+0xe08>
    {
      /* Set the source of LPTIM3/4/5 clock */
      __HAL_RCC_LPTIM345_CONFIG(PeriphClkInit->Lptim345ClockSelection);
 81031b8:	4ba1      	ldr	r3, [pc, #644]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 81031ba:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 81031bc:	f423 4160 	bic.w	r1, r3, #57344	@ 0xe000
 81031c0:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81031c4:	f8d3 30a0 	ldr.w	r3, [r3, #160]	@ 0xa0
 81031c8:	4a9d      	ldr	r2, [pc, #628]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 81031ca:	430b      	orrs	r3, r1
 81031cc:	6593      	str	r3, [r2, #88]	@ 0x58
 81031ce:	e003      	b.n	81031d8 <HAL_RCCEx_PeriphCLKConfig+0xe10>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81031d0:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81031d4:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126

    __HAL_RCC_I2C1235_CONFIG(PeriphClkInit->I2c1235ClockSelection);

  }
#else
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C123) == RCC_PERIPHCLK_I2C123)
 81031d8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81031dc:	e9d3 2300 	ldrd	r2, r3, [r3]
 81031e0:	f002 0308 	and.w	r3, r2, #8
 81031e4:	f8c7 3090 	str.w	r3, [r7, #144]	@ 0x90
 81031e8:	2300      	movs	r3, #0
 81031ea:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
 81031ee:	e9d7 1224 	ldrd	r1, r2, [r7, #144]	@ 0x90
 81031f2:	460b      	mov	r3, r1
 81031f4:	4313      	orrs	r3, r2
 81031f6:	d01e      	beq.n	8103236 <HAL_RCCEx_PeriphCLKConfig+0xe6e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C123CLKSOURCE(PeriphClkInit->I2c123ClockSelection));

    if ((PeriphClkInit->I2c123ClockSelection) == RCC_I2C123CLKSOURCE_PLL3)
 81031f8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81031fc:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8103200:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8103204:	d10c      	bne.n	8103220 <HAL_RCCEx_PeriphCLKConfig+0xe58>
    {
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 8103206:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810320a:	3328      	adds	r3, #40	@ 0x28
 810320c:	2102      	movs	r1, #2
 810320e:	4618      	mov	r0, r3
 8103210:	f000 fb96 	bl	8103940 <RCCEx_PLL3_Config>
 8103214:	4603      	mov	r3, r0
 8103216:	2b00      	cmp	r3, #0
 8103218:	d002      	beq.n	8103220 <HAL_RCCEx_PeriphCLKConfig+0xe58>
      {
        status = HAL_ERROR;
 810321a:	2301      	movs	r3, #1
 810321c:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
      }
    }

    __HAL_RCC_I2C123_CONFIG(PeriphClkInit->I2c123ClockSelection);
 8103220:	4b87      	ldr	r3, [pc, #540]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8103222:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8103224:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
 8103228:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810322c:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8103230:	4a83      	ldr	r2, [pc, #524]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8103232:	430b      	orrs	r3, r1
 8103234:	6553      	str	r3, [r2, #84]	@ 0x54

  }
#endif /* I2C5 */

  /*------------------------------ I2C4 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8103236:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810323a:	e9d3 2300 	ldrd	r2, r3, [r3]
 810323e:	f002 0310 	and.w	r3, r2, #16
 8103242:	f8c7 3088 	str.w	r3, [r7, #136]	@ 0x88
 8103246:	2300      	movs	r3, #0
 8103248:	f8c7 308c 	str.w	r3, [r7, #140]	@ 0x8c
 810324c:	e9d7 1222 	ldrd	r1, r2, [r7, #136]	@ 0x88
 8103250:	460b      	mov	r3, r1
 8103252:	4313      	orrs	r3, r2
 8103254:	d01e      	beq.n	8103294 <HAL_RCCEx_PeriphCLKConfig+0xecc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    if ((PeriphClkInit->I2c4ClockSelection) == RCC_I2C4CLKSOURCE_PLL3)
 8103256:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810325a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 810325e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8103262:	d10c      	bne.n	810327e <HAL_RCCEx_PeriphCLKConfig+0xeb6>
    {
      if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 8103264:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103268:	3328      	adds	r3, #40	@ 0x28
 810326a:	2102      	movs	r1, #2
 810326c:	4618      	mov	r0, r3
 810326e:	f000 fb67 	bl	8103940 <RCCEx_PLL3_Config>
 8103272:	4603      	mov	r3, r0
 8103274:	2b00      	cmp	r3, #0
 8103276:	d002      	beq.n	810327e <HAL_RCCEx_PeriphCLKConfig+0xeb6>
      {
        status = HAL_ERROR;
 8103278:	2301      	movs	r3, #1
 810327a:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
      }
    }

    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 810327e:	4b70      	ldr	r3, [pc, #448]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8103280:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8103282:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 8103286:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810328a:	f8d3 3098 	ldr.w	r3, [r3, #152]	@ 0x98
 810328e:	4a6c      	ldr	r2, [pc, #432]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8103290:	430b      	orrs	r3, r1
 8103292:	6593      	str	r3, [r2, #88]	@ 0x58

  }

  /*---------------------------- ADC configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8103294:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103298:	e9d3 2300 	ldrd	r2, r3, [r3]
 810329c:	f402 2300 	and.w	r3, r2, #524288	@ 0x80000
 81032a0:	f8c7 3080 	str.w	r3, [r7, #128]	@ 0x80
 81032a4:	2300      	movs	r3, #0
 81032a6:	f8c7 3084 	str.w	r3, [r7, #132]	@ 0x84
 81032aa:	e9d7 1220 	ldrd	r1, r2, [r7, #128]	@ 0x80
 81032ae:	460b      	mov	r3, r1
 81032b0:	4313      	orrs	r3, r2
 81032b2:	d03e      	beq.n	8103332 <HAL_RCCEx_PeriphCLKConfig+0xf6a>
  {
    switch (PeriphClkInit->AdcClockSelection)
 81032b4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81032b8:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 81032bc:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 81032c0:	d022      	beq.n	8103308 <HAL_RCCEx_PeriphCLKConfig+0xf40>
 81032c2:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
 81032c6:	d81b      	bhi.n	8103300 <HAL_RCCEx_PeriphCLKConfig+0xf38>
 81032c8:	2b00      	cmp	r3, #0
 81032ca:	d003      	beq.n	81032d4 <HAL_RCCEx_PeriphCLKConfig+0xf0c>
 81032cc:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 81032d0:	d00b      	beq.n	81032ea <HAL_RCCEx_PeriphCLKConfig+0xf22>
 81032d2:	e015      	b.n	8103300 <HAL_RCCEx_PeriphCLKConfig+0xf38>
    {

      case RCC_ADCCLKSOURCE_PLL2: /* PLL2 is used as clock source for ADC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 81032d4:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81032d8:	3308      	adds	r3, #8
 81032da:	2100      	movs	r1, #0
 81032dc:	4618      	mov	r0, r3
 81032de:	f000 fa7d 	bl	81037dc <RCCEx_PLL2_Config>
 81032e2:	4603      	mov	r3, r0
 81032e4:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* ADC clock source configuration done later after clock selection check */
        break;
 81032e8:	e00f      	b.n	810330a <HAL_RCCEx_PeriphCLKConfig+0xf42>

      case RCC_ADCCLKSOURCE_PLL3:  /* PLL3 is used as clock source for ADC*/
        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 81032ea:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81032ee:	3328      	adds	r3, #40	@ 0x28
 81032f0:	2102      	movs	r1, #2
 81032f2:	4618      	mov	r0, r3
 81032f4:	f000 fb24 	bl	8103940 <RCCEx_PLL3_Config>
 81032f8:	4603      	mov	r3, r0
 81032fa:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* ADC clock source configuration done later after clock selection check */
        break;
 81032fe:	e004      	b.n	810330a <HAL_RCCEx_PeriphCLKConfig+0xf42>
        /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
        /* ADC clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8103300:	2301      	movs	r3, #1
 8103302:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 8103306:	e000      	b.n	810330a <HAL_RCCEx_PeriphCLKConfig+0xf42>
        break;
 8103308:	bf00      	nop
    }

    if (ret == HAL_OK)
 810330a:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810330e:	2b00      	cmp	r3, #0
 8103310:	d10b      	bne.n	810332a <HAL_RCCEx_PeriphCLKConfig+0xf62>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8103312:	4b4b      	ldr	r3, [pc, #300]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8103314:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8103316:	f423 3140 	bic.w	r1, r3, #196608	@ 0x30000
 810331a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810331e:	f8d3 30a4 	ldr.w	r3, [r3, #164]	@ 0xa4
 8103322:	4a47      	ldr	r2, [pc, #284]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8103324:	430b      	orrs	r3, r1
 8103326:	6593      	str	r3, [r2, #88]	@ 0x58
 8103328:	e003      	b.n	8103332 <HAL_RCCEx_PeriphCLKConfig+0xf6a>
    }
    else
    {
      /* set overall return value */
      status = ret;
 810332a:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810332e:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

  /*------------------------------ USB Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 8103332:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103336:	e9d3 2300 	ldrd	r2, r3, [r3]
 810333a:	f402 2380 	and.w	r3, r2, #262144	@ 0x40000
 810333e:	67bb      	str	r3, [r7, #120]	@ 0x78
 8103340:	2300      	movs	r3, #0
 8103342:	67fb      	str	r3, [r7, #124]	@ 0x7c
 8103344:	e9d7 121e 	ldrd	r1, r2, [r7, #120]	@ 0x78
 8103348:	460b      	mov	r3, r1
 810334a:	4313      	orrs	r3, r2
 810334c:	d03b      	beq.n	81033c6 <HAL_RCCEx_PeriphCLKConfig+0xffe>
  {

    switch (PeriphClkInit->UsbClockSelection)
 810334e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103352:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 8103356:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 810335a:	d01f      	beq.n	810339c <HAL_RCCEx_PeriphCLKConfig+0xfd4>
 810335c:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
 8103360:	d818      	bhi.n	8103394 <HAL_RCCEx_PeriphCLKConfig+0xfcc>
 8103362:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8103366:	d003      	beq.n	8103370 <HAL_RCCEx_PeriphCLKConfig+0xfa8>
 8103368:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
 810336c:	d007      	beq.n	810337e <HAL_RCCEx_PeriphCLKConfig+0xfb6>
 810336e:	e011      	b.n	8103394 <HAL_RCCEx_PeriphCLKConfig+0xfcc>
    {
      case RCC_USBCLKSOURCE_PLL:      /* PLL is used as clock source for USB*/
        /* Enable USB Clock output generated form System USB . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 8103370:	4b33      	ldr	r3, [pc, #204]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8103372:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8103374:	4a32      	ldr	r2, [pc, #200]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8103376:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 810337a:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* USB clock source configuration done later after clock selection check */
        break;
 810337c:	e00f      	b.n	810339e <HAL_RCCEx_PeriphCLKConfig+0xfd6>

      case RCC_USBCLKSOURCE_PLL3: /* PLL3 is used as clock source for USB*/

        ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 810337e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103382:	3328      	adds	r3, #40	@ 0x28
 8103384:	2101      	movs	r1, #1
 8103386:	4618      	mov	r0, r3
 8103388:	f000 fada 	bl	8103940 <RCCEx_PLL3_Config>
 810338c:	4603      	mov	r3, r0
 810338e:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* USB clock source configuration done later after clock selection check */
        break;
 8103392:	e004      	b.n	810339e <HAL_RCCEx_PeriphCLKConfig+0xfd6>
        /* HSI48 oscillator is used as source of USB clock */
        /* USB clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 8103394:	2301      	movs	r3, #1
 8103396:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 810339a:	e000      	b.n	810339e <HAL_RCCEx_PeriphCLKConfig+0xfd6>
        break;
 810339c:	bf00      	nop
    }

    if (ret == HAL_OK)
 810339e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81033a2:	2b00      	cmp	r3, #0
 81033a4:	d10b      	bne.n	81033be <HAL_RCCEx_PeriphCLKConfig+0xff6>
    {
      /* Set the source of USB clock*/
      __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 81033a6:	4b26      	ldr	r3, [pc, #152]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 81033a8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 81033aa:	f423 1140 	bic.w	r1, r3, #3145728	@ 0x300000
 81033ae:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81033b2:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
 81033b6:	4a22      	ldr	r2, [pc, #136]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 81033b8:	430b      	orrs	r3, r1
 81033ba:	6553      	str	r3, [r2, #84]	@ 0x54
 81033bc:	e003      	b.n	81033c6 <HAL_RCCEx_PeriphCLKConfig+0xffe>
    }
    else
    {
      /* set overall return value */
      status = ret;
 81033be:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81033c2:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }

  }

  /*------------------------------------- SDMMC Configuration ------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC) == RCC_PERIPHCLK_SDMMC)
 81033c6:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81033ca:	e9d3 2300 	ldrd	r2, r3, [r3]
 81033ce:	f402 3380 	and.w	r3, r2, #65536	@ 0x10000
 81033d2:	673b      	str	r3, [r7, #112]	@ 0x70
 81033d4:	2300      	movs	r3, #0
 81033d6:	677b      	str	r3, [r7, #116]	@ 0x74
 81033d8:	e9d7 121c 	ldrd	r1, r2, [r7, #112]	@ 0x70
 81033dc:	460b      	mov	r3, r1
 81033de:	4313      	orrs	r3, r2
 81033e0:	d034      	beq.n	810344c <HAL_RCCEx_PeriphCLKConfig+0x1084>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC(PeriphClkInit->SdmmcClockSelection));

    switch (PeriphClkInit->SdmmcClockSelection)
 81033e2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81033e6:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 81033e8:	2b00      	cmp	r3, #0
 81033ea:	d003      	beq.n	81033f4 <HAL_RCCEx_PeriphCLKConfig+0x102c>
 81033ec:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 81033f0:	d007      	beq.n	8103402 <HAL_RCCEx_PeriphCLKConfig+0x103a>
 81033f2:	e011      	b.n	8103418 <HAL_RCCEx_PeriphCLKConfig+0x1050>
    {
      case RCC_SDMMCCLKSOURCE_PLL:      /* PLL is used as clock source for SDMMC*/
        /* Enable SDMMC Clock output generated form System PLL . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 81033f4:	4b12      	ldr	r3, [pc, #72]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 81033f6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81033f8:	4a11      	ldr	r2, [pc, #68]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 81033fa:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 81033fe:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* SDMMC clock source configuration done later after clock selection check */
        break;
 8103400:	e00e      	b.n	8103420 <HAL_RCCEx_PeriphCLKConfig+0x1058>

      case RCC_SDMMCCLKSOURCE_PLL2: /* PLL2 is used as clock source for SDMMC*/

        ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 8103402:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103406:	3308      	adds	r3, #8
 8103408:	2102      	movs	r1, #2
 810340a:	4618      	mov	r0, r3
 810340c:	f000 f9e6 	bl	81037dc <RCCEx_PLL2_Config>
 8103410:	4603      	mov	r3, r0
 8103412:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127

        /* SDMMC clock source configuration done later after clock selection check */
        break;
 8103416:	e003      	b.n	8103420 <HAL_RCCEx_PeriphCLKConfig+0x1058>

      default:
        ret = HAL_ERROR;
 8103418:	2301      	movs	r3, #1
 810341a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 810341e:	bf00      	nop
    }

    if (ret == HAL_OK)
 8103420:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8103424:	2b00      	cmp	r3, #0
 8103426:	d10d      	bne.n	8103444 <HAL_RCCEx_PeriphCLKConfig+0x107c>
    {
      /* Set the source of SDMMC clock*/
      __HAL_RCC_SDMMC_CONFIG(PeriphClkInit->SdmmcClockSelection);
 8103428:	4b05      	ldr	r3, [pc, #20]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 810342a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 810342c:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
 8103430:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103434:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8103436:	4a02      	ldr	r2, [pc, #8]	@ (8103440 <HAL_RCCEx_PeriphCLKConfig+0x1078>)
 8103438:	430b      	orrs	r3, r1
 810343a:	64d3      	str	r3, [r2, #76]	@ 0x4c
 810343c:	e006      	b.n	810344c <HAL_RCCEx_PeriphCLKConfig+0x1084>
 810343e:	bf00      	nop
 8103440:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
 8103444:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8103448:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }

#if defined(LTDC)
  /*-------------------------------------- LTDC Configuration -----------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
 810344c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103450:	e9d3 2300 	ldrd	r2, r3, [r3]
 8103454:	f002 5300 	and.w	r3, r2, #536870912	@ 0x20000000
 8103458:	66bb      	str	r3, [r7, #104]	@ 0x68
 810345a:	2300      	movs	r3, #0
 810345c:	66fb      	str	r3, [r7, #108]	@ 0x6c
 810345e:	e9d7 121a 	ldrd	r1, r2, [r7, #104]	@ 0x68
 8103462:	460b      	mov	r3, r1
 8103464:	4313      	orrs	r3, r2
 8103466:	d00c      	beq.n	8103482 <HAL_RCCEx_PeriphCLKConfig+0x10ba>
  {
    if (RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE) != HAL_OK)
 8103468:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810346c:	3328      	adds	r3, #40	@ 0x28
 810346e:	2102      	movs	r1, #2
 8103470:	4618      	mov	r0, r3
 8103472:	f000 fa65 	bl	8103940 <RCCEx_PLL3_Config>
 8103476:	4603      	mov	r3, r0
 8103478:	2b00      	cmp	r3, #0
 810347a:	d002      	beq.n	8103482 <HAL_RCCEx_PeriphCLKConfig+0x10ba>
    {
      status = HAL_ERROR;
 810347c:	2301      	movs	r3, #1
 810347e:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
#endif /* LTDC */

  /*------------------------------ RNG Configuration -------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == RCC_PERIPHCLK_RNG)
 8103482:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103486:	e9d3 2300 	ldrd	r2, r3, [r3]
 810348a:	f402 3300 	and.w	r3, r2, #131072	@ 0x20000
 810348e:	663b      	str	r3, [r7, #96]	@ 0x60
 8103490:	2300      	movs	r3, #0
 8103492:	667b      	str	r3, [r7, #100]	@ 0x64
 8103494:	e9d7 1218 	ldrd	r1, r2, [r7, #96]	@ 0x60
 8103498:	460b      	mov	r3, r1
 810349a:	4313      	orrs	r3, r2
 810349c:	d038      	beq.n	8103510 <HAL_RCCEx_PeriphCLKConfig+0x1148>
  {

    switch (PeriphClkInit->RngClockSelection)
 810349e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81034a2:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 81034a6:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 81034aa:	d018      	beq.n	81034de <HAL_RCCEx_PeriphCLKConfig+0x1116>
 81034ac:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
 81034b0:	d811      	bhi.n	81034d6 <HAL_RCCEx_PeriphCLKConfig+0x110e>
 81034b2:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 81034b6:	d014      	beq.n	81034e2 <HAL_RCCEx_PeriphCLKConfig+0x111a>
 81034b8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 81034bc:	d80b      	bhi.n	81034d6 <HAL_RCCEx_PeriphCLKConfig+0x110e>
 81034be:	2b00      	cmp	r3, #0
 81034c0:	d011      	beq.n	81034e6 <HAL_RCCEx_PeriphCLKConfig+0x111e>
 81034c2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 81034c6:	d106      	bne.n	81034d6 <HAL_RCCEx_PeriphCLKConfig+0x110e>
    {
      case RCC_RNGCLKSOURCE_PLL:     /* PLL is used as clock source for RNG*/
        /* Enable RNG Clock output generated form System RNG . */
        __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 81034c8:	4bc3      	ldr	r3, [pc, #780]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81034ca:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81034cc:	4ac2      	ldr	r2, [pc, #776]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81034ce:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 81034d2:	62d3      	str	r3, [r2, #44]	@ 0x2c

        /* RNG clock source configuration done later after clock selection check */
        break;
 81034d4:	e008      	b.n	81034e8 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        /* HSI48 oscillator is used as source of RNG clock */
        /* RNG clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
 81034d6:	2301      	movs	r3, #1
 81034d8:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
        break;
 81034dc:	e004      	b.n	81034e8 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
 81034de:	bf00      	nop
 81034e0:	e002      	b.n	81034e8 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
 81034e2:	bf00      	nop
 81034e4:	e000      	b.n	81034e8 <HAL_RCCEx_PeriphCLKConfig+0x1120>
        break;
 81034e6:	bf00      	nop
    }

    if (ret == HAL_OK)
 81034e8:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81034ec:	2b00      	cmp	r3, #0
 81034ee:	d10b      	bne.n	8103508 <HAL_RCCEx_PeriphCLKConfig+0x1140>
    {
      /* Set the source of RNG clock*/
      __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 81034f0:	4bb9      	ldr	r3, [pc, #740]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81034f2:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 81034f4:	f423 7140 	bic.w	r1, r3, #768	@ 0x300
 81034f8:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81034fc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
 8103500:	4ab5      	ldr	r2, [pc, #724]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8103502:	430b      	orrs	r3, r1
 8103504:	6553      	str	r3, [r2, #84]	@ 0x54
 8103506:	e003      	b.n	8103510 <HAL_RCCEx_PeriphCLKConfig+0x1148>
    }
    else
    {
      /* set overall return value */
      status = ret;
 8103508:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810350c:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }

  }

  /*------------------------------ SWPMI1 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SWPMI1) == RCC_PERIPHCLK_SWPMI1)
 8103510:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103514:	e9d3 2300 	ldrd	r2, r3, [r3]
 8103518:	f402 1380 	and.w	r3, r2, #1048576	@ 0x100000
 810351c:	65bb      	str	r3, [r7, #88]	@ 0x58
 810351e:	2300      	movs	r3, #0
 8103520:	65fb      	str	r3, [r7, #92]	@ 0x5c
 8103522:	e9d7 1216 	ldrd	r1, r2, [r7, #88]	@ 0x58
 8103526:	460b      	mov	r3, r1
 8103528:	4313      	orrs	r3, r2
 810352a:	d009      	beq.n	8103540 <HAL_RCCEx_PeriphCLKConfig+0x1178>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SWPMI1CLKSOURCE(PeriphClkInit->Swpmi1ClockSelection));

    /* Configure the SWPMI1 interface clock source */
    __HAL_RCC_SWPMI1_CONFIG(PeriphClkInit->Swpmi1ClockSelection);
 810352c:	4baa      	ldr	r3, [pc, #680]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810352e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8103530:	f023 4100 	bic.w	r1, r3, #2147483648	@ 0x80000000
 8103534:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103538:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
 810353a:	4aa7      	ldr	r2, [pc, #668]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810353c:	430b      	orrs	r3, r1
 810353e:	6513      	str	r3, [r2, #80]	@ 0x50
  }
#if defined(HRTIM1)
  /*------------------------------ HRTIM1 clock Configuration ----------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_HRTIM1) == RCC_PERIPHCLK_HRTIM1)
 8103540:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103544:	e9d3 2300 	ldrd	r2, r3, [r3]
 8103548:	f002 5380 	and.w	r3, r2, #268435456	@ 0x10000000
 810354c:	653b      	str	r3, [r7, #80]	@ 0x50
 810354e:	2300      	movs	r3, #0
 8103550:	657b      	str	r3, [r7, #84]	@ 0x54
 8103552:	e9d7 1214 	ldrd	r1, r2, [r7, #80]	@ 0x50
 8103556:	460b      	mov	r3, r1
 8103558:	4313      	orrs	r3, r2
 810355a:	d00a      	beq.n	8103572 <HAL_RCCEx_PeriphCLKConfig+0x11aa>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HRTIM1CLKSOURCE(PeriphClkInit->Hrtim1ClockSelection));

    /* Configure the HRTIM1 clock source */
    __HAL_RCC_HRTIM1_CONFIG(PeriphClkInit->Hrtim1ClockSelection);
 810355c:	4b9e      	ldr	r3, [pc, #632]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810355e:	691b      	ldr	r3, [r3, #16]
 8103560:	f423 4180 	bic.w	r1, r3, #16384	@ 0x4000
 8103564:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103568:	f8d3 30b8 	ldr.w	r3, [r3, #184]	@ 0xb8
 810356c:	4a9a      	ldr	r2, [pc, #616]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810356e:	430b      	orrs	r3, r1
 8103570:	6113      	str	r3, [r2, #16]
  }
#endif  /*HRTIM1*/
  /*------------------------------ DFSDM1 Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8103572:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103576:	e9d3 2300 	ldrd	r2, r3, [r3]
 810357a:	f402 1300 	and.w	r3, r2, #2097152	@ 0x200000
 810357e:	64bb      	str	r3, [r7, #72]	@ 0x48
 8103580:	2300      	movs	r3, #0
 8103582:	64fb      	str	r3, [r7, #76]	@ 0x4c
 8103584:	e9d7 1212 	ldrd	r1, r2, [r7, #72]	@ 0x48
 8103588:	460b      	mov	r3, r1
 810358a:	4313      	orrs	r3, r2
 810358c:	d009      	beq.n	81035a2 <HAL_RCCEx_PeriphCLKConfig+0x11da>
  {
    /* Check the parameters */
    assert_param(IS_RCC_DFSDM1CLKSOURCE(PeriphClkInit->Dfsdm1ClockSelection));

    /* Configure the DFSDM1 interface clock source */
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 810358e:	4b92      	ldr	r3, [pc, #584]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8103590:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 8103592:	f023 7180 	bic.w	r1, r3, #16777216	@ 0x1000000
 8103596:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810359a:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 810359c:	4a8e      	ldr	r2, [pc, #568]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810359e:	430b      	orrs	r3, r1
 81035a0:	6513      	str	r3, [r2, #80]	@ 0x50
    __HAL_RCC_DFSDM2_CONFIG(PeriphClkInit->Dfsdm2ClockSelection);
  }
#endif  /* DFSDM2 */

  /*------------------------------------ TIM configuration --------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
 81035a2:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81035a6:	e9d3 2300 	ldrd	r2, r3, [r3]
 81035aa:	f002 4380 	and.w	r3, r2, #1073741824	@ 0x40000000
 81035ae:	643b      	str	r3, [r7, #64]	@ 0x40
 81035b0:	2300      	movs	r3, #0
 81035b2:	647b      	str	r3, [r7, #68]	@ 0x44
 81035b4:	e9d7 1210 	ldrd	r1, r2, [r7, #64]	@ 0x40
 81035b8:	460b      	mov	r3, r1
 81035ba:	4313      	orrs	r3, r2
 81035bc:	d00e      	beq.n	81035dc <HAL_RCCEx_PeriphCLKConfig+0x1214>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMPRES(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection);
 81035be:	4b86      	ldr	r3, [pc, #536]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81035c0:	691b      	ldr	r3, [r3, #16]
 81035c2:	4a85      	ldr	r2, [pc, #532]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81035c4:	f423 4300 	bic.w	r3, r3, #32768	@ 0x8000
 81035c8:	6113      	str	r3, [r2, #16]
 81035ca:	4b83      	ldr	r3, [pc, #524]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81035cc:	6919      	ldr	r1, [r3, #16]
 81035ce:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81035d2:	f8d3 30bc 	ldr.w	r3, [r3, #188]	@ 0xbc
 81035d6:	4a80      	ldr	r2, [pc, #512]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81035d8:	430b      	orrs	r3, r1
 81035da:	6113      	str	r3, [r2, #16]
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
 81035dc:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81035e0:	e9d3 2300 	ldrd	r2, r3, [r3]
 81035e4:	f002 4300 	and.w	r3, r2, #2147483648	@ 0x80000000
 81035e8:	63bb      	str	r3, [r7, #56]	@ 0x38
 81035ea:	2300      	movs	r3, #0
 81035ec:	63fb      	str	r3, [r7, #60]	@ 0x3c
 81035ee:	e9d7 120e 	ldrd	r1, r2, [r7, #56]	@ 0x38
 81035f2:	460b      	mov	r3, r1
 81035f4:	4313      	orrs	r3, r2
 81035f6:	d009      	beq.n	810360c <HAL_RCCEx_PeriphCLKConfig+0x1244>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CLKPSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
 81035f8:	4b77      	ldr	r3, [pc, #476]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 81035fa:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 81035fc:	f023 5140 	bic.w	r1, r3, #805306368	@ 0x30000000
 8103600:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103604:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 8103606:	4a74      	ldr	r2, [pc, #464]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 8103608:	430b      	orrs	r3, r1
 810360a:	64d3      	str	r3, [r2, #76]	@ 0x4c
  }

  /*------------------------------ CEC Configuration ------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
 810360c:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103610:	e9d3 2300 	ldrd	r2, r3, [r3]
 8103614:	f402 0300 	and.w	r3, r2, #8388608	@ 0x800000
 8103618:	633b      	str	r3, [r7, #48]	@ 0x30
 810361a:	2300      	movs	r3, #0
 810361c:	637b      	str	r3, [r7, #52]	@ 0x34
 810361e:	e9d7 120c 	ldrd	r1, r2, [r7, #48]	@ 0x30
 8103622:	460b      	mov	r3, r1
 8103624:	4313      	orrs	r3, r2
 8103626:	d00a      	beq.n	810363e <HAL_RCCEx_PeriphCLKConfig+0x1276>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC interface clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
 8103628:	4b6b      	ldr	r3, [pc, #428]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810362a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
 810362c:	f423 0140 	bic.w	r1, r3, #12582912	@ 0xc00000
 8103630:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103634:	f8d3 308c 	ldr.w	r3, [r3, #140]	@ 0x8c
 8103638:	4a67      	ldr	r2, [pc, #412]	@ (81037d8 <HAL_RCCEx_PeriphCLKConfig+0x1410>)
 810363a:	430b      	orrs	r3, r1
 810363c:	6553      	str	r3, [r2, #84]	@ 0x54
  }

  /*---------------------------- PLL2 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVP) == RCC_PERIPHCLK_PLL2_DIVP)
 810363e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103642:	e9d3 2300 	ldrd	r2, r3, [r3]
 8103646:	2100      	movs	r1, #0
 8103648:	62b9      	str	r1, [r7, #40]	@ 0x28
 810364a:	f003 0301 	and.w	r3, r3, #1
 810364e:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8103650:	e9d7 120a 	ldrd	r1, r2, [r7, #40]	@ 0x28
 8103654:	460b      	mov	r3, r1
 8103656:	4313      	orrs	r3, r2
 8103658:	d011      	beq.n	810367e <HAL_RCCEx_PeriphCLKConfig+0x12b6>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_P_UPDATE);
 810365a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810365e:	3308      	adds	r3, #8
 8103660:	2100      	movs	r1, #0
 8103662:	4618      	mov	r0, r3
 8103664:	f000 f8ba 	bl	81037dc <RCCEx_PLL2_Config>
 8103668:	4603      	mov	r3, r0
 810366a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 810366e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8103672:	2b00      	cmp	r3, #0
 8103674:	d003      	beq.n	810367e <HAL_RCCEx_PeriphCLKConfig+0x12b6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 8103676:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810367a:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    } 
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVQ) == RCC_PERIPHCLK_PLL2_DIVQ)
 810367e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103682:	e9d3 2300 	ldrd	r2, r3, [r3]
 8103686:	2100      	movs	r1, #0
 8103688:	6239      	str	r1, [r7, #32]
 810368a:	f003 0302 	and.w	r3, r3, #2
 810368e:	627b      	str	r3, [r7, #36]	@ 0x24
 8103690:	e9d7 1208 	ldrd	r1, r2, [r7, #32]
 8103694:	460b      	mov	r3, r1
 8103696:	4313      	orrs	r3, r2
 8103698:	d011      	beq.n	81036be <HAL_RCCEx_PeriphCLKConfig+0x12f6>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_Q_UPDATE);
 810369a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810369e:	3308      	adds	r3, #8
 81036a0:	2101      	movs	r1, #1
 81036a2:	4618      	mov	r0, r3
 81036a4:	f000 f89a 	bl	81037dc <RCCEx_PLL2_Config>
 81036a8:	4603      	mov	r3, r0
 81036aa:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 81036ae:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81036b2:	2b00      	cmp	r3, #0
 81036b4:	d003      	beq.n	81036be <HAL_RCCEx_PeriphCLKConfig+0x12f6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 81036b6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81036ba:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL2_DIVR) == RCC_PERIPHCLK_PLL2_DIVR)
 81036be:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81036c2:	e9d3 2300 	ldrd	r2, r3, [r3]
 81036c6:	2100      	movs	r1, #0
 81036c8:	61b9      	str	r1, [r7, #24]
 81036ca:	f003 0304 	and.w	r3, r3, #4
 81036ce:	61fb      	str	r3, [r7, #28]
 81036d0:	e9d7 1206 	ldrd	r1, r2, [r7, #24]
 81036d4:	460b      	mov	r3, r1
 81036d6:	4313      	orrs	r3, r2
 81036d8:	d011      	beq.n	81036fe <HAL_RCCEx_PeriphCLKConfig+0x1336>
  {
    ret = RCCEx_PLL2_Config(&(PeriphClkInit->PLL2), DIVIDER_R_UPDATE);
 81036da:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 81036de:	3308      	adds	r3, #8
 81036e0:	2102      	movs	r1, #2
 81036e2:	4618      	mov	r0, r3
 81036e4:	f000 f87a 	bl	81037dc <RCCEx_PLL2_Config>
 81036e8:	4603      	mov	r3, r0
 81036ea:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 81036ee:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81036f2:	2b00      	cmp	r3, #0
 81036f4:	d003      	beq.n	81036fe <HAL_RCCEx_PeriphCLKConfig+0x1336>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 81036f6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81036fa:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  

  /*---------------------------- PLL3 configuration -------------------------------*/
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVP) == RCC_PERIPHCLK_PLL3_DIVP)
 81036fe:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103702:	e9d3 2300 	ldrd	r2, r3, [r3]
 8103706:	2100      	movs	r1, #0
 8103708:	6139      	str	r1, [r7, #16]
 810370a:	f003 0308 	and.w	r3, r3, #8
 810370e:	617b      	str	r3, [r7, #20]
 8103710:	e9d7 1204 	ldrd	r1, r2, [r7, #16]
 8103714:	460b      	mov	r3, r1
 8103716:	4313      	orrs	r3, r2
 8103718:	d011      	beq.n	810373e <HAL_RCCEx_PeriphCLKConfig+0x1376>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_P_UPDATE);
 810371a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810371e:	3328      	adds	r3, #40	@ 0x28
 8103720:	2100      	movs	r1, #0
 8103722:	4618      	mov	r0, r3
 8103724:	f000 f90c 	bl	8103940 <RCCEx_PLL3_Config>
 8103728:	4603      	mov	r3, r0
 810372a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
  
    if (ret == HAL_OK)
 810372e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8103732:	2b00      	cmp	r3, #0
 8103734:	d003      	beq.n	810373e <HAL_RCCEx_PeriphCLKConfig+0x1376>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 8103736:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810373a:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVQ) == RCC_PERIPHCLK_PLL3_DIVQ)
 810373e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103742:	e9d3 2300 	ldrd	r2, r3, [r3]
 8103746:	2100      	movs	r1, #0
 8103748:	60b9      	str	r1, [r7, #8]
 810374a:	f003 0310 	and.w	r3, r3, #16
 810374e:	60fb      	str	r3, [r7, #12]
 8103750:	e9d7 1202 	ldrd	r1, r2, [r7, #8]
 8103754:	460b      	mov	r3, r1
 8103756:	4313      	orrs	r3, r2
 8103758:	d011      	beq.n	810377e <HAL_RCCEx_PeriphCLKConfig+0x13b6>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_Q_UPDATE);
 810375a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810375e:	3328      	adds	r3, #40	@ 0x28
 8103760:	2101      	movs	r1, #1
 8103762:	4618      	mov	r0, r3
 8103764:	f000 f8ec 	bl	8103940 <RCCEx_PLL3_Config>
 8103768:	4603      	mov	r3, r0
 810376a:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 810376e:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 8103772:	2b00      	cmp	r3, #0
 8103774:	d003      	beq.n	810377e <HAL_RCCEx_PeriphCLKConfig+0x13b6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 8103776:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 810377a:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    }
  }
  
  
  if (((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_PLL3_DIVR) == RCC_PERIPHCLK_PLL3_DIVR)
 810377e:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 8103782:	e9d3 2300 	ldrd	r2, r3, [r3]
 8103786:	2100      	movs	r1, #0
 8103788:	6039      	str	r1, [r7, #0]
 810378a:	f003 0320 	and.w	r3, r3, #32
 810378e:	607b      	str	r3, [r7, #4]
 8103790:	e9d7 1200 	ldrd	r1, r2, [r7]
 8103794:	460b      	mov	r3, r1
 8103796:	4313      	orrs	r3, r2
 8103798:	d011      	beq.n	81037be <HAL_RCCEx_PeriphCLKConfig+0x13f6>
  {
    ret = RCCEx_PLL3_Config(&(PeriphClkInit->PLL3), DIVIDER_R_UPDATE);
 810379a:	f8d7 3114 	ldr.w	r3, [r7, #276]	@ 0x114
 810379e:	3328      	adds	r3, #40	@ 0x28
 81037a0:	2102      	movs	r1, #2
 81037a2:	4618      	mov	r0, r3
 81037a4:	f000 f8cc 	bl	8103940 <RCCEx_PLL3_Config>
 81037a8:	4603      	mov	r3, r0
 81037aa:	f887 3127 	strb.w	r3, [r7, #295]	@ 0x127
    
    if (ret == HAL_OK)
 81037ae:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81037b2:	2b00      	cmp	r3, #0
 81037b4:	d003      	beq.n	81037be <HAL_RCCEx_PeriphCLKConfig+0x13f6>
      /*Nothing to do*/
    }
    else
    {
      /* set overall return value */
      status = ret;
 81037b6:	f897 3127 	ldrb.w	r3, [r7, #295]	@ 0x127
 81037ba:	f887 3126 	strb.w	r3, [r7, #294]	@ 0x126
    } 
  }

  if (status == HAL_OK)
 81037be:	f897 3126 	ldrb.w	r3, [r7, #294]	@ 0x126
 81037c2:	2b00      	cmp	r3, #0
 81037c4:	d101      	bne.n	81037ca <HAL_RCCEx_PeriphCLKConfig+0x1402>
  {
    return HAL_OK;
 81037c6:	2300      	movs	r3, #0
 81037c8:	e000      	b.n	81037cc <HAL_RCCEx_PeriphCLKConfig+0x1404>
  }
  return HAL_ERROR;
 81037ca:	2301      	movs	r3, #1
}
 81037cc:	4618      	mov	r0, r3
 81037ce:	f507 7794 	add.w	r7, r7, #296	@ 0x128
 81037d2:	46bd      	mov	sp, r7
 81037d4:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
 81037d8:	58024400 	.word	0x58024400

081037dc <RCCEx_PLL2_Config>:
  * @note   PLL2 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL2_Config(RCC_PLL2InitTypeDef *pll2, uint32_t Divider)
{
 81037dc:	b580      	push	{r7, lr}
 81037de:	b084      	sub	sp, #16
 81037e0:	af00      	add	r7, sp, #0
 81037e2:	6078      	str	r0, [r7, #4]
 81037e4:	6039      	str	r1, [r7, #0]

  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 81037e6:	2300      	movs	r3, #0
 81037e8:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL2RGE_VALUE(pll2->PLL2RGE));
  assert_param(IS_RCC_PLL2VCO_VALUE(pll2->PLL2VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll2->PLL2FRACN));

  /* Check that PLL2 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 81037ea:	4b54      	ldr	r3, [pc, #336]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81037ec:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 81037ee:	f003 0303 	and.w	r3, r3, #3
 81037f2:	2b03      	cmp	r3, #3
 81037f4:	d101      	bne.n	81037fa <RCCEx_PLL2_Config+0x1e>
  {
    return HAL_ERROR;
 81037f6:	2301      	movs	r3, #1
 81037f8:	e09b      	b.n	8103932 <RCCEx_PLL2_Config+0x156>


  else
  {
    /* Disable  PLL2. */
    __HAL_RCC_PLL2_DISABLE();
 81037fa:	4b50      	ldr	r3, [pc, #320]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81037fc:	681b      	ldr	r3, [r3, #0]
 81037fe:	4a4f      	ldr	r2, [pc, #316]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 8103800:	f023 6380 	bic.w	r3, r3, #67108864	@ 0x4000000
 8103804:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8103806:	f7fd ffe3 	bl	81017d0 <HAL_GetTick>
 810380a:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL is disabled */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 810380c:	e008      	b.n	8103820 <RCCEx_PLL2_Config+0x44>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 810380e:	f7fd ffdf 	bl	81017d0 <HAL_GetTick>
 8103812:	4602      	mov	r2, r0
 8103814:	68bb      	ldr	r3, [r7, #8]
 8103816:	1ad3      	subs	r3, r2, r3
 8103818:	2b02      	cmp	r3, #2
 810381a:	d901      	bls.n	8103820 <RCCEx_PLL2_Config+0x44>
      {
        return HAL_TIMEOUT;
 810381c:	2303      	movs	r3, #3
 810381e:	e088      	b.n	8103932 <RCCEx_PLL2_Config+0x156>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) != 0U)
 8103820:	4b46      	ldr	r3, [pc, #280]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 8103822:	681b      	ldr	r3, [r3, #0]
 8103824:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 8103828:	2b00      	cmp	r3, #0
 810382a:	d1f0      	bne.n	810380e <RCCEx_PLL2_Config+0x32>
      }
    }

    /* Configure PLL2 multiplication and division factors. */
    __HAL_RCC_PLL2_CONFIG(pll2->PLL2M,
 810382c:	4b43      	ldr	r3, [pc, #268]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 810382e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8103830:	f423 327c 	bic.w	r2, r3, #258048	@ 0x3f000
 8103834:	687b      	ldr	r3, [r7, #4]
 8103836:	681b      	ldr	r3, [r3, #0]
 8103838:	031b      	lsls	r3, r3, #12
 810383a:	4940      	ldr	r1, [pc, #256]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 810383c:	4313      	orrs	r3, r2
 810383e:	628b      	str	r3, [r1, #40]	@ 0x28
 8103840:	687b      	ldr	r3, [r7, #4]
 8103842:	685b      	ldr	r3, [r3, #4]
 8103844:	3b01      	subs	r3, #1
 8103846:	f3c3 0208 	ubfx	r2, r3, #0, #9
 810384a:	687b      	ldr	r3, [r7, #4]
 810384c:	689b      	ldr	r3, [r3, #8]
 810384e:	3b01      	subs	r3, #1
 8103850:	025b      	lsls	r3, r3, #9
 8103852:	b29b      	uxth	r3, r3
 8103854:	431a      	orrs	r2, r3
 8103856:	687b      	ldr	r3, [r7, #4]
 8103858:	68db      	ldr	r3, [r3, #12]
 810385a:	3b01      	subs	r3, #1
 810385c:	041b      	lsls	r3, r3, #16
 810385e:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 8103862:	431a      	orrs	r2, r3
 8103864:	687b      	ldr	r3, [r7, #4]
 8103866:	691b      	ldr	r3, [r3, #16]
 8103868:	3b01      	subs	r3, #1
 810386a:	061b      	lsls	r3, r3, #24
 810386c:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 8103870:	4932      	ldr	r1, [pc, #200]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 8103872:	4313      	orrs	r3, r2
 8103874:	638b      	str	r3, [r1, #56]	@ 0x38
                          pll2->PLL2P,
                          pll2->PLL2Q,
                          pll2->PLL2R);

    /* Select PLL2 input reference frequency range: VCI */
    __HAL_RCC_PLL2_VCIRANGE(pll2->PLL2RGE) ;
 8103876:	4b31      	ldr	r3, [pc, #196]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 8103878:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810387a:	f023 02c0 	bic.w	r2, r3, #192	@ 0xc0
 810387e:	687b      	ldr	r3, [r7, #4]
 8103880:	695b      	ldr	r3, [r3, #20]
 8103882:	492e      	ldr	r1, [pc, #184]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 8103884:	4313      	orrs	r3, r2
 8103886:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Select PLL2 output frequency range : VCO */
    __HAL_RCC_PLL2_VCORANGE(pll2->PLL2VCOSEL) ;
 8103888:	4b2c      	ldr	r3, [pc, #176]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 810388a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810388c:	f023 0220 	bic.w	r2, r3, #32
 8103890:	687b      	ldr	r3, [r7, #4]
 8103892:	699b      	ldr	r3, [r3, #24]
 8103894:	4929      	ldr	r1, [pc, #164]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 8103896:	4313      	orrs	r3, r2
 8103898:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Disable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_DISABLE();
 810389a:	4b28      	ldr	r3, [pc, #160]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 810389c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810389e:	4a27      	ldr	r2, [pc, #156]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81038a0:	f023 0310 	bic.w	r3, r3, #16
 81038a4:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Configures PLL2 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL2FRACN_CONFIG(pll2->PLL2FRACN);
 81038a6:	4b25      	ldr	r3, [pc, #148]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81038a8:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 81038aa:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 81038ae:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 81038b2:	687a      	ldr	r2, [r7, #4]
 81038b4:	69d2      	ldr	r2, [r2, #28]
 81038b6:	00d2      	lsls	r2, r2, #3
 81038b8:	4920      	ldr	r1, [pc, #128]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81038ba:	4313      	orrs	r3, r2
 81038bc:	63cb      	str	r3, [r1, #60]	@ 0x3c

    /* Enable PLL2FRACN . */
    __HAL_RCC_PLL2FRACN_ENABLE();
 81038be:	4b1f      	ldr	r3, [pc, #124]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81038c0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81038c2:	4a1e      	ldr	r2, [pc, #120]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81038c4:	f043 0310 	orr.w	r3, r3, #16
 81038c8:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Enable the PLL2 clock output */
    if (Divider == DIVIDER_P_UPDATE)
 81038ca:	683b      	ldr	r3, [r7, #0]
 81038cc:	2b00      	cmp	r3, #0
 81038ce:	d106      	bne.n	81038de <RCCEx_PLL2_Config+0x102>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVP);
 81038d0:	4b1a      	ldr	r3, [pc, #104]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81038d2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81038d4:	4a19      	ldr	r2, [pc, #100]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81038d6:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 81038da:	62d3      	str	r3, [r2, #44]	@ 0x2c
 81038dc:	e00f      	b.n	81038fe <RCCEx_PLL2_Config+0x122>
    }
    else if (Divider == DIVIDER_Q_UPDATE)
 81038de:	683b      	ldr	r3, [r7, #0]
 81038e0:	2b01      	cmp	r3, #1
 81038e2:	d106      	bne.n	81038f2 <RCCEx_PLL2_Config+0x116>
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVQ);
 81038e4:	4b15      	ldr	r3, [pc, #84]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81038e6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81038e8:	4a14      	ldr	r2, [pc, #80]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81038ea:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 81038ee:	62d3      	str	r3, [r2, #44]	@ 0x2c
 81038f0:	e005      	b.n	81038fe <RCCEx_PLL2_Config+0x122>
    }
    else
    {
      __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL2_DIVR);
 81038f2:	4b12      	ldr	r3, [pc, #72]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81038f4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81038f6:	4a11      	ldr	r2, [pc, #68]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 81038f8:	f443 1300 	orr.w	r3, r3, #2097152	@ 0x200000
 81038fc:	62d3      	str	r3, [r2, #44]	@ 0x2c
    }

    /* Enable  PLL2. */
    __HAL_RCC_PLL2_ENABLE();
 81038fe:	4b0f      	ldr	r3, [pc, #60]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 8103900:	681b      	ldr	r3, [r3, #0]
 8103902:	4a0e      	ldr	r2, [pc, #56]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 8103904:	f043 6380 	orr.w	r3, r3, #67108864	@ 0x4000000
 8103908:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 810390a:	f7fd ff61 	bl	81017d0 <HAL_GetTick>
 810390e:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL2 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8103910:	e008      	b.n	8103924 <RCCEx_PLL2_Config+0x148>
    {
      if ((HAL_GetTick() - tickstart) > PLL2_TIMEOUT_VALUE)
 8103912:	f7fd ff5d 	bl	81017d0 <HAL_GetTick>
 8103916:	4602      	mov	r2, r0
 8103918:	68bb      	ldr	r3, [r7, #8]
 810391a:	1ad3      	subs	r3, r2, r3
 810391c:	2b02      	cmp	r3, #2
 810391e:	d901      	bls.n	8103924 <RCCEx_PLL2_Config+0x148>
      {
        return HAL_TIMEOUT;
 8103920:	2303      	movs	r3, #3
 8103922:	e006      	b.n	8103932 <RCCEx_PLL2_Config+0x156>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL2RDY) == 0U)
 8103924:	4b05      	ldr	r3, [pc, #20]	@ (810393c <RCCEx_PLL2_Config+0x160>)
 8103926:	681b      	ldr	r3, [r3, #0]
 8103928:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
 810392c:	2b00      	cmp	r3, #0
 810392e:	d0f0      	beq.n	8103912 <RCCEx_PLL2_Config+0x136>
    }

  }


  return status;
 8103930:	7bfb      	ldrb	r3, [r7, #15]
}
 8103932:	4618      	mov	r0, r3
 8103934:	3710      	adds	r7, #16
 8103936:	46bd      	mov	sp, r7
 8103938:	bd80      	pop	{r7, pc}
 810393a:	bf00      	nop
 810393c:	58024400 	.word	0x58024400

08103940 <RCCEx_PLL3_Config>:
  * @note   PLL3 is temporary disabled to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLL3_Config(RCC_PLL3InitTypeDef *pll3, uint32_t Divider)
{
 8103940:	b580      	push	{r7, lr}
 8103942:	b084      	sub	sp, #16
 8103944:	af00      	add	r7, sp, #0
 8103946:	6078      	str	r0, [r7, #4]
 8103948:	6039      	str	r1, [r7, #0]
  uint32_t tickstart;
  HAL_StatusTypeDef status = HAL_OK;
 810394a:	2300      	movs	r3, #0
 810394c:	73fb      	strb	r3, [r7, #15]
  assert_param(IS_RCC_PLL3RGE_VALUE(pll3->PLL3RGE));
  assert_param(IS_RCC_PLL3VCO_VALUE(pll3->PLL3VCOSEL));
  assert_param(IS_RCC_PLLFRACN_VALUE(pll3->PLL3FRACN));

  /* Check that PLL3 OSC clock source is already set */
  if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_NONE)
 810394e:	4b54      	ldr	r3, [pc, #336]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103950:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8103952:	f003 0303 	and.w	r3, r3, #3
 8103956:	2b03      	cmp	r3, #3
 8103958:	d101      	bne.n	810395e <RCCEx_PLL3_Config+0x1e>
  {
    return HAL_ERROR;
 810395a:	2301      	movs	r3, #1
 810395c:	e09b      	b.n	8103a96 <RCCEx_PLL3_Config+0x156>


  else
  {
    /* Disable  PLL3. */
    __HAL_RCC_PLL3_DISABLE();
 810395e:	4b50      	ldr	r3, [pc, #320]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103960:	681b      	ldr	r3, [r3, #0]
 8103962:	4a4f      	ldr	r2, [pc, #316]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103964:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8103968:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 810396a:	f7fd ff31 	bl	81017d0 <HAL_GetTick>
 810396e:	60b8      	str	r0, [r7, #8]
    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8103970:	e008      	b.n	8103984 <RCCEx_PLL3_Config+0x44>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8103972:	f7fd ff2d 	bl	81017d0 <HAL_GetTick>
 8103976:	4602      	mov	r2, r0
 8103978:	68bb      	ldr	r3, [r7, #8]
 810397a:	1ad3      	subs	r3, r2, r3
 810397c:	2b02      	cmp	r3, #2
 810397e:	d901      	bls.n	8103984 <RCCEx_PLL3_Config+0x44>
      {
        return HAL_TIMEOUT;
 8103980:	2303      	movs	r3, #3
 8103982:	e088      	b.n	8103a96 <RCCEx_PLL3_Config+0x156>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) != 0U)
 8103984:	4b46      	ldr	r3, [pc, #280]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103986:	681b      	ldr	r3, [r3, #0]
 8103988:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 810398c:	2b00      	cmp	r3, #0
 810398e:	d1f0      	bne.n	8103972 <RCCEx_PLL3_Config+0x32>
      }
    }

    /* Configure the PLL3  multiplication and division factors. */
    __HAL_RCC_PLL3_CONFIG(pll3->PLL3M,
 8103990:	4b43      	ldr	r3, [pc, #268]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103992:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8103994:	f023 727c 	bic.w	r2, r3, #66060288	@ 0x3f00000
 8103998:	687b      	ldr	r3, [r7, #4]
 810399a:	681b      	ldr	r3, [r3, #0]
 810399c:	051b      	lsls	r3, r3, #20
 810399e:	4940      	ldr	r1, [pc, #256]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 81039a0:	4313      	orrs	r3, r2
 81039a2:	628b      	str	r3, [r1, #40]	@ 0x28
 81039a4:	687b      	ldr	r3, [r7, #4]
 81039a6:	685b      	ldr	r3, [r3, #4]
 81039a8:	3b01      	subs	r3, #1
 81039aa:	f3c3 0208 	ubfx	r2, r3, #0, #9
 81039ae:	687b      	ldr	r3, [r7, #4]
 81039b0:	689b      	ldr	r3, [r3, #8]
 81039b2:	3b01      	subs	r3, #1
 81039b4:	025b      	lsls	r3, r3, #9
 81039b6:	b29b      	uxth	r3, r3
 81039b8:	431a      	orrs	r2, r3
 81039ba:	687b      	ldr	r3, [r7, #4]
 81039bc:	68db      	ldr	r3, [r3, #12]
 81039be:	3b01      	subs	r3, #1
 81039c0:	041b      	lsls	r3, r3, #16
 81039c2:	f403 03fe 	and.w	r3, r3, #8323072	@ 0x7f0000
 81039c6:	431a      	orrs	r2, r3
 81039c8:	687b      	ldr	r3, [r7, #4]
 81039ca:	691b      	ldr	r3, [r3, #16]
 81039cc:	3b01      	subs	r3, #1
 81039ce:	061b      	lsls	r3, r3, #24
 81039d0:	f003 43fe 	and.w	r3, r3, #2130706432	@ 0x7f000000
 81039d4:	4932      	ldr	r1, [pc, #200]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 81039d6:	4313      	orrs	r3, r2
 81039d8:	640b      	str	r3, [r1, #64]	@ 0x40
                          pll3->PLL3P,
                          pll3->PLL3Q,
                          pll3->PLL3R);

    /* Select PLL3 input reference frequency range: VCI */
    __HAL_RCC_PLL3_VCIRANGE(pll3->PLL3RGE) ;
 81039da:	4b31      	ldr	r3, [pc, #196]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 81039dc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81039de:	f423 6240 	bic.w	r2, r3, #3072	@ 0xc00
 81039e2:	687b      	ldr	r3, [r7, #4]
 81039e4:	695b      	ldr	r3, [r3, #20]
 81039e6:	492e      	ldr	r1, [pc, #184]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 81039e8:	4313      	orrs	r3, r2
 81039ea:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Select PLL3 output frequency range : VCO */
    __HAL_RCC_PLL3_VCORANGE(pll3->PLL3VCOSEL) ;
 81039ec:	4b2c      	ldr	r3, [pc, #176]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 81039ee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 81039f0:	f423 7200 	bic.w	r2, r3, #512	@ 0x200
 81039f4:	687b      	ldr	r3, [r7, #4]
 81039f6:	699b      	ldr	r3, [r3, #24]
 81039f8:	4929      	ldr	r1, [pc, #164]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 81039fa:	4313      	orrs	r3, r2
 81039fc:	62cb      	str	r3, [r1, #44]	@ 0x2c

    /* Disable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_DISABLE();
 81039fe:	4b28      	ldr	r3, [pc, #160]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a00:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8103a02:	4a27      	ldr	r2, [pc, #156]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a04:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8103a08:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Configures PLL3 clock Fractional Part Of The Multiplication Factor */
    __HAL_RCC_PLL3FRACN_CONFIG(pll3->PLL3FRACN);
 8103a0a:	4b25      	ldr	r3, [pc, #148]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a0c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
 8103a0e:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 8103a12:	f023 03f8 	bic.w	r3, r3, #248	@ 0xf8
 8103a16:	687a      	ldr	r2, [r7, #4]
 8103a18:	69d2      	ldr	r2, [r2, #28]
 8103a1a:	00d2      	lsls	r2, r2, #3
 8103a1c:	4920      	ldr	r1, [pc, #128]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a1e:	4313      	orrs	r3, r2
 8103a20:	644b      	str	r3, [r1, #68]	@ 0x44

    /* Enable PLL3FRACN . */
    __HAL_RCC_PLL3FRACN_ENABLE();
 8103a22:	4b1f      	ldr	r3, [pc, #124]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a24:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8103a26:	4a1e      	ldr	r2, [pc, #120]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a28:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8103a2c:	62d3      	str	r3, [r2, #44]	@ 0x2c

    /* Enable the PLL3 clock output */
    if (Divider == DIVIDER_P_UPDATE)
 8103a2e:	683b      	ldr	r3, [r7, #0]
 8103a30:	2b00      	cmp	r3, #0
 8103a32:	d106      	bne.n	8103a42 <RCCEx_PLL3_Config+0x102>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVP);
 8103a34:	4b1a      	ldr	r3, [pc, #104]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a36:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8103a38:	4a19      	ldr	r2, [pc, #100]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a3a:	f443 0380 	orr.w	r3, r3, #4194304	@ 0x400000
 8103a3e:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8103a40:	e00f      	b.n	8103a62 <RCCEx_PLL3_Config+0x122>
    }
    else if (Divider == DIVIDER_Q_UPDATE)
 8103a42:	683b      	ldr	r3, [r7, #0]
 8103a44:	2b01      	cmp	r3, #1
 8103a46:	d106      	bne.n	8103a56 <RCCEx_PLL3_Config+0x116>
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVQ);
 8103a48:	4b15      	ldr	r3, [pc, #84]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a4a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8103a4c:	4a14      	ldr	r2, [pc, #80]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a4e:	f443 0300 	orr.w	r3, r3, #8388608	@ 0x800000
 8103a52:	62d3      	str	r3, [r2, #44]	@ 0x2c
 8103a54:	e005      	b.n	8103a62 <RCCEx_PLL3_Config+0x122>
    }
    else
    {
      __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL3_DIVR);
 8103a56:	4b12      	ldr	r3, [pc, #72]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a58:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 8103a5a:	4a11      	ldr	r2, [pc, #68]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a5c:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8103a60:	62d3      	str	r3, [r2, #44]	@ 0x2c
    }

    /* Enable  PLL3. */
    __HAL_RCC_PLL3_ENABLE();
 8103a62:	4b0f      	ldr	r3, [pc, #60]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a64:	681b      	ldr	r3, [r3, #0]
 8103a66:	4a0e      	ldr	r2, [pc, #56]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a68:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8103a6c:	6013      	str	r3, [r2, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8103a6e:	f7fd feaf 	bl	81017d0 <HAL_GetTick>
 8103a72:	60b8      	str	r0, [r7, #8]

    /* Wait till PLL3 is ready */
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8103a74:	e008      	b.n	8103a88 <RCCEx_PLL3_Config+0x148>
    {
      if ((HAL_GetTick() - tickstart) > PLL3_TIMEOUT_VALUE)
 8103a76:	f7fd feab 	bl	81017d0 <HAL_GetTick>
 8103a7a:	4602      	mov	r2, r0
 8103a7c:	68bb      	ldr	r3, [r7, #8]
 8103a7e:	1ad3      	subs	r3, r2, r3
 8103a80:	2b02      	cmp	r3, #2
 8103a82:	d901      	bls.n	8103a88 <RCCEx_PLL3_Config+0x148>
      {
        return HAL_TIMEOUT;
 8103a84:	2303      	movs	r3, #3
 8103a86:	e006      	b.n	8103a96 <RCCEx_PLL3_Config+0x156>
    while (__HAL_RCC_GET_FLAG(RCC_FLAG_PLL3RDY) == 0U)
 8103a88:	4b05      	ldr	r3, [pc, #20]	@ (8103aa0 <RCCEx_PLL3_Config+0x160>)
 8103a8a:	681b      	ldr	r3, [r3, #0]
 8103a8c:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
 8103a90:	2b00      	cmp	r3, #0
 8103a92:	d0f0      	beq.n	8103a76 <RCCEx_PLL3_Config+0x136>
    }

  }


  return status;
 8103a94:	7bfb      	ldrb	r3, [r7, #15]
}
 8103a96:	4618      	mov	r0, r3
 8103a98:	3710      	adds	r7, #16
 8103a9a:	46bd      	mov	sp, r7
 8103a9c:	bd80      	pop	{r7, pc}
 8103a9e:	bf00      	nop
 8103aa0:	58024400 	.word	0x58024400

08103aa4 <HAL_SPI_Init>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_Init(SPI_HandleTypeDef *hspi)
{
 8103aa4:	b580      	push	{r7, lr}
 8103aa6:	b084      	sub	sp, #16
 8103aa8:	af00      	add	r7, sp, #0
 8103aaa:	6078      	str	r0, [r7, #4]
#if (USE_SPI_CRC != 0UL)
  uint32_t crc_poly_msb_mask;
#endif /* USE_SPI_CRC */

  /* Check the SPI handle allocation */
  if (hspi == NULL)
 8103aac:	687b      	ldr	r3, [r7, #4]
 8103aae:	2b00      	cmp	r3, #0
 8103ab0:	d101      	bne.n	8103ab6 <HAL_SPI_Init+0x12>
  {
    return HAL_ERROR;
 8103ab2:	2301      	movs	r3, #1
 8103ab4:	e10f      	b.n	8103cd6 <HAL_SPI_Init+0x232>
    assert_param(IS_SPI_CRC_POLYNOMIAL(hspi->Init.CRCPolynomial));
    assert_param(IS_SPI_CRC_INITIALIZATION_PATTERN(hspi->Init.TxCRCInitializationPattern));
    assert_param(IS_SPI_CRC_INITIALIZATION_PATTERN(hspi->Init.RxCRCInitializationPattern));
  }
#else
  hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 8103ab6:	687b      	ldr	r3, [r7, #4]
 8103ab8:	2200      	movs	r2, #0
 8103aba:	629a      	str	r2, [r3, #40]	@ 0x28
#endif /* USE_SPI_CRC */

  /* Verify that the SPI instance supports Data Size higher than 16bits */
  if ((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (hspi->Init.DataSize > SPI_DATASIZE_16BIT))
 8103abc:	687b      	ldr	r3, [r7, #4]
 8103abe:	681b      	ldr	r3, [r3, #0]
 8103ac0:	4a87      	ldr	r2, [pc, #540]	@ (8103ce0 <HAL_SPI_Init+0x23c>)
 8103ac2:	4293      	cmp	r3, r2
 8103ac4:	d00f      	beq.n	8103ae6 <HAL_SPI_Init+0x42>
 8103ac6:	687b      	ldr	r3, [r7, #4]
 8103ac8:	681b      	ldr	r3, [r3, #0]
 8103aca:	4a86      	ldr	r2, [pc, #536]	@ (8103ce4 <HAL_SPI_Init+0x240>)
 8103acc:	4293      	cmp	r3, r2
 8103ace:	d00a      	beq.n	8103ae6 <HAL_SPI_Init+0x42>
 8103ad0:	687b      	ldr	r3, [r7, #4]
 8103ad2:	681b      	ldr	r3, [r3, #0]
 8103ad4:	4a84      	ldr	r2, [pc, #528]	@ (8103ce8 <HAL_SPI_Init+0x244>)
 8103ad6:	4293      	cmp	r3, r2
 8103ad8:	d005      	beq.n	8103ae6 <HAL_SPI_Init+0x42>
 8103ada:	687b      	ldr	r3, [r7, #4]
 8103adc:	68db      	ldr	r3, [r3, #12]
 8103ade:	2b0f      	cmp	r3, #15
 8103ae0:	d901      	bls.n	8103ae6 <HAL_SPI_Init+0x42>
  {
    return HAL_ERROR;
 8103ae2:	2301      	movs	r3, #1
 8103ae4:	e0f7      	b.n	8103cd6 <HAL_SPI_Init+0x232>
  }

  /* Verify that the SPI instance supports requested data packing */
  packet_length = SPI_GetPacketSize(hspi);
 8103ae6:	6878      	ldr	r0, [r7, #4]
 8103ae8:	f000 fd06 	bl	81044f8 <SPI_GetPacketSize>
 8103aec:	60f8      	str	r0, [r7, #12]
  if (((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_LOWEND_FIFO_SIZE)) ||
 8103aee:	687b      	ldr	r3, [r7, #4]
 8103af0:	681b      	ldr	r3, [r3, #0]
 8103af2:	4a7b      	ldr	r2, [pc, #492]	@ (8103ce0 <HAL_SPI_Init+0x23c>)
 8103af4:	4293      	cmp	r3, r2
 8103af6:	d00c      	beq.n	8103b12 <HAL_SPI_Init+0x6e>
 8103af8:	687b      	ldr	r3, [r7, #4]
 8103afa:	681b      	ldr	r3, [r3, #0]
 8103afc:	4a79      	ldr	r2, [pc, #484]	@ (8103ce4 <HAL_SPI_Init+0x240>)
 8103afe:	4293      	cmp	r3, r2
 8103b00:	d007      	beq.n	8103b12 <HAL_SPI_Init+0x6e>
 8103b02:	687b      	ldr	r3, [r7, #4]
 8103b04:	681b      	ldr	r3, [r3, #0]
 8103b06:	4a78      	ldr	r2, [pc, #480]	@ (8103ce8 <HAL_SPI_Init+0x244>)
 8103b08:	4293      	cmp	r3, r2
 8103b0a:	d002      	beq.n	8103b12 <HAL_SPI_Init+0x6e>
 8103b0c:	68fb      	ldr	r3, [r7, #12]
 8103b0e:	2b08      	cmp	r3, #8
 8103b10:	d811      	bhi.n	8103b36 <HAL_SPI_Init+0x92>
      ((IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_HIGHEND_FIFO_SIZE)))
 8103b12:	687b      	ldr	r3, [r7, #4]
 8103b14:	681b      	ldr	r3, [r3, #0]
  if (((!IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_LOWEND_FIFO_SIZE)) ||
 8103b16:	4a72      	ldr	r2, [pc, #456]	@ (8103ce0 <HAL_SPI_Init+0x23c>)
 8103b18:	4293      	cmp	r3, r2
 8103b1a:	d009      	beq.n	8103b30 <HAL_SPI_Init+0x8c>
      ((IS_SPI_HIGHEND_INSTANCE(hspi->Instance)) && (packet_length > SPI_HIGHEND_FIFO_SIZE)))
 8103b1c:	687b      	ldr	r3, [r7, #4]
 8103b1e:	681b      	ldr	r3, [r3, #0]
 8103b20:	4a70      	ldr	r2, [pc, #448]	@ (8103ce4 <HAL_SPI_Init+0x240>)
 8103b22:	4293      	cmp	r3, r2
 8103b24:	d004      	beq.n	8103b30 <HAL_SPI_Init+0x8c>
 8103b26:	687b      	ldr	r3, [r7, #4]
 8103b28:	681b      	ldr	r3, [r3, #0]
 8103b2a:	4a6f      	ldr	r2, [pc, #444]	@ (8103ce8 <HAL_SPI_Init+0x244>)
 8103b2c:	4293      	cmp	r3, r2
 8103b2e:	d104      	bne.n	8103b3a <HAL_SPI_Init+0x96>
 8103b30:	68fb      	ldr	r3, [r7, #12]
 8103b32:	2b10      	cmp	r3, #16
 8103b34:	d901      	bls.n	8103b3a <HAL_SPI_Init+0x96>
  {
    return HAL_ERROR;
 8103b36:	2301      	movs	r3, #1
 8103b38:	e0cd      	b.n	8103cd6 <HAL_SPI_Init+0x232>
  {
    crc_length = hspi->Init.DataSize << SPI_CFG1_CRCSIZE_Pos;
  }
#endif /* USE_SPI_CRC */

  if (hspi->State == HAL_SPI_STATE_RESET)
 8103b3a:	687b      	ldr	r3, [r7, #4]
 8103b3c:	f893 3081 	ldrb.w	r3, [r3, #129]	@ 0x81
 8103b40:	b2db      	uxtb	r3, r3
 8103b42:	2b00      	cmp	r3, #0
 8103b44:	d106      	bne.n	8103b54 <HAL_SPI_Init+0xb0>
  {
    /* Allocate lock resource and initialize it */
    hspi->Lock = HAL_UNLOCKED;
 8103b46:	687b      	ldr	r3, [r7, #4]
 8103b48:	2200      	movs	r2, #0
 8103b4a:	f883 2080 	strb.w	r2, [r3, #128]	@ 0x80

    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    hspi->MspInitCallback(hspi);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_SPI_MspInit(hspi);
 8103b4e:	6878      	ldr	r0, [r7, #4]
 8103b50:	f7fd fb9c 	bl	810128c <HAL_SPI_MspInit>
#endif /* USE_HAL_SPI_REGISTER_CALLBACKS */
  }

  hspi->State = HAL_SPI_STATE_BUSY;
 8103b54:	687b      	ldr	r3, [r7, #4]
 8103b56:	2202      	movs	r2, #2
 8103b58:	f883 2081 	strb.w	r2, [r3, #129]	@ 0x81

  /* Disable the selected SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 8103b5c:	687b      	ldr	r3, [r7, #4]
 8103b5e:	681b      	ldr	r3, [r3, #0]
 8103b60:	681a      	ldr	r2, [r3, #0]
 8103b62:	687b      	ldr	r3, [r7, #4]
 8103b64:	681b      	ldr	r3, [r3, #0]
 8103b66:	f022 0201 	bic.w	r2, r2, #1
 8103b6a:	601a      	str	r2, [r3, #0]

#if (USE_SPI_CRC == 0)
  /* Keep the default value of CRCSIZE in case of CRC is not used */
  crc_length = hspi->Instance->CFG1 & SPI_CFG1_CRCSIZE;
 8103b6c:	687b      	ldr	r3, [r7, #4]
 8103b6e:	681b      	ldr	r3, [r3, #0]
 8103b70:	689b      	ldr	r3, [r3, #8]
 8103b72:	f403 13f8 	and.w	r3, r3, #2031616	@ 0x1f0000
 8103b76:	60bb      	str	r3, [r7, #8]
  /*----------------------- SPIx CR1 & CR2 Configuration ---------------------*/
  /* Configure : SPI Mode, Communication Mode, Clock polarity and phase, NSS management,
  Communication speed, First bit, CRC calculation state, CRC Length */

  /* SPIx NSS Software Management Configuration */
  if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&  \
 8103b78:	687b      	ldr	r3, [r7, #4]
 8103b7a:	699b      	ldr	r3, [r3, #24]
 8103b7c:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
 8103b80:	d119      	bne.n	8103bb6 <HAL_SPI_Init+0x112>
 8103b82:	687b      	ldr	r3, [r7, #4]
 8103b84:	685b      	ldr	r3, [r3, #4]
 8103b86:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8103b8a:	d103      	bne.n	8103b94 <HAL_SPI_Init+0xf0>
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_LOW)) || \
 8103b8c:	687b      	ldr	r3, [r7, #4]
 8103b8e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
  if ((hspi->Init.NSS == SPI_NSS_SOFT) && (((hspi->Init.Mode == SPI_MODE_MASTER) &&  \
 8103b90:	2b00      	cmp	r3, #0
 8103b92:	d008      	beq.n	8103ba6 <HAL_SPI_Init+0x102>
                                           ((hspi->Init.Mode == SPI_MODE_SLAVE) && \
 8103b94:	687b      	ldr	r3, [r7, #4]
 8103b96:	685b      	ldr	r3, [r3, #4]
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_LOW)) || \
 8103b98:	2b00      	cmp	r3, #0
 8103b9a:	d10c      	bne.n	8103bb6 <HAL_SPI_Init+0x112>
                                            (hspi->Init.NSSPolarity == SPI_NSS_POLARITY_HIGH))))
 8103b9c:	687b      	ldr	r3, [r7, #4]
 8103b9e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
                                           ((hspi->Init.Mode == SPI_MODE_SLAVE) && \
 8103ba0:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
 8103ba4:	d107      	bne.n	8103bb6 <HAL_SPI_Init+0x112>
  {
    SET_BIT(hspi->Instance->CR1, SPI_CR1_SSI);
 8103ba6:	687b      	ldr	r3, [r7, #4]
 8103ba8:	681b      	ldr	r3, [r3, #0]
 8103baa:	681a      	ldr	r2, [r3, #0]
 8103bac:	687b      	ldr	r3, [r7, #4]
 8103bae:	681b      	ldr	r3, [r3, #0]
 8103bb0:	f442 5280 	orr.w	r2, r2, #4096	@ 0x1000
 8103bb4:	601a      	str	r2, [r3, #0]
  }

  /* SPIx Master Rx Auto Suspend Configuration */
  if (((hspi->Init.Mode & SPI_MODE_MASTER) == SPI_MODE_MASTER) && (hspi->Init.DataSize >= SPI_DATASIZE_8BIT))
 8103bb6:	687b      	ldr	r3, [r7, #4]
 8103bb8:	685b      	ldr	r3, [r3, #4]
 8103bba:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8103bbe:	2b00      	cmp	r3, #0
 8103bc0:	d00f      	beq.n	8103be2 <HAL_SPI_Init+0x13e>
 8103bc2:	687b      	ldr	r3, [r7, #4]
 8103bc4:	68db      	ldr	r3, [r3, #12]
 8103bc6:	2b06      	cmp	r3, #6
 8103bc8:	d90b      	bls.n	8103be2 <HAL_SPI_Init+0x13e>
  {
    MODIFY_REG(hspi->Instance->CR1, SPI_CR1_MASRX, hspi->Init.MasterReceiverAutoSusp);
 8103bca:	687b      	ldr	r3, [r7, #4]
 8103bcc:	681b      	ldr	r3, [r3, #0]
 8103bce:	681b      	ldr	r3, [r3, #0]
 8103bd0:	f423 7180 	bic.w	r1, r3, #256	@ 0x100
 8103bd4:	687b      	ldr	r3, [r7, #4]
 8103bd6:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8103bd8:	687b      	ldr	r3, [r7, #4]
 8103bda:	681b      	ldr	r3, [r3, #0]
 8103bdc:	430a      	orrs	r2, r1
 8103bde:	601a      	str	r2, [r3, #0]
 8103be0:	e007      	b.n	8103bf2 <HAL_SPI_Init+0x14e>
  }
  else
  {
    CLEAR_BIT(hspi->Instance->CR1, SPI_CR1_MASRX);
 8103be2:	687b      	ldr	r3, [r7, #4]
 8103be4:	681b      	ldr	r3, [r3, #0]
 8103be6:	681a      	ldr	r2, [r3, #0]
 8103be8:	687b      	ldr	r3, [r7, #4]
 8103bea:	681b      	ldr	r3, [r3, #0]
 8103bec:	f422 7280 	bic.w	r2, r2, #256	@ 0x100
 8103bf0:	601a      	str	r2, [r3, #0]
  }

  /* SPIx CFG1 Configuration */
  WRITE_REG(hspi->Instance->CFG1, (hspi->Init.BaudRatePrescaler | hspi->Init.CRCCalculation | crc_length |
 8103bf2:	687b      	ldr	r3, [r7, #4]
 8103bf4:	69da      	ldr	r2, [r3, #28]
 8103bf6:	687b      	ldr	r3, [r7, #4]
 8103bf8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 8103bfa:	431a      	orrs	r2, r3
 8103bfc:	68bb      	ldr	r3, [r7, #8]
 8103bfe:	431a      	orrs	r2, r3
 8103c00:	687b      	ldr	r3, [r7, #4]
 8103c02:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8103c04:	ea42 0103 	orr.w	r1, r2, r3
 8103c08:	687b      	ldr	r3, [r7, #4]
 8103c0a:	68da      	ldr	r2, [r3, #12]
 8103c0c:	687b      	ldr	r3, [r7, #4]
 8103c0e:	681b      	ldr	r3, [r3, #0]
 8103c10:	430a      	orrs	r2, r1
 8103c12:	609a      	str	r2, [r3, #8]
                                   hspi->Init.FifoThreshold     | hspi->Init.DataSize));

  /* SPIx CFG2 Configuration */
  WRITE_REG(hspi->Instance->CFG2, (hspi->Init.NSSPMode                | hspi->Init.TIMode    |
 8103c14:	687b      	ldr	r3, [r7, #4]
 8103c16:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
 8103c18:	687b      	ldr	r3, [r7, #4]
 8103c1a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8103c1c:	431a      	orrs	r2, r3
 8103c1e:	687b      	ldr	r3, [r7, #4]
 8103c20:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 8103c22:	431a      	orrs	r2, r3
 8103c24:	687b      	ldr	r3, [r7, #4]
 8103c26:	699b      	ldr	r3, [r3, #24]
 8103c28:	431a      	orrs	r2, r3
 8103c2a:	687b      	ldr	r3, [r7, #4]
 8103c2c:	691b      	ldr	r3, [r3, #16]
 8103c2e:	431a      	orrs	r2, r3
 8103c30:	687b      	ldr	r3, [r7, #4]
 8103c32:	695b      	ldr	r3, [r3, #20]
 8103c34:	431a      	orrs	r2, r3
 8103c36:	687b      	ldr	r3, [r7, #4]
 8103c38:	6a1b      	ldr	r3, [r3, #32]
 8103c3a:	431a      	orrs	r2, r3
 8103c3c:	687b      	ldr	r3, [r7, #4]
 8103c3e:	685b      	ldr	r3, [r3, #4]
 8103c40:	431a      	orrs	r2, r3
 8103c42:	687b      	ldr	r3, [r7, #4]
 8103c44:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8103c46:	431a      	orrs	r2, r3
 8103c48:	687b      	ldr	r3, [r7, #4]
 8103c4a:	689b      	ldr	r3, [r3, #8]
 8103c4c:	431a      	orrs	r2, r3
 8103c4e:	687b      	ldr	r3, [r7, #4]
 8103c50:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 8103c52:	ea42 0103 	orr.w	r1, r2, r3
 8103c56:	687b      	ldr	r3, [r7, #4]
 8103c58:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8103c5a:	687b      	ldr	r3, [r7, #4]
 8103c5c:	681b      	ldr	r3, [r3, #0]
 8103c5e:	430a      	orrs	r2, r1
 8103c60:	60da      	str	r2, [r3, #12]
    }
  }
#endif /* USE_SPI_CRC */

  /* Insure that Underrun configuration is managed only by Salve */
  if (hspi->Init.Mode == SPI_MODE_SLAVE)
 8103c62:	687b      	ldr	r3, [r7, #4]
 8103c64:	685b      	ldr	r3, [r3, #4]
 8103c66:	2b00      	cmp	r3, #0
 8103c68:	d113      	bne.n	8103c92 <HAL_SPI_Init+0x1ee>
    /* Set Default Underrun configuration */
#if (USE_SPI_CRC != 0UL)
    if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_DISABLE)
#endif /* USE_SPI_CRC */
    {
      MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRDET, SPI_CFG1_UDRDET_0);
 8103c6a:	687b      	ldr	r3, [r7, #4]
 8103c6c:	681b      	ldr	r3, [r3, #0]
 8103c6e:	689b      	ldr	r3, [r3, #8]
 8103c70:	f423 52c0 	bic.w	r2, r3, #6144	@ 0x1800
 8103c74:	687b      	ldr	r3, [r7, #4]
 8103c76:	681b      	ldr	r3, [r3, #0]
 8103c78:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 8103c7c:	609a      	str	r2, [r3, #8]
    }
    MODIFY_REG(hspi->Instance->CFG1, SPI_CFG1_UDRCFG, SPI_CFG1_UDRCFG_1);
 8103c7e:	687b      	ldr	r3, [r7, #4]
 8103c80:	681b      	ldr	r3, [r3, #0]
 8103c82:	689b      	ldr	r3, [r3, #8]
 8103c84:	f423 62c0 	bic.w	r2, r3, #1536	@ 0x600
 8103c88:	687b      	ldr	r3, [r7, #4]
 8103c8a:	681b      	ldr	r3, [r3, #0]
 8103c8c:	f442 6280 	orr.w	r2, r2, #1024	@ 0x400
 8103c90:	609a      	str	r2, [r3, #8]
  }

#if defined(SPI_I2SCFGR_I2SMOD)
  /* Activate the SPI mode (Make sure that I2SMOD bit in I2SCFGR register is reset) */
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8103c92:	687b      	ldr	r3, [r7, #4]
 8103c94:	681b      	ldr	r3, [r3, #0]
 8103c96:	6d1a      	ldr	r2, [r3, #80]	@ 0x50
 8103c98:	687b      	ldr	r3, [r7, #4]
 8103c9a:	681b      	ldr	r3, [r3, #0]
 8103c9c:	f022 0201 	bic.w	r2, r2, #1
 8103ca0:	651a      	str	r2, [r3, #80]	@ 0x50
#endif /* SPI_I2SCFGR_I2SMOD */

  /* Insure that AFCNTR is managed only by Master */
  if ((hspi->Init.Mode & SPI_MODE_MASTER) == SPI_MODE_MASTER)
 8103ca2:	687b      	ldr	r3, [r7, #4]
 8103ca4:	685b      	ldr	r3, [r3, #4]
 8103ca6:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
 8103caa:	2b00      	cmp	r3, #0
 8103cac:	d00a      	beq.n	8103cc4 <HAL_SPI_Init+0x220>
  {
    /* Alternate function GPIOs control */
    MODIFY_REG(hspi->Instance->CFG2, SPI_CFG2_AFCNTR, (hspi->Init.MasterKeepIOState));
 8103cae:	687b      	ldr	r3, [r7, #4]
 8103cb0:	681b      	ldr	r3, [r3, #0]
 8103cb2:	68db      	ldr	r3, [r3, #12]
 8103cb4:	f023 4100 	bic.w	r1, r3, #2147483648	@ 0x80000000
 8103cb8:	687b      	ldr	r3, [r7, #4]
 8103cba:	6d5a      	ldr	r2, [r3, #84]	@ 0x54
 8103cbc:	687b      	ldr	r3, [r7, #4]
 8103cbe:	681b      	ldr	r3, [r3, #0]
 8103cc0:	430a      	orrs	r2, r1
 8103cc2:	60da      	str	r2, [r3, #12]
  }

  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8103cc4:	687b      	ldr	r3, [r7, #4]
 8103cc6:	2200      	movs	r2, #0
 8103cc8:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  hspi->State     = HAL_SPI_STATE_READY;
 8103ccc:	687b      	ldr	r3, [r7, #4]
 8103cce:	2201      	movs	r2, #1
 8103cd0:	f883 2081 	strb.w	r2, [r3, #129]	@ 0x81

  return HAL_OK;
 8103cd4:	2300      	movs	r3, #0
}
 8103cd6:	4618      	mov	r0, r3
 8103cd8:	3710      	adds	r7, #16
 8103cda:	46bd      	mov	sp, r7
 8103cdc:	bd80      	pop	{r7, pc}
 8103cde:	bf00      	nop
 8103ce0:	40013000 	.word	0x40013000
 8103ce4:	40003800 	.word	0x40003800
 8103ce8:	40003c00 	.word	0x40003c00

08103cec <HAL_SPI_TransmitReceive>:
  * @param  Timeout: Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SPI_TransmitReceive(SPI_HandleTypeDef *hspi, const uint8_t *pTxData, uint8_t *pRxData,
                                          uint16_t Size, uint32_t Timeout)
{
 8103cec:	b580      	push	{r7, lr}
 8103cee:	b08e      	sub	sp, #56	@ 0x38
 8103cf0:	af02      	add	r7, sp, #8
 8103cf2:	60f8      	str	r0, [r7, #12]
 8103cf4:	60b9      	str	r1, [r7, #8]
 8103cf6:	607a      	str	r2, [r7, #4]
 8103cf8:	807b      	strh	r3, [r7, #2]
#if defined (__GNUC__)
  __IO uint16_t *ptxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->TXDR));
 8103cfa:	68fb      	ldr	r3, [r7, #12]
 8103cfc:	681b      	ldr	r3, [r3, #0]
 8103cfe:	3320      	adds	r3, #32
 8103d00:	627b      	str	r3, [r7, #36]	@ 0x24
  __IO uint16_t *prxdr_16bits = (__IO uint16_t *)(&(hspi->Instance->RXDR));
 8103d02:	68fb      	ldr	r3, [r7, #12]
 8103d04:	681b      	ldr	r3, [r3, #0]
 8103d06:	3330      	adds	r3, #48	@ 0x30
 8103d08:	623b      	str	r3, [r7, #32]
  uint32_t   fifo_length;
  uint32_t   temp_sr_reg;
  uint16_t   initial_TxXferCount;
  uint16_t   initial_RxXferCount;
  uint16_t   init_max_data_in_fifo;
  init_max_data_in_fifo = (((uint16_t)(hspi->Init.FifoThreshold >> 5U) + 1U));
 8103d0a:	68fb      	ldr	r3, [r7, #12]
 8103d0c:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8103d0e:	095b      	lsrs	r3, r3, #5
 8103d10:	b29b      	uxth	r3, r3
 8103d12:	3301      	adds	r3, #1
 8103d14:	83fb      	strh	r3, [r7, #30]

  /* Check Direction parameter */
  assert_param(IS_SPI_DIRECTION_2LINES(hspi->Init.Direction));

  /* Init tickstart for timeout management*/
  tickstart = HAL_GetTick();
 8103d16:	f7fd fd5b 	bl	81017d0 <HAL_GetTick>
 8103d1a:	61b8      	str	r0, [r7, #24]

  initial_TxXferCount = Size;
 8103d1c:	887b      	ldrh	r3, [r7, #2]
 8103d1e:	857b      	strh	r3, [r7, #42]	@ 0x2a
  initial_RxXferCount = Size;
 8103d20:	887b      	ldrh	r3, [r7, #2]
 8103d22:	853b      	strh	r3, [r7, #40]	@ 0x28

  if (hspi->State != HAL_SPI_STATE_READY)
 8103d24:	68fb      	ldr	r3, [r7, #12]
 8103d26:	f893 3081 	ldrb.w	r3, [r3, #129]	@ 0x81
 8103d2a:	b2db      	uxtb	r3, r3
 8103d2c:	2b01      	cmp	r3, #1
 8103d2e:	d001      	beq.n	8103d34 <HAL_SPI_TransmitReceive+0x48>
  {
    return HAL_BUSY;
 8103d30:	2302      	movs	r3, #2
 8103d32:	e30e      	b.n	8104352 <HAL_SPI_TransmitReceive+0x666>
  }

  if ((pTxData == NULL) || (pRxData == NULL) || (Size == 0UL))
 8103d34:	68bb      	ldr	r3, [r7, #8]
 8103d36:	2b00      	cmp	r3, #0
 8103d38:	d005      	beq.n	8103d46 <HAL_SPI_TransmitReceive+0x5a>
 8103d3a:	687b      	ldr	r3, [r7, #4]
 8103d3c:	2b00      	cmp	r3, #0
 8103d3e:	d002      	beq.n	8103d46 <HAL_SPI_TransmitReceive+0x5a>
 8103d40:	887b      	ldrh	r3, [r7, #2]
 8103d42:	2b00      	cmp	r3, #0
 8103d44:	d101      	bne.n	8103d4a <HAL_SPI_TransmitReceive+0x5e>
  {
    return HAL_ERROR;
 8103d46:	2301      	movs	r3, #1
 8103d48:	e303      	b.n	8104352 <HAL_SPI_TransmitReceive+0x666>
  }

  /* Lock the process */
  __HAL_LOCK(hspi);
 8103d4a:	68fb      	ldr	r3, [r7, #12]
 8103d4c:	f893 3080 	ldrb.w	r3, [r3, #128]	@ 0x80
 8103d50:	2b01      	cmp	r3, #1
 8103d52:	d101      	bne.n	8103d58 <HAL_SPI_TransmitReceive+0x6c>
 8103d54:	2302      	movs	r3, #2
 8103d56:	e2fc      	b.n	8104352 <HAL_SPI_TransmitReceive+0x666>
 8103d58:	68fb      	ldr	r3, [r7, #12]
 8103d5a:	2201      	movs	r2, #1
 8103d5c:	f883 2080 	strb.w	r2, [r3, #128]	@ 0x80

  /* Set the transaction information */
  hspi->State       = HAL_SPI_STATE_BUSY_TX_RX;
 8103d60:	68fb      	ldr	r3, [r7, #12]
 8103d62:	2205      	movs	r2, #5
 8103d64:	f883 2081 	strb.w	r2, [r3, #129]	@ 0x81
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8103d68:	68fb      	ldr	r3, [r7, #12]
 8103d6a:	2200      	movs	r2, #0
 8103d6c:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  hspi->pRxBuffPtr  = (uint8_t *)pRxData;
 8103d70:	68fb      	ldr	r3, [r7, #12]
 8103d72:	687a      	ldr	r2, [r7, #4]
 8103d74:	665a      	str	r2, [r3, #100]	@ 0x64
  hspi->RxXferCount = Size;
 8103d76:	68fb      	ldr	r3, [r7, #12]
 8103d78:	887a      	ldrh	r2, [r7, #2]
 8103d7a:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  hspi->RxXferSize  = Size;
 8103d7e:	68fb      	ldr	r3, [r7, #12]
 8103d80:	887a      	ldrh	r2, [r7, #2]
 8103d82:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
  hspi->pTxBuffPtr  = (const uint8_t *)pTxData;
 8103d86:	68fb      	ldr	r3, [r7, #12]
 8103d88:	68ba      	ldr	r2, [r7, #8]
 8103d8a:	65da      	str	r2, [r3, #92]	@ 0x5c
  hspi->TxXferCount = Size;
 8103d8c:	68fb      	ldr	r3, [r7, #12]
 8103d8e:	887a      	ldrh	r2, [r7, #2]
 8103d90:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
  hspi->TxXferSize  = Size;
 8103d94:	68fb      	ldr	r3, [r7, #12]
 8103d96:	887a      	ldrh	r2, [r7, #2]
 8103d98:	f8a3 2060 	strh.w	r2, [r3, #96]	@ 0x60

  /*Init field not used in handle to zero */
  hspi->RxISR       = NULL;
 8103d9c:	68fb      	ldr	r3, [r7, #12]
 8103d9e:	2200      	movs	r2, #0
 8103da0:	671a      	str	r2, [r3, #112]	@ 0x70
  hspi->TxISR       = NULL;
 8103da2:	68fb      	ldr	r3, [r7, #12]
 8103da4:	2200      	movs	r2, #0
 8103da6:	675a      	str	r2, [r3, #116]	@ 0x74

  /* Set Full-Duplex mode */
  SPI_2LINES(hspi);
 8103da8:	68fb      	ldr	r3, [r7, #12]
 8103daa:	681b      	ldr	r3, [r3, #0]
 8103dac:	68da      	ldr	r2, [r3, #12]
 8103dae:	68fb      	ldr	r3, [r7, #12]
 8103db0:	681b      	ldr	r3, [r3, #0]
 8103db2:	f422 22c0 	bic.w	r2, r2, #393216	@ 0x60000
 8103db6:	60da      	str	r2, [r3, #12]

  /* Initialize FIFO length */
  if (IS_SPI_HIGHEND_INSTANCE(hspi->Instance))
 8103db8:	68fb      	ldr	r3, [r7, #12]
 8103dba:	681b      	ldr	r3, [r3, #0]
 8103dbc:	4a70      	ldr	r2, [pc, #448]	@ (8103f80 <HAL_SPI_TransmitReceive+0x294>)
 8103dbe:	4293      	cmp	r3, r2
 8103dc0:	d009      	beq.n	8103dd6 <HAL_SPI_TransmitReceive+0xea>
 8103dc2:	68fb      	ldr	r3, [r7, #12]
 8103dc4:	681b      	ldr	r3, [r3, #0]
 8103dc6:	4a6f      	ldr	r2, [pc, #444]	@ (8103f84 <HAL_SPI_TransmitReceive+0x298>)
 8103dc8:	4293      	cmp	r3, r2
 8103dca:	d004      	beq.n	8103dd6 <HAL_SPI_TransmitReceive+0xea>
 8103dcc:	68fb      	ldr	r3, [r7, #12]
 8103dce:	681b      	ldr	r3, [r3, #0]
 8103dd0:	4a6d      	ldr	r2, [pc, #436]	@ (8103f88 <HAL_SPI_TransmitReceive+0x29c>)
 8103dd2:	4293      	cmp	r3, r2
 8103dd4:	d102      	bne.n	8103ddc <HAL_SPI_TransmitReceive+0xf0>
  {
    fifo_length = SPI_HIGHEND_FIFO_SIZE;
 8103dd6:	2310      	movs	r3, #16
 8103dd8:	62fb      	str	r3, [r7, #44]	@ 0x2c
 8103dda:	e001      	b.n	8103de0 <HAL_SPI_TransmitReceive+0xf4>
  }
  else
  {
    fifo_length = SPI_LOWEND_FIFO_SIZE;
 8103ddc:	2308      	movs	r3, #8
 8103dde:	62fb      	str	r3, [r7, #44]	@ 0x2c
  }

  /* Set the number of data at current transfer */
  MODIFY_REG(hspi->Instance->CR2, SPI_CR2_TSIZE, Size);
 8103de0:	68fb      	ldr	r3, [r7, #12]
 8103de2:	681b      	ldr	r3, [r3, #0]
 8103de4:	685b      	ldr	r3, [r3, #4]
 8103de6:	0c1b      	lsrs	r3, r3, #16
 8103de8:	041b      	lsls	r3, r3, #16
 8103dea:	8879      	ldrh	r1, [r7, #2]
 8103dec:	68fa      	ldr	r2, [r7, #12]
 8103dee:	6812      	ldr	r2, [r2, #0]
 8103df0:	430b      	orrs	r3, r1
 8103df2:	6053      	str	r3, [r2, #4]

  __HAL_SPI_ENABLE(hspi);
 8103df4:	68fb      	ldr	r3, [r7, #12]
 8103df6:	681b      	ldr	r3, [r3, #0]
 8103df8:	681a      	ldr	r2, [r3, #0]
 8103dfa:	68fb      	ldr	r3, [r7, #12]
 8103dfc:	681b      	ldr	r3, [r3, #0]
 8103dfe:	f042 0201 	orr.w	r2, r2, #1
 8103e02:	601a      	str	r2, [r3, #0]

  if (hspi->Init.Mode == SPI_MODE_MASTER)
 8103e04:	68fb      	ldr	r3, [r7, #12]
 8103e06:	685b      	ldr	r3, [r3, #4]
 8103e08:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
 8103e0c:	d107      	bne.n	8103e1e <HAL_SPI_TransmitReceive+0x132>
  {
    /* Master transfer start */
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CSTART);
 8103e0e:	68fb      	ldr	r3, [r7, #12]
 8103e10:	681b      	ldr	r3, [r3, #0]
 8103e12:	681a      	ldr	r2, [r3, #0]
 8103e14:	68fb      	ldr	r3, [r7, #12]
 8103e16:	681b      	ldr	r3, [r3, #0]
 8103e18:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8103e1c:	601a      	str	r2, [r3, #0]
  }

  /* Transmit and Receive data in 32 Bit mode */
  if (hspi->Init.DataSize > SPI_DATASIZE_16BIT)
 8103e1e:	68fb      	ldr	r3, [r7, #12]
 8103e20:	68db      	ldr	r3, [r3, #12]
 8103e22:	2b0f      	cmp	r3, #15
 8103e24:	f240 80a2 	bls.w	8103f6c <HAL_SPI_TransmitReceive+0x280>
  {
    /* Adapt fifo length to 32bits data width */
    fifo_length = (fifo_length / 4UL);
 8103e28:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8103e2a:	089b      	lsrs	r3, r3, #2
 8103e2c:	62fb      	str	r3, [r7, #44]	@ 0x2c

    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8103e2e:	e094      	b.n	8103f5a <HAL_SPI_TransmitReceive+0x26e>
    {
      /* Check TXP flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL) &&
 8103e30:	68fb      	ldr	r3, [r7, #12]
 8103e32:	681b      	ldr	r3, [r3, #0]
 8103e34:	695b      	ldr	r3, [r3, #20]
 8103e36:	f003 0302 	and.w	r3, r3, #2
 8103e3a:	2b02      	cmp	r3, #2
 8103e3c:	d120      	bne.n	8103e80 <HAL_SPI_TransmitReceive+0x194>
 8103e3e:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8103e40:	2b00      	cmp	r3, #0
 8103e42:	d01d      	beq.n	8103e80 <HAL_SPI_TransmitReceive+0x194>
          (initial_RxXferCount  < (initial_TxXferCount + fifo_length)))
 8103e44:	8d3a      	ldrh	r2, [r7, #40]	@ 0x28
 8103e46:	8d79      	ldrh	r1, [r7, #42]	@ 0x2a
 8103e48:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8103e4a:	440b      	add	r3, r1
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL) &&
 8103e4c:	429a      	cmp	r2, r3
 8103e4e:	d217      	bcs.n	8103e80 <HAL_SPI_TransmitReceive+0x194>
      {
        *((__IO uint32_t *)&hspi->Instance->TXDR) = *((const uint32_t *)hspi->pTxBuffPtr);
 8103e50:	68fb      	ldr	r3, [r7, #12]
 8103e52:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 8103e54:	68fb      	ldr	r3, [r7, #12]
 8103e56:	681b      	ldr	r3, [r3, #0]
 8103e58:	6812      	ldr	r2, [r2, #0]
 8103e5a:	621a      	str	r2, [r3, #32]
        hspi->pTxBuffPtr += sizeof(uint32_t);
 8103e5c:	68fb      	ldr	r3, [r7, #12]
 8103e5e:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8103e60:	1d1a      	adds	r2, r3, #4
 8103e62:	68fb      	ldr	r3, [r7, #12]
 8103e64:	65da      	str	r2, [r3, #92]	@ 0x5c
        hspi->TxXferCount --;
 8103e66:	68fb      	ldr	r3, [r7, #12]
 8103e68:	f8b3 3062 	ldrh.w	r3, [r3, #98]	@ 0x62
 8103e6c:	b29b      	uxth	r3, r3
 8103e6e:	3b01      	subs	r3, #1
 8103e70:	b29a      	uxth	r2, r3
 8103e72:	68fb      	ldr	r3, [r7, #12]
 8103e74:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
        initial_TxXferCount = hspi->TxXferCount;
 8103e78:	68fb      	ldr	r3, [r7, #12]
 8103e7a:	f8b3 3062 	ldrh.w	r3, [r3, #98]	@ 0x62
 8103e7e:	857b      	strh	r3, [r7, #42]	@ 0x2a
      }

      /* Evaluate state of SR register */
      temp_sr_reg = hspi->Instance->SR;
 8103e80:	68fb      	ldr	r3, [r7, #12]
 8103e82:	681b      	ldr	r3, [r3, #0]
 8103e84:	695b      	ldr	r3, [r3, #20]
 8103e86:	617b      	str	r3, [r7, #20]

      if (initial_RxXferCount > 0UL)
 8103e88:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8103e8a:	2b00      	cmp	r3, #0
 8103e8c:	d065      	beq.n	8103f5a <HAL_SPI_TransmitReceive+0x26e>
      {
        /* Check the RXP flag */
        if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXP))
 8103e8e:	68fb      	ldr	r3, [r7, #12]
 8103e90:	681b      	ldr	r3, [r3, #0]
 8103e92:	695b      	ldr	r3, [r3, #20]
 8103e94:	f003 0301 	and.w	r3, r3, #1
 8103e98:	2b01      	cmp	r3, #1
 8103e9a:	d118      	bne.n	8103ece <HAL_SPI_TransmitReceive+0x1e2>
        {
          *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);
 8103e9c:	68fb      	ldr	r3, [r7, #12]
 8103e9e:	681a      	ldr	r2, [r3, #0]
 8103ea0:	68fb      	ldr	r3, [r7, #12]
 8103ea2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8103ea4:	6b12      	ldr	r2, [r2, #48]	@ 0x30
 8103ea6:	601a      	str	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint32_t);
 8103ea8:	68fb      	ldr	r3, [r7, #12]
 8103eaa:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8103eac:	1d1a      	adds	r2, r3, #4
 8103eae:	68fb      	ldr	r3, [r7, #12]
 8103eb0:	665a      	str	r2, [r3, #100]	@ 0x64
          hspi->RxXferCount--;
 8103eb2:	68fb      	ldr	r3, [r7, #12]
 8103eb4:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8103eb8:	b29b      	uxth	r3, r3
 8103eba:	3b01      	subs	r3, #1
 8103ebc:	b29a      	uxth	r2, r3
 8103ebe:	68fb      	ldr	r3, [r7, #12]
 8103ec0:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 8103ec4:	68fb      	ldr	r3, [r7, #12]
 8103ec6:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8103eca:	853b      	strh	r3, [r7, #40]	@ 0x28
 8103ecc:	e045      	b.n	8103f5a <HAL_SPI_TransmitReceive+0x26e>
        }
        /* Check RXWNE flag if RXP cannot be reached */
        else if ((initial_RxXferCount < init_max_data_in_fifo) && ((temp_sr_reg & SPI_SR_RXWNE_Msk) != 0UL))
 8103ece:	8d3a      	ldrh	r2, [r7, #40]	@ 0x28
 8103ed0:	8bfb      	ldrh	r3, [r7, #30]
 8103ed2:	429a      	cmp	r2, r3
 8103ed4:	d21d      	bcs.n	8103f12 <HAL_SPI_TransmitReceive+0x226>
 8103ed6:	697b      	ldr	r3, [r7, #20]
 8103ed8:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8103edc:	2b00      	cmp	r3, #0
 8103ede:	d018      	beq.n	8103f12 <HAL_SPI_TransmitReceive+0x226>
        {
          *((uint32_t *)hspi->pRxBuffPtr) = *((__IO uint32_t *)&hspi->Instance->RXDR);
 8103ee0:	68fb      	ldr	r3, [r7, #12]
 8103ee2:	681a      	ldr	r2, [r3, #0]
 8103ee4:	68fb      	ldr	r3, [r7, #12]
 8103ee6:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8103ee8:	6b12      	ldr	r2, [r2, #48]	@ 0x30
 8103eea:	601a      	str	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint32_t);
 8103eec:	68fb      	ldr	r3, [r7, #12]
 8103eee:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8103ef0:	1d1a      	adds	r2, r3, #4
 8103ef2:	68fb      	ldr	r3, [r7, #12]
 8103ef4:	665a      	str	r2, [r3, #100]	@ 0x64
          hspi->RxXferCount--;
 8103ef6:	68fb      	ldr	r3, [r7, #12]
 8103ef8:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8103efc:	b29b      	uxth	r3, r3
 8103efe:	3b01      	subs	r3, #1
 8103f00:	b29a      	uxth	r2, r3
 8103f02:	68fb      	ldr	r3, [r7, #12]
 8103f04:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 8103f08:	68fb      	ldr	r3, [r7, #12]
 8103f0a:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8103f0e:	853b      	strh	r3, [r7, #40]	@ 0x28
 8103f10:	e023      	b.n	8103f5a <HAL_SPI_TransmitReceive+0x26e>
        }
        else
        {
          /* Timeout management */
          if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8103f12:	f7fd fc5d 	bl	81017d0 <HAL_GetTick>
 8103f16:	4602      	mov	r2, r0
 8103f18:	69bb      	ldr	r3, [r7, #24]
 8103f1a:	1ad3      	subs	r3, r2, r3
 8103f1c:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 8103f1e:	429a      	cmp	r2, r3
 8103f20:	d803      	bhi.n	8103f2a <HAL_SPI_TransmitReceive+0x23e>
 8103f22:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8103f24:	f1b3 3fff 	cmp.w	r3, #4294967295
 8103f28:	d102      	bne.n	8103f30 <HAL_SPI_TransmitReceive+0x244>
 8103f2a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 8103f2c:	2b00      	cmp	r3, #0
 8103f2e:	d114      	bne.n	8103f5a <HAL_SPI_TransmitReceive+0x26e>
          {
            /* Call standard close procedure with error check */
            SPI_CloseTransfer(hspi);
 8103f30:	68f8      	ldr	r0, [r7, #12]
 8103f32:	f000 fa13 	bl	810435c <SPI_CloseTransfer>

            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);
 8103f36:	68fb      	ldr	r3, [r7, #12]
 8103f38:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8103f3c:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
 8103f40:	68fb      	ldr	r3, [r7, #12]
 8103f42:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
            hspi->State = HAL_SPI_STATE_READY;
 8103f46:	68fb      	ldr	r3, [r7, #12]
 8103f48:	2201      	movs	r2, #1
 8103f4a:	f883 2081 	strb.w	r2, [r3, #129]	@ 0x81

            /* Unlock the process */
            __HAL_UNLOCK(hspi);
 8103f4e:	68fb      	ldr	r3, [r7, #12]
 8103f50:	2200      	movs	r2, #0
 8103f52:	f883 2080 	strb.w	r2, [r3, #128]	@ 0x80

            return HAL_TIMEOUT;
 8103f56:	2303      	movs	r3, #3
 8103f58:	e1fb      	b.n	8104352 <HAL_SPI_TransmitReceive+0x666>
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8103f5a:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8103f5c:	2b00      	cmp	r3, #0
 8103f5e:	f47f af67 	bne.w	8103e30 <HAL_SPI_TransmitReceive+0x144>
 8103f62:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8103f64:	2b00      	cmp	r3, #0
 8103f66:	f47f af63 	bne.w	8103e30 <HAL_SPI_TransmitReceive+0x144>
 8103f6a:	e1cc      	b.n	8104306 <HAL_SPI_TransmitReceive+0x61a>
        }
      }
    }
  }
  /* Transmit and Receive data in 16 Bit mode */
  else if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8103f6c:	68fb      	ldr	r3, [r7, #12]
 8103f6e:	68db      	ldr	r3, [r3, #12]
 8103f70:	2b07      	cmp	r3, #7
 8103f72:	f240 81c0 	bls.w	81042f6 <HAL_SPI_TransmitReceive+0x60a>
  {
    /* Adapt fifo length to 16bits data width */
    fifo_length = (fifo_length / 2UL);
 8103f76:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8103f78:	085b      	lsrs	r3, r3, #1
 8103f7a:	62fb      	str	r3, [r7, #44]	@ 0x2c

    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 8103f7c:	e0c7      	b.n	810410e <HAL_SPI_TransmitReceive+0x422>
 8103f7e:	bf00      	nop
 8103f80:	40013000 	.word	0x40013000
 8103f84:	40003800 	.word	0x40003800
 8103f88:	40003c00 	.word	0x40003c00
    {
      /* Check the TXP flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL) &&
 8103f8c:	68fb      	ldr	r3, [r7, #12]
 8103f8e:	681b      	ldr	r3, [r3, #0]
 8103f90:	695b      	ldr	r3, [r3, #20]
 8103f92:	f003 0302 	and.w	r3, r3, #2
 8103f96:	2b02      	cmp	r3, #2
 8103f98:	d11f      	bne.n	8103fda <HAL_SPI_TransmitReceive+0x2ee>
 8103f9a:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8103f9c:	2b00      	cmp	r3, #0
 8103f9e:	d01c      	beq.n	8103fda <HAL_SPI_TransmitReceive+0x2ee>
          (initial_RxXferCount  < (initial_TxXferCount + fifo_length)))
 8103fa0:	8d3a      	ldrh	r2, [r7, #40]	@ 0x28
 8103fa2:	8d79      	ldrh	r1, [r7, #42]	@ 0x2a
 8103fa4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 8103fa6:	440b      	add	r3, r1
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL) &&
 8103fa8:	429a      	cmp	r2, r3
 8103faa:	d216      	bcs.n	8103fda <HAL_SPI_TransmitReceive+0x2ee>
      {
#if defined (__GNUC__)
        *ptxdr_16bits = *((const uint16_t *)hspi->pTxBuffPtr);
 8103fac:	68fb      	ldr	r3, [r7, #12]
 8103fae:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8103fb0:	881a      	ldrh	r2, [r3, #0]
 8103fb2:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8103fb4:	801a      	strh	r2, [r3, #0]
#else
        *((__IO uint16_t *)&hspi->Instance->TXDR) = *((const uint16_t *)hspi->pTxBuffPtr);
#endif /* __GNUC__ */
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8103fb6:	68fb      	ldr	r3, [r7, #12]
 8103fb8:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8103fba:	1c9a      	adds	r2, r3, #2
 8103fbc:	68fb      	ldr	r3, [r7, #12]
 8103fbe:	65da      	str	r2, [r3, #92]	@ 0x5c
        hspi->TxXferCount--;
 8103fc0:	68fb      	ldr	r3, [r7, #12]
 8103fc2:	f8b3 3062 	ldrh.w	r3, [r3, #98]	@ 0x62
 8103fc6:	b29b      	uxth	r3, r3
 8103fc8:	3b01      	subs	r3, #1
 8103fca:	b29a      	uxth	r2, r3
 8103fcc:	68fb      	ldr	r3, [r7, #12]
 8103fce:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
        initial_TxXferCount = hspi->TxXferCount;
 8103fd2:	68fb      	ldr	r3, [r7, #12]
 8103fd4:	f8b3 3062 	ldrh.w	r3, [r3, #98]	@ 0x62
 8103fd8:	857b      	strh	r3, [r7, #42]	@ 0x2a
      }

      /* Evaluate state of SR register */
      temp_sr_reg = hspi->Instance->SR;
 8103fda:	68fb      	ldr	r3, [r7, #12]
 8103fdc:	681b      	ldr	r3, [r3, #0]
 8103fde:	695b      	ldr	r3, [r3, #20]
 8103fe0:	617b      	str	r3, [r7, #20]

      if (initial_RxXferCount > 0UL)
 8103fe2:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8103fe4:	2b00      	cmp	r3, #0
 8103fe6:	f000 8092 	beq.w	810410e <HAL_SPI_TransmitReceive+0x422>
      {
        /* Check the RXP flag */
        if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXP))
 8103fea:	68fb      	ldr	r3, [r7, #12]
 8103fec:	681b      	ldr	r3, [r3, #0]
 8103fee:	695b      	ldr	r3, [r3, #20]
 8103ff0:	f003 0301 	and.w	r3, r3, #1
 8103ff4:	2b01      	cmp	r3, #1
 8103ff6:	d118      	bne.n	810402a <HAL_SPI_TransmitReceive+0x33e>
        {
#if defined (__GNUC__)
          *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;
 8103ff8:	68fb      	ldr	r3, [r7, #12]
 8103ffa:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8103ffc:	6a3a      	ldr	r2, [r7, #32]
 8103ffe:	8812      	ldrh	r2, [r2, #0]
 8104000:	b292      	uxth	r2, r2
 8104002:	801a      	strh	r2, [r3, #0]
#else
          *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);
#endif /* __GNUC__ */
          hspi->pRxBuffPtr += sizeof(uint16_t);
 8104004:	68fb      	ldr	r3, [r7, #12]
 8104006:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8104008:	1c9a      	adds	r2, r3, #2
 810400a:	68fb      	ldr	r3, [r7, #12]
 810400c:	665a      	str	r2, [r3, #100]	@ 0x64
          hspi->RxXferCount--;
 810400e:	68fb      	ldr	r3, [r7, #12]
 8104010:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8104014:	b29b      	uxth	r3, r3
 8104016:	3b01      	subs	r3, #1
 8104018:	b29a      	uxth	r2, r3
 810401a:	68fb      	ldr	r3, [r7, #12]
 810401c:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 8104020:	68fb      	ldr	r3, [r7, #12]
 8104022:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8104026:	853b      	strh	r3, [r7, #40]	@ 0x28
 8104028:	e071      	b.n	810410e <HAL_SPI_TransmitReceive+0x422>
        }
        /* Check RXWNE flag if RXP cannot be reached */
        else if ((initial_RxXferCount < init_max_data_in_fifo) && ((temp_sr_reg & SPI_SR_RXWNE_Msk) != 0UL))
 810402a:	8d3a      	ldrh	r2, [r7, #40]	@ 0x28
 810402c:	8bfb      	ldrh	r3, [r7, #30]
 810402e:	429a      	cmp	r2, r3
 8104030:	d228      	bcs.n	8104084 <HAL_SPI_TransmitReceive+0x398>
 8104032:	697b      	ldr	r3, [r7, #20]
 8104034:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8104038:	2b00      	cmp	r3, #0
 810403a:	d023      	beq.n	8104084 <HAL_SPI_TransmitReceive+0x398>
        {
#if defined (__GNUC__)
          *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;
 810403c:	68fb      	ldr	r3, [r7, #12]
 810403e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8104040:	6a3a      	ldr	r2, [r7, #32]
 8104042:	8812      	ldrh	r2, [r2, #0]
 8104044:	b292      	uxth	r2, r2
 8104046:	801a      	strh	r2, [r3, #0]
#else
          *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);
#endif /* __GNUC__ */
          hspi->pRxBuffPtr += sizeof(uint16_t);
 8104048:	68fb      	ldr	r3, [r7, #12]
 810404a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810404c:	1c9a      	adds	r2, r3, #2
 810404e:	68fb      	ldr	r3, [r7, #12]
 8104050:	665a      	str	r2, [r3, #100]	@ 0x64
#if defined (__GNUC__)
          *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;
 8104052:	68fb      	ldr	r3, [r7, #12]
 8104054:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8104056:	6a3a      	ldr	r2, [r7, #32]
 8104058:	8812      	ldrh	r2, [r2, #0]
 810405a:	b292      	uxth	r2, r2
 810405c:	801a      	strh	r2, [r3, #0]
#else
          *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);
#endif /* __GNUC__ */
          hspi->pRxBuffPtr += sizeof(uint16_t);
 810405e:	68fb      	ldr	r3, [r7, #12]
 8104060:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8104062:	1c9a      	adds	r2, r3, #2
 8104064:	68fb      	ldr	r3, [r7, #12]
 8104066:	665a      	str	r2, [r3, #100]	@ 0x64
          hspi->RxXferCount -= (uint16_t)2UL;
 8104068:	68fb      	ldr	r3, [r7, #12]
 810406a:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 810406e:	b29b      	uxth	r3, r3
 8104070:	3b02      	subs	r3, #2
 8104072:	b29a      	uxth	r2, r3
 8104074:	68fb      	ldr	r3, [r7, #12]
 8104076:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 810407a:	68fb      	ldr	r3, [r7, #12]
 810407c:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8104080:	853b      	strh	r3, [r7, #40]	@ 0x28
 8104082:	e044      	b.n	810410e <HAL_SPI_TransmitReceive+0x422>
        }
        /* Check RXPLVL flags when RXWNE cannot be reached */
        else if ((initial_RxXferCount == 1UL) && ((temp_sr_reg & SPI_SR_RXPLVL_0) != 0UL))
 8104084:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8104086:	2b01      	cmp	r3, #1
 8104088:	d11d      	bne.n	81040c6 <HAL_SPI_TransmitReceive+0x3da>
 810408a:	697b      	ldr	r3, [r7, #20]
 810408c:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
 8104090:	2b00      	cmp	r3, #0
 8104092:	d018      	beq.n	81040c6 <HAL_SPI_TransmitReceive+0x3da>
        {
#if defined (__GNUC__)
          *((uint16_t *)hspi->pRxBuffPtr) = *prxdr_16bits;
 8104094:	68fb      	ldr	r3, [r7, #12]
 8104096:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8104098:	6a3a      	ldr	r2, [r7, #32]
 810409a:	8812      	ldrh	r2, [r2, #0]
 810409c:	b292      	uxth	r2, r2
 810409e:	801a      	strh	r2, [r3, #0]
#else
          *((uint16_t *)hspi->pRxBuffPtr) = *((__IO uint16_t *)&hspi->Instance->RXDR);
#endif /* __GNUC__ */
          hspi->pRxBuffPtr += sizeof(uint16_t);
 81040a0:	68fb      	ldr	r3, [r7, #12]
 81040a2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 81040a4:	1c9a      	adds	r2, r3, #2
 81040a6:	68fb      	ldr	r3, [r7, #12]
 81040a8:	665a      	str	r2, [r3, #100]	@ 0x64
          hspi->RxXferCount--;
 81040aa:	68fb      	ldr	r3, [r7, #12]
 81040ac:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 81040b0:	b29b      	uxth	r3, r3
 81040b2:	3b01      	subs	r3, #1
 81040b4:	b29a      	uxth	r2, r3
 81040b6:	68fb      	ldr	r3, [r7, #12]
 81040b8:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 81040bc:	68fb      	ldr	r3, [r7, #12]
 81040be:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 81040c2:	853b      	strh	r3, [r7, #40]	@ 0x28
 81040c4:	e023      	b.n	810410e <HAL_SPI_TransmitReceive+0x422>
        }
        else
        {
          /* Timeout management */
          if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 81040c6:	f7fd fb83 	bl	81017d0 <HAL_GetTick>
 81040ca:	4602      	mov	r2, r0
 81040cc:	69bb      	ldr	r3, [r7, #24]
 81040ce:	1ad3      	subs	r3, r2, r3
 81040d0:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 81040d2:	429a      	cmp	r2, r3
 81040d4:	d803      	bhi.n	81040de <HAL_SPI_TransmitReceive+0x3f2>
 81040d6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81040d8:	f1b3 3fff 	cmp.w	r3, #4294967295
 81040dc:	d102      	bne.n	81040e4 <HAL_SPI_TransmitReceive+0x3f8>
 81040de:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81040e0:	2b00      	cmp	r3, #0
 81040e2:	d114      	bne.n	810410e <HAL_SPI_TransmitReceive+0x422>
          {
            /* Call standard close procedure with error check */
            SPI_CloseTransfer(hspi);
 81040e4:	68f8      	ldr	r0, [r7, #12]
 81040e6:	f000 f939 	bl	810435c <SPI_CloseTransfer>

            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);
 81040ea:	68fb      	ldr	r3, [r7, #12]
 81040ec:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 81040f0:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
 81040f4:	68fb      	ldr	r3, [r7, #12]
 81040f6:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
            hspi->State = HAL_SPI_STATE_READY;
 81040fa:	68fb      	ldr	r3, [r7, #12]
 81040fc:	2201      	movs	r2, #1
 81040fe:	f883 2081 	strb.w	r2, [r3, #129]	@ 0x81

            /* Unlock the process */
            __HAL_UNLOCK(hspi);
 8104102:	68fb      	ldr	r3, [r7, #12]
 8104104:	2200      	movs	r2, #0
 8104106:	f883 2080 	strb.w	r2, [r3, #128]	@ 0x80

            return HAL_TIMEOUT;
 810410a:	2303      	movs	r3, #3
 810410c:	e121      	b.n	8104352 <HAL_SPI_TransmitReceive+0x666>
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 810410e:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8104110:	2b00      	cmp	r3, #0
 8104112:	f47f af3b 	bne.w	8103f8c <HAL_SPI_TransmitReceive+0x2a0>
 8104116:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8104118:	2b00      	cmp	r3, #0
 810411a:	f47f af37 	bne.w	8103f8c <HAL_SPI_TransmitReceive+0x2a0>
 810411e:	e0f2      	b.n	8104306 <HAL_SPI_TransmitReceive+0x61a>
  else
  {
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
    {
      /* Check the TXP flag */
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL) &&
 8104120:	68fb      	ldr	r3, [r7, #12]
 8104122:	681b      	ldr	r3, [r3, #0]
 8104124:	695b      	ldr	r3, [r3, #20]
 8104126:	f003 0302 	and.w	r3, r3, #2
 810412a:	2b02      	cmp	r3, #2
 810412c:	d121      	bne.n	8104172 <HAL_SPI_TransmitReceive+0x486>
 810412e:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8104130:	2b00      	cmp	r3, #0
 8104132:	d01e      	beq.n	8104172 <HAL_SPI_TransmitReceive+0x486>
          (initial_RxXferCount  < (initial_TxXferCount + fifo_length)))
 8104134:	8d3a      	ldrh	r2, [r7, #40]	@ 0x28
 8104136:	8d79      	ldrh	r1, [r7, #42]	@ 0x2a
 8104138:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810413a:	440b      	add	r3, r1
      if ((__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXP)) && (initial_TxXferCount > 0UL) &&
 810413c:	429a      	cmp	r2, r3
 810413e:	d218      	bcs.n	8104172 <HAL_SPI_TransmitReceive+0x486>
      {
        *((__IO uint8_t *)&hspi->Instance->TXDR) = *((const uint8_t *)hspi->pTxBuffPtr);
 8104140:	68fb      	ldr	r3, [r7, #12]
 8104142:	6dda      	ldr	r2, [r3, #92]	@ 0x5c
 8104144:	68fb      	ldr	r3, [r7, #12]
 8104146:	681b      	ldr	r3, [r3, #0]
 8104148:	3320      	adds	r3, #32
 810414a:	7812      	ldrb	r2, [r2, #0]
 810414c:	701a      	strb	r2, [r3, #0]
        hspi->pTxBuffPtr += sizeof(uint8_t);
 810414e:	68fb      	ldr	r3, [r7, #12]
 8104150:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 8104152:	1c5a      	adds	r2, r3, #1
 8104154:	68fb      	ldr	r3, [r7, #12]
 8104156:	65da      	str	r2, [r3, #92]	@ 0x5c
        hspi->TxXferCount--;
 8104158:	68fb      	ldr	r3, [r7, #12]
 810415a:	f8b3 3062 	ldrh.w	r3, [r3, #98]	@ 0x62
 810415e:	b29b      	uxth	r3, r3
 8104160:	3b01      	subs	r3, #1
 8104162:	b29a      	uxth	r2, r3
 8104164:	68fb      	ldr	r3, [r7, #12]
 8104166:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
        initial_TxXferCount = hspi->TxXferCount;
 810416a:	68fb      	ldr	r3, [r7, #12]
 810416c:	f8b3 3062 	ldrh.w	r3, [r3, #98]	@ 0x62
 8104170:	857b      	strh	r3, [r7, #42]	@ 0x2a
      }

      /* Evaluate state of SR register */
      temp_sr_reg = hspi->Instance->SR;
 8104172:	68fb      	ldr	r3, [r7, #12]
 8104174:	681b      	ldr	r3, [r3, #0]
 8104176:	695b      	ldr	r3, [r3, #20]
 8104178:	617b      	str	r3, [r7, #20]

      if (initial_RxXferCount > 0UL)
 810417a:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 810417c:	2b00      	cmp	r3, #0
 810417e:	f000 80ba 	beq.w	81042f6 <HAL_SPI_TransmitReceive+0x60a>
      {
        /* Check the RXP flag */
        if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_RXP))
 8104182:	68fb      	ldr	r3, [r7, #12]
 8104184:	681b      	ldr	r3, [r3, #0]
 8104186:	695b      	ldr	r3, [r3, #20]
 8104188:	f003 0301 	and.w	r3, r3, #1
 810418c:	2b01      	cmp	r3, #1
 810418e:	d11b      	bne.n	81041c8 <HAL_SPI_TransmitReceive+0x4dc>
        {
          *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);
 8104190:	68fb      	ldr	r3, [r7, #12]
 8104192:	681b      	ldr	r3, [r3, #0]
 8104194:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 8104198:	68fb      	ldr	r3, [r7, #12]
 810419a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810419c:	7812      	ldrb	r2, [r2, #0]
 810419e:	b2d2      	uxtb	r2, r2
 81041a0:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint8_t);
 81041a2:	68fb      	ldr	r3, [r7, #12]
 81041a4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 81041a6:	1c5a      	adds	r2, r3, #1
 81041a8:	68fb      	ldr	r3, [r7, #12]
 81041aa:	665a      	str	r2, [r3, #100]	@ 0x64
          hspi->RxXferCount--;
 81041ac:	68fb      	ldr	r3, [r7, #12]
 81041ae:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 81041b2:	b29b      	uxth	r3, r3
 81041b4:	3b01      	subs	r3, #1
 81041b6:	b29a      	uxth	r2, r3
 81041b8:	68fb      	ldr	r3, [r7, #12]
 81041ba:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 81041be:	68fb      	ldr	r3, [r7, #12]
 81041c0:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 81041c4:	853b      	strh	r3, [r7, #40]	@ 0x28
 81041c6:	e096      	b.n	81042f6 <HAL_SPI_TransmitReceive+0x60a>
        }
        /* Check RXWNE flag if RXP cannot be reached */
        else if ((initial_RxXferCount < init_max_data_in_fifo) && ((temp_sr_reg & SPI_SR_RXWNE_Msk) != 0UL))
 81041c8:	8d3a      	ldrh	r2, [r7, #40]	@ 0x28
 81041ca:	8bfb      	ldrh	r3, [r7, #30]
 81041cc:	429a      	cmp	r2, r3
 81041ce:	d24a      	bcs.n	8104266 <HAL_SPI_TransmitReceive+0x57a>
 81041d0:	697b      	ldr	r3, [r7, #20]
 81041d2:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 81041d6:	2b00      	cmp	r3, #0
 81041d8:	d045      	beq.n	8104266 <HAL_SPI_TransmitReceive+0x57a>
        {
          *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);
 81041da:	68fb      	ldr	r3, [r7, #12]
 81041dc:	681b      	ldr	r3, [r3, #0]
 81041de:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 81041e2:	68fb      	ldr	r3, [r7, #12]
 81041e4:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 81041e6:	7812      	ldrb	r2, [r2, #0]
 81041e8:	b2d2      	uxtb	r2, r2
 81041ea:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint8_t);
 81041ec:	68fb      	ldr	r3, [r7, #12]
 81041ee:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 81041f0:	1c5a      	adds	r2, r3, #1
 81041f2:	68fb      	ldr	r3, [r7, #12]
 81041f4:	665a      	str	r2, [r3, #100]	@ 0x64
          *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);
 81041f6:	68fb      	ldr	r3, [r7, #12]
 81041f8:	681b      	ldr	r3, [r3, #0]
 81041fa:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 81041fe:	68fb      	ldr	r3, [r7, #12]
 8104200:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8104202:	7812      	ldrb	r2, [r2, #0]
 8104204:	b2d2      	uxtb	r2, r2
 8104206:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint8_t);
 8104208:	68fb      	ldr	r3, [r7, #12]
 810420a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810420c:	1c5a      	adds	r2, r3, #1
 810420e:	68fb      	ldr	r3, [r7, #12]
 8104210:	665a      	str	r2, [r3, #100]	@ 0x64
          *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);
 8104212:	68fb      	ldr	r3, [r7, #12]
 8104214:	681b      	ldr	r3, [r3, #0]
 8104216:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 810421a:	68fb      	ldr	r3, [r7, #12]
 810421c:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810421e:	7812      	ldrb	r2, [r2, #0]
 8104220:	b2d2      	uxtb	r2, r2
 8104222:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint8_t);
 8104224:	68fb      	ldr	r3, [r7, #12]
 8104226:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8104228:	1c5a      	adds	r2, r3, #1
 810422a:	68fb      	ldr	r3, [r7, #12]
 810422c:	665a      	str	r2, [r3, #100]	@ 0x64
          *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);
 810422e:	68fb      	ldr	r3, [r7, #12]
 8104230:	681b      	ldr	r3, [r3, #0]
 8104232:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 8104236:	68fb      	ldr	r3, [r7, #12]
 8104238:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810423a:	7812      	ldrb	r2, [r2, #0]
 810423c:	b2d2      	uxtb	r2, r2
 810423e:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint8_t);
 8104240:	68fb      	ldr	r3, [r7, #12]
 8104242:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8104244:	1c5a      	adds	r2, r3, #1
 8104246:	68fb      	ldr	r3, [r7, #12]
 8104248:	665a      	str	r2, [r3, #100]	@ 0x64
          hspi->RxXferCount -= (uint16_t)4UL;
 810424a:	68fb      	ldr	r3, [r7, #12]
 810424c:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8104250:	b29b      	uxth	r3, r3
 8104252:	3b04      	subs	r3, #4
 8104254:	b29a      	uxth	r2, r3
 8104256:	68fb      	ldr	r3, [r7, #12]
 8104258:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 810425c:	68fb      	ldr	r3, [r7, #12]
 810425e:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8104262:	853b      	strh	r3, [r7, #40]	@ 0x28
 8104264:	e047      	b.n	81042f6 <HAL_SPI_TransmitReceive+0x60a>
        }
        /* Check RXPLVL flags when RXWNE cannot be reached */
        else if ((initial_RxXferCount < 4UL) && ((temp_sr_reg & SPI_SR_RXPLVL_Msk) != 0UL))
 8104266:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8104268:	2b03      	cmp	r3, #3
 810426a:	d820      	bhi.n	81042ae <HAL_SPI_TransmitReceive+0x5c2>
 810426c:	697b      	ldr	r3, [r7, #20]
 810426e:	f403 43c0 	and.w	r3, r3, #24576	@ 0x6000
 8104272:	2b00      	cmp	r3, #0
 8104274:	d01b      	beq.n	81042ae <HAL_SPI_TransmitReceive+0x5c2>
        {
          *((uint8_t *)hspi->pRxBuffPtr) = *((__IO uint8_t *)&hspi->Instance->RXDR);
 8104276:	68fb      	ldr	r3, [r7, #12]
 8104278:	681b      	ldr	r3, [r3, #0]
 810427a:	f103 0230 	add.w	r2, r3, #48	@ 0x30
 810427e:	68fb      	ldr	r3, [r7, #12]
 8104280:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 8104282:	7812      	ldrb	r2, [r2, #0]
 8104284:	b2d2      	uxtb	r2, r2
 8104286:	701a      	strb	r2, [r3, #0]
          hspi->pRxBuffPtr += sizeof(uint8_t);
 8104288:	68fb      	ldr	r3, [r7, #12]
 810428a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810428c:	1c5a      	adds	r2, r3, #1
 810428e:	68fb      	ldr	r3, [r7, #12]
 8104290:	665a      	str	r2, [r3, #100]	@ 0x64
          hspi->RxXferCount--;
 8104292:	68fb      	ldr	r3, [r7, #12]
 8104294:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 8104298:	b29b      	uxth	r3, r3
 810429a:	3b01      	subs	r3, #1
 810429c:	b29a      	uxth	r2, r3
 810429e:	68fb      	ldr	r3, [r7, #12]
 81042a0:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
          initial_RxXferCount = hspi->RxXferCount;
 81042a4:	68fb      	ldr	r3, [r7, #12]
 81042a6:	f8b3 306a 	ldrh.w	r3, [r3, #106]	@ 0x6a
 81042aa:	853b      	strh	r3, [r7, #40]	@ 0x28
 81042ac:	e023      	b.n	81042f6 <HAL_SPI_TransmitReceive+0x60a>
        }
        else
        {
          /* Timeout management */
          if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 81042ae:	f7fd fa8f 	bl	81017d0 <HAL_GetTick>
 81042b2:	4602      	mov	r2, r0
 81042b4:	69bb      	ldr	r3, [r7, #24]
 81042b6:	1ad3      	subs	r3, r2, r3
 81042b8:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 81042ba:	429a      	cmp	r2, r3
 81042bc:	d803      	bhi.n	81042c6 <HAL_SPI_TransmitReceive+0x5da>
 81042be:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81042c0:	f1b3 3fff 	cmp.w	r3, #4294967295
 81042c4:	d102      	bne.n	81042cc <HAL_SPI_TransmitReceive+0x5e0>
 81042c6:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 81042c8:	2b00      	cmp	r3, #0
 81042ca:	d114      	bne.n	81042f6 <HAL_SPI_TransmitReceive+0x60a>
          {
            /* Call standard close procedure with error check */
            SPI_CloseTransfer(hspi);
 81042cc:	68f8      	ldr	r0, [r7, #12]
 81042ce:	f000 f845 	bl	810435c <SPI_CloseTransfer>

            SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_TIMEOUT);
 81042d2:	68fb      	ldr	r3, [r7, #12]
 81042d4:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 81042d8:	f443 7280 	orr.w	r2, r3, #256	@ 0x100
 81042dc:	68fb      	ldr	r3, [r7, #12]
 81042de:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
            hspi->State = HAL_SPI_STATE_READY;
 81042e2:	68fb      	ldr	r3, [r7, #12]
 81042e4:	2201      	movs	r2, #1
 81042e6:	f883 2081 	strb.w	r2, [r3, #129]	@ 0x81

            /* Unlock the process */
            __HAL_UNLOCK(hspi);
 81042ea:	68fb      	ldr	r3, [r7, #12]
 81042ec:	2200      	movs	r2, #0
 81042ee:	f883 2080 	strb.w	r2, [r3, #128]	@ 0x80

            return HAL_TIMEOUT;
 81042f2:	2303      	movs	r3, #3
 81042f4:	e02d      	b.n	8104352 <HAL_SPI_TransmitReceive+0x666>
    while ((initial_TxXferCount > 0UL) || (initial_RxXferCount > 0UL))
 81042f6:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 81042f8:	2b00      	cmp	r3, #0
 81042fa:	f47f af11 	bne.w	8104120 <HAL_SPI_TransmitReceive+0x434>
 81042fe:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8104300:	2b00      	cmp	r3, #0
 8104302:	f47f af0d 	bne.w	8104120 <HAL_SPI_TransmitReceive+0x434>
      }
    }
  }

  /* Wait for Tx/Rx (and CRC) data to be sent/received */
  if (SPI_WaitOnFlagUntilTimeout(hspi, SPI_FLAG_EOT, RESET, Timeout, tickstart) != HAL_OK)
 8104306:	69bb      	ldr	r3, [r7, #24]
 8104308:	9300      	str	r3, [sp, #0]
 810430a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810430c:	2200      	movs	r2, #0
 810430e:	2108      	movs	r1, #8
 8104310:	68f8      	ldr	r0, [r7, #12]
 8104312:	f000 f8c3 	bl	810449c <SPI_WaitOnFlagUntilTimeout>
 8104316:	4603      	mov	r3, r0
 8104318:	2b00      	cmp	r3, #0
 810431a:	d007      	beq.n	810432c <HAL_SPI_TransmitReceive+0x640>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 810431c:	68fb      	ldr	r3, [r7, #12]
 810431e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8104322:	f043 0220 	orr.w	r2, r3, #32
 8104326:	68fb      	ldr	r3, [r7, #12]
 8104328:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  }

  /* Call standard close procedure with error check */
  SPI_CloseTransfer(hspi);
 810432c:	68f8      	ldr	r0, [r7, #12]
 810432e:	f000 f815 	bl	810435c <SPI_CloseTransfer>

  hspi->State = HAL_SPI_STATE_READY;
 8104332:	68fb      	ldr	r3, [r7, #12]
 8104334:	2201      	movs	r2, #1
 8104336:	f883 2081 	strb.w	r2, [r3, #129]	@ 0x81

  /* Unlock the process */
  __HAL_UNLOCK(hspi);
 810433a:	68fb      	ldr	r3, [r7, #12]
 810433c:	2200      	movs	r2, #0
 810433e:	f883 2080 	strb.w	r2, [r3, #128]	@ 0x80

  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8104342:	68fb      	ldr	r3, [r7, #12]
 8104344:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8104348:	2b00      	cmp	r3, #0
 810434a:	d001      	beq.n	8104350 <HAL_SPI_TransmitReceive+0x664>
  {
    return HAL_ERROR;
 810434c:	2301      	movs	r3, #1
 810434e:	e000      	b.n	8104352 <HAL_SPI_TransmitReceive+0x666>
  }
  else
  {
    return HAL_OK;
 8104350:	2300      	movs	r3, #0
  }
}
 8104352:	4618      	mov	r0, r3
 8104354:	3730      	adds	r7, #48	@ 0x30
 8104356:	46bd      	mov	sp, r7
 8104358:	bd80      	pop	{r7, pc}
 810435a:	bf00      	nop

0810435c <SPI_CloseTransfer>:
  *               the configuration information for SPI module.
  * @retval HAL_ERROR: if any error detected
  *         HAL_OK: if nothing detected
  */
static void SPI_CloseTransfer(SPI_HandleTypeDef *hspi)
{
 810435c:	b480      	push	{r7}
 810435e:	b085      	sub	sp, #20
 8104360:	af00      	add	r7, sp, #0
 8104362:	6078      	str	r0, [r7, #4]
  uint32_t itflag = hspi->Instance->SR;
 8104364:	687b      	ldr	r3, [r7, #4]
 8104366:	681b      	ldr	r3, [r3, #0]
 8104368:	695b      	ldr	r3, [r3, #20]
 810436a:	60fb      	str	r3, [r7, #12]

  __HAL_SPI_CLEAR_EOTFLAG(hspi);
 810436c:	687b      	ldr	r3, [r7, #4]
 810436e:	681b      	ldr	r3, [r3, #0]
 8104370:	699a      	ldr	r2, [r3, #24]
 8104372:	687b      	ldr	r3, [r7, #4]
 8104374:	681b      	ldr	r3, [r3, #0]
 8104376:	f042 0208 	orr.w	r2, r2, #8
 810437a:	619a      	str	r2, [r3, #24]
  __HAL_SPI_CLEAR_TXTFFLAG(hspi);
 810437c:	687b      	ldr	r3, [r7, #4]
 810437e:	681b      	ldr	r3, [r3, #0]
 8104380:	699a      	ldr	r2, [r3, #24]
 8104382:	687b      	ldr	r3, [r7, #4]
 8104384:	681b      	ldr	r3, [r3, #0]
 8104386:	f042 0210 	orr.w	r2, r2, #16
 810438a:	619a      	str	r2, [r3, #24]

  /* Disable SPI peripheral */
  __HAL_SPI_DISABLE(hspi);
 810438c:	687b      	ldr	r3, [r7, #4]
 810438e:	681b      	ldr	r3, [r3, #0]
 8104390:	681a      	ldr	r2, [r3, #0]
 8104392:	687b      	ldr	r3, [r7, #4]
 8104394:	681b      	ldr	r3, [r3, #0]
 8104396:	f022 0201 	bic.w	r2, r2, #1
 810439a:	601a      	str	r2, [r3, #0]

  /* Disable ITs */
  __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_EOT | SPI_IT_TXP | SPI_IT_RXP | SPI_IT_DXP | SPI_IT_UDR | SPI_IT_OVR | \
 810439c:	687b      	ldr	r3, [r7, #4]
 810439e:	681b      	ldr	r3, [r3, #0]
 81043a0:	691b      	ldr	r3, [r3, #16]
 81043a2:	687a      	ldr	r2, [r7, #4]
 81043a4:	6812      	ldr	r2, [r2, #0]
 81043a6:	f423 735b 	bic.w	r3, r3, #876	@ 0x36c
 81043aa:	f023 0303 	bic.w	r3, r3, #3
 81043ae:	6113      	str	r3, [r2, #16]
                              SPI_IT_FRE | SPI_IT_MODF));

  /* Disable Tx DMA Request */
  CLEAR_BIT(hspi->Instance->CFG1, SPI_CFG1_TXDMAEN | SPI_CFG1_RXDMAEN);
 81043b0:	687b      	ldr	r3, [r7, #4]
 81043b2:	681b      	ldr	r3, [r3, #0]
 81043b4:	689a      	ldr	r2, [r3, #8]
 81043b6:	687b      	ldr	r3, [r7, #4]
 81043b8:	681b      	ldr	r3, [r3, #0]
 81043ba:	f422 4240 	bic.w	r2, r2, #49152	@ 0xc000
 81043be:	609a      	str	r2, [r3, #8]

  /* Report UnderRun error for non RX Only communication */
  if (hspi->State != HAL_SPI_STATE_BUSY_RX)
 81043c0:	687b      	ldr	r3, [r7, #4]
 81043c2:	f893 3081 	ldrb.w	r3, [r3, #129]	@ 0x81
 81043c6:	b2db      	uxtb	r3, r3
 81043c8:	2b04      	cmp	r3, #4
 81043ca:	d014      	beq.n	81043f6 <SPI_CloseTransfer+0x9a>
  {
    if ((itflag & SPI_FLAG_UDR) != 0UL)
 81043cc:	68fb      	ldr	r3, [r7, #12]
 81043ce:	f003 0320 	and.w	r3, r3, #32
 81043d2:	2b00      	cmp	r3, #0
 81043d4:	d00f      	beq.n	81043f6 <SPI_CloseTransfer+0x9a>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_UDR);
 81043d6:	687b      	ldr	r3, [r7, #4]
 81043d8:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 81043dc:	f043 0280 	orr.w	r2, r3, #128	@ 0x80
 81043e0:	687b      	ldr	r3, [r7, #4]
 81043e2:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
      __HAL_SPI_CLEAR_UDRFLAG(hspi);
 81043e6:	687b      	ldr	r3, [r7, #4]
 81043e8:	681b      	ldr	r3, [r3, #0]
 81043ea:	699a      	ldr	r2, [r3, #24]
 81043ec:	687b      	ldr	r3, [r7, #4]
 81043ee:	681b      	ldr	r3, [r3, #0]
 81043f0:	f042 0220 	orr.w	r2, r2, #32
 81043f4:	619a      	str	r2, [r3, #24]
    }
  }

  /* Report OverRun error for non TX Only communication */
  if (hspi->State != HAL_SPI_STATE_BUSY_TX)
 81043f6:	687b      	ldr	r3, [r7, #4]
 81043f8:	f893 3081 	ldrb.w	r3, [r3, #129]	@ 0x81
 81043fc:	b2db      	uxtb	r3, r3
 81043fe:	2b03      	cmp	r3, #3
 8104400:	d014      	beq.n	810442c <SPI_CloseTransfer+0xd0>
  {
    if ((itflag & SPI_FLAG_OVR) != 0UL)
 8104402:	68fb      	ldr	r3, [r7, #12]
 8104404:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8104408:	2b00      	cmp	r3, #0
 810440a:	d00f      	beq.n	810442c <SPI_CloseTransfer+0xd0>
    {
      SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_OVR);
 810440c:	687b      	ldr	r3, [r7, #4]
 810440e:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8104412:	f043 0204 	orr.w	r2, r3, #4
 8104416:	687b      	ldr	r3, [r7, #4]
 8104418:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
      __HAL_SPI_CLEAR_OVRFLAG(hspi);
 810441c:	687b      	ldr	r3, [r7, #4]
 810441e:	681b      	ldr	r3, [r3, #0]
 8104420:	699a      	ldr	r2, [r3, #24]
 8104422:	687b      	ldr	r3, [r7, #4]
 8104424:	681b      	ldr	r3, [r3, #0]
 8104426:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 810442a:	619a      	str	r2, [r3, #24]
    }
#endif /* USE_SPI_CRC */
  }

  /* SPI Mode Fault error interrupt occurred -------------------------------*/
  if ((itflag & SPI_FLAG_MODF) != 0UL)
 810442c:	68fb      	ldr	r3, [r7, #12]
 810442e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8104432:	2b00      	cmp	r3, #0
 8104434:	d00f      	beq.n	8104456 <SPI_CloseTransfer+0xfa>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_MODF);
 8104436:	687b      	ldr	r3, [r7, #4]
 8104438:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 810443c:	f043 0201 	orr.w	r2, r3, #1
 8104440:	687b      	ldr	r3, [r7, #4]
 8104442:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
    __HAL_SPI_CLEAR_MODFFLAG(hspi);
 8104446:	687b      	ldr	r3, [r7, #4]
 8104448:	681b      	ldr	r3, [r3, #0]
 810444a:	699a      	ldr	r2, [r3, #24]
 810444c:	687b      	ldr	r3, [r7, #4]
 810444e:	681b      	ldr	r3, [r3, #0]
 8104450:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 8104454:	619a      	str	r2, [r3, #24]
  }

  /* SPI Frame error interrupt occurred ------------------------------------*/
  if ((itflag & SPI_FLAG_FRE) != 0UL)
 8104456:	68fb      	ldr	r3, [r7, #12]
 8104458:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 810445c:	2b00      	cmp	r3, #0
 810445e:	d00f      	beq.n	8104480 <SPI_CloseTransfer+0x124>
  {
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FRE);
 8104460:	687b      	ldr	r3, [r7, #4]
 8104462:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
 8104466:	f043 0208 	orr.w	r2, r3, #8
 810446a:	687b      	ldr	r3, [r7, #4]
 810446c:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
    __HAL_SPI_CLEAR_FREFLAG(hspi);
 8104470:	687b      	ldr	r3, [r7, #4]
 8104472:	681b      	ldr	r3, [r3, #0]
 8104474:	699a      	ldr	r2, [r3, #24]
 8104476:	687b      	ldr	r3, [r7, #4]
 8104478:	681b      	ldr	r3, [r3, #0]
 810447a:	f442 7280 	orr.w	r2, r2, #256	@ 0x100
 810447e:	619a      	str	r2, [r3, #24]
  }

  hspi->TxXferCount = (uint16_t)0UL;
 8104480:	687b      	ldr	r3, [r7, #4]
 8104482:	2200      	movs	r2, #0
 8104484:	f8a3 2062 	strh.w	r2, [r3, #98]	@ 0x62
  hspi->RxXferCount = (uint16_t)0UL;
 8104488:	687b      	ldr	r3, [r7, #4]
 810448a:	2200      	movs	r2, #0
 810448c:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
}
 8104490:	bf00      	nop
 8104492:	3714      	adds	r7, #20
 8104494:	46bd      	mov	sp, r7
 8104496:	f85d 7b04 	ldr.w	r7, [sp], #4
 810449a:	4770      	bx	lr

0810449c <SPI_WaitOnFlagUntilTimeout>:
  * @param Tickstart: Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitOnFlagUntilTimeout(const SPI_HandleTypeDef *hspi, uint32_t Flag, FlagStatus Status,
                                                    uint32_t Timeout, uint32_t Tickstart)
{
 810449c:	b580      	push	{r7, lr}
 810449e:	b084      	sub	sp, #16
 81044a0:	af00      	add	r7, sp, #0
 81044a2:	60f8      	str	r0, [r7, #12]
 81044a4:	60b9      	str	r1, [r7, #8]
 81044a6:	603b      	str	r3, [r7, #0]
 81044a8:	4613      	mov	r3, r2
 81044aa:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) == Status)
 81044ac:	e010      	b.n	81044d0 <SPI_WaitOnFlagUntilTimeout+0x34>
  {
    /* Check for the Timeout */
    if ((((HAL_GetTick() - Tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 81044ae:	f7fd f98f 	bl	81017d0 <HAL_GetTick>
 81044b2:	4602      	mov	r2, r0
 81044b4:	69bb      	ldr	r3, [r7, #24]
 81044b6:	1ad3      	subs	r3, r2, r3
 81044b8:	683a      	ldr	r2, [r7, #0]
 81044ba:	429a      	cmp	r2, r3
 81044bc:	d803      	bhi.n	81044c6 <SPI_WaitOnFlagUntilTimeout+0x2a>
 81044be:	683b      	ldr	r3, [r7, #0]
 81044c0:	f1b3 3fff 	cmp.w	r3, #4294967295
 81044c4:	d102      	bne.n	81044cc <SPI_WaitOnFlagUntilTimeout+0x30>
 81044c6:	683b      	ldr	r3, [r7, #0]
 81044c8:	2b00      	cmp	r3, #0
 81044ca:	d101      	bne.n	81044d0 <SPI_WaitOnFlagUntilTimeout+0x34>
    {
      return HAL_TIMEOUT;
 81044cc:	2303      	movs	r3, #3
 81044ce:	e00f      	b.n	81044f0 <SPI_WaitOnFlagUntilTimeout+0x54>
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) == Status)
 81044d0:	68fb      	ldr	r3, [r7, #12]
 81044d2:	681b      	ldr	r3, [r3, #0]
 81044d4:	695a      	ldr	r2, [r3, #20]
 81044d6:	68bb      	ldr	r3, [r7, #8]
 81044d8:	4013      	ands	r3, r2
 81044da:	68ba      	ldr	r2, [r7, #8]
 81044dc:	429a      	cmp	r2, r3
 81044de:	bf0c      	ite	eq
 81044e0:	2301      	moveq	r3, #1
 81044e2:	2300      	movne	r3, #0
 81044e4:	b2db      	uxtb	r3, r3
 81044e6:	461a      	mov	r2, r3
 81044e8:	79fb      	ldrb	r3, [r7, #7]
 81044ea:	429a      	cmp	r2, r3
 81044ec:	d0df      	beq.n	81044ae <SPI_WaitOnFlagUntilTimeout+0x12>
    }
  }
  return HAL_OK;
 81044ee:	2300      	movs	r3, #0
}
 81044f0:	4618      	mov	r0, r3
 81044f2:	3710      	adds	r7, #16
 81044f4:	46bd      	mov	sp, r7
 81044f6:	bd80      	pop	{r7, pc}

081044f8 <SPI_GetPacketSize>:
  * @param  hspi: pointer to a SPI_HandleTypeDef structure that contains
  *               the configuration information for SPI module.
  * @retval Packet size occupied in the fifo
  */
static uint32_t SPI_GetPacketSize(const SPI_HandleTypeDef *hspi)
{
 81044f8:	b480      	push	{r7}
 81044fa:	b085      	sub	sp, #20
 81044fc:	af00      	add	r7, sp, #0
 81044fe:	6078      	str	r0, [r7, #4]
  uint32_t fifo_threashold = (hspi->Init.FifoThreshold >> SPI_CFG1_FTHLV_Pos) + 1UL;
 8104500:	687b      	ldr	r3, [r7, #4]
 8104502:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 8104504:	095b      	lsrs	r3, r3, #5
 8104506:	3301      	adds	r3, #1
 8104508:	60fb      	str	r3, [r7, #12]
  uint32_t data_size       = (hspi->Init.DataSize      >> SPI_CFG1_DSIZE_Pos) + 1UL;
 810450a:	687b      	ldr	r3, [r7, #4]
 810450c:	68db      	ldr	r3, [r3, #12]
 810450e:	3301      	adds	r3, #1
 8104510:	60bb      	str	r3, [r7, #8]

  /* Convert data size to Byte */
  data_size = (data_size + 7UL) / 8UL;
 8104512:	68bb      	ldr	r3, [r7, #8]
 8104514:	3307      	adds	r3, #7
 8104516:	08db      	lsrs	r3, r3, #3
 8104518:	60bb      	str	r3, [r7, #8]

  return data_size * fifo_threashold;
 810451a:	68bb      	ldr	r3, [r7, #8]
 810451c:	68fa      	ldr	r2, [r7, #12]
 810451e:	fb02 f303 	mul.w	r3, r2, r3
}
 8104522:	4618      	mov	r0, r3
 8104524:	3714      	adds	r7, #20
 8104526:	46bd      	mov	sp, r7
 8104528:	f85d 7b04 	ldr.w	r7, [sp], #4
 810452c:	4770      	bx	lr

0810452e <HAL_TIM_Base_Init>:
  *         Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
{
 810452e:	b580      	push	{r7, lr}
 8104530:	b082      	sub	sp, #8
 8104532:	af00      	add	r7, sp, #0
 8104534:	6078      	str	r0, [r7, #4]
  /* Check the TIM handle allocation */
  if (htim == NULL)
 8104536:	687b      	ldr	r3, [r7, #4]
 8104538:	2b00      	cmp	r3, #0
 810453a:	d101      	bne.n	8104540 <HAL_TIM_Base_Init+0x12>
  {
    return HAL_ERROR;
 810453c:	2301      	movs	r3, #1
 810453e:	e049      	b.n	81045d4 <HAL_TIM_Base_Init+0xa6>
  assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
  assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
  assert_param(IS_TIM_PERIOD(htim, htim->Init.Period));
  assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));

  if (htim->State == HAL_TIM_STATE_RESET)
 8104540:	687b      	ldr	r3, [r7, #4]
 8104542:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 8104546:	b2db      	uxtb	r3, r3
 8104548:	2b00      	cmp	r3, #0
 810454a:	d106      	bne.n	810455a <HAL_TIM_Base_Init+0x2c>
  {
    /* Allocate lock resource and initialize it */
    htim->Lock = HAL_UNLOCKED;
 810454c:	687b      	ldr	r3, [r7, #4]
 810454e:	2200      	movs	r2, #0
 8104550:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c
    }
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    htim->Base_MspInitCallback(htim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_TIM_Base_MspInit(htim);
 8104554:	6878      	ldr	r0, [r7, #4]
 8104556:	f7fc ff01 	bl	810135c <HAL_TIM_Base_MspInit>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 810455a:	687b      	ldr	r3, [r7, #4]
 810455c:	2202      	movs	r2, #2
 810455e:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Set the Time Base configuration */
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8104562:	687b      	ldr	r3, [r7, #4]
 8104564:	681a      	ldr	r2, [r3, #0]
 8104566:	687b      	ldr	r3, [r7, #4]
 8104568:	3304      	adds	r3, #4
 810456a:	4619      	mov	r1, r3
 810456c:	4610      	mov	r0, r2
 810456e:	f000 fad5 	bl	8104b1c <TIM_Base_SetConfig>

  /* Initialize the DMA burst operation state */
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8104572:	687b      	ldr	r3, [r7, #4]
 8104574:	2201      	movs	r2, #1
 8104576:	f883 2048 	strb.w	r2, [r3, #72]	@ 0x48

  /* Initialize the TIM channels state */
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 810457a:	687b      	ldr	r3, [r7, #4]
 810457c:	2201      	movs	r2, #1
 810457e:	f883 203e 	strb.w	r2, [r3, #62]	@ 0x3e
 8104582:	687b      	ldr	r3, [r7, #4]
 8104584:	2201      	movs	r2, #1
 8104586:	f883 203f 	strb.w	r2, [r3, #63]	@ 0x3f
 810458a:	687b      	ldr	r3, [r7, #4]
 810458c:	2201      	movs	r2, #1
 810458e:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
 8104592:	687b      	ldr	r3, [r7, #4]
 8104594:	2201      	movs	r2, #1
 8104596:	f883 2041 	strb.w	r2, [r3, #65]	@ 0x41
 810459a:	687b      	ldr	r3, [r7, #4]
 810459c:	2201      	movs	r2, #1
 810459e:	f883 2042 	strb.w	r2, [r3, #66]	@ 0x42
 81045a2:	687b      	ldr	r3, [r7, #4]
 81045a4:	2201      	movs	r2, #1
 81045a6:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 81045aa:	687b      	ldr	r3, [r7, #4]
 81045ac:	2201      	movs	r2, #1
 81045ae:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 81045b2:	687b      	ldr	r3, [r7, #4]
 81045b4:	2201      	movs	r2, #1
 81045b6:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 81045ba:	687b      	ldr	r3, [r7, #4]
 81045bc:	2201      	movs	r2, #1
 81045be:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46
 81045c2:	687b      	ldr	r3, [r7, #4]
 81045c4:	2201      	movs	r2, #1
 81045c6:	f883 2047 	strb.w	r2, [r3, #71]	@ 0x47

  /* Initialize the TIM state*/
  htim->State = HAL_TIM_STATE_READY;
 81045ca:	687b      	ldr	r3, [r7, #4]
 81045cc:	2201      	movs	r2, #1
 81045ce:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  return HAL_OK;
 81045d2:	2300      	movs	r3, #0
}
 81045d4:	4618      	mov	r0, r3
 81045d6:	3708      	adds	r7, #8
 81045d8:	46bd      	mov	sp, r7
 81045da:	bd80      	pop	{r7, pc}

081045dc <HAL_TIM_Base_Start_IT>:
  * @brief  Starts the TIM Base generation in interrupt mode.
  * @param  htim TIM Base handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
{
 81045dc:	b480      	push	{r7}
 81045de:	b085      	sub	sp, #20
 81045e0:	af00      	add	r7, sp, #0
 81045e2:	6078      	str	r0, [r7, #4]

  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));

  /* Check the TIM state */
  if (htim->State != HAL_TIM_STATE_READY)
 81045e4:	687b      	ldr	r3, [r7, #4]
 81045e6:	f893 303d 	ldrb.w	r3, [r3, #61]	@ 0x3d
 81045ea:	b2db      	uxtb	r3, r3
 81045ec:	2b01      	cmp	r3, #1
 81045ee:	d001      	beq.n	81045f4 <HAL_TIM_Base_Start_IT+0x18>
  {
    return HAL_ERROR;
 81045f0:	2301      	movs	r3, #1
 81045f2:	e054      	b.n	810469e <HAL_TIM_Base_Start_IT+0xc2>
  }

  /* Set the TIM state */
  htim->State = HAL_TIM_STATE_BUSY;
 81045f4:	687b      	ldr	r3, [r7, #4]
 81045f6:	2202      	movs	r2, #2
 81045f8:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Enable the TIM Update interrupt */
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 81045fc:	687b      	ldr	r3, [r7, #4]
 81045fe:	681b      	ldr	r3, [r3, #0]
 8104600:	68da      	ldr	r2, [r3, #12]
 8104602:	687b      	ldr	r3, [r7, #4]
 8104604:	681b      	ldr	r3, [r3, #0]
 8104606:	f042 0201 	orr.w	r2, r2, #1
 810460a:	60da      	str	r2, [r3, #12]

  /* Enable the Peripheral, except in trigger mode where enable is automatically done with trigger */
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 810460c:	687b      	ldr	r3, [r7, #4]
 810460e:	681b      	ldr	r3, [r3, #0]
 8104610:	4a26      	ldr	r2, [pc, #152]	@ (81046ac <HAL_TIM_Base_Start_IT+0xd0>)
 8104612:	4293      	cmp	r3, r2
 8104614:	d022      	beq.n	810465c <HAL_TIM_Base_Start_IT+0x80>
 8104616:	687b      	ldr	r3, [r7, #4]
 8104618:	681b      	ldr	r3, [r3, #0]
 810461a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 810461e:	d01d      	beq.n	810465c <HAL_TIM_Base_Start_IT+0x80>
 8104620:	687b      	ldr	r3, [r7, #4]
 8104622:	681b      	ldr	r3, [r3, #0]
 8104624:	4a22      	ldr	r2, [pc, #136]	@ (81046b0 <HAL_TIM_Base_Start_IT+0xd4>)
 8104626:	4293      	cmp	r3, r2
 8104628:	d018      	beq.n	810465c <HAL_TIM_Base_Start_IT+0x80>
 810462a:	687b      	ldr	r3, [r7, #4]
 810462c:	681b      	ldr	r3, [r3, #0]
 810462e:	4a21      	ldr	r2, [pc, #132]	@ (81046b4 <HAL_TIM_Base_Start_IT+0xd8>)
 8104630:	4293      	cmp	r3, r2
 8104632:	d013      	beq.n	810465c <HAL_TIM_Base_Start_IT+0x80>
 8104634:	687b      	ldr	r3, [r7, #4]
 8104636:	681b      	ldr	r3, [r3, #0]
 8104638:	4a1f      	ldr	r2, [pc, #124]	@ (81046b8 <HAL_TIM_Base_Start_IT+0xdc>)
 810463a:	4293      	cmp	r3, r2
 810463c:	d00e      	beq.n	810465c <HAL_TIM_Base_Start_IT+0x80>
 810463e:	687b      	ldr	r3, [r7, #4]
 8104640:	681b      	ldr	r3, [r3, #0]
 8104642:	4a1e      	ldr	r2, [pc, #120]	@ (81046bc <HAL_TIM_Base_Start_IT+0xe0>)
 8104644:	4293      	cmp	r3, r2
 8104646:	d009      	beq.n	810465c <HAL_TIM_Base_Start_IT+0x80>
 8104648:	687b      	ldr	r3, [r7, #4]
 810464a:	681b      	ldr	r3, [r3, #0]
 810464c:	4a1c      	ldr	r2, [pc, #112]	@ (81046c0 <HAL_TIM_Base_Start_IT+0xe4>)
 810464e:	4293      	cmp	r3, r2
 8104650:	d004      	beq.n	810465c <HAL_TIM_Base_Start_IT+0x80>
 8104652:	687b      	ldr	r3, [r7, #4]
 8104654:	681b      	ldr	r3, [r3, #0]
 8104656:	4a1b      	ldr	r2, [pc, #108]	@ (81046c4 <HAL_TIM_Base_Start_IT+0xe8>)
 8104658:	4293      	cmp	r3, r2
 810465a:	d115      	bne.n	8104688 <HAL_TIM_Base_Start_IT+0xac>
  {
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 810465c:	687b      	ldr	r3, [r7, #4]
 810465e:	681b      	ldr	r3, [r3, #0]
 8104660:	689a      	ldr	r2, [r3, #8]
 8104662:	4b19      	ldr	r3, [pc, #100]	@ (81046c8 <HAL_TIM_Base_Start_IT+0xec>)
 8104664:	4013      	ands	r3, r2
 8104666:	60fb      	str	r3, [r7, #12]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8104668:	68fb      	ldr	r3, [r7, #12]
 810466a:	2b06      	cmp	r3, #6
 810466c:	d015      	beq.n	810469a <HAL_TIM_Base_Start_IT+0xbe>
 810466e:	68fb      	ldr	r3, [r7, #12]
 8104670:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8104674:	d011      	beq.n	810469a <HAL_TIM_Base_Start_IT+0xbe>
    {
      __HAL_TIM_ENABLE(htim);
 8104676:	687b      	ldr	r3, [r7, #4]
 8104678:	681b      	ldr	r3, [r3, #0]
 810467a:	681a      	ldr	r2, [r3, #0]
 810467c:	687b      	ldr	r3, [r7, #4]
 810467e:	681b      	ldr	r3, [r3, #0]
 8104680:	f042 0201 	orr.w	r2, r2, #1
 8104684:	601a      	str	r2, [r3, #0]
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8104686:	e008      	b.n	810469a <HAL_TIM_Base_Start_IT+0xbe>
    }
  }
  else
  {
    __HAL_TIM_ENABLE(htim);
 8104688:	687b      	ldr	r3, [r7, #4]
 810468a:	681b      	ldr	r3, [r3, #0]
 810468c:	681a      	ldr	r2, [r3, #0]
 810468e:	687b      	ldr	r3, [r7, #4]
 8104690:	681b      	ldr	r3, [r3, #0]
 8104692:	f042 0201 	orr.w	r2, r2, #1
 8104696:	601a      	str	r2, [r3, #0]
 8104698:	e000      	b.n	810469c <HAL_TIM_Base_Start_IT+0xc0>
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 810469a:	bf00      	nop
  }

  /* Return function status */
  return HAL_OK;
 810469c:	2300      	movs	r3, #0
}
 810469e:	4618      	mov	r0, r3
 81046a0:	3714      	adds	r7, #20
 81046a2:	46bd      	mov	sp, r7
 81046a4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81046a8:	4770      	bx	lr
 81046aa:	bf00      	nop
 81046ac:	40010000 	.word	0x40010000
 81046b0:	40000400 	.word	0x40000400
 81046b4:	40000800 	.word	0x40000800
 81046b8:	40000c00 	.word	0x40000c00
 81046bc:	40010400 	.word	0x40010400
 81046c0:	40001800 	.word	0x40001800
 81046c4:	40014000 	.word	0x40014000
 81046c8:	00010007 	.word	0x00010007

081046cc <HAL_TIM_IRQHandler>:
  * @brief  This function handles TIM interrupts requests.
  * @param  htim TIM  handle
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
 81046cc:	b580      	push	{r7, lr}
 81046ce:	b084      	sub	sp, #16
 81046d0:	af00      	add	r7, sp, #0
 81046d2:	6078      	str	r0, [r7, #4]
  uint32_t itsource = htim->Instance->DIER;
 81046d4:	687b      	ldr	r3, [r7, #4]
 81046d6:	681b      	ldr	r3, [r3, #0]
 81046d8:	68db      	ldr	r3, [r3, #12]
 81046da:	60fb      	str	r3, [r7, #12]
  uint32_t itflag   = htim->Instance->SR;
 81046dc:	687b      	ldr	r3, [r7, #4]
 81046de:	681b      	ldr	r3, [r3, #0]
 81046e0:	691b      	ldr	r3, [r3, #16]
 81046e2:	60bb      	str	r3, [r7, #8]

  /* Capture compare 1 event */
  if ((itflag & (TIM_FLAG_CC1)) == (TIM_FLAG_CC1))
 81046e4:	68bb      	ldr	r3, [r7, #8]
 81046e6:	f003 0302 	and.w	r3, r3, #2
 81046ea:	2b00      	cmp	r3, #0
 81046ec:	d020      	beq.n	8104730 <HAL_TIM_IRQHandler+0x64>
  {
    if ((itsource & (TIM_IT_CC1)) == (TIM_IT_CC1))
 81046ee:	68fb      	ldr	r3, [r7, #12]
 81046f0:	f003 0302 	and.w	r3, r3, #2
 81046f4:	2b00      	cmp	r3, #0
 81046f6:	d01b      	beq.n	8104730 <HAL_TIM_IRQHandler+0x64>
    {
      {
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 81046f8:	687b      	ldr	r3, [r7, #4]
 81046fa:	681b      	ldr	r3, [r3, #0]
 81046fc:	f06f 0202 	mvn.w	r2, #2
 8104700:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8104702:	687b      	ldr	r3, [r7, #4]
 8104704:	2201      	movs	r2, #1
 8104706:	771a      	strb	r2, [r3, #28]

        /* Input capture event */
        if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8104708:	687b      	ldr	r3, [r7, #4]
 810470a:	681b      	ldr	r3, [r3, #0]
 810470c:	699b      	ldr	r3, [r3, #24]
 810470e:	f003 0303 	and.w	r3, r3, #3
 8104712:	2b00      	cmp	r3, #0
 8104714:	d003      	beq.n	810471e <HAL_TIM_IRQHandler+0x52>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->IC_CaptureCallback(htim);
#else
          HAL_TIM_IC_CaptureCallback(htim);
 8104716:	6878      	ldr	r0, [r7, #4]
 8104718:	f000 f9e2 	bl	8104ae0 <HAL_TIM_IC_CaptureCallback>
 810471c:	e005      	b.n	810472a <HAL_TIM_IRQHandler+0x5e>
        {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
          htim->OC_DelayElapsedCallback(htim);
          htim->PWM_PulseFinishedCallback(htim);
#else
          HAL_TIM_OC_DelayElapsedCallback(htim);
 810471e:	6878      	ldr	r0, [r7, #4]
 8104720:	f000 f9d4 	bl	8104acc <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8104724:	6878      	ldr	r0, [r7, #4]
 8104726:	f000 f9e5 	bl	8104af4 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 810472a:	687b      	ldr	r3, [r7, #4]
 810472c:	2200      	movs	r2, #0
 810472e:	771a      	strb	r2, [r3, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if ((itflag & (TIM_FLAG_CC2)) == (TIM_FLAG_CC2))
 8104730:	68bb      	ldr	r3, [r7, #8]
 8104732:	f003 0304 	and.w	r3, r3, #4
 8104736:	2b00      	cmp	r3, #0
 8104738:	d020      	beq.n	810477c <HAL_TIM_IRQHandler+0xb0>
  {
    if ((itsource & (TIM_IT_CC2)) == (TIM_IT_CC2))
 810473a:	68fb      	ldr	r3, [r7, #12]
 810473c:	f003 0304 	and.w	r3, r3, #4
 8104740:	2b00      	cmp	r3, #0
 8104742:	d01b      	beq.n	810477c <HAL_TIM_IRQHandler+0xb0>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8104744:	687b      	ldr	r3, [r7, #4]
 8104746:	681b      	ldr	r3, [r3, #0]
 8104748:	f06f 0204 	mvn.w	r2, #4
 810474c:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 810474e:	687b      	ldr	r3, [r7, #4]
 8104750:	2202      	movs	r2, #2
 8104752:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8104754:	687b      	ldr	r3, [r7, #4]
 8104756:	681b      	ldr	r3, [r3, #0]
 8104758:	699b      	ldr	r3, [r3, #24]
 810475a:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 810475e:	2b00      	cmp	r3, #0
 8104760:	d003      	beq.n	810476a <HAL_TIM_IRQHandler+0x9e>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 8104762:	6878      	ldr	r0, [r7, #4]
 8104764:	f000 f9bc 	bl	8104ae0 <HAL_TIM_IC_CaptureCallback>
 8104768:	e005      	b.n	8104776 <HAL_TIM_IRQHandler+0xaa>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 810476a:	6878      	ldr	r0, [r7, #4]
 810476c:	f000 f9ae 	bl	8104acc <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8104770:	6878      	ldr	r0, [r7, #4]
 8104772:	f000 f9bf 	bl	8104af4 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8104776:	687b      	ldr	r3, [r7, #4]
 8104778:	2200      	movs	r2, #0
 810477a:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 3 event */
  if ((itflag & (TIM_FLAG_CC3)) == (TIM_FLAG_CC3))
 810477c:	68bb      	ldr	r3, [r7, #8]
 810477e:	f003 0308 	and.w	r3, r3, #8
 8104782:	2b00      	cmp	r3, #0
 8104784:	d020      	beq.n	81047c8 <HAL_TIM_IRQHandler+0xfc>
  {
    if ((itsource & (TIM_IT_CC3)) == (TIM_IT_CC3))
 8104786:	68fb      	ldr	r3, [r7, #12]
 8104788:	f003 0308 	and.w	r3, r3, #8
 810478c:	2b00      	cmp	r3, #0
 810478e:	d01b      	beq.n	81047c8 <HAL_TIM_IRQHandler+0xfc>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 8104790:	687b      	ldr	r3, [r7, #4]
 8104792:	681b      	ldr	r3, [r3, #0]
 8104794:	f06f 0208 	mvn.w	r2, #8
 8104798:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 810479a:	687b      	ldr	r3, [r7, #4]
 810479c:	2204      	movs	r2, #4
 810479e:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 81047a0:	687b      	ldr	r3, [r7, #4]
 81047a2:	681b      	ldr	r3, [r3, #0]
 81047a4:	69db      	ldr	r3, [r3, #28]
 81047a6:	f003 0303 	and.w	r3, r3, #3
 81047aa:	2b00      	cmp	r3, #0
 81047ac:	d003      	beq.n	81047b6 <HAL_TIM_IRQHandler+0xea>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 81047ae:	6878      	ldr	r0, [r7, #4]
 81047b0:	f000 f996 	bl	8104ae0 <HAL_TIM_IC_CaptureCallback>
 81047b4:	e005      	b.n	81047c2 <HAL_TIM_IRQHandler+0xf6>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 81047b6:	6878      	ldr	r0, [r7, #4]
 81047b8:	f000 f988 	bl	8104acc <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 81047bc:	6878      	ldr	r0, [r7, #4]
 81047be:	f000 f999 	bl	8104af4 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 81047c2:	687b      	ldr	r3, [r7, #4]
 81047c4:	2200      	movs	r2, #0
 81047c6:	771a      	strb	r2, [r3, #28]
    }
  }
  /* Capture compare 4 event */
  if ((itflag & (TIM_FLAG_CC4)) == (TIM_FLAG_CC4))
 81047c8:	68bb      	ldr	r3, [r7, #8]
 81047ca:	f003 0310 	and.w	r3, r3, #16
 81047ce:	2b00      	cmp	r3, #0
 81047d0:	d020      	beq.n	8104814 <HAL_TIM_IRQHandler+0x148>
  {
    if ((itsource & (TIM_IT_CC4)) == (TIM_IT_CC4))
 81047d2:	68fb      	ldr	r3, [r7, #12]
 81047d4:	f003 0310 	and.w	r3, r3, #16
 81047d8:	2b00      	cmp	r3, #0
 81047da:	d01b      	beq.n	8104814 <HAL_TIM_IRQHandler+0x148>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 81047dc:	687b      	ldr	r3, [r7, #4]
 81047de:	681b      	ldr	r3, [r3, #0]
 81047e0:	f06f 0210 	mvn.w	r2, #16
 81047e4:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 81047e6:	687b      	ldr	r3, [r7, #4]
 81047e8:	2208      	movs	r2, #8
 81047ea:	771a      	strb	r2, [r3, #28]
      /* Input capture event */
      if ((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 81047ec:	687b      	ldr	r3, [r7, #4]
 81047ee:	681b      	ldr	r3, [r3, #0]
 81047f0:	69db      	ldr	r3, [r3, #28]
 81047f2:	f403 7340 	and.w	r3, r3, #768	@ 0x300
 81047f6:	2b00      	cmp	r3, #0
 81047f8:	d003      	beq.n	8104802 <HAL_TIM_IRQHandler+0x136>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->IC_CaptureCallback(htim);
#else
        HAL_TIM_IC_CaptureCallback(htim);
 81047fa:	6878      	ldr	r0, [r7, #4]
 81047fc:	f000 f970 	bl	8104ae0 <HAL_TIM_IC_CaptureCallback>
 8104800:	e005      	b.n	810480e <HAL_TIM_IRQHandler+0x142>
      {
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
        htim->OC_DelayElapsedCallback(htim);
        htim->PWM_PulseFinishedCallback(htim);
#else
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8104802:	6878      	ldr	r0, [r7, #4]
 8104804:	f000 f962 	bl	8104acc <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8104808:	6878      	ldr	r0, [r7, #4]
 810480a:	f000 f973 	bl	8104af4 <HAL_TIM_PWM_PulseFinishedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 810480e:	687b      	ldr	r3, [r7, #4]
 8104810:	2200      	movs	r2, #0
 8104812:	771a      	strb	r2, [r3, #28]
    }
  }
  /* TIM Update event */
  if ((itflag & (TIM_FLAG_UPDATE)) == (TIM_FLAG_UPDATE))
 8104814:	68bb      	ldr	r3, [r7, #8]
 8104816:	f003 0301 	and.w	r3, r3, #1
 810481a:	2b00      	cmp	r3, #0
 810481c:	d00c      	beq.n	8104838 <HAL_TIM_IRQHandler+0x16c>
  {
    if ((itsource & (TIM_IT_UPDATE)) == (TIM_IT_UPDATE))
 810481e:	68fb      	ldr	r3, [r7, #12]
 8104820:	f003 0301 	and.w	r3, r3, #1
 8104824:	2b00      	cmp	r3, #0
 8104826:	d007      	beq.n	8104838 <HAL_TIM_IRQHandler+0x16c>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 8104828:	687b      	ldr	r3, [r7, #4]
 810482a:	681b      	ldr	r3, [r3, #0]
 810482c:	f06f 0201 	mvn.w	r2, #1
 8104830:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->PeriodElapsedCallback(htim);
#else
      HAL_TIM_PeriodElapsedCallback(htim);
 8104832:	6878      	ldr	r0, [r7, #4]
 8104834:	f7fc f858 	bl	81008e8 <HAL_TIM_PeriodElapsedCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break input event */
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 8104838:	68bb      	ldr	r3, [r7, #8]
 810483a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 810483e:	2b00      	cmp	r3, #0
 8104840:	d104      	bne.n	810484c <HAL_TIM_IRQHandler+0x180>
      ((itflag & (TIM_FLAG_SYSTEM_BREAK)) == (TIM_FLAG_SYSTEM_BREAK)))
 8104842:	68bb      	ldr	r3, [r7, #8]
 8104844:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
  if (((itflag & (TIM_FLAG_BREAK)) == (TIM_FLAG_BREAK)) || \
 8104848:	2b00      	cmp	r3, #0
 810484a:	d00c      	beq.n	8104866 <HAL_TIM_IRQHandler+0x19a>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 810484c:	68fb      	ldr	r3, [r7, #12]
 810484e:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8104852:	2b00      	cmp	r3, #0
 8104854:	d007      	beq.n	8104866 <HAL_TIM_IRQHandler+0x19a>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK | TIM_FLAG_SYSTEM_BREAK);
 8104856:	687b      	ldr	r3, [r7, #4]
 8104858:	681b      	ldr	r3, [r3, #0]
 810485a:	f46f 5202 	mvn.w	r2, #8320	@ 0x2080
 810485e:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->BreakCallback(htim);
#else
      HAL_TIMEx_BreakCallback(htim);
 8104860:	6878      	ldr	r0, [r7, #4]
 8104862:	f000 fb35 	bl	8104ed0 <HAL_TIMEx_BreakCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Break2 input event */
  if ((itflag & (TIM_FLAG_BREAK2)) == (TIM_FLAG_BREAK2))
 8104866:	68bb      	ldr	r3, [r7, #8]
 8104868:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 810486c:	2b00      	cmp	r3, #0
 810486e:	d00c      	beq.n	810488a <HAL_TIM_IRQHandler+0x1be>
  {
    if ((itsource & (TIM_IT_BREAK)) == (TIM_IT_BREAK))
 8104870:	68fb      	ldr	r3, [r7, #12]
 8104872:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8104876:	2b00      	cmp	r3, #0
 8104878:	d007      	beq.n	810488a <HAL_TIM_IRQHandler+0x1be>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 810487a:	687b      	ldr	r3, [r7, #4]
 810487c:	681b      	ldr	r3, [r3, #0]
 810487e:	f46f 7280 	mvn.w	r2, #256	@ 0x100
 8104882:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->Break2Callback(htim);
#else
      HAL_TIMEx_Break2Callback(htim);
 8104884:	6878      	ldr	r0, [r7, #4]
 8104886:	f000 fb2d 	bl	8104ee4 <HAL_TIMEx_Break2Callback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM Trigger detection event */
  if ((itflag & (TIM_FLAG_TRIGGER)) == (TIM_FLAG_TRIGGER))
 810488a:	68bb      	ldr	r3, [r7, #8]
 810488c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8104890:	2b00      	cmp	r3, #0
 8104892:	d00c      	beq.n	81048ae <HAL_TIM_IRQHandler+0x1e2>
  {
    if ((itsource & (TIM_IT_TRIGGER)) == (TIM_IT_TRIGGER))
 8104894:	68fb      	ldr	r3, [r7, #12]
 8104896:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 810489a:	2b00      	cmp	r3, #0
 810489c:	d007      	beq.n	81048ae <HAL_TIM_IRQHandler+0x1e2>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 810489e:	687b      	ldr	r3, [r7, #4]
 81048a0:	681b      	ldr	r3, [r3, #0]
 81048a2:	f06f 0240 	mvn.w	r2, #64	@ 0x40
 81048a6:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->TriggerCallback(htim);
#else
      HAL_TIM_TriggerCallback(htim);
 81048a8:	6878      	ldr	r0, [r7, #4]
 81048aa:	f000 f92d 	bl	8104b08 <HAL_TIM_TriggerCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
  /* TIM commutation event */
  if ((itflag & (TIM_FLAG_COM)) == (TIM_FLAG_COM))
 81048ae:	68bb      	ldr	r3, [r7, #8]
 81048b0:	f003 0320 	and.w	r3, r3, #32
 81048b4:	2b00      	cmp	r3, #0
 81048b6:	d00c      	beq.n	81048d2 <HAL_TIM_IRQHandler+0x206>
  {
    if ((itsource & (TIM_IT_COM)) == (TIM_IT_COM))
 81048b8:	68fb      	ldr	r3, [r7, #12]
 81048ba:	f003 0320 	and.w	r3, r3, #32
 81048be:	2b00      	cmp	r3, #0
 81048c0:	d007      	beq.n	81048d2 <HAL_TIM_IRQHandler+0x206>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 81048c2:	687b      	ldr	r3, [r7, #4]
 81048c4:	681b      	ldr	r3, [r3, #0]
 81048c6:	f06f 0220 	mvn.w	r2, #32
 81048ca:	611a      	str	r2, [r3, #16]
#if (USE_HAL_TIM_REGISTER_CALLBACKS == 1)
      htim->CommutationCallback(htim);
#else
      HAL_TIMEx_CommutCallback(htim);
 81048cc:	6878      	ldr	r0, [r7, #4]
 81048ce:	f000 faf5 	bl	8104ebc <HAL_TIMEx_CommutCallback>
#endif /* USE_HAL_TIM_REGISTER_CALLBACKS */
    }
  }
}
 81048d2:	bf00      	nop
 81048d4:	3710      	adds	r7, #16
 81048d6:	46bd      	mov	sp, r7
 81048d8:	bd80      	pop	{r7, pc}
	...

081048dc <HAL_TIM_ConfigClockSource>:
  * @param  sClockSourceConfig pointer to a TIM_ClockConfigTypeDef structure that
  *         contains the clock source information for the TIM peripheral.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, const TIM_ClockConfigTypeDef *sClockSourceConfig)
{
 81048dc:	b580      	push	{r7, lr}
 81048de:	b084      	sub	sp, #16
 81048e0:	af00      	add	r7, sp, #0
 81048e2:	6078      	str	r0, [r7, #4]
 81048e4:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
 81048e6:	2300      	movs	r3, #0
 81048e8:	73fb      	strb	r3, [r7, #15]
  uint32_t tmpsmcr;

  /* Process Locked */
  __HAL_LOCK(htim);
 81048ea:	687b      	ldr	r3, [r7, #4]
 81048ec:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 81048f0:	2b01      	cmp	r3, #1
 81048f2:	d101      	bne.n	81048f8 <HAL_TIM_ConfigClockSource+0x1c>
 81048f4:	2302      	movs	r3, #2
 81048f6:	e0de      	b.n	8104ab6 <HAL_TIM_ConfigClockSource+0x1da>
 81048f8:	687b      	ldr	r3, [r7, #4]
 81048fa:	2201      	movs	r2, #1
 81048fc:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  htim->State = HAL_TIM_STATE_BUSY;
 8104900:	687b      	ldr	r3, [r7, #4]
 8104902:	2202      	movs	r2, #2
 8104904:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Check the parameters */
  assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));

  /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
  tmpsmcr = htim->Instance->SMCR;
 8104908:	687b      	ldr	r3, [r7, #4]
 810490a:	681b      	ldr	r3, [r3, #0]
 810490c:	689b      	ldr	r3, [r3, #8]
 810490e:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
 8104910:	68bb      	ldr	r3, [r7, #8]
 8104912:	f423 1344 	bic.w	r3, r3, #3211264	@ 0x310000
 8104916:	f023 0377 	bic.w	r3, r3, #119	@ 0x77
 810491a:	60bb      	str	r3, [r7, #8]
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 810491c:	68bb      	ldr	r3, [r7, #8]
 810491e:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 8104922:	60bb      	str	r3, [r7, #8]
  htim->Instance->SMCR = tmpsmcr;
 8104924:	687b      	ldr	r3, [r7, #4]
 8104926:	681b      	ldr	r3, [r3, #0]
 8104928:	68ba      	ldr	r2, [r7, #8]
 810492a:	609a      	str	r2, [r3, #8]

  switch (sClockSourceConfig->ClockSource)
 810492c:	683b      	ldr	r3, [r7, #0]
 810492e:	681b      	ldr	r3, [r3, #0]
 8104930:	4a63      	ldr	r2, [pc, #396]	@ (8104ac0 <HAL_TIM_ConfigClockSource+0x1e4>)
 8104932:	4293      	cmp	r3, r2
 8104934:	f000 80a9 	beq.w	8104a8a <HAL_TIM_ConfigClockSource+0x1ae>
 8104938:	4a61      	ldr	r2, [pc, #388]	@ (8104ac0 <HAL_TIM_ConfigClockSource+0x1e4>)
 810493a:	4293      	cmp	r3, r2
 810493c:	f200 80ae 	bhi.w	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 8104940:	4a60      	ldr	r2, [pc, #384]	@ (8104ac4 <HAL_TIM_ConfigClockSource+0x1e8>)
 8104942:	4293      	cmp	r3, r2
 8104944:	f000 80a1 	beq.w	8104a8a <HAL_TIM_ConfigClockSource+0x1ae>
 8104948:	4a5e      	ldr	r2, [pc, #376]	@ (8104ac4 <HAL_TIM_ConfigClockSource+0x1e8>)
 810494a:	4293      	cmp	r3, r2
 810494c:	f200 80a6 	bhi.w	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 8104950:	4a5d      	ldr	r2, [pc, #372]	@ (8104ac8 <HAL_TIM_ConfigClockSource+0x1ec>)
 8104952:	4293      	cmp	r3, r2
 8104954:	f000 8099 	beq.w	8104a8a <HAL_TIM_ConfigClockSource+0x1ae>
 8104958:	4a5b      	ldr	r2, [pc, #364]	@ (8104ac8 <HAL_TIM_ConfigClockSource+0x1ec>)
 810495a:	4293      	cmp	r3, r2
 810495c:	f200 809e 	bhi.w	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 8104960:	f1b3 1f10 	cmp.w	r3, #1048592	@ 0x100010
 8104964:	f000 8091 	beq.w	8104a8a <HAL_TIM_ConfigClockSource+0x1ae>
 8104968:	f1b3 1f10 	cmp.w	r3, #1048592	@ 0x100010
 810496c:	f200 8096 	bhi.w	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 8104970:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 8104974:	f000 8089 	beq.w	8104a8a <HAL_TIM_ConfigClockSource+0x1ae>
 8104978:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
 810497c:	f200 808e 	bhi.w	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 8104980:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 8104984:	d03e      	beq.n	8104a04 <HAL_TIM_ConfigClockSource+0x128>
 8104986:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
 810498a:	f200 8087 	bhi.w	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 810498e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8104992:	f000 8086 	beq.w	8104aa2 <HAL_TIM_ConfigClockSource+0x1c6>
 8104996:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 810499a:	d87f      	bhi.n	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 810499c:	2b70      	cmp	r3, #112	@ 0x70
 810499e:	d01a      	beq.n	81049d6 <HAL_TIM_ConfigClockSource+0xfa>
 81049a0:	2b70      	cmp	r3, #112	@ 0x70
 81049a2:	d87b      	bhi.n	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 81049a4:	2b60      	cmp	r3, #96	@ 0x60
 81049a6:	d050      	beq.n	8104a4a <HAL_TIM_ConfigClockSource+0x16e>
 81049a8:	2b60      	cmp	r3, #96	@ 0x60
 81049aa:	d877      	bhi.n	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 81049ac:	2b50      	cmp	r3, #80	@ 0x50
 81049ae:	d03c      	beq.n	8104a2a <HAL_TIM_ConfigClockSource+0x14e>
 81049b0:	2b50      	cmp	r3, #80	@ 0x50
 81049b2:	d873      	bhi.n	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 81049b4:	2b40      	cmp	r3, #64	@ 0x40
 81049b6:	d058      	beq.n	8104a6a <HAL_TIM_ConfigClockSource+0x18e>
 81049b8:	2b40      	cmp	r3, #64	@ 0x40
 81049ba:	d86f      	bhi.n	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 81049bc:	2b30      	cmp	r3, #48	@ 0x30
 81049be:	d064      	beq.n	8104a8a <HAL_TIM_ConfigClockSource+0x1ae>
 81049c0:	2b30      	cmp	r3, #48	@ 0x30
 81049c2:	d86b      	bhi.n	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 81049c4:	2b20      	cmp	r3, #32
 81049c6:	d060      	beq.n	8104a8a <HAL_TIM_ConfigClockSource+0x1ae>
 81049c8:	2b20      	cmp	r3, #32
 81049ca:	d867      	bhi.n	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
 81049cc:	2b00      	cmp	r3, #0
 81049ce:	d05c      	beq.n	8104a8a <HAL_TIM_ConfigClockSource+0x1ae>
 81049d0:	2b10      	cmp	r3, #16
 81049d2:	d05a      	beq.n	8104a8a <HAL_TIM_ConfigClockSource+0x1ae>
 81049d4:	e062      	b.n	8104a9c <HAL_TIM_ConfigClockSource+0x1c0>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 81049d6:	687b      	ldr	r3, [r7, #4]
 81049d8:	6818      	ldr	r0, [r3, #0]
                        sClockSourceConfig->ClockPrescaler,
 81049da:	683b      	ldr	r3, [r7, #0]
 81049dc:	6899      	ldr	r1, [r3, #8]
                        sClockSourceConfig->ClockPolarity,
 81049de:	683b      	ldr	r3, [r7, #0]
 81049e0:	685a      	ldr	r2, [r3, #4]
                        sClockSourceConfig->ClockFilter);
 81049e2:	683b      	ldr	r3, [r7, #0]
 81049e4:	68db      	ldr	r3, [r3, #12]
      TIM_ETR_SetConfig(htim->Instance,
 81049e6:	f000 f9bb 	bl	8104d60 <TIM_ETR_SetConfig>

      /* Select the External clock mode1 and the ETRF trigger */
      tmpsmcr = htim->Instance->SMCR;
 81049ea:	687b      	ldr	r3, [r7, #4]
 81049ec:	681b      	ldr	r3, [r3, #0]
 81049ee:	689b      	ldr	r3, [r3, #8]
 81049f0:	60bb      	str	r3, [r7, #8]
      tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
 81049f2:	68bb      	ldr	r3, [r7, #8]
 81049f4:	f043 0377 	orr.w	r3, r3, #119	@ 0x77
 81049f8:	60bb      	str	r3, [r7, #8]
      /* Write to TIMx SMCR */
      htim->Instance->SMCR = tmpsmcr;
 81049fa:	687b      	ldr	r3, [r7, #4]
 81049fc:	681b      	ldr	r3, [r3, #0]
 81049fe:	68ba      	ldr	r2, [r7, #8]
 8104a00:	609a      	str	r2, [r3, #8]
      break;
 8104a02:	e04f      	b.n	8104aa4 <HAL_TIM_ConfigClockSource+0x1c8>
      assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      /* Configure the ETR Clock source */
      TIM_ETR_SetConfig(htim->Instance,
 8104a04:	687b      	ldr	r3, [r7, #4]
 8104a06:	6818      	ldr	r0, [r3, #0]
                        sClockSourceConfig->ClockPrescaler,
 8104a08:	683b      	ldr	r3, [r7, #0]
 8104a0a:	6899      	ldr	r1, [r3, #8]
                        sClockSourceConfig->ClockPolarity,
 8104a0c:	683b      	ldr	r3, [r7, #0]
 8104a0e:	685a      	ldr	r2, [r3, #4]
                        sClockSourceConfig->ClockFilter);
 8104a10:	683b      	ldr	r3, [r7, #0]
 8104a12:	68db      	ldr	r3, [r3, #12]
      TIM_ETR_SetConfig(htim->Instance,
 8104a14:	f000 f9a4 	bl	8104d60 <TIM_ETR_SetConfig>
      /* Enable the External clock mode2 */
      htim->Instance->SMCR |= TIM_SMCR_ECE;
 8104a18:	687b      	ldr	r3, [r7, #4]
 8104a1a:	681b      	ldr	r3, [r3, #0]
 8104a1c:	689a      	ldr	r2, [r3, #8]
 8104a1e:	687b      	ldr	r3, [r7, #4]
 8104a20:	681b      	ldr	r3, [r3, #0]
 8104a22:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8104a26:	609a      	str	r2, [r3, #8]
      break;
 8104a28:	e03c      	b.n	8104aa4 <HAL_TIM_ConfigClockSource+0x1c8>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 8104a2a:	687b      	ldr	r3, [r7, #4]
 8104a2c:	6818      	ldr	r0, [r3, #0]
                               sClockSourceConfig->ClockPolarity,
 8104a2e:	683b      	ldr	r3, [r7, #0]
 8104a30:	6859      	ldr	r1, [r3, #4]
                               sClockSourceConfig->ClockFilter);
 8104a32:	683b      	ldr	r3, [r7, #0]
 8104a34:	68db      	ldr	r3, [r3, #12]
      TIM_TI1_ConfigInputStage(htim->Instance,
 8104a36:	461a      	mov	r2, r3
 8104a38:	f000 f916 	bl	8104c68 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
 8104a3c:	687b      	ldr	r3, [r7, #4]
 8104a3e:	681b      	ldr	r3, [r3, #0]
 8104a40:	2150      	movs	r1, #80	@ 0x50
 8104a42:	4618      	mov	r0, r3
 8104a44:	f000 f96f 	bl	8104d26 <TIM_ITRx_SetConfig>
      break;
 8104a48:	e02c      	b.n	8104aa4 <HAL_TIM_ConfigClockSource+0x1c8>

      /* Check TI2 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI2_ConfigInputStage(htim->Instance,
 8104a4a:	687b      	ldr	r3, [r7, #4]
 8104a4c:	6818      	ldr	r0, [r3, #0]
                               sClockSourceConfig->ClockPolarity,
 8104a4e:	683b      	ldr	r3, [r7, #0]
 8104a50:	6859      	ldr	r1, [r3, #4]
                               sClockSourceConfig->ClockFilter);
 8104a52:	683b      	ldr	r3, [r7, #0]
 8104a54:	68db      	ldr	r3, [r3, #12]
      TIM_TI2_ConfigInputStage(htim->Instance,
 8104a56:	461a      	mov	r2, r3
 8104a58:	f000 f935 	bl	8104cc6 <TIM_TI2_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
 8104a5c:	687b      	ldr	r3, [r7, #4]
 8104a5e:	681b      	ldr	r3, [r3, #0]
 8104a60:	2160      	movs	r1, #96	@ 0x60
 8104a62:	4618      	mov	r0, r3
 8104a64:	f000 f95f 	bl	8104d26 <TIM_ITRx_SetConfig>
      break;
 8104a68:	e01c      	b.n	8104aa4 <HAL_TIM_ConfigClockSource+0x1c8>

      /* Check TI1 input conditioning related parameters */
      assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
      assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));

      TIM_TI1_ConfigInputStage(htim->Instance,
 8104a6a:	687b      	ldr	r3, [r7, #4]
 8104a6c:	6818      	ldr	r0, [r3, #0]
                               sClockSourceConfig->ClockPolarity,
 8104a6e:	683b      	ldr	r3, [r7, #0]
 8104a70:	6859      	ldr	r1, [r3, #4]
                               sClockSourceConfig->ClockFilter);
 8104a72:	683b      	ldr	r3, [r7, #0]
 8104a74:	68db      	ldr	r3, [r3, #12]
      TIM_TI1_ConfigInputStage(htim->Instance,
 8104a76:	461a      	mov	r2, r3
 8104a78:	f000 f8f6 	bl	8104c68 <TIM_TI1_ConfigInputStage>
      TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
 8104a7c:	687b      	ldr	r3, [r7, #4]
 8104a7e:	681b      	ldr	r3, [r3, #0]
 8104a80:	2140      	movs	r1, #64	@ 0x40
 8104a82:	4618      	mov	r0, r3
 8104a84:	f000 f94f 	bl	8104d26 <TIM_ITRx_SetConfig>
      break;
 8104a88:	e00c      	b.n	8104aa4 <HAL_TIM_ConfigClockSource+0x1c8>
    case TIM_CLOCKSOURCE_ITR8:
    {
      /* Check whether or not the timer instance supports internal trigger input */
      assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));

      TIM_ITRx_SetConfig(htim->Instance, sClockSourceConfig->ClockSource);
 8104a8a:	687b      	ldr	r3, [r7, #4]
 8104a8c:	681a      	ldr	r2, [r3, #0]
 8104a8e:	683b      	ldr	r3, [r7, #0]
 8104a90:	681b      	ldr	r3, [r3, #0]
 8104a92:	4619      	mov	r1, r3
 8104a94:	4610      	mov	r0, r2
 8104a96:	f000 f946 	bl	8104d26 <TIM_ITRx_SetConfig>
      break;
 8104a9a:	e003      	b.n	8104aa4 <HAL_TIM_ConfigClockSource+0x1c8>
    }

    default:
      status = HAL_ERROR;
 8104a9c:	2301      	movs	r3, #1
 8104a9e:	73fb      	strb	r3, [r7, #15]
      break;
 8104aa0:	e000      	b.n	8104aa4 <HAL_TIM_ConfigClockSource+0x1c8>
      break;
 8104aa2:	bf00      	nop
  }
  htim->State = HAL_TIM_STATE_READY;
 8104aa4:	687b      	ldr	r3, [r7, #4]
 8104aa6:	2201      	movs	r2, #1
 8104aa8:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  __HAL_UNLOCK(htim);
 8104aac:	687b      	ldr	r3, [r7, #4]
 8104aae:	2200      	movs	r2, #0
 8104ab0:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return status;
 8104ab4:	7bfb      	ldrb	r3, [r7, #15]
}
 8104ab6:	4618      	mov	r0, r3
 8104ab8:	3710      	adds	r7, #16
 8104aba:	46bd      	mov	sp, r7
 8104abc:	bd80      	pop	{r7, pc}
 8104abe:	bf00      	nop
 8104ac0:	00100040 	.word	0x00100040
 8104ac4:	00100030 	.word	0x00100030
 8104ac8:	00100020 	.word	0x00100020

08104acc <HAL_TIM_OC_DelayElapsedCallback>:
  * @brief  Output Compare callback in non-blocking mode
  * @param  htim TIM OC handle
  * @retval None
  */
__weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
{
 8104acc:	b480      	push	{r7}
 8104ace:	b083      	sub	sp, #12
 8104ad0:	af00      	add	r7, sp, #0
 8104ad2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   */
}
 8104ad4:	bf00      	nop
 8104ad6:	370c      	adds	r7, #12
 8104ad8:	46bd      	mov	sp, r7
 8104ada:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104ade:	4770      	bx	lr

08104ae0 <HAL_TIM_IC_CaptureCallback>:
  * @brief  Input Capture callback in non-blocking mode
  * @param  htim TIM IC handle
  * @retval None
  */
__weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
 8104ae0:	b480      	push	{r7}
 8104ae2:	b083      	sub	sp, #12
 8104ae4:	af00      	add	r7, sp, #0
 8104ae6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_IC_CaptureCallback could be implemented in the user file
   */
}
 8104ae8:	bf00      	nop
 8104aea:	370c      	adds	r7, #12
 8104aec:	46bd      	mov	sp, r7
 8104aee:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104af2:	4770      	bx	lr

08104af4 <HAL_TIM_PWM_PulseFinishedCallback>:
  * @brief  PWM Pulse finished callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
 8104af4:	b480      	push	{r7}
 8104af6:	b083      	sub	sp, #12
 8104af8:	af00      	add	r7, sp, #0
 8104afa:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   */
}
 8104afc:	bf00      	nop
 8104afe:	370c      	adds	r7, #12
 8104b00:	46bd      	mov	sp, r7
 8104b02:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104b06:	4770      	bx	lr

08104b08 <HAL_TIM_TriggerCallback>:
  * @brief  Hall Trigger detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
{
 8104b08:	b480      	push	{r7}
 8104b0a:	b083      	sub	sp, #12
 8104b0c:	af00      	add	r7, sp, #0
 8104b0e:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_TriggerCallback could be implemented in the user file
   */
}
 8104b10:	bf00      	nop
 8104b12:	370c      	adds	r7, #12
 8104b14:	46bd      	mov	sp, r7
 8104b16:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104b1a:	4770      	bx	lr

08104b1c <TIM_Base_SetConfig>:
  * @param  TIMx TIM peripheral
  * @param  Structure TIM Base configuration structure
  * @retval None
  */
void TIM_Base_SetConfig(TIM_TypeDef *TIMx, const TIM_Base_InitTypeDef *Structure)
{
 8104b1c:	b480      	push	{r7}
 8104b1e:	b085      	sub	sp, #20
 8104b20:	af00      	add	r7, sp, #0
 8104b22:	6078      	str	r0, [r7, #4]
 8104b24:	6039      	str	r1, [r7, #0]
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;
 8104b26:	687b      	ldr	r3, [r7, #4]
 8104b28:	681b      	ldr	r3, [r3, #0]
 8104b2a:	60fb      	str	r3, [r7, #12]

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8104b2c:	687b      	ldr	r3, [r7, #4]
 8104b2e:	4a46      	ldr	r2, [pc, #280]	@ (8104c48 <TIM_Base_SetConfig+0x12c>)
 8104b30:	4293      	cmp	r3, r2
 8104b32:	d013      	beq.n	8104b5c <TIM_Base_SetConfig+0x40>
 8104b34:	687b      	ldr	r3, [r7, #4]
 8104b36:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8104b3a:	d00f      	beq.n	8104b5c <TIM_Base_SetConfig+0x40>
 8104b3c:	687b      	ldr	r3, [r7, #4]
 8104b3e:	4a43      	ldr	r2, [pc, #268]	@ (8104c4c <TIM_Base_SetConfig+0x130>)
 8104b40:	4293      	cmp	r3, r2
 8104b42:	d00b      	beq.n	8104b5c <TIM_Base_SetConfig+0x40>
 8104b44:	687b      	ldr	r3, [r7, #4]
 8104b46:	4a42      	ldr	r2, [pc, #264]	@ (8104c50 <TIM_Base_SetConfig+0x134>)
 8104b48:	4293      	cmp	r3, r2
 8104b4a:	d007      	beq.n	8104b5c <TIM_Base_SetConfig+0x40>
 8104b4c:	687b      	ldr	r3, [r7, #4]
 8104b4e:	4a41      	ldr	r2, [pc, #260]	@ (8104c54 <TIM_Base_SetConfig+0x138>)
 8104b50:	4293      	cmp	r3, r2
 8104b52:	d003      	beq.n	8104b5c <TIM_Base_SetConfig+0x40>
 8104b54:	687b      	ldr	r3, [r7, #4]
 8104b56:	4a40      	ldr	r2, [pc, #256]	@ (8104c58 <TIM_Base_SetConfig+0x13c>)
 8104b58:	4293      	cmp	r3, r2
 8104b5a:	d108      	bne.n	8104b6e <TIM_Base_SetConfig+0x52>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8104b5c:	68fb      	ldr	r3, [r7, #12]
 8104b5e:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8104b62:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= Structure->CounterMode;
 8104b64:	683b      	ldr	r3, [r7, #0]
 8104b66:	685b      	ldr	r3, [r3, #4]
 8104b68:	68fa      	ldr	r2, [r7, #12]
 8104b6a:	4313      	orrs	r3, r2
 8104b6c:	60fb      	str	r3, [r7, #12]
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8104b6e:	687b      	ldr	r3, [r7, #4]
 8104b70:	4a35      	ldr	r2, [pc, #212]	@ (8104c48 <TIM_Base_SetConfig+0x12c>)
 8104b72:	4293      	cmp	r3, r2
 8104b74:	d01f      	beq.n	8104bb6 <TIM_Base_SetConfig+0x9a>
 8104b76:	687b      	ldr	r3, [r7, #4]
 8104b78:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8104b7c:	d01b      	beq.n	8104bb6 <TIM_Base_SetConfig+0x9a>
 8104b7e:	687b      	ldr	r3, [r7, #4]
 8104b80:	4a32      	ldr	r2, [pc, #200]	@ (8104c4c <TIM_Base_SetConfig+0x130>)
 8104b82:	4293      	cmp	r3, r2
 8104b84:	d017      	beq.n	8104bb6 <TIM_Base_SetConfig+0x9a>
 8104b86:	687b      	ldr	r3, [r7, #4]
 8104b88:	4a31      	ldr	r2, [pc, #196]	@ (8104c50 <TIM_Base_SetConfig+0x134>)
 8104b8a:	4293      	cmp	r3, r2
 8104b8c:	d013      	beq.n	8104bb6 <TIM_Base_SetConfig+0x9a>
 8104b8e:	687b      	ldr	r3, [r7, #4]
 8104b90:	4a30      	ldr	r2, [pc, #192]	@ (8104c54 <TIM_Base_SetConfig+0x138>)
 8104b92:	4293      	cmp	r3, r2
 8104b94:	d00f      	beq.n	8104bb6 <TIM_Base_SetConfig+0x9a>
 8104b96:	687b      	ldr	r3, [r7, #4]
 8104b98:	4a2f      	ldr	r2, [pc, #188]	@ (8104c58 <TIM_Base_SetConfig+0x13c>)
 8104b9a:	4293      	cmp	r3, r2
 8104b9c:	d00b      	beq.n	8104bb6 <TIM_Base_SetConfig+0x9a>
 8104b9e:	687b      	ldr	r3, [r7, #4]
 8104ba0:	4a2e      	ldr	r2, [pc, #184]	@ (8104c5c <TIM_Base_SetConfig+0x140>)
 8104ba2:	4293      	cmp	r3, r2
 8104ba4:	d007      	beq.n	8104bb6 <TIM_Base_SetConfig+0x9a>
 8104ba6:	687b      	ldr	r3, [r7, #4]
 8104ba8:	4a2d      	ldr	r2, [pc, #180]	@ (8104c60 <TIM_Base_SetConfig+0x144>)
 8104baa:	4293      	cmp	r3, r2
 8104bac:	d003      	beq.n	8104bb6 <TIM_Base_SetConfig+0x9a>
 8104bae:	687b      	ldr	r3, [r7, #4]
 8104bb0:	4a2c      	ldr	r2, [pc, #176]	@ (8104c64 <TIM_Base_SetConfig+0x148>)
 8104bb2:	4293      	cmp	r3, r2
 8104bb4:	d108      	bne.n	8104bc8 <TIM_Base_SetConfig+0xac>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
 8104bb6:	68fb      	ldr	r3, [r7, #12]
 8104bb8:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8104bbc:	60fb      	str	r3, [r7, #12]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8104bbe:	683b      	ldr	r3, [r7, #0]
 8104bc0:	68db      	ldr	r3, [r3, #12]
 8104bc2:	68fa      	ldr	r2, [r7, #12]
 8104bc4:	4313      	orrs	r3, r2
 8104bc6:	60fb      	str	r3, [r7, #12]
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8104bc8:	68fb      	ldr	r3, [r7, #12]
 8104bca:	f023 0280 	bic.w	r2, r3, #128	@ 0x80
 8104bce:	683b      	ldr	r3, [r7, #0]
 8104bd0:	695b      	ldr	r3, [r3, #20]
 8104bd2:	4313      	orrs	r3, r2
 8104bd4:	60fb      	str	r3, [r7, #12]

  TIMx->CR1 = tmpcr1;
 8104bd6:	687b      	ldr	r3, [r7, #4]
 8104bd8:	68fa      	ldr	r2, [r7, #12]
 8104bda:	601a      	str	r2, [r3, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8104bdc:	683b      	ldr	r3, [r7, #0]
 8104bde:	689a      	ldr	r2, [r3, #8]
 8104be0:	687b      	ldr	r3, [r7, #4]
 8104be2:	62da      	str	r2, [r3, #44]	@ 0x2c

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8104be4:	683b      	ldr	r3, [r7, #0]
 8104be6:	681a      	ldr	r2, [r3, #0]
 8104be8:	687b      	ldr	r3, [r7, #4]
 8104bea:	629a      	str	r2, [r3, #40]	@ 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8104bec:	687b      	ldr	r3, [r7, #4]
 8104bee:	4a16      	ldr	r2, [pc, #88]	@ (8104c48 <TIM_Base_SetConfig+0x12c>)
 8104bf0:	4293      	cmp	r3, r2
 8104bf2:	d00f      	beq.n	8104c14 <TIM_Base_SetConfig+0xf8>
 8104bf4:	687b      	ldr	r3, [r7, #4]
 8104bf6:	4a18      	ldr	r2, [pc, #96]	@ (8104c58 <TIM_Base_SetConfig+0x13c>)
 8104bf8:	4293      	cmp	r3, r2
 8104bfa:	d00b      	beq.n	8104c14 <TIM_Base_SetConfig+0xf8>
 8104bfc:	687b      	ldr	r3, [r7, #4]
 8104bfe:	4a17      	ldr	r2, [pc, #92]	@ (8104c5c <TIM_Base_SetConfig+0x140>)
 8104c00:	4293      	cmp	r3, r2
 8104c02:	d007      	beq.n	8104c14 <TIM_Base_SetConfig+0xf8>
 8104c04:	687b      	ldr	r3, [r7, #4]
 8104c06:	4a16      	ldr	r2, [pc, #88]	@ (8104c60 <TIM_Base_SetConfig+0x144>)
 8104c08:	4293      	cmp	r3, r2
 8104c0a:	d003      	beq.n	8104c14 <TIM_Base_SetConfig+0xf8>
 8104c0c:	687b      	ldr	r3, [r7, #4]
 8104c0e:	4a15      	ldr	r2, [pc, #84]	@ (8104c64 <TIM_Base_SetConfig+0x148>)
 8104c10:	4293      	cmp	r3, r2
 8104c12:	d103      	bne.n	8104c1c <TIM_Base_SetConfig+0x100>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8104c14:	683b      	ldr	r3, [r7, #0]
 8104c16:	691a      	ldr	r2, [r3, #16]
 8104c18:	687b      	ldr	r3, [r7, #4]
 8104c1a:	631a      	str	r2, [r3, #48]	@ 0x30
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8104c1c:	687b      	ldr	r3, [r7, #4]
 8104c1e:	2201      	movs	r2, #1
 8104c20:	615a      	str	r2, [r3, #20]

  /* Check if the update flag is set after the Update Generation, if so clear the UIF flag */
  if (HAL_IS_BIT_SET(TIMx->SR, TIM_FLAG_UPDATE))
 8104c22:	687b      	ldr	r3, [r7, #4]
 8104c24:	691b      	ldr	r3, [r3, #16]
 8104c26:	f003 0301 	and.w	r3, r3, #1
 8104c2a:	2b01      	cmp	r3, #1
 8104c2c:	d105      	bne.n	8104c3a <TIM_Base_SetConfig+0x11e>
  {
    /* Clear the update flag */
    CLEAR_BIT(TIMx->SR, TIM_FLAG_UPDATE);
 8104c2e:	687b      	ldr	r3, [r7, #4]
 8104c30:	691b      	ldr	r3, [r3, #16]
 8104c32:	f023 0201 	bic.w	r2, r3, #1
 8104c36:	687b      	ldr	r3, [r7, #4]
 8104c38:	611a      	str	r2, [r3, #16]
  }
}
 8104c3a:	bf00      	nop
 8104c3c:	3714      	adds	r7, #20
 8104c3e:	46bd      	mov	sp, r7
 8104c40:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104c44:	4770      	bx	lr
 8104c46:	bf00      	nop
 8104c48:	40010000 	.word	0x40010000
 8104c4c:	40000400 	.word	0x40000400
 8104c50:	40000800 	.word	0x40000800
 8104c54:	40000c00 	.word	0x40000c00
 8104c58:	40010400 	.word	0x40010400
 8104c5c:	40014000 	.word	0x40014000
 8104c60:	40014400 	.word	0x40014400
 8104c64:	40014800 	.word	0x40014800

08104c68 <TIM_TI1_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8104c68:	b480      	push	{r7}
 8104c6a:	b087      	sub	sp, #28
 8104c6c:	af00      	add	r7, sp, #0
 8104c6e:	60f8      	str	r0, [r7, #12]
 8104c70:	60b9      	str	r1, [r7, #8]
 8104c72:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 1: Reset the CC1E Bit */
  tmpccer = TIMx->CCER;
 8104c74:	68fb      	ldr	r3, [r7, #12]
 8104c76:	6a1b      	ldr	r3, [r3, #32]
 8104c78:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC1E;
 8104c7a:	68fb      	ldr	r3, [r7, #12]
 8104c7c:	6a1b      	ldr	r3, [r3, #32]
 8104c7e:	f023 0201 	bic.w	r2, r3, #1
 8104c82:	68fb      	ldr	r3, [r7, #12]
 8104c84:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8104c86:	68fb      	ldr	r3, [r7, #12]
 8104c88:	699b      	ldr	r3, [r3, #24]
 8104c8a:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC1F;
 8104c8c:	693b      	ldr	r3, [r7, #16]
 8104c8e:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8104c92:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 4U);
 8104c94:	687b      	ldr	r3, [r7, #4]
 8104c96:	011b      	lsls	r3, r3, #4
 8104c98:	693a      	ldr	r2, [r7, #16]
 8104c9a:	4313      	orrs	r3, r2
 8104c9c:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC1E Bit */
  tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
 8104c9e:	697b      	ldr	r3, [r7, #20]
 8104ca0:	f023 030a 	bic.w	r3, r3, #10
 8104ca4:	617b      	str	r3, [r7, #20]
  tmpccer |= TIM_ICPolarity;
 8104ca6:	697a      	ldr	r2, [r7, #20]
 8104ca8:	68bb      	ldr	r3, [r7, #8]
 8104caa:	4313      	orrs	r3, r2
 8104cac:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1;
 8104cae:	68fb      	ldr	r3, [r7, #12]
 8104cb0:	693a      	ldr	r2, [r7, #16]
 8104cb2:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8104cb4:	68fb      	ldr	r3, [r7, #12]
 8104cb6:	697a      	ldr	r2, [r7, #20]
 8104cb8:	621a      	str	r2, [r3, #32]
}
 8104cba:	bf00      	nop
 8104cbc:	371c      	adds	r7, #28
 8104cbe:	46bd      	mov	sp, r7
 8104cc0:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104cc4:	4770      	bx	lr

08104cc6 <TIM_TI2_ConfigInputStage>:
  * @param  TIM_ICFilter Specifies the Input Capture Filter.
  *          This parameter must be a value between 0x00 and 0x0F.
  * @retval None
  */
static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
{
 8104cc6:	b480      	push	{r7}
 8104cc8:	b087      	sub	sp, #28
 8104cca:	af00      	add	r7, sp, #0
 8104ccc:	60f8      	str	r0, [r7, #12]
 8104cce:	60b9      	str	r1, [r7, #8]
 8104cd0:	607a      	str	r2, [r7, #4]
  uint32_t tmpccmr1;
  uint32_t tmpccer;

  /* Disable the Channel 2: Reset the CC2E Bit */
  tmpccer = TIMx->CCER;
 8104cd2:	68fb      	ldr	r3, [r7, #12]
 8104cd4:	6a1b      	ldr	r3, [r3, #32]
 8104cd6:	617b      	str	r3, [r7, #20]
  TIMx->CCER &= ~TIM_CCER_CC2E;
 8104cd8:	68fb      	ldr	r3, [r7, #12]
 8104cda:	6a1b      	ldr	r3, [r3, #32]
 8104cdc:	f023 0210 	bic.w	r2, r3, #16
 8104ce0:	68fb      	ldr	r3, [r7, #12]
 8104ce2:	621a      	str	r2, [r3, #32]
  tmpccmr1 = TIMx->CCMR1;
 8104ce4:	68fb      	ldr	r3, [r7, #12]
 8104ce6:	699b      	ldr	r3, [r3, #24]
 8104ce8:	613b      	str	r3, [r7, #16]

  /* Set the filter */
  tmpccmr1 &= ~TIM_CCMR1_IC2F;
 8104cea:	693b      	ldr	r3, [r7, #16]
 8104cec:	f423 4370 	bic.w	r3, r3, #61440	@ 0xf000
 8104cf0:	613b      	str	r3, [r7, #16]
  tmpccmr1 |= (TIM_ICFilter << 12U);
 8104cf2:	687b      	ldr	r3, [r7, #4]
 8104cf4:	031b      	lsls	r3, r3, #12
 8104cf6:	693a      	ldr	r2, [r7, #16]
 8104cf8:	4313      	orrs	r3, r2
 8104cfa:	613b      	str	r3, [r7, #16]

  /* Select the Polarity and set the CC2E Bit */
  tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
 8104cfc:	697b      	ldr	r3, [r7, #20]
 8104cfe:	f023 03a0 	bic.w	r3, r3, #160	@ 0xa0
 8104d02:	617b      	str	r3, [r7, #20]
  tmpccer |= (TIM_ICPolarity << 4U);
 8104d04:	68bb      	ldr	r3, [r7, #8]
 8104d06:	011b      	lsls	r3, r3, #4
 8104d08:	697a      	ldr	r2, [r7, #20]
 8104d0a:	4313      	orrs	r3, r2
 8104d0c:	617b      	str	r3, [r7, #20]

  /* Write to TIMx CCMR1 and CCER registers */
  TIMx->CCMR1 = tmpccmr1 ;
 8104d0e:	68fb      	ldr	r3, [r7, #12]
 8104d10:	693a      	ldr	r2, [r7, #16]
 8104d12:	619a      	str	r2, [r3, #24]
  TIMx->CCER = tmpccer;
 8104d14:	68fb      	ldr	r3, [r7, #12]
 8104d16:	697a      	ldr	r2, [r7, #20]
 8104d18:	621a      	str	r2, [r3, #32]
}
 8104d1a:	bf00      	nop
 8104d1c:	371c      	adds	r7, #28
 8104d1e:	46bd      	mov	sp, r7
 8104d20:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104d24:	4770      	bx	lr

08104d26 <TIM_ITRx_SetConfig>:
  *       (*)  Value not defined in all devices.
  *
  * @retval None
  */
static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint32_t InputTriggerSource)
{
 8104d26:	b480      	push	{r7}
 8104d28:	b085      	sub	sp, #20
 8104d2a:	af00      	add	r7, sp, #0
 8104d2c:	6078      	str	r0, [r7, #4]
 8104d2e:	6039      	str	r1, [r7, #0]
  uint32_t tmpsmcr;

  /* Get the TIMx SMCR register value */
  tmpsmcr = TIMx->SMCR;
 8104d30:	687b      	ldr	r3, [r7, #4]
 8104d32:	689b      	ldr	r3, [r3, #8]
 8104d34:	60fb      	str	r3, [r7, #12]
  /* Reset the TS Bits */
  tmpsmcr &= ~TIM_SMCR_TS;
 8104d36:	68fb      	ldr	r3, [r7, #12]
 8104d38:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
 8104d3c:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8104d40:	60fb      	str	r3, [r7, #12]
  /* Set the Input Trigger source and the slave mode*/
  tmpsmcr |= (InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1);
 8104d42:	683a      	ldr	r2, [r7, #0]
 8104d44:	68fb      	ldr	r3, [r7, #12]
 8104d46:	4313      	orrs	r3, r2
 8104d48:	f043 0307 	orr.w	r3, r3, #7
 8104d4c:	60fb      	str	r3, [r7, #12]
  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8104d4e:	687b      	ldr	r3, [r7, #4]
 8104d50:	68fa      	ldr	r2, [r7, #12]
 8104d52:	609a      	str	r2, [r3, #8]
}
 8104d54:	bf00      	nop
 8104d56:	3714      	adds	r7, #20
 8104d58:	46bd      	mov	sp, r7
 8104d5a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104d5e:	4770      	bx	lr

08104d60 <TIM_ETR_SetConfig>:
  *          This parameter must be a value between 0x00 and 0x0F
  * @retval None
  */
void TIM_ETR_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ExtTRGPrescaler,
                       uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
{
 8104d60:	b480      	push	{r7}
 8104d62:	b087      	sub	sp, #28
 8104d64:	af00      	add	r7, sp, #0
 8104d66:	60f8      	str	r0, [r7, #12]
 8104d68:	60b9      	str	r1, [r7, #8]
 8104d6a:	607a      	str	r2, [r7, #4]
 8104d6c:	603b      	str	r3, [r7, #0]
  uint32_t tmpsmcr;

  tmpsmcr = TIMx->SMCR;
 8104d6e:	68fb      	ldr	r3, [r7, #12]
 8104d70:	689b      	ldr	r3, [r3, #8]
 8104d72:	617b      	str	r3, [r7, #20]

  /* Reset the ETR Bits */
  tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
 8104d74:	697b      	ldr	r3, [r7, #20]
 8104d76:	f423 437f 	bic.w	r3, r3, #65280	@ 0xff00
 8104d7a:	617b      	str	r3, [r7, #20]

  /* Set the Prescaler, the Filter value and the Polarity */
  tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
 8104d7c:	683b      	ldr	r3, [r7, #0]
 8104d7e:	021a      	lsls	r2, r3, #8
 8104d80:	687b      	ldr	r3, [r7, #4]
 8104d82:	431a      	orrs	r2, r3
 8104d84:	68bb      	ldr	r3, [r7, #8]
 8104d86:	4313      	orrs	r3, r2
 8104d88:	697a      	ldr	r2, [r7, #20]
 8104d8a:	4313      	orrs	r3, r2
 8104d8c:	617b      	str	r3, [r7, #20]

  /* Write to TIMx SMCR */
  TIMx->SMCR = tmpsmcr;
 8104d8e:	68fb      	ldr	r3, [r7, #12]
 8104d90:	697a      	ldr	r2, [r7, #20]
 8104d92:	609a      	str	r2, [r3, #8]
}
 8104d94:	bf00      	nop
 8104d96:	371c      	adds	r7, #28
 8104d98:	46bd      	mov	sp, r7
 8104d9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104d9e:	4770      	bx	lr

08104da0 <HAL_TIMEx_MasterConfigSynchronization>:
  *         mode.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_TIMEx_MasterConfigSynchronization(TIM_HandleTypeDef *htim,
                                                        const TIM_MasterConfigTypeDef *sMasterConfig)
{
 8104da0:	b480      	push	{r7}
 8104da2:	b085      	sub	sp, #20
 8104da4:	af00      	add	r7, sp, #0
 8104da6:	6078      	str	r0, [r7, #4]
 8104da8:	6039      	str	r1, [r7, #0]
  assert_param(IS_TIM_MASTER_INSTANCE(htim->Instance));
  assert_param(IS_TIM_TRGO_SOURCE(sMasterConfig->MasterOutputTrigger));
  assert_param(IS_TIM_MSM_STATE(sMasterConfig->MasterSlaveMode));

  /* Check input state */
  __HAL_LOCK(htim);
 8104daa:	687b      	ldr	r3, [r7, #4]
 8104dac:	f893 303c 	ldrb.w	r3, [r3, #60]	@ 0x3c
 8104db0:	2b01      	cmp	r3, #1
 8104db2:	d101      	bne.n	8104db8 <HAL_TIMEx_MasterConfigSynchronization+0x18>
 8104db4:	2302      	movs	r3, #2
 8104db6:	e06d      	b.n	8104e94 <HAL_TIMEx_MasterConfigSynchronization+0xf4>
 8104db8:	687b      	ldr	r3, [r7, #4]
 8104dba:	2201      	movs	r2, #1
 8104dbc:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  /* Change the handler state */
  htim->State = HAL_TIM_STATE_BUSY;
 8104dc0:	687b      	ldr	r3, [r7, #4]
 8104dc2:	2202      	movs	r2, #2
 8104dc4:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  /* Get the TIMx CR2 register value */
  tmpcr2 = htim->Instance->CR2;
 8104dc8:	687b      	ldr	r3, [r7, #4]
 8104dca:	681b      	ldr	r3, [r3, #0]
 8104dcc:	685b      	ldr	r3, [r3, #4]
 8104dce:	60fb      	str	r3, [r7, #12]

  /* Get the TIMx SMCR register value */
  tmpsmcr = htim->Instance->SMCR;
 8104dd0:	687b      	ldr	r3, [r7, #4]
 8104dd2:	681b      	ldr	r3, [r3, #0]
 8104dd4:	689b      	ldr	r3, [r3, #8]
 8104dd6:	60bb      	str	r3, [r7, #8]

  /* If the timer supports ADC synchronization through TRGO2, set the master mode selection 2 */
  if (IS_TIM_TRGO2_INSTANCE(htim->Instance))
 8104dd8:	687b      	ldr	r3, [r7, #4]
 8104dda:	681b      	ldr	r3, [r3, #0]
 8104ddc:	4a30      	ldr	r2, [pc, #192]	@ (8104ea0 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 8104dde:	4293      	cmp	r3, r2
 8104de0:	d004      	beq.n	8104dec <HAL_TIMEx_MasterConfigSynchronization+0x4c>
 8104de2:	687b      	ldr	r3, [r7, #4]
 8104de4:	681b      	ldr	r3, [r3, #0]
 8104de6:	4a2f      	ldr	r2, [pc, #188]	@ (8104ea4 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 8104de8:	4293      	cmp	r3, r2
 8104dea:	d108      	bne.n	8104dfe <HAL_TIMEx_MasterConfigSynchronization+0x5e>
  {
    /* Check the parameters */
    assert_param(IS_TIM_TRGO2_SOURCE(sMasterConfig->MasterOutputTrigger2));

    /* Clear the MMS2 bits */
    tmpcr2 &= ~TIM_CR2_MMS2;
 8104dec:	68fb      	ldr	r3, [r7, #12]
 8104dee:	f423 0370 	bic.w	r3, r3, #15728640	@ 0xf00000
 8104df2:	60fb      	str	r3, [r7, #12]
    /* Select the TRGO2 source*/
    tmpcr2 |= sMasterConfig->MasterOutputTrigger2;
 8104df4:	683b      	ldr	r3, [r7, #0]
 8104df6:	685b      	ldr	r3, [r3, #4]
 8104df8:	68fa      	ldr	r2, [r7, #12]
 8104dfa:	4313      	orrs	r3, r2
 8104dfc:	60fb      	str	r3, [r7, #12]
  }

  /* Reset the MMS Bits */
  tmpcr2 &= ~TIM_CR2_MMS;
 8104dfe:	68fb      	ldr	r3, [r7, #12]
 8104e00:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8104e04:	60fb      	str	r3, [r7, #12]
  /* Select the TRGO source */
  tmpcr2 |=  sMasterConfig->MasterOutputTrigger;
 8104e06:	683b      	ldr	r3, [r7, #0]
 8104e08:	681b      	ldr	r3, [r3, #0]
 8104e0a:	68fa      	ldr	r2, [r7, #12]
 8104e0c:	4313      	orrs	r3, r2
 8104e0e:	60fb      	str	r3, [r7, #12]

  /* Update TIMx CR2 */
  htim->Instance->CR2 = tmpcr2;
 8104e10:	687b      	ldr	r3, [r7, #4]
 8104e12:	681b      	ldr	r3, [r3, #0]
 8104e14:	68fa      	ldr	r2, [r7, #12]
 8104e16:	605a      	str	r2, [r3, #4]

  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8104e18:	687b      	ldr	r3, [r7, #4]
 8104e1a:	681b      	ldr	r3, [r3, #0]
 8104e1c:	4a20      	ldr	r2, [pc, #128]	@ (8104ea0 <HAL_TIMEx_MasterConfigSynchronization+0x100>)
 8104e1e:	4293      	cmp	r3, r2
 8104e20:	d022      	beq.n	8104e68 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 8104e22:	687b      	ldr	r3, [r7, #4]
 8104e24:	681b      	ldr	r3, [r3, #0]
 8104e26:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8104e2a:	d01d      	beq.n	8104e68 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 8104e2c:	687b      	ldr	r3, [r7, #4]
 8104e2e:	681b      	ldr	r3, [r3, #0]
 8104e30:	4a1d      	ldr	r2, [pc, #116]	@ (8104ea8 <HAL_TIMEx_MasterConfigSynchronization+0x108>)
 8104e32:	4293      	cmp	r3, r2
 8104e34:	d018      	beq.n	8104e68 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 8104e36:	687b      	ldr	r3, [r7, #4]
 8104e38:	681b      	ldr	r3, [r3, #0]
 8104e3a:	4a1c      	ldr	r2, [pc, #112]	@ (8104eac <HAL_TIMEx_MasterConfigSynchronization+0x10c>)
 8104e3c:	4293      	cmp	r3, r2
 8104e3e:	d013      	beq.n	8104e68 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 8104e40:	687b      	ldr	r3, [r7, #4]
 8104e42:	681b      	ldr	r3, [r3, #0]
 8104e44:	4a1a      	ldr	r2, [pc, #104]	@ (8104eb0 <HAL_TIMEx_MasterConfigSynchronization+0x110>)
 8104e46:	4293      	cmp	r3, r2
 8104e48:	d00e      	beq.n	8104e68 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 8104e4a:	687b      	ldr	r3, [r7, #4]
 8104e4c:	681b      	ldr	r3, [r3, #0]
 8104e4e:	4a15      	ldr	r2, [pc, #84]	@ (8104ea4 <HAL_TIMEx_MasterConfigSynchronization+0x104>)
 8104e50:	4293      	cmp	r3, r2
 8104e52:	d009      	beq.n	8104e68 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 8104e54:	687b      	ldr	r3, [r7, #4]
 8104e56:	681b      	ldr	r3, [r3, #0]
 8104e58:	4a16      	ldr	r2, [pc, #88]	@ (8104eb4 <HAL_TIMEx_MasterConfigSynchronization+0x114>)
 8104e5a:	4293      	cmp	r3, r2
 8104e5c:	d004      	beq.n	8104e68 <HAL_TIMEx_MasterConfigSynchronization+0xc8>
 8104e5e:	687b      	ldr	r3, [r7, #4]
 8104e60:	681b      	ldr	r3, [r3, #0]
 8104e62:	4a15      	ldr	r2, [pc, #84]	@ (8104eb8 <HAL_TIMEx_MasterConfigSynchronization+0x118>)
 8104e64:	4293      	cmp	r3, r2
 8104e66:	d10c      	bne.n	8104e82 <HAL_TIMEx_MasterConfigSynchronization+0xe2>
  {
    /* Reset the MSM Bit */
    tmpsmcr &= ~TIM_SMCR_MSM;
 8104e68:	68bb      	ldr	r3, [r7, #8]
 8104e6a:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8104e6e:	60bb      	str	r3, [r7, #8]
    /* Set master mode */
    tmpsmcr |= sMasterConfig->MasterSlaveMode;
 8104e70:	683b      	ldr	r3, [r7, #0]
 8104e72:	689b      	ldr	r3, [r3, #8]
 8104e74:	68ba      	ldr	r2, [r7, #8]
 8104e76:	4313      	orrs	r3, r2
 8104e78:	60bb      	str	r3, [r7, #8]

    /* Update TIMx SMCR */
    htim->Instance->SMCR = tmpsmcr;
 8104e7a:	687b      	ldr	r3, [r7, #4]
 8104e7c:	681b      	ldr	r3, [r3, #0]
 8104e7e:	68ba      	ldr	r2, [r7, #8]
 8104e80:	609a      	str	r2, [r3, #8]
  }

  /* Change the htim state */
  htim->State = HAL_TIM_STATE_READY;
 8104e82:	687b      	ldr	r3, [r7, #4]
 8104e84:	2201      	movs	r2, #1
 8104e86:	f883 203d 	strb.w	r2, [r3, #61]	@ 0x3d

  __HAL_UNLOCK(htim);
 8104e8a:	687b      	ldr	r3, [r7, #4]
 8104e8c:	2200      	movs	r2, #0
 8104e8e:	f883 203c 	strb.w	r2, [r3, #60]	@ 0x3c

  return HAL_OK;
 8104e92:	2300      	movs	r3, #0
}
 8104e94:	4618      	mov	r0, r3
 8104e96:	3714      	adds	r7, #20
 8104e98:	46bd      	mov	sp, r7
 8104e9a:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104e9e:	4770      	bx	lr
 8104ea0:	40010000 	.word	0x40010000
 8104ea4:	40010400 	.word	0x40010400
 8104ea8:	40000400 	.word	0x40000400
 8104eac:	40000800 	.word	0x40000800
 8104eb0:	40000c00 	.word	0x40000c00
 8104eb4:	40001800 	.word	0x40001800
 8104eb8:	40014000 	.word	0x40014000

08104ebc <HAL_TIMEx_CommutCallback>:
  * @brief  Commutation callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_CommutCallback(TIM_HandleTypeDef *htim)
{
 8104ebc:	b480      	push	{r7}
 8104ebe:	b083      	sub	sp, #12
 8104ec0:	af00      	add	r7, sp, #0
 8104ec2:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_CommutCallback could be implemented in the user file
   */
}
 8104ec4:	bf00      	nop
 8104ec6:	370c      	adds	r7, #12
 8104ec8:	46bd      	mov	sp, r7
 8104eca:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104ece:	4770      	bx	lr

08104ed0 <HAL_TIMEx_BreakCallback>:
  * @brief  Break detection callback in non-blocking mode
  * @param  htim TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_BreakCallback(TIM_HandleTypeDef *htim)
{
 8104ed0:	b480      	push	{r7}
 8104ed2:	b083      	sub	sp, #12
 8104ed4:	af00      	add	r7, sp, #0
 8104ed6:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIMEx_BreakCallback could be implemented in the user file
   */
}
 8104ed8:	bf00      	nop
 8104eda:	370c      	adds	r7, #12
 8104edc:	46bd      	mov	sp, r7
 8104ede:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104ee2:	4770      	bx	lr

08104ee4 <HAL_TIMEx_Break2Callback>:
  * @brief  Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 8104ee4:	b480      	push	{r7}
 8104ee6:	b083      	sub	sp, #12
 8104ee8:	af00      	add	r7, sp, #0
 8104eea:	6078      	str	r0, [r7, #4]
  UNUSED(htim);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_TIMEx_Break2Callback could be implemented in the user file
   */
}
 8104eec:	bf00      	nop
 8104eee:	370c      	adds	r7, #12
 8104ef0:	46bd      	mov	sp, r7
 8104ef2:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104ef6:	4770      	bx	lr

08104ef8 <COE_GetObjectDictionary>:
/**

 \brief    returns the pointer to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
OBJCONST TOBJECT OBJMEM * COE_GetObjectDictionary(void)
{
 8104ef8:	b480      	push	{r7}
 8104efa:	af00      	add	r7, sp, #0
    return (OBJCONST TOBJECT OBJMEM *) ObjDicList;
 8104efc:	4b03      	ldr	r3, [pc, #12]	@ (8104f0c <COE_GetObjectDictionary+0x14>)
 8104efe:	681b      	ldr	r3, [r3, #0]
}
 8104f00:	4618      	mov	r0, r3
 8104f02:	46bd      	mov	sp, r7
 8104f04:	f85d 7b04 	ldr.w	r7, [sp], #4
 8104f08:	4770      	bx	lr
 8104f0a:	bf00      	nop
 8104f0c:	10000788 	.word	0x10000788

08104f10 <COE_ObjInit>:
/**
 \brief     This function initialize the several objects
*////////////////////////////////////////////////////////////////////////////////////////

void COE_ObjInit(void)
{
 8104f10:	b580      	push	{r7, lr}
 8104f12:	b082      	sub	sp, #8
 8104f14:	af00      	add	r7, sp, #0

    /* initialize the Sync Manager Output parameter object 0x1C32 */

    sSyncManOutPar.subindex0         = 32;
 8104f16:	4b34      	ldr	r3, [pc, #208]	@ (8104fe8 <COE_ObjInit+0xd8>)
 8104f18:	2220      	movs	r2, #32
 8104f1a:	801a      	strh	r2, [r3, #0]
      from the master to switch between ECAT FreeRun and ECAT Synchron Mode
        if the slave supports both modes,
        in DC mode (selected by the DC registers) this value will be overwritten
        with SYNCTYPE_DCSYNC0 or SYNCTYPE_DCSYNC1 */
     /*default mode is ECAT Synchron Mode */
    sSyncManOutPar.u16SyncType     = SYNCTYPE_FREERUN;
 8104f1c:	4b32      	ldr	r3, [pc, #200]	@ (8104fe8 <COE_ObjInit+0xd8>)
 8104f1e:	2200      	movs	r2, #0
 8104f20:	805a      	strh	r2, [r3, #2]
    /* subindex 2 contains the cycle time of the application,
       in ECAT FreeRun mode it could be used for a timer interrupt to run the application,
        in ECAT Synchron mode it could be written from the master with its local cycle time
        that the slave can check if this cycle time is supported,
        in DC Mode this value will be overwritten with the DC cycle time register */
    sSyncManOutPar.u32CycleTime     = 0;
 8104f22:	4b31      	ldr	r3, [pc, #196]	@ (8104fe8 <COE_ObjInit+0xd8>)
 8104f24:	2200      	movs	r2, #0
 8104f26:	605a      	str	r2, [r3, #4]
    /* only for DC Mode important: the subindex 3 contains the time shift between the
       SYNC0 (SYNC1) signal and when the outputs are put to the hardware to allow the
        master a very exactly calculation of delay times*/
    sSyncManOutPar.u32ShiftTime     = 0;
 8104f28:	4b2f      	ldr	r3, [pc, #188]	@ (8104fe8 <COE_ObjInit+0xd8>)
 8104f2a:	2200      	movs	r2, #0
 8104f2c:	609a      	str	r2, [r3, #8]

    /* the subindex 4 contains the supported synchronization types */

    sSyncManOutPar.u16SyncTypesSupported    = SYNCTYPE_FREERUNSUPP            /* ECAT FreeRun Mode is supported */
 8104f2e:	4b2e      	ldr	r3, [pc, #184]	@ (8104fe8 <COE_ObjInit+0xd8>)
 8104f30:	f244 021f 	movw	r2, #16415	@ 0x401f
 8104f34:	819a      	strh	r2, [r3, #12]

    /* subindex 5 contains the minimum cycle time the slave is able to support,
       will be calculated dynamically because it depends on the connected modules
        (in this example we will make an online measurement in the ESC Interrupt Routine).
        For the sample application this value is set to MIN_PD_CYCLE_TIME */
    sSyncManOutPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
 8104f36:	4b2c      	ldr	r3, [pc, #176]	@ (8104fe8 <COE_ObjInit+0xd8>)
 8104f38:	4a2c      	ldr	r2, [pc, #176]	@ (8104fec <COE_ObjInit+0xdc>)
 8104f3a:	611a      	str	r2, [r3, #16]
    /* only for DC Mode important: subindex 6 contains the minimum delay time the slave
       needs after receiving the SM2-event before the SYNC0(SYNC1) can be received without delays
       will be calculated dynamically because it depends on the connected modules
        (in this example we will make an online measurement in the ESC Interrupt Routine) */
    sSyncManOutPar.u32CalcAndCopyTime = (PD_OUTPUT_CALC_AND_COPY_TIME);
 8104f3c:	4b2a      	ldr	r3, [pc, #168]	@ (8104fe8 <COE_ObjInit+0xd8>)
 8104f3e:	2200      	movs	r2, #0
 8104f40:	615a      	str	r2, [r3, #20]

    /*subindex 8: trigger cycle time measurement*/
    sSyncManOutPar.u16GetCycleTime = 0;
 8104f42:	4b29      	ldr	r3, [pc, #164]	@ (8104fe8 <COE_ObjInit+0xd8>)
 8104f44:	2200      	movs	r2, #0
 8104f46:	839a      	strh	r2, [r3, #28]

    /*subindex 9: time from start driving outputs until outputs are valid*/
    sSyncManOutPar.u32DelayTime = (PD_OUTPUT_DELAY_TIME);
 8104f48:	4b27      	ldr	r3, [pc, #156]	@ (8104fe8 <COE_ObjInit+0xd8>)
 8104f4a:	2200      	movs	r2, #0
 8104f4c:	621a      	str	r2, [r3, #32]

    /*subindex 32: indicates if a synchronisation error has occurred*/
    sSyncManOutPar.u8SyncError = 0;
 8104f4e:	4b26      	ldr	r3, [pc, #152]	@ (8104fe8 <COE_ObjInit+0xd8>)
 8104f50:	2200      	movs	r2, #0
 8104f52:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40

/*ECATCHANGE_START(V5.11) ECAT4*/
    /* initialize the Sync Manager Input parameter object 0x1C33 */
    sSyncManInPar.subindex0         = 32;
 8104f56:	4b26      	ldr	r3, [pc, #152]	@ (8104ff0 <COE_ObjInit+0xe0>)
 8104f58:	2220      	movs	r2, #32
 8104f5a:	801a      	strh	r2, [r3, #0]
    /* default mode is ECAT Synchron Mode, if output size > 0 the inputs are updated with the SM2-event */
    sSyncManInPar.u16SyncType         = SYNCTYPE_FREERUN;
 8104f5c:	4b24      	ldr	r3, [pc, #144]	@ (8104ff0 <COE_ObjInit+0xe0>)
 8104f5e:	2200      	movs	r2, #0
 8104f60:	805a      	strh	r2, [r3, #2]

    /* subindex 2: same as 0x1C32:02 */
    sSyncManInPar.u32CycleTime     = sSyncManOutPar.u32CycleTime;
 8104f62:	4b21      	ldr	r3, [pc, #132]	@ (8104fe8 <COE_ObjInit+0xd8>)
 8104f64:	685b      	ldr	r3, [r3, #4]
 8104f66:	4a22      	ldr	r2, [pc, #136]	@ (8104ff0 <COE_ObjInit+0xe0>)
 8104f68:	6053      	str	r3, [r2, #4]
    /* only for DC Mode important: subindex 3 contains the time shift between the
       SYNC0 (SYNC1) signal and when the inputs are got to the hardware to allow the
        master a very exactly calculation of delay times,
       will be calculated dynamically because it depends on the connected modules
        (in this example we will make an online measurement in the ESC Interrupt Routine) */
    sSyncManInPar.u32ShiftTime     = 0;
 8104f6a:	4b21      	ldr	r3, [pc, #132]	@ (8104ff0 <COE_ObjInit+0xe0>)
 8104f6c:	2200      	movs	r2, #0
 8104f6e:	609a      	str	r2, [r3, #8]
    /* subindex 4: same as 0x1C32:04 */
    sSyncManInPar.u16SyncTypesSupported    = sSyncManOutPar.u16SyncTypesSupported;
 8104f70:	4b1d      	ldr	r3, [pc, #116]	@ (8104fe8 <COE_ObjInit+0xd8>)
 8104f72:	899a      	ldrh	r2, [r3, #12]
 8104f74:	4b1e      	ldr	r3, [pc, #120]	@ (8104ff0 <COE_ObjInit+0xe0>)
 8104f76:	819a      	strh	r2, [r3, #12]

    /* subindex 5: same as 0x1C32:05 */
    sSyncManInPar.u32MinCycleTime = MIN_PD_CYCLE_TIME;
 8104f78:	4b1d      	ldr	r3, [pc, #116]	@ (8104ff0 <COE_ObjInit+0xe0>)
 8104f7a:	4a1c      	ldr	r2, [pc, #112]	@ (8104fec <COE_ObjInit+0xdc>)
 8104f7c:	611a      	str	r2, [r3, #16]
    /* subindex 6: delay read inputs, calculation and copy to SM buffer*/
    sSyncManInPar.u32CalcAndCopyTime = (PD_INPUT_CALC_AND_COPY_TIME);
 8104f7e:	4b1c      	ldr	r3, [pc, #112]	@ (8104ff0 <COE_ObjInit+0xe0>)
 8104f80:	2200      	movs	r2, #0
 8104f82:	615a      	str	r2, [r3, #20]
    /*subindex 8: trigger cycle time measurement*/
    sSyncManInPar.u16GetCycleTime = 0;
 8104f84:	4b1a      	ldr	r3, [pc, #104]	@ (8104ff0 <COE_ObjInit+0xe0>)
 8104f86:	2200      	movs	r2, #0
 8104f88:	839a      	strh	r2, [r3, #28]
    /*subindex 9: delay to prepare input latch*/
    sSyncManInPar.u32DelayTime = (PD_INPUT_DELAY_TIME);
 8104f8a:	4b19      	ldr	r3, [pc, #100]	@ (8104ff0 <COE_ObjInit+0xe0>)
 8104f8c:	2200      	movs	r2, #0
 8104f8e:	621a      	str	r2, [r3, #32]

    /*subindex 32: incremented if a synchronisation error has occurred*/
    sSyncManInPar.u8SyncError = 0;
 8104f90:	4b17      	ldr	r3, [pc, #92]	@ (8104ff0 <COE_ObjInit+0xe0>)
 8104f92:	2200      	movs	r2, #0
 8104f94:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
/*ECATCHANGE_END(V5.11) ECAT4*/

    /*Indicate no user specified Sync mode*/
    bSyncSetByUser = FALSE;
 8104f98:	4b16      	ldr	r3, [pc, #88]	@ (8104ff4 <COE_ObjInit+0xe4>)
 8104f9a:	2200      	movs	r2, #0
 8104f9c:	701a      	strb	r2, [r3, #0]

    {
    UINT16 result = COE_ObjDictionaryInit();
 8104f9e:	f000 f931 	bl	8105204 <COE_ObjDictionaryInit>
 8104fa2:	4603      	mov	r3, r0
 8104fa4:	80fb      	strh	r3, [r7, #6]
    if(result != 0)
 8104fa6:	88fb      	ldrh	r3, [r7, #6]
 8104fa8:	2b00      	cmp	r3, #0
 8104faa:	d001      	beq.n	8104fb0 <COE_ObjInit+0xa0>
    {
        /*clear already linked objects*/
        COE_ClearObjDictionary();
 8104fac:	f000 f8e8 	bl	8105180 <COE_ClearObjDictionary>
    }
    }

    u8PendingSdo = 0;
 8104fb0:	4b11      	ldr	r3, [pc, #68]	@ (8104ff8 <COE_ObjInit+0xe8>)
 8104fb2:	2200      	movs	r2, #0
 8104fb4:	701a      	strb	r2, [r3, #0]
    bStoreCompleteAccess = FALSE;
 8104fb6:	4b11      	ldr	r3, [pc, #68]	@ (8104ffc <COE_ObjInit+0xec>)
 8104fb8:	2200      	movs	r2, #0
 8104fba:	701a      	strb	r2, [r3, #0]
    u16StoreIndex   =   0;
 8104fbc:	4b10      	ldr	r3, [pc, #64]	@ (8105000 <COE_ObjInit+0xf0>)
 8104fbe:	2200      	movs	r2, #0
 8104fc0:	801a      	strh	r2, [r3, #0]
    u8StoreSubindex = 0;
 8104fc2:	4b10      	ldr	r3, [pc, #64]	@ (8105004 <COE_ObjInit+0xf4>)
 8104fc4:	2200      	movs	r2, #0
 8104fc6:	701a      	strb	r2, [r3, #0]
    u32StoreDataSize = 0;
 8104fc8:	4b0f      	ldr	r3, [pc, #60]	@ (8105008 <COE_ObjInit+0xf8>)
 8104fca:	2200      	movs	r2, #0
 8104fcc:	601a      	str	r2, [r3, #0]
    pStoreData = NULL;
 8104fce:	4b0f      	ldr	r3, [pc, #60]	@ (810500c <COE_ObjInit+0xfc>)
 8104fd0:	2200      	movs	r2, #0
 8104fd2:	601a      	str	r2, [r3, #0]
    pSdoPendFunc    = NULL;
 8104fd4:	4b0e      	ldr	r3, [pc, #56]	@ (8105010 <COE_ObjInit+0x100>)
 8104fd6:	2200      	movs	r2, #0
 8104fd8:	601a      	str	r2, [r3, #0]

    pSdoSegData = NULL;
 8104fda:	4b0e      	ldr	r3, [pc, #56]	@ (8105014 <COE_ObjInit+0x104>)
 8104fdc:	2200      	movs	r2, #0
 8104fde:	601a      	str	r2, [r3, #0]
}
 8104fe0:	bf00      	nop
 8104fe2:	3708      	adds	r7, #8
 8104fe4:	46bd      	mov	sp, r7
 8104fe6:	bd80      	pop	{r7, pc}
 8104fe8:	10000b08 	.word	0x10000b08
 8104fec:	0007a120 	.word	0x0007a120
 8104ff0:	10000b4c 	.word	0x10000b4c
 8104ff4:	10000b01 	.word	0x10000b01
 8104ff8:	10000b90 	.word	0x10000b90
 8104ffc:	10000b91 	.word	0x10000b91
 8105000:	10000b94 	.word	0x10000b94
 8105004:	10000b92 	.word	0x10000b92
 8105008:	10000b98 	.word	0x10000b98
 810500c:	10000b9c 	.word	0x10000b9c
 8105010:	10000ba0 	.word	0x10000ba0
 8105014:	10000bb4 	.word	0x10000bb4

08105018 <COE_AddObjectToDic>:
            ALSTATUSCODE_XX add object failed

 \brief    This function adds an object to the object dictionary
 *////////////////////////////////////////////////////////////////////////////////////////
UINT16 COE_AddObjectToDic(TOBJECT OBJMEM * pNewObjEntry)
{
 8105018:	b480      	push	{r7}
 810501a:	b085      	sub	sp, #20
 810501c:	af00      	add	r7, sp, #0
 810501e:	6078      	str	r0, [r7, #4]
    if(pNewObjEntry != NULL)
 8105020:	687b      	ldr	r3, [r7, #4]
 8105022:	2b00      	cmp	r3, #0
 8105024:	d062      	beq.n	81050ec <COE_AddObjectToDic+0xd4>
    {
        if(ObjDicList == NULL)
 8105026:	4b35      	ldr	r3, [pc, #212]	@ (81050fc <COE_AddObjectToDic+0xe4>)
 8105028:	681b      	ldr	r3, [r3, #0]
 810502a:	2b00      	cmp	r3, #0
 810502c:	d10c      	bne.n	8105048 <COE_AddObjectToDic+0x30>
        {
            /* Object dictionary is empty */
            ObjDicList = pNewObjEntry;
 810502e:	4a33      	ldr	r2, [pc, #204]	@ (81050fc <COE_AddObjectToDic+0xe4>)
 8105030:	687b      	ldr	r3, [r7, #4]
 8105032:	6013      	str	r3, [r2, #0]
            ObjDicList->pNext = NULL;
 8105034:	4b31      	ldr	r3, [pc, #196]	@ (81050fc <COE_AddObjectToDic+0xe4>)
 8105036:	681b      	ldr	r3, [r3, #0]
 8105038:	2200      	movs	r2, #0
 810503a:	605a      	str	r2, [r3, #4]
            ObjDicList->pPrev = NULL;
 810503c:	4b2f      	ldr	r3, [pc, #188]	@ (81050fc <COE_AddObjectToDic+0xe4>)
 810503e:	681b      	ldr	r3, [r3, #0]
 8105040:	2200      	movs	r2, #0
 8105042:	601a      	str	r2, [r3, #0]
            return 0;
 8105044:	2300      	movs	r3, #0
 8105046:	e052      	b.n	81050ee <COE_AddObjectToDic+0xd6>
        }
        else if(ObjDicList->Index > pNewObjEntry->Index)
 8105048:	4b2c      	ldr	r3, [pc, #176]	@ (81050fc <COE_AddObjectToDic+0xe4>)
 810504a:	681b      	ldr	r3, [r3, #0]
 810504c:	891a      	ldrh	r2, [r3, #8]
 810504e:	687b      	ldr	r3, [r7, #4]
 8105050:	891b      	ldrh	r3, [r3, #8]
 8105052:	429a      	cmp	r2, r3
 8105054:	d90f      	bls.n	8105076 <COE_AddObjectToDic+0x5e>
        {
            /*insert new object dictionary head*/
            pNewObjEntry->pPrev = NULL;
 8105056:	687b      	ldr	r3, [r7, #4]
 8105058:	2200      	movs	r2, #0
 810505a:	601a      	str	r2, [r3, #0]
            pNewObjEntry->pNext = ObjDicList;
 810505c:	4b27      	ldr	r3, [pc, #156]	@ (81050fc <COE_AddObjectToDic+0xe4>)
 810505e:	681a      	ldr	r2, [r3, #0]
 8105060:	687b      	ldr	r3, [r7, #4]
 8105062:	605a      	str	r2, [r3, #4]
            ObjDicList->pPrev = pNewObjEntry;
 8105064:	4b25      	ldr	r3, [pc, #148]	@ (81050fc <COE_AddObjectToDic+0xe4>)
 8105066:	681b      	ldr	r3, [r3, #0]
 8105068:	687a      	ldr	r2, [r7, #4]
 810506a:	601a      	str	r2, [r3, #0]
            ObjDicList = pNewObjEntry;
 810506c:	4a23      	ldr	r2, [pc, #140]	@ (81050fc <COE_AddObjectToDic+0xe4>)
 810506e:	687b      	ldr	r3, [r7, #4]
 8105070:	6013      	str	r3, [r2, #0]
            return 0;
 8105072:	2300      	movs	r3, #0
 8105074:	e03b      	b.n	81050ee <COE_AddObjectToDic+0xd6>
        }
        else
        {
            TOBJECT    OBJMEM * pDicEntry = ObjDicList;
 8105076:	4b21      	ldr	r3, [pc, #132]	@ (81050fc <COE_AddObjectToDic+0xe4>)
 8105078:	681b      	ldr	r3, [r3, #0]
 810507a:	60fb      	str	r3, [r7, #12]
            while(pDicEntry != NULL)
 810507c:	e033      	b.n	81050e6 <COE_AddObjectToDic+0xce>
            {
                if(pDicEntry->Index == pNewObjEntry->Index)
 810507e:	68fb      	ldr	r3, [r7, #12]
 8105080:	891a      	ldrh	r2, [r3, #8]
 8105082:	687b      	ldr	r3, [r7, #4]
 8105084:	891b      	ldrh	r3, [r3, #8]
 8105086:	429a      	cmp	r2, r3
 8105088:	d101      	bne.n	810508e <COE_AddObjectToDic+0x76>
                {
                    /*object already exists in object dictionary*/
                    return ALSTATUSCODE_UNSPECIFIEDERROR;
 810508a:	2301      	movs	r3, #1
 810508c:	e02f      	b.n	81050ee <COE_AddObjectToDic+0xd6>
                }
                else if(pDicEntry->Index > pNewObjEntry->Index)
 810508e:	68fb      	ldr	r3, [r7, #12]
 8105090:	891a      	ldrh	r2, [r3, #8]
 8105092:	687b      	ldr	r3, [r7, #4]
 8105094:	891b      	ldrh	r3, [r3, #8]
 8105096:	429a      	cmp	r2, r3
 8105098:	d913      	bls.n	81050c2 <COE_AddObjectToDic+0xaa>
                {
                    pNewObjEntry->pPrev = pDicEntry->pPrev;
 810509a:	68fb      	ldr	r3, [r7, #12]
 810509c:	681a      	ldr	r2, [r3, #0]
 810509e:	687b      	ldr	r3, [r7, #4]
 81050a0:	601a      	str	r2, [r3, #0]
                    pNewObjEntry->pNext = pDicEntry;
 81050a2:	687b      	ldr	r3, [r7, #4]
 81050a4:	68fa      	ldr	r2, [r7, #12]
 81050a6:	605a      	str	r2, [r3, #4]

                    if(pDicEntry->pPrev != NULL)
 81050a8:	68fb      	ldr	r3, [r7, #12]
 81050aa:	681b      	ldr	r3, [r3, #0]
 81050ac:	2b00      	cmp	r3, #0
 81050ae:	d003      	beq.n	81050b8 <COE_AddObjectToDic+0xa0>
                        pDicEntry->pPrev->pNext = pNewObjEntry;
 81050b0:	68fb      	ldr	r3, [r7, #12]
 81050b2:	681b      	ldr	r3, [r3, #0]
 81050b4:	687a      	ldr	r2, [r7, #4]
 81050b6:	605a      	str	r2, [r3, #4]

                    pDicEntry->pPrev = pNewObjEntry;
 81050b8:	68fb      	ldr	r3, [r7, #12]
 81050ba:	687a      	ldr	r2, [r7, #4]
 81050bc:	601a      	str	r2, [r3, #0]

                    return 0;
 81050be:	2300      	movs	r3, #0
 81050c0:	e015      	b.n	81050ee <COE_AddObjectToDic+0xd6>
                }
                else if(pDicEntry->pNext == NULL)
 81050c2:	68fb      	ldr	r3, [r7, #12]
 81050c4:	685b      	ldr	r3, [r3, #4]
 81050c6:	2b00      	cmp	r3, #0
 81050c8:	d10a      	bne.n	81050e0 <COE_AddObjectToDic+0xc8>
                {
                    /*Last entry reached => add object to list tail*/
                    pDicEntry->pNext = pNewObjEntry;
 81050ca:	68fb      	ldr	r3, [r7, #12]
 81050cc:	687a      	ldr	r2, [r7, #4]
 81050ce:	605a      	str	r2, [r3, #4]
                    pNewObjEntry->pPrev = pDicEntry;
 81050d0:	687b      	ldr	r3, [r7, #4]
 81050d2:	68fa      	ldr	r2, [r7, #12]
 81050d4:	601a      	str	r2, [r3, #0]
                    pNewObjEntry->pNext = NULL;
 81050d6:	687b      	ldr	r3, [r7, #4]
 81050d8:	2200      	movs	r2, #0
 81050da:	605a      	str	r2, [r3, #4]
                    return 0;
 81050dc:	2300      	movs	r3, #0
 81050de:	e006      	b.n	81050ee <COE_AddObjectToDic+0xd6>
                }
                else
                {
                    /*The new object index is smaller than the current index. Get next object handle.*/
                    pDicEntry = pDicEntry->pNext;
 81050e0:	68fb      	ldr	r3, [r7, #12]
 81050e2:	685b      	ldr	r3, [r3, #4]
 81050e4:	60fb      	str	r3, [r7, #12]
            while(pDicEntry != NULL)
 81050e6:	68fb      	ldr	r3, [r7, #12]
 81050e8:	2b00      	cmp	r3, #0
 81050ea:	d1c8      	bne.n	810507e <COE_AddObjectToDic+0x66>
                }
            }
        }
    }
    return ALSTATUSCODE_UNSPECIFIEDERROR;
 81050ec:	2301      	movs	r3, #1
}
 81050ee:	4618      	mov	r0, r3
 81050f0:	3714      	adds	r7, #20
 81050f2:	46bd      	mov	sp, r7
 81050f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81050f8:	4770      	bx	lr
 81050fa:	bf00      	nop
 81050fc:	10000788 	.word	0x10000788

08105100 <COE_RemoveDicEntry>:
/**

 \brief    This function removes an object to the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_RemoveDicEntry(UINT16 index)
{
 8105100:	b480      	push	{r7}
 8105102:	b087      	sub	sp, #28
 8105104:	af00      	add	r7, sp, #0
 8105106:	4603      	mov	r3, r0
 8105108:	80fb      	strh	r3, [r7, #6]
    TOBJECT    OBJMEM * pDicEntry = ObjDicList;
 810510a:	4b1c      	ldr	r3, [pc, #112]	@ (810517c <COE_RemoveDicEntry+0x7c>)
 810510c:	681b      	ldr	r3, [r3, #0]
 810510e:	617b      	str	r3, [r7, #20]

    while(pDicEntry != NULL)
 8105110:	e02a      	b.n	8105168 <COE_RemoveDicEntry+0x68>
    {
        if(pDicEntry->Index == index)
 8105112:	697b      	ldr	r3, [r7, #20]
 8105114:	891b      	ldrh	r3, [r3, #8]
 8105116:	88fa      	ldrh	r2, [r7, #6]
 8105118:	429a      	cmp	r2, r3
 810511a:	d122      	bne.n	8105162 <COE_RemoveDicEntry+0x62>
        {
            TOBJECT OBJMEM *pPrevEntry = pDicEntry->pPrev;
 810511c:	697b      	ldr	r3, [r7, #20]
 810511e:	681b      	ldr	r3, [r3, #0]
 8105120:	613b      	str	r3, [r7, #16]
            TOBJECT OBJMEM *pNextEntry = pDicEntry->pNext;
 8105122:	697b      	ldr	r3, [r7, #20]
 8105124:	685b      	ldr	r3, [r3, #4]
 8105126:	60fb      	str	r3, [r7, #12]

            if(pPrevEntry != NULL)
 8105128:	693b      	ldr	r3, [r7, #16]
 810512a:	2b00      	cmp	r3, #0
 810512c:	d002      	beq.n	8105134 <COE_RemoveDicEntry+0x34>
                pPrevEntry->pNext = pNextEntry;
 810512e:	693b      	ldr	r3, [r7, #16]
 8105130:	68fa      	ldr	r2, [r7, #12]
 8105132:	605a      	str	r2, [r3, #4]

            if(pNextEntry != NULL)
 8105134:	68fb      	ldr	r3, [r7, #12]
 8105136:	2b00      	cmp	r3, #0
 8105138:	d002      	beq.n	8105140 <COE_RemoveDicEntry+0x40>
                pNextEntry->pPrev = pPrevEntry;
 810513a:	68fb      	ldr	r3, [r7, #12]
 810513c:	693a      	ldr	r2, [r7, #16]
 810513e:	601a      	str	r2, [r3, #0]

            pDicEntry->pPrev = NULL;
 8105140:	697b      	ldr	r3, [r7, #20]
 8105142:	2200      	movs	r2, #0
 8105144:	601a      	str	r2, [r3, #0]
            pDicEntry->pNext = NULL;
 8105146:	697b      	ldr	r3, [r7, #20]
 8105148:	2200      	movs	r2, #0
 810514a:	605a      	str	r2, [r3, #4]
            /*Update Object dictionary pointer if list head was removed*/
            if(pDicEntry->Index == ObjDicList->Index)
 810514c:	697b      	ldr	r3, [r7, #20]
 810514e:	891a      	ldrh	r2, [r3, #8]
 8105150:	4b0a      	ldr	r3, [pc, #40]	@ (810517c <COE_RemoveDicEntry+0x7c>)
 8105152:	681b      	ldr	r3, [r3, #0]
 8105154:	891b      	ldrh	r3, [r3, #8]
 8105156:	429a      	cmp	r2, r3
 8105158:	d10a      	bne.n	8105170 <COE_RemoveDicEntry+0x70>
            {
                ObjDicList = pNextEntry;
 810515a:	4a08      	ldr	r2, [pc, #32]	@ (810517c <COE_RemoveDicEntry+0x7c>)
 810515c:	68fb      	ldr	r3, [r7, #12]
 810515e:	6013      	str	r3, [r2, #0]
            }
            return;
 8105160:	e006      	b.n	8105170 <COE_RemoveDicEntry+0x70>
        }

        pDicEntry = pDicEntry->pNext;
 8105162:	697b      	ldr	r3, [r7, #20]
 8105164:	685b      	ldr	r3, [r3, #4]
 8105166:	617b      	str	r3, [r7, #20]
    while(pDicEntry != NULL)
 8105168:	697b      	ldr	r3, [r7, #20]
 810516a:	2b00      	cmp	r3, #0
 810516c:	d1d1      	bne.n	8105112 <COE_RemoveDicEntry+0x12>
 810516e:	e000      	b.n	8105172 <COE_RemoveDicEntry+0x72>
            return;
 8105170:	bf00      	nop
    }
}
 8105172:	371c      	adds	r7, #28
 8105174:	46bd      	mov	sp, r7
 8105176:	f85d 7b04 	ldr.w	r7, [sp], #4
 810517a:	4770      	bx	lr
 810517c:	10000788 	.word	0x10000788

08105180 <COE_ClearObjDictionary>:
/**

 \brief    This function clear the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
void COE_ClearObjDictionary(void)
{
 8105180:	b580      	push	{r7, lr}
 8105182:	b082      	sub	sp, #8
 8105184:	af00      	add	r7, sp, #0
    TOBJECT OBJMEM * pObjEntry = (TOBJECT OBJMEM *) ObjDicList;
 8105186:	4b0d      	ldr	r3, [pc, #52]	@ (81051bc <COE_ClearObjDictionary+0x3c>)
 8105188:	681b      	ldr	r3, [r3, #0]
 810518a:	607b      	str	r3, [r7, #4]
    UINT16 Index = 0;
 810518c:	2300      	movs	r3, #0
 810518e:	807b      	strh	r3, [r7, #2]

    while(pObjEntry != NULL)
 8105190:	e009      	b.n	81051a6 <COE_ClearObjDictionary+0x26>
    {
        Index = pObjEntry->Index;
 8105192:	687b      	ldr	r3, [r7, #4]
 8105194:	891b      	ldrh	r3, [r3, #8]
 8105196:	807b      	strh	r3, [r7, #2]
        pObjEntry = pObjEntry->pNext;
 8105198:	687b      	ldr	r3, [r7, #4]
 810519a:	685b      	ldr	r3, [r3, #4]
 810519c:	607b      	str	r3, [r7, #4]

        COE_RemoveDicEntry(Index);
 810519e:	887b      	ldrh	r3, [r7, #2]
 81051a0:	4618      	mov	r0, r3
 81051a2:	f7ff ffad 	bl	8105100 <COE_RemoveDicEntry>
    while(pObjEntry != NULL)
 81051a6:	687b      	ldr	r3, [r7, #4]
 81051a8:	2b00      	cmp	r3, #0
 81051aa:	d1f2      	bne.n	8105192 <COE_ClearObjDictionary+0x12>
    }
    ObjDicList = NULL;
 81051ac:	4b03      	ldr	r3, [pc, #12]	@ (81051bc <COE_ClearObjDictionary+0x3c>)
 81051ae:	2200      	movs	r2, #0
 81051b0:	601a      	str	r2, [r3, #0]
}
 81051b2:	bf00      	nop
 81051b4:	3708      	adds	r7, #8
 81051b6:	46bd      	mov	sp, r7
 81051b8:	bd80      	pop	{r7, pc}
 81051ba:	bf00      	nop
 81051bc:	10000788 	.word	0x10000788

081051c0 <AddObjectsToObjDictionary>:


UINT16 AddObjectsToObjDictionary(TOBJECT OBJMEM * pObjEntry)
{
 81051c0:	b580      	push	{r7, lr}
 81051c2:	b084      	sub	sp, #16
 81051c4:	af00      	add	r7, sp, #0
 81051c6:	6078      	str	r0, [r7, #4]
    UINT16 result = 0;
 81051c8:	2300      	movs	r3, #0
 81051ca:	81fb      	strh	r3, [r7, #14]
    TOBJECT OBJMEM * pEntry = (TOBJECT OBJMEM *)pObjEntry;
 81051cc:	687b      	ldr	r3, [r7, #4]
 81051ce:	60bb      	str	r3, [r7, #8]

    while(pEntry->Index != 0xFFFF)
 81051d0:	e00c      	b.n	81051ec <AddObjectsToObjDictionary+0x2c>
    {
        result = COE_AddObjectToDic(pEntry);
 81051d2:	68b8      	ldr	r0, [r7, #8]
 81051d4:	f7ff ff20 	bl	8105018 <COE_AddObjectToDic>
 81051d8:	4603      	mov	r3, r0
 81051da:	81fb      	strh	r3, [r7, #14]

        if(result != 0)
 81051dc:	89fb      	ldrh	r3, [r7, #14]
 81051de:	2b00      	cmp	r3, #0
 81051e0:	d001      	beq.n	81051e6 <AddObjectsToObjDictionary+0x26>
            return result;
 81051e2:	89fb      	ldrh	r3, [r7, #14]
 81051e4:	e009      	b.n	81051fa <AddObjectsToObjDictionary+0x3a>

        pEntry++;
 81051e6:	68bb      	ldr	r3, [r7, #8]
 81051e8:	3328      	adds	r3, #40	@ 0x28
 81051ea:	60bb      	str	r3, [r7, #8]
    while(pEntry->Index != 0xFFFF)
 81051ec:	68bb      	ldr	r3, [r7, #8]
 81051ee:	891b      	ldrh	r3, [r3, #8]
 81051f0:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 81051f4:	4293      	cmp	r3, r2
 81051f6:	d1ec      	bne.n	81051d2 <AddObjectsToObjDictionary+0x12>
    }

    return result;
 81051f8:	89fb      	ldrh	r3, [r7, #14]

}
 81051fa:	4618      	mov	r0, r3
 81051fc:	3710      	adds	r7, #16
 81051fe:	46bd      	mov	sp, r7
 8105200:	bd80      	pop	{r7, pc}
	...

08105204 <COE_ObjDictionaryInit>:
            ALSTATUSCODE_XX create object dictionary failed

 \brief    This function initialize the object dictionary
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 COE_ObjDictionaryInit(void)
{
 8105204:	b580      	push	{r7, lr}
 8105206:	b082      	sub	sp, #8
 8105208:	af00      	add	r7, sp, #0
    UINT16 result = 0;
 810520a:	2300      	movs	r3, #0
 810520c:	80fb      	strh	r3, [r7, #6]

    /*Reset object dictionary pointer*/
    ObjDicList = NULL;
 810520e:	4b0b      	ldr	r3, [pc, #44]	@ (810523c <COE_ObjDictionaryInit+0x38>)
 8105210:	2200      	movs	r2, #0
 8105212:	601a      	str	r2, [r3, #0]

    result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) GenObjDic);
 8105214:	480a      	ldr	r0, [pc, #40]	@ (8105240 <COE_ObjDictionaryInit+0x3c>)
 8105216:	f7ff ffd3 	bl	81051c0 <AddObjectsToObjDictionary>
 810521a:	4603      	mov	r3, r0
 810521c:	80fb      	strh	r3, [r7, #6]

    if(result != 0)
 810521e:	88fb      	ldrh	r3, [r7, #6]
 8105220:	2b00      	cmp	r3, #0
 8105222:	d001      	beq.n	8105228 <COE_ObjDictionaryInit+0x24>
        return result;
 8105224:	88fb      	ldrh	r3, [r7, #6]
 8105226:	e005      	b.n	8105234 <COE_ObjDictionaryInit+0x30>
    if(ApplicationObjDic != NULL)
    {
        result = AddObjectsToObjDictionary((TOBJECT OBJMEM *) ApplicationObjDic);
 8105228:	4806      	ldr	r0, [pc, #24]	@ (8105244 <COE_ObjDictionaryInit+0x40>)
 810522a:	f7ff ffc9 	bl	81051c0 <AddObjectsToObjDictionary>
 810522e:	4603      	mov	r3, r0
 8105230:	80fb      	strh	r3, [r7, #6]
    }

    return result;
 8105232:	88fb      	ldrh	r3, [r7, #6]
}
 8105234:	4618      	mov	r0, r3
 8105236:	3708      	adds	r7, #8
 8105238:	46bd      	mov	sp, r7
 810523a:	bd80      	pop	{r7, pc}
 810523c:	10000788 	.word	0x10000788
 8105240:	100002bc 	.word	0x100002bc
 8105244:	100000c0 	.word	0x100000c0

08105248 <COE_Main>:
 \brief    is called for background calculations which should not influence the
             ECAT_Application in synchronous modes
*////////////////////////////////////////////////////////////////////////////////////////

void COE_Main(void)
{
 8105248:	b5b0      	push	{r4, r5, r7, lr}
 810524a:	b084      	sub	sp, #16
 810524c:	af02      	add	r7, sp, #8
     UINT8 abort = 0;
 810524e:	2300      	movs	r3, #0
 8105250:	71fb      	strb	r3, [r7, #7]
    if(pSdoPendFunc != NULL)
 8105252:	4b2b      	ldr	r3, [pc, #172]	@ (8105300 <COE_Main+0xb8>)
 8105254:	681b      	ldr	r3, [r3, #0]
 8105256:	2b00      	cmp	r3, #0
 8105258:	d04e      	beq.n	81052f8 <COE_Main+0xb0>
    {
        abort = pSdoPendFunc(u16StoreIndex,u8StoreSubindex,u32StoreDataSize,pStoreData,bStoreCompleteAccess);
 810525a:	4b29      	ldr	r3, [pc, #164]	@ (8105300 <COE_Main+0xb8>)
 810525c:	681c      	ldr	r4, [r3, #0]
 810525e:	4b29      	ldr	r3, [pc, #164]	@ (8105304 <COE_Main+0xbc>)
 8105260:	8818      	ldrh	r0, [r3, #0]
 8105262:	4b29      	ldr	r3, [pc, #164]	@ (8105308 <COE_Main+0xc0>)
 8105264:	7819      	ldrb	r1, [r3, #0]
 8105266:	4b29      	ldr	r3, [pc, #164]	@ (810530c <COE_Main+0xc4>)
 8105268:	681a      	ldr	r2, [r3, #0]
 810526a:	4b29      	ldr	r3, [pc, #164]	@ (8105310 <COE_Main+0xc8>)
 810526c:	681d      	ldr	r5, [r3, #0]
 810526e:	4b29      	ldr	r3, [pc, #164]	@ (8105314 <COE_Main+0xcc>)
 8105270:	781b      	ldrb	r3, [r3, #0]
 8105272:	9300      	str	r3, [sp, #0]
 8105274:	462b      	mov	r3, r5
 8105276:	47a0      	blx	r4
 8105278:	4603      	mov	r3, r0
 810527a:	71fb      	strb	r3, [r7, #7]

        if(abort != ABORTIDX_WORKING)
 810527c:	79fb      	ldrb	r3, [r7, #7]
 810527e:	2bff      	cmp	r3, #255	@ 0xff
 8105280:	d03a      	beq.n	81052f8 <COE_Main+0xb0>
        {
            switch(u8PendingSdo)
 8105282:	4b25      	ldr	r3, [pc, #148]	@ (8105318 <COE_Main+0xd0>)
 8105284:	781b      	ldrb	r3, [r3, #0]
 8105286:	2b04      	cmp	r3, #4
 8105288:	dc21      	bgt.n	81052ce <COE_Main+0x86>
 810528a:	2b03      	cmp	r3, #3
 810528c:	da16      	bge.n	81052bc <COE_Main+0x74>
 810528e:	2b01      	cmp	r3, #1
 8105290:	d00d      	beq.n	81052ae <COE_Main+0x66>
 8105292:	2b02      	cmp	r3, #2
 8105294:	d11b      	bne.n	81052ce <COE_Main+0x86>
            {
                case SDO_PENDING_SEG_WRITE:
                    if(pSdoSegData)
 8105296:	4b21      	ldr	r3, [pc, #132]	@ (810531c <COE_Main+0xd4>)
 8105298:	681b      	ldr	r3, [r3, #0]
 810529a:	2b00      	cmp	r3, #0
 810529c:	d007      	beq.n	81052ae <COE_Main+0x66>
                    {
                        /* the allocated buffer can be released */
                        FREEMEM( (UINT16 VARMEM *) pSdoSegData );
 810529e:	4b1f      	ldr	r3, [pc, #124]	@ (810531c <COE_Main+0xd4>)
 81052a0:	681b      	ldr	r3, [r3, #0]
 81052a2:	4618      	mov	r0, r3
 81052a4:	f00a fb2c 	bl	810f900 <free>
                        pSdoSegData = NULL;
 81052a8:	4b1c      	ldr	r3, [pc, #112]	@ (810531c <COE_Main+0xd4>)
 81052aa:	2200      	movs	r2, #0
 81052ac:	601a      	str	r2, [r3, #0]
                    }
                case SDO_PENDING_WRITE:
                     /*send SDO Download Response*/
                    SDOS_SdoRes(abort, 0, NULL);
 81052ae:	79fb      	ldrb	r3, [r7, #7]
 81052b0:	2200      	movs	r2, #0
 81052b2:	2100      	movs	r1, #0
 81052b4:	4618      	mov	r0, r3
 81052b6:	f004 fe35 	bl	8109f24 <SDOS_SdoRes>
                break;
 81052ba:	e008      	b.n	81052ce <COE_Main+0x86>

                case SDO_PENDING_SEG_READ:
                case SDO_PENDING_READ:
                    /* send SDO upload response */
                      SDOS_SdoRes(abort, u32StoreDataSize, pStoreData);
 81052bc:	4b13      	ldr	r3, [pc, #76]	@ (810530c <COE_Main+0xc4>)
 81052be:	6819      	ldr	r1, [r3, #0]
 81052c0:	4b13      	ldr	r3, [pc, #76]	@ (8105310 <COE_Main+0xc8>)
 81052c2:	681a      	ldr	r2, [r3, #0]
 81052c4:	79fb      	ldrb	r3, [r7, #7]
 81052c6:	4618      	mov	r0, r3
 81052c8:	f004 fe2c 	bl	8109f24 <SDOS_SdoRes>
                    break;
 81052cc:	bf00      	nop

            }

            u8PendingSdo = 0;
 81052ce:	4b12      	ldr	r3, [pc, #72]	@ (8105318 <COE_Main+0xd0>)
 81052d0:	2200      	movs	r2, #0
 81052d2:	701a      	strb	r2, [r3, #0]
            u16StoreIndex = 0;
 81052d4:	4b0b      	ldr	r3, [pc, #44]	@ (8105304 <COE_Main+0xbc>)
 81052d6:	2200      	movs	r2, #0
 81052d8:	801a      	strh	r2, [r3, #0]
            u8StoreSubindex = 0;
 81052da:	4b0b      	ldr	r3, [pc, #44]	@ (8105308 <COE_Main+0xc0>)
 81052dc:	2200      	movs	r2, #0
 81052de:	701a      	strb	r2, [r3, #0]
            u32StoreDataSize = 0;
 81052e0:	4b0a      	ldr	r3, [pc, #40]	@ (810530c <COE_Main+0xc4>)
 81052e2:	2200      	movs	r2, #0
 81052e4:	601a      	str	r2, [r3, #0]
            pStoreData = NULL;
 81052e6:	4b0a      	ldr	r3, [pc, #40]	@ (8105310 <COE_Main+0xc8>)
 81052e8:	2200      	movs	r2, #0
 81052ea:	601a      	str	r2, [r3, #0]
            bStoreCompleteAccess = 0;
 81052ec:	4b09      	ldr	r3, [pc, #36]	@ (8105314 <COE_Main+0xcc>)
 81052ee:	2200      	movs	r2, #0
 81052f0:	701a      	strb	r2, [r3, #0]
            pSdoPendFunc = NULL;
 81052f2:	4b03      	ldr	r3, [pc, #12]	@ (8105300 <COE_Main+0xb8>)
 81052f4:	2200      	movs	r2, #0
 81052f6:	601a      	str	r2, [r3, #0]
        }
    }
}
 81052f8:	bf00      	nop
 81052fa:	3708      	adds	r7, #8
 81052fc:	46bd      	mov	sp, r7
 81052fe:	bdb0      	pop	{r4, r5, r7, pc}
 8105300:	10000ba0 	.word	0x10000ba0
 8105304:	10000b94 	.word	0x10000b94
 8105308:	10000b92 	.word	0x10000b92
 810530c:	10000b98 	.word	0x10000b98
 8105310:	10000b9c 	.word	0x10000b9c
 8105314:	10000b91 	.word	0x10000b91
 8105318:	10000b90 	.word	0x10000b90
 810531c:	10000bb4 	.word	0x10000bb4

08105320 <PDO_InputMapping>:
/**
\brief      This function will copies the inputs from the local memory to the ESC memory
            to the hardware
*////////////////////////////////////////////////////////////////////////////////////////
void PDO_InputMapping(void)
{
 8105320:	b580      	push	{r7, lr}
 8105322:	af00      	add	r7, sp, #0
    APPL_InputMapping((UINT16*)aPdInputData);
 8105324:	4806      	ldr	r0, [pc, #24]	@ (8105340 <PDO_InputMapping+0x20>)
 8105326:	f7fb fbe9 	bl	8100afc <APPL_InputMapping>
    HW_EscWriteIsr(((MEM_ADDR *) aPdInputData), nEscAddrInputData, nPdInputSize );
 810532a:	4b06      	ldr	r3, [pc, #24]	@ (8105344 <PDO_InputMapping+0x24>)
 810532c:	881b      	ldrh	r3, [r3, #0]
 810532e:	4a06      	ldr	r2, [pc, #24]	@ (8105348 <PDO_InputMapping+0x28>)
 8105330:	8812      	ldrh	r2, [r2, #0]
 8105332:	4619      	mov	r1, r3
 8105334:	4802      	ldr	r0, [pc, #8]	@ (8105340 <PDO_InputMapping+0x20>)
 8105336:	f7fb ff55 	bl	81011e4 <HW_EscWriteIsr>
}
 810533a:	bf00      	nop
 810533c:	bd80      	pop	{r7, pc}
 810533e:	bf00      	nop
 8105340:	100007dc 	.word	0x100007dc
 8105344:	10000862 	.word	0x10000862
 8105348:	10000854 	.word	0x10000854

0810534c <PDO_OutputMapping>:
\brief    This function will copies the outputs from the ESC memory to the local memory
          to the hardware. This function is only called in case of an SM2 
          (output process data) event.
*////////////////////////////////////////////////////////////////////////////////////////
void PDO_OutputMapping(void)
{
 810534c:	b580      	push	{r7, lr}
 810534e:	af00      	add	r7, sp, #0

    HW_EscReadIsr(((MEM_ADDR *)aPdOutputData), nEscAddrOutputData, nPdOutputSize );
 8105350:	4b06      	ldr	r3, [pc, #24]	@ (810536c <PDO_OutputMapping+0x20>)
 8105352:	881b      	ldrh	r3, [r3, #0]
 8105354:	4a06      	ldr	r2, [pc, #24]	@ (8105370 <PDO_OutputMapping+0x24>)
 8105356:	8812      	ldrh	r2, [r2, #0]
 8105358:	4619      	mov	r1, r3
 810535a:	4806      	ldr	r0, [pc, #24]	@ (8105374 <PDO_OutputMapping+0x28>)
 810535c:	f7fb fed8 	bl	8101110 <HW_EscReadIsr>

    APPL_OutputMapping((UINT16*) aPdOutputData);
 8105360:	4804      	ldr	r0, [pc, #16]	@ (8105374 <PDO_OutputMapping+0x28>)
 8105362:	f7fb fc8b 	bl	8100c7c <APPL_OutputMapping>
}
 8105366:	bf00      	nop
 8105368:	bd80      	pop	{r7, pc}
 810536a:	bf00      	nop
 810536c:	10000860 	.word	0x10000860
 8105370:	10000856 	.word	0x10000856
 8105374:	10000798 	.word	0x10000798

08105378 <MainInit>:
 \brief    This function initialize the EtherCAT Sample Code

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 MainInit(void)
{
 8105378:	b580      	push	{r7, lr}
 810537a:	b082      	sub	sp, #8
 810537c:	af00      	add	r7, sp, #0
    UINT16 Error = 0;
 810537e:	2300      	movs	r3, #0
 8105380:	80fb      	strh	r3, [r7, #6]
    SET_EEPROM_PTR
#endif
/*ECATCHANGE_END(V5.11) EEPROM1*/

    /* initialize the EtherCAT Slave Interface */
    ECAT_Init();
 8105382:	f001 fdfd 	bl	8106f80 <ECAT_Init>
    /* initialize the objects */
    COE_ObjInit();
 8105386:	f7ff fdc3 	bl	8104f10 <COE_ObjInit>


    /*Timer initialization*/
    u16BusCycleCntMs = 0;
 810538a:	4b08      	ldr	r3, [pc, #32]	@ (81053ac <MainInit+0x34>)
 810538c:	2200      	movs	r2, #0
 810538e:	801a      	strh	r2, [r3, #0]
    StartTimerCnt = 0;
 8105390:	4b07      	ldr	r3, [pc, #28]	@ (81053b0 <MainInit+0x38>)
 8105392:	2200      	movs	r2, #0
 8105394:	601a      	str	r2, [r3, #0]
    bCycleTimeMeasurementStarted = FALSE;
 8105396:	4b07      	ldr	r3, [pc, #28]	@ (81053b4 <MainInit+0x3c>)
 8105398:	2200      	movs	r2, #0
 810539a:	701a      	strb	r2, [r3, #0]

    /*indicate that the slave stack initialization finished*/
    bInitFinished = TRUE;
 810539c:	4b06      	ldr	r3, [pc, #24]	@ (81053b8 <MainInit+0x40>)
 810539e:	2201      	movs	r2, #1
 81053a0:	701a      	strb	r2, [r3, #0]

/*Application Init need to be called from the application layer*/
     return Error;
 81053a2:	88fb      	ldrh	r3, [r7, #6]
}
 81053a4:	4618      	mov	r0, r3
 81053a6:	3708      	adds	r7, #8
 81053a8:	46bd      	mov	sp, r7
 81053aa:	bd80      	pop	{r7, pc}
 81053ac:	1000078e 	.word	0x1000078e
 81053b0:	10000790 	.word	0x10000790
 81053b4:	10000794 	.word	0x10000794
 81053b8:	10000820 	.word	0x10000820

081053bc <MainLoop>:
 \brief    This function shall be called cyclically from main

*////////////////////////////////////////////////////////////////////////////////////////

void MainLoop(void)
{
 81053bc:	b580      	push	{r7, lr}
 81053be:	b082      	sub	sp, #8
 81053c0:	af00      	add	r7, sp, #0
    /*return if initialization not finished */
    if(bInitFinished == FALSE)
 81053c2:	4b26      	ldr	r3, [pc, #152]	@ (810545c <MainLoop+0xa0>)
 81053c4:	781b      	ldrb	r3, [r3, #0]
 81053c6:	2b00      	cmp	r3, #0
 81053c8:	d043      	beq.n	8105452 <MainLoop+0x96>

        /* FreeRun-Mode:  bEscIntEnabled = FALSE, bDcSyncActive = FALSE
           Synchron-Mode: bEscIntEnabled = TRUE, bDcSyncActive = FALSE
           DC-Mode:       bEscIntEnabled = TRUE, bDcSyncActive = TRUE */
        if (
            (!bEscIntEnabled || !bEcatFirstOutputsReceived)     /* SM-Synchronous, but not SM-event received */
 81053ca:	4b25      	ldr	r3, [pc, #148]	@ (8105460 <MainLoop+0xa4>)
 81053cc:	781b      	ldrb	r3, [r3, #0]
        if (
 81053ce:	2b00      	cmp	r3, #0
 81053d0:	d003      	beq.n	81053da <MainLoop+0x1e>
            (!bEscIntEnabled || !bEcatFirstOutputsReceived)     /* SM-Synchronous, but not SM-event received */
 81053d2:	4b24      	ldr	r3, [pc, #144]	@ (8105464 <MainLoop+0xa8>)
 81053d4:	781b      	ldrb	r3, [r3, #0]
 81053d6:	2b00      	cmp	r3, #0
 81053d8:	d134      	bne.n	8105444 <MainLoop+0x88>
          && !bDcSyncActive                                               /* DC-Synchronous */
 81053da:	4b23      	ldr	r3, [pc, #140]	@ (8105468 <MainLoop+0xac>)
 81053dc:	781b      	ldrb	r3, [r3, #0]
 81053de:	2b00      	cmp	r3, #0
 81053e0:	d130      	bne.n	8105444 <MainLoop+0x88>
               from the ESC interrupt routine (in mcihw.c or spihw.c),
               in ECAT Synchron Mode it should be additionally checked, if the SM-event is received
               at least once (bEcatFirstOutputsReceived = 1), otherwise no interrupt is generated
               and the function ECAT_Application has to be called here (with interrupts disabled,
               because the SM-event could be generated while executing ECAT_Application) */
            if ( !bEscIntEnabled )
 81053e2:	4b1f      	ldr	r3, [pc, #124]	@ (8105460 <MainLoop+0xa4>)
 81053e4:	781b      	ldrb	r3, [r3, #0]
 81053e6:	2b00      	cmp	r3, #0
 81053e8:	d11e      	bne.n	8105428 <MainLoop+0x6c>
            {
                /* application is running in ECAT FreeRun Mode,
                   first we have to check, if outputs were received */
                UINT16 ALEvent = HW_GetALEventRegister();
 81053ea:	f7fb fe53 	bl	8101094 <HW_GetALEventRegister>
 81053ee:	4603      	mov	r3, r0
 81053f0:	80fb      	strh	r3, [r7, #6]
                ALEvent = SWAPWORD(ALEvent);

                if ( ALEvent & PROCESS_OUTPUT_EVENT )
 81053f2:	88fb      	ldrh	r3, [r7, #6]
 81053f4:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 81053f8:	2b00      	cmp	r3, #0
 81053fa:	d009      	beq.n	8105410 <MainLoop+0x54>
                {
                    /* set the flag for the state machine behaviour */
                    bEcatFirstOutputsReceived = TRUE;
 81053fc:	4b19      	ldr	r3, [pc, #100]	@ (8105464 <MainLoop+0xa8>)
 81053fe:	2201      	movs	r2, #1
 8105400:	701a      	strb	r2, [r3, #0]
                    if ( bEcatOutputUpdateRunning )
 8105402:	4b1a      	ldr	r3, [pc, #104]	@ (810546c <MainLoop+0xb0>)
 8105404:	781b      	ldrb	r3, [r3, #0]
 8105406:	2b00      	cmp	r3, #0
 8105408:	d00e      	beq.n	8105428 <MainLoop+0x6c>
                    {
                        /* update the outputs */
                        PDO_OutputMapping();
 810540a:	f7ff ff9f 	bl	810534c <PDO_OutputMapping>
 810540e:	e00b      	b.n	8105428 <MainLoop+0x6c>
                    }
                }
                else if ( nPdOutputSize == 0 )
 8105410:	4b17      	ldr	r3, [pc, #92]	@ (8105470 <MainLoop+0xb4>)
 8105412:	881b      	ldrh	r3, [r3, #0]
 8105414:	2b00      	cmp	r3, #0
 8105416:	d107      	bne.n	8105428 <MainLoop+0x6c>
                {
                    /* if no outputs are transmitted, the watchdog must be reset, when the inputs were read */
                    if ( ALEvent & PROCESS_INPUT_EVENT )
 8105418:	88fb      	ldrh	r3, [r7, #6]
 810541a:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 810541e:	2b00      	cmp	r3, #0
 8105420:	d002      	beq.n	8105428 <MainLoop+0x6c>
                    {
                        /* Outputs were updated, set flag for watchdog monitoring */
                        bEcatFirstOutputsReceived = TRUE;
 8105422:	4b10      	ldr	r3, [pc, #64]	@ (8105464 <MainLoop+0xa8>)
 8105424:	2201      	movs	r2, #1
 8105426:	701a      	strb	r2, [r3, #0]
                    }
                }
            }

            DISABLE_ESC_INT();
 8105428:	200a      	movs	r0, #10
 810542a:	f7fc fae1 	bl	81019f0 <HAL_NVIC_DisableIRQ>
            ECAT_Application();
 810542e:	f000 f823 	bl	8105478 <ECAT_Application>

            if ( bEcatInputUpdateRunning )
 8105432:	4b10      	ldr	r3, [pc, #64]	@ (8105474 <MainLoop+0xb8>)
 8105434:	781b      	ldrb	r3, [r3, #0]
 8105436:	2b00      	cmp	r3, #0
 8105438:	d001      	beq.n	810543e <MainLoop+0x82>
            {
                /* EtherCAT slave is at least in SAFE-OPERATIONAL, update inputs */
                PDO_InputMapping();
 810543a:	f7ff ff71 	bl	8105320 <PDO_InputMapping>
            }
            ENABLE_ESC_INT();
 810543e:	200a      	movs	r0, #10
 8105440:	f7fc fac8 	bl	81019d4 <HAL_NVIC_EnableIRQ>
        }


        /* call EtherCAT functions */
        ECAT_Main();
 8105444:	f001 fe4c 	bl	81070e0 <ECAT_Main>

        /* call lower prior application part */
       COE_Main();
 8105448:	f7ff fefe 	bl	8105248 <COE_Main>
       CheckIfEcatError();
 810544c:	f001 fd42 	bl	8106ed4 <CheckIfEcatError>
 8105450:	e000      	b.n	8105454 <MainLoop+0x98>
        return;
 8105452:	bf00      	nop

}
 8105454:	3708      	adds	r7, #8
 8105456:	46bd      	mov	sp, r7
 8105458:	bd80      	pop	{r7, pc}
 810545a:	bf00      	nop
 810545c:	10000820 	.word	0x10000820
 8105460:	10000848 	.word	0x10000848
 8105464:	1000082a 	.word	0x1000082a
 8105468:	1000082c 	.word	0x1000082c
 810546c:	10000828 	.word	0x10000828
 8105470:	10000856 	.word	0x10000856
 8105474:	10000829 	.word	0x10000829

08105478 <ECAT_Application>:
/**
 \brief    ECAT_Application (prev. SSC versions "COE_Application")
 this function calculates and the physical process signals and triggers the input mapping
*////////////////////////////////////////////////////////////////////////////////////////
void ECAT_Application(void)
{
 8105478:	b580      	push	{r7, lr}
 810547a:	af00      	add	r7, sp, #0
    {
        APPL_Application();
 810547c:	f7fb fc42 	bl	8100d04 <APPL_Application>
    }
/* PDO Input mapping is called from the specific trigger ISR */
}
 8105480:	bf00      	nop
 8105482:	bd80      	pop	{r7, pc}

08105484 <COE_Init>:

 \brief    This function intialize the CoE Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void COE_Init(void)
{
 8105484:	b480      	push	{r7}
 8105486:	af00      	add	r7, sp, #0
    pCoeSendStored = 0;
 8105488:	4b05      	ldr	r3, [pc, #20]	@ (81054a0 <COE_Init+0x1c>)
 810548a:	2200      	movs	r2, #0
 810548c:	601a      	str	r2, [r3, #0]
    nSdoInfoFragmentsLeft = 0;
 810548e:	4b05      	ldr	r3, [pc, #20]	@ (81054a4 <COE_Init+0x20>)
 8105490:	2200      	movs	r2, #0
 8105492:	801a      	strh	r2, [r3, #0]
}
 8105494:	bf00      	nop
 8105496:	46bd      	mov	sp, r7
 8105498:	f85d 7b04 	ldr.w	r7, [sp], #4
 810549c:	4770      	bx	lr
 810549e:	bf00      	nop
 81054a0:	10000824 	.word	0x10000824
 81054a4:	10000bb8 	.word	0x10000bb8

081054a8 <COE_ServiceInd>:
 \brief    This function is called when a CoE (CAN application layer over EtherCAT) service is received from
             the master.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 COE_ServiceInd(TCOEMBX MBXMEM *pCoeMbx)
{
 81054a8:	b580      	push	{r7, lr}
 81054aa:	b084      	sub	sp, #16
 81054ac:	af00      	add	r7, sp, #0
 81054ae:	6078      	str	r0, [r7, #4]
    UINT8 result = 0;
 81054b0:	2300      	movs	r3, #0
 81054b2:	73fb      	strb	r3, [r7, #15]

    switch ((pCoeMbx->CoeHeader & COEHEADER_COESERVICEMASK) >> COEHEADER_COESERVICESHIFT)
 81054b4:	687b      	ldr	r3, [r7, #4]
 81054b6:	88db      	ldrh	r3, [r3, #6]
 81054b8:	0b1b      	lsrs	r3, r3, #12
 81054ba:	b29b      	uxth	r3, r3
 81054bc:	3b01      	subs	r3, #1
 81054be:	2b07      	cmp	r3, #7
 81054c0:	d821      	bhi.n	8105506 <COE_ServiceInd+0x5e>
 81054c2:	a201      	add	r2, pc, #4	@ (adr r2, 81054c8 <COE_ServiceInd+0x20>)
 81054c4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 81054c8:	08105501 	.word	0x08105501
 81054cc:	081054e9 	.word	0x081054e9
 81054d0:	08105501 	.word	0x08105501
 81054d4:	08105501 	.word	0x08105501
 81054d8:	08105501 	.word	0x08105501
 81054dc:	08105501 	.word	0x08105501
 81054e0:	08105501 	.word	0x08105501
 81054e4:	081054f5 	.word	0x081054f5
    {
    case COESERVICE_SDOREQUEST:
        /* SDO-Request received, call SDOS_SdoInd to process the SDO-Request
           if an existing SDO-Stack shall be used, the corresponding function
            should be called */
        result = SDOS_SdoInd( (TINITSDOMBX MBXMEM *) pCoeMbx );
 81054e8:	6878      	ldr	r0, [r7, #4]
 81054ea:	f004 fa67 	bl	81099bc <SDOS_SdoInd>
 81054ee:	4603      	mov	r3, r0
 81054f0:	73fb      	strb	r3, [r7, #15]
        break;
 81054f2:	e00b      	b.n	810550c <COE_ServiceInd+0x64>

    case COESERVICE_SDOINFO:
        /* SDO-Information Request received, call SDOS_SdoInfoInd to process the SDO-Request */
        result = SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pCoeMbx );
 81054f4:	6878      	ldr	r0, [r7, #4]
 81054f6:	f004 fda3 	bl	810a040 <SDOS_SdoInfoInd>
 81054fa:	4603      	mov	r3, r0
 81054fc:	73fb      	strb	r3, [r7, #15]
        /*NOERROR_INWORK is never returned by SDOS_SdoInfoInd() => delete return code handling*/
        break;
 81054fe:	e005      	b.n	810550c <COE_ServiceInd+0x64>
    case COESERVICE_TXPDO:
    case COESERVICE_RXPDO:
    case COESERVICE_TXPDOREMREQ:
    case COESERVICE_RXPDOREMREQ:
        /* these CoE services are not supported yet */
        result = MBXERR_SERVICENOTSUPPORTED;
 8105500:	2304      	movs	r3, #4
 8105502:	73fb      	strb	r3, [r7, #15]
        break;
 8105504:	e002      	b.n	810550c <COE_ServiceInd+0x64>

    default:
        result = MBXERR_INVALIDHEADER;
 8105506:	2305      	movs	r3, #5
 8105508:	73fb      	strb	r3, [r7, #15]
        break;
 810550a:	bf00      	nop
    }
    return result;
 810550c:	7bfb      	ldrb	r3, [r7, #15]
}
 810550e:	4618      	mov	r0, r3
 8105510:	3710      	adds	r7, #16
 8105512:	46bd      	mov	sp, r7
 8105514:	bd80      	pop	{r7, pc}
 8105516:	bf00      	nop

08105518 <COE_ContinueInd>:
*////////////////////////////////////////////////////////////////////////////////////////

/*ECATCHANGE_START(V5.11) COE4*/
UINT8 COE_ContinueInd(TMBX MBXMEM * pMbx)
/*ECATCHANGE_END(V5.11) COE4*/
{
 8105518:	b580      	push	{r7, lr}
 810551a:	b082      	sub	sp, #8
 810551c:	af00      	add	r7, sp, #0
 810551e:	6078      	str	r0, [r7, #4]
    if (pCoeSendStored)
 8105520:	4b12      	ldr	r3, [pc, #72]	@ (810556c <COE_ContinueInd+0x54>)
 8105522:	681b      	ldr	r3, [r3, #0]
 8105524:	2b00      	cmp	r3, #0
 8105526:	d009      	beq.n	810553c <COE_ContinueInd+0x24>
    {
        /* send the stored CoE service which could not be sent before */
        MBX_MailboxSendReq(pCoeSendStored, 0);
 8105528:	4b10      	ldr	r3, [pc, #64]	@ (810556c <COE_ContinueInd+0x54>)
 810552a:	681b      	ldr	r3, [r3, #0]
 810552c:	2100      	movs	r1, #0
 810552e:	4618      	mov	r0, r3
 8105530:	f002 f9b6 	bl	81078a0 <MBX_MailboxSendReq>
        pCoeSendStored = 0;
 8105534:	4b0d      	ldr	r3, [pc, #52]	@ (810556c <COE_ContinueInd+0x54>)
 8105536:	2200      	movs	r2, #0
 8105538:	601a      	str	r2, [r3, #0]
 810553a:	e012      	b.n	8105562 <COE_ContinueInd+0x4a>
    }
    else
    {
        /* send the next fragment of the last CoE service (only for SDO-Information possible) */
        /* in mailbox queue mode pMbx is always 0, so a mailbox buffer shall be get */
        pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(SIZEOF(TMBX));
 810553c:	f44f 7080 	mov.w	r0, #256	@ 0x100
 8105540:	f00a f9d6 	bl	810f8f0 <malloc>
 8105544:	4603      	mov	r3, r0
 8105546:	607b      	str	r3, [r7, #4]
        /* it shall be checked if a valid pointer was returned */
/*ECATCHANGE_START(V5.11) COE4*/
        if (pMbx == NULL)
 8105548:	687b      	ldr	r3, [r7, #4]
 810554a:	2b00      	cmp	r3, #0
 810554c:	d101      	bne.n	8105552 <COE_ContinueInd+0x3a>
        {
            return MBXERR_NOMOREMEMORY;
 810554e:	2307      	movs	r3, #7
 8105550:	e008      	b.n	8105564 <COE_ContinueInd+0x4c>
        }
        else
/*ECATCHANGE_END(V5.11) COE4*/
        {
            /* copy the stored SDO-Info-Header in the request */
            MBXMEMCPY(pMbx, aSdoInfoHeader, SDO_INFO_HEADER_BYTE_SIZE);
 8105552:	220e      	movs	r2, #14
 8105554:	4906      	ldr	r1, [pc, #24]	@ (8105570 <COE_ContinueInd+0x58>)
 8105556:	6878      	ldr	r0, [r7, #4]
 8105558:	f00a fc4f 	bl	810fdfa <memcpy>
            /* call SDOS_SdoInfoInd to generate and send the next fragment */
            SDOS_SdoInfoInd( (TSDOINFORMATION MBXMEM *) pMbx );
 810555c:	6878      	ldr	r0, [r7, #4]
 810555e:	f004 fd6f 	bl	810a040 <SDOS_SdoInfoInd>
        }
    }

    return 0;
 8105562:	2300      	movs	r3, #0
}
 8105564:	4618      	mov	r0, r3
 8105566:	3708      	adds	r7, #8
 8105568:	46bd      	mov	sp, r7
 810556a:	bd80      	pop	{r7, pc}
 810556c:	10000824 	.word	0x10000824
 8105570:	10000ba4 	.word	0x10000ba4

08105574 <ResetALEventMask>:
 \param    intMask        interrupt mask (disabled interrupt shall be zero)

 \brief    This function makes an logical and with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void ResetALEventMask(UINT16 intMask)
{
 8105574:	b580      	push	{r7, lr}
 8105576:	b084      	sub	sp, #16
 8105578:	af00      	add	r7, sp, #0
 810557a:	4603      	mov	r3, r0
 810557c:	80fb      	strh	r3, [r7, #6]
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
 810557e:	f107 030e 	add.w	r3, r7, #14
 8105582:	2202      	movs	r2, #2
 8105584:	f44f 7101 	mov.w	r1, #516	@ 0x204
 8105588:	4618      	mov	r0, r3
 810558a:	f7fb fd8d 	bl	81010a8 <HW_EscRead>
    
    mask &= intMask;
 810558e:	89fa      	ldrh	r2, [r7, #14]
 8105590:	88fb      	ldrh	r3, [r7, #6]
 8105592:	4013      	ands	r3, r2
 8105594:	b29b      	uxth	r3, r3
 8105596:	81fb      	strh	r3, [r7, #14]

    DISABLE_ESC_INT();
 8105598:	200a      	movs	r0, #10
 810559a:	f7fc fa29 	bl	81019f0 <HAL_NVIC_DisableIRQ>


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
 810559e:	f107 030e 	add.w	r3, r7, #14
 81055a2:	2202      	movs	r2, #2
 81055a4:	f44f 7101 	mov.w	r1, #516	@ 0x204
 81055a8:	4618      	mov	r0, r3
 81055aa:	f7fb fde5 	bl	8101178 <HW_EscWrite>
    ENABLE_ESC_INT();
 81055ae:	200a      	movs	r0, #10
 81055b0:	f7fc fa10 	bl	81019d4 <HAL_NVIC_EnableIRQ>
}
 81055b4:	bf00      	nop
 81055b6:	3710      	adds	r7, #16
 81055b8:	46bd      	mov	sp, r7
 81055ba:	bd80      	pop	{r7, pc}

081055bc <SetALEventMask>:
 \param    intMask        interrupt mask (enabled interrupt shall be one)

  \brief    This function makes an logical or with the AL Event Mask register (0x204)
*////////////////////////////////////////////////////////////////////////////////////////
void SetALEventMask(UINT16 intMask)
{
 81055bc:	b580      	push	{r7, lr}
 81055be:	b084      	sub	sp, #16
 81055c0:	af00      	add	r7, sp, #0
 81055c2:	4603      	mov	r3, r0
 81055c4:	80fb      	strh	r3, [r7, #6]
    UINT16 mask;
    HW_EscReadWord(mask, ESC_AL_EVENTMASK_OFFSET);
 81055c6:	f107 030e 	add.w	r3, r7, #14
 81055ca:	2202      	movs	r2, #2
 81055cc:	f44f 7101 	mov.w	r1, #516	@ 0x204
 81055d0:	4618      	mov	r0, r3
 81055d2:	f7fb fd69 	bl	81010a8 <HW_EscRead>
    
    mask |= intMask;
 81055d6:	89fa      	ldrh	r2, [r7, #14]
 81055d8:	88fb      	ldrh	r3, [r7, #6]
 81055da:	4313      	orrs	r3, r2
 81055dc:	b29b      	uxth	r3, r3
 81055de:	81fb      	strh	r3, [r7, #14]

    DISABLE_ESC_INT();
 81055e0:	200a      	movs	r0, #10
 81055e2:	f7fc fa05 	bl	81019f0 <HAL_NVIC_DisableIRQ>


    HW_EscWriteWord(mask, ESC_AL_EVENTMASK_OFFSET);
 81055e6:	f107 030e 	add.w	r3, r7, #14
 81055ea:	2202      	movs	r2, #2
 81055ec:	f44f 7101 	mov.w	r1, #516	@ 0x204
 81055f0:	4618      	mov	r0, r3
 81055f2:	f7fb fdc1 	bl	8101178 <HW_EscWrite>
    ENABLE_ESC_INT();
 81055f6:	200a      	movs	r0, #10
 81055f8:	f7fc f9ec 	bl	81019d4 <HAL_NVIC_EnableIRQ>
}
 81055fc:	bf00      	nop
 81055fe:	3710      	adds	r7, #16
 8105600:	46bd      	mov	sp, r7
 8105602:	bd80      	pop	{r7, pc}

08105604 <UpdateEEPROMLoadedState>:
/**

\brief    This function reads the EEPROM loaded state
*////////////////////////////////////////////////////////////////////////////////////////
void UpdateEEPROMLoadedState(void)
{
 8105604:	b580      	push	{r7, lr}
 8105606:	b082      	sub	sp, #8
 8105608:	af00      	add	r7, sp, #0
    {
       UINT16 TmpVar = 0;
 810560a:	2300      	movs	r3, #0
 810560c:	80fb      	strh	r3, [r7, #6]
       //read EEPROM loaded information
       HW_EscReadWord(TmpVar, ESC_EEPROM_CONTROL_OFFSET);
 810560e:	1dbb      	adds	r3, r7, #6
 8105610:	2202      	movs	r2, #2
 8105612:	f240 5102 	movw	r1, #1282	@ 0x502
 8105616:	4618      	mov	r0, r3
 8105618:	f7fb fd46 	bl	81010a8 <HW_EscRead>
       TmpVar = SWAPWORD(TmpVar);
 810561c:	88fb      	ldrh	r3, [r7, #6]
 810561e:	80fb      	strh	r3, [r7, #6]

       if (((TmpVar & ESC_EEPROM_ERROR_CRC) > 0)
 8105620:	88fb      	ldrh	r3, [r7, #6]
 8105622:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8105626:	2b00      	cmp	r3, #0
 8105628:	dc04      	bgt.n	8105634 <UpdateEEPROMLoadedState+0x30>
          || ((TmpVar & ESC_EEPROM_ERROR_LOAD) > 0))
 810562a:	88fb      	ldrh	r3, [r7, #6]
 810562c:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8105630:	2b00      	cmp	r3, #0
 8105632:	dd03      	ble.n	810563c <UpdateEEPROMLoadedState+0x38>
       {
          EepromLoaded = FALSE;
 8105634:	4b05      	ldr	r3, [pc, #20]	@ (810564c <UpdateEEPROMLoadedState+0x48>)
 8105636:	2200      	movs	r2, #0
 8105638:	701a      	strb	r2, [r3, #0]
 810563a:	e003      	b.n	8105644 <UpdateEEPROMLoadedState+0x40>
       }
       else
       {
          EepromLoaded = TRUE;
 810563c:	4b03      	ldr	r3, [pc, #12]	@ (810564c <UpdateEEPROMLoadedState+0x48>)
 810563e:	2201      	movs	r2, #1
 8105640:	701a      	strb	r2, [r3, #0]
       }
    }
}
 8105642:	bf00      	nop
 8105644:	bf00      	nop
 8105646:	3708      	adds	r7, #8
 8105648:	46bd      	mov	sp, r7
 810564a:	bd80      	pop	{r7, pc}
 810564c:	10000874 	.word	0x10000874

08105650 <GetSyncMan>:
 \brief    This function is called to read the SYNC Manager channel descriptions of the
             process data SYNC Managers.
*////////////////////////////////////////////////////////////////////////////////////////

TSYNCMAN ESCMEM * GetSyncMan( UINT8 channel )
{
 8105650:	b580      	push	{r7, lr}
 8105652:	b082      	sub	sp, #8
 8105654:	af00      	add	r7, sp, #0
 8105656:	4603      	mov	r3, r0
 8105658:	71fb      	strb	r3, [r7, #7]
    HW_EscRead((MEM_ADDR *)&SyncManInfo, ESC_SYNCMAN_REG_OFFSET + (channel * SIZEOF_SM_REGISTER), SIZEOF_SM_REGISTER );
 810565a:	79fb      	ldrb	r3, [r7, #7]
 810565c:	f503 7380 	add.w	r3, r3, #256	@ 0x100
 8105660:	b29b      	uxth	r3, r3
 8105662:	00db      	lsls	r3, r3, #3
 8105664:	b29b      	uxth	r3, r3
 8105666:	2208      	movs	r2, #8
 8105668:	4619      	mov	r1, r3
 810566a:	4804      	ldr	r0, [pc, #16]	@ (810567c <GetSyncMan+0x2c>)
 810566c:	f7fb fd1c 	bl	81010a8 <HW_EscRead>


    return &SyncManInfo;
 8105670:	4b02      	ldr	r3, [pc, #8]	@ (810567c <GetSyncMan+0x2c>)
}
 8105672:	4618      	mov	r0, r3
 8105674:	3708      	adds	r7, #8
 8105676:	46bd      	mov	sp, r7
 8105678:	bd80      	pop	{r7, pc}
 810567a:	bf00      	nop
 810567c:	1000086c 	.word	0x1000086c

08105680 <DisableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function disables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void DisableSyncManChannel(UINT8 channel)
{
 8105680:	b580      	push	{r7, lr}
 8105682:	b084      	sub	sp, #16
 8105684:	af00      	add	r7, sp, #0
 8105686:	4603      	mov	r3, r0
 8105688:	71fb      	strb	r3, [r7, #7]
    UINT16 Offset;
    //The register 0x806 is only readable from PDI => writing 0 is valid
    VARVOLATILE UINT16 smStatus = SM_SETTING_PDI_DISABLE;
 810568a:	f44f 7380 	mov.w	r3, #256	@ 0x100
 810568e:	81bb      	strh	r3, [r7, #12]
    Offset = (ESC_SYNCMAN_ACTIVE_OFFSET + (SIZEOF_SM_REGISTER*channel));
 8105690:	79fb      	ldrb	r3, [r7, #7]
 8105692:	b29b      	uxth	r3, r3
 8105694:	00db      	lsls	r3, r3, #3
 8105696:	b29b      	uxth	r3, r3
 8105698:	f603 0306 	addw	r3, r3, #2054	@ 0x806
 810569c:	81fb      	strh	r3, [r7, #14]


    HW_EscWriteWord(smStatus,Offset);
 810569e:	89f9      	ldrh	r1, [r7, #14]
 81056a0:	f107 030c 	add.w	r3, r7, #12
 81056a4:	2202      	movs	r2, #2
 81056a6:	4618      	mov	r0, r3
 81056a8:	f7fb fd66 	bl	8101178 <HW_EscWrite>
    
    /*wait until SyncManager is disabled*/
    do
    {
        HW_EscReadWord(smStatus, Offset);
 81056ac:	89f9      	ldrh	r1, [r7, #14]
 81056ae:	f107 030c 	add.w	r3, r7, #12
 81056b2:	2202      	movs	r2, #2
 81056b4:	4618      	mov	r0, r3
 81056b6:	f7fb fcf7 	bl	81010a8 <HW_EscRead>
    }while(!(smStatus & SM_SETTING_PDI_DISABLE));
 81056ba:	89bb      	ldrh	r3, [r7, #12]
 81056bc:	b29b      	uxth	r3, r3
 81056be:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 81056c2:	2b00      	cmp	r3, #0
 81056c4:	d0f2      	beq.n	81056ac <DisableSyncManChannel+0x2c>
}
 81056c6:	bf00      	nop
 81056c8:	bf00      	nop
 81056ca:	3710      	adds	r7, #16
 81056cc:	46bd      	mov	sp, r7
 81056ce:	bd80      	pop	{r7, pc}

081056d0 <EnableSyncManChannel>:
 \param     channel        Sync Manager channel

 \brief    This function enables a Sync Manager channel
*////////////////////////////////////////////////////////////////////////////////////////
void EnableSyncManChannel(UINT8 channel)
{
 81056d0:	b580      	push	{r7, lr}
 81056d2:	b084      	sub	sp, #16
 81056d4:	af00      	add	r7, sp, #0
 81056d6:	4603      	mov	r3, r0
 81056d8:	71fb      	strb	r3, [r7, #7]
    UINT16 Offset;
    //The register 0x806 is only readable from PDI => writing 0 is valid
    VARVOLATILE UINT16 smStatus = 0x0000;
 81056da:	2300      	movs	r3, #0
 81056dc:	81bb      	strh	r3, [r7, #12]
    Offset = (ESC_SYNCMAN_ACTIVE_OFFSET + (SIZEOF_SM_REGISTER*channel));
 81056de:	79fb      	ldrb	r3, [r7, #7]
 81056e0:	b29b      	uxth	r3, r3
 81056e2:	00db      	lsls	r3, r3, #3
 81056e4:	b29b      	uxth	r3, r3
 81056e6:	f603 0306 	addw	r3, r3, #2054	@ 0x806
 81056ea:	81fb      	strh	r3, [r7, #14]


    HW_EscWriteWord(smStatus,Offset);
 81056ec:	89f9      	ldrh	r1, [r7, #14]
 81056ee:	f107 030c 	add.w	r3, r7, #12
 81056f2:	2202      	movs	r2, #2
 81056f4:	4618      	mov	r0, r3
 81056f6:	f7fb fd3f 	bl	8101178 <HW_EscWrite>
    
    /*wait until SyncManager is enabled*/
    do
    {
        HW_EscReadWord(smStatus,Offset);
 81056fa:	89f9      	ldrh	r1, [r7, #14]
 81056fc:	f107 030c 	add.w	r3, r7, #12
 8105700:	2202      	movs	r2, #2
 8105702:	4618      	mov	r0, r3
 8105704:	f7fb fcd0 	bl	81010a8 <HW_EscRead>

    }while((smStatus & SM_SETTING_PDI_DISABLE));
 8105708:	89bb      	ldrh	r3, [r7, #12]
 810570a:	b29b      	uxth	r3, r3
 810570c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8105710:	2b00      	cmp	r3, #0
 8105712:	d1f2      	bne.n	81056fa <EnableSyncManChannel+0x2a>
}
 8105714:	bf00      	nop
 8105716:	bf00      	nop
 8105718:	3710      	adds	r7, #16
 810571a:	46bd      	mov	sp, r7
 810571c:	bd80      	pop	{r7, pc}
	...

08105720 <CheckSmSettings>:
 \brief    This function checks all SM channels

*////////////////////////////////////////////////////////////////////////////////////////

UINT8    CheckSmSettings(UINT8 maxChannel)
{
 8105720:	b580      	push	{r7, lr}
 8105722:	b086      	sub	sp, #24
 8105724:	af00      	add	r7, sp, #0
 8105726:	4603      	mov	r3, r0
 8105728:	71fb      	strb	r3, [r7, #7]
    UINT8 i;
    UINT8 result = 0;
 810572a:	2300      	movs	r3, #0
 810572c:	75bb      	strb	r3, [r7, #22]
    TSYNCMAN ESCMEM *pSyncMan;
    UINT16 SMLength = 0;
 810572e:	2300      	movs	r3, #0
 8105730:	82bb      	strh	r3, [r7, #20]
    UINT16 SMAddress = 0;
 8105732:	2300      	movs	r3, #0
 8105734:	827b      	strh	r3, [r7, #18]

    //Check if max address defines are within the available ESC address range
    if((nMaxEscAddress < MAX_PD_WRITE_ADDRESS)
 8105736:	4b92      	ldr	r3, [pc, #584]	@ (8105980 <CheckSmSettings+0x260>)
 8105738:	881b      	ldrh	r3, [r3, #0]
 810573a:	f642 72fe 	movw	r2, #12286	@ 0x2ffe
 810573e:	4293      	cmp	r3, r2
 8105740:	d911      	bls.n	8105766 <CheckSmSettings+0x46>
        ||(nMaxEscAddress < MAX_PD_READ_ADDRESS)
 8105742:	4b8f      	ldr	r3, [pc, #572]	@ (8105980 <CheckSmSettings+0x260>)
 8105744:	881b      	ldrh	r3, [r3, #0]
 8105746:	f642 72fe 	movw	r2, #12286	@ 0x2ffe
 810574a:	4293      	cmp	r3, r2
 810574c:	d90b      	bls.n	8105766 <CheckSmSettings+0x46>
/*ECATCHANGE_START(V5.11) ESM5*/
        ||(nMaxEscAddress < MAX_MBX_WRITE_ADDRESS)
 810574e:	4b8c      	ldr	r3, [pc, #560]	@ (8105980 <CheckSmSettings+0x260>)
 8105750:	881b      	ldrh	r3, [r3, #0]
 8105752:	f642 72fe 	movw	r2, #12286	@ 0x2ffe
 8105756:	4293      	cmp	r3, r2
 8105758:	d905      	bls.n	8105766 <CheckSmSettings+0x46>
/*ECATCHANGE_END(V5.11) ESM5*/
        ||(nMaxEscAddress < MAX_MBX_READ_ADDRESS))
 810575a:	4b89      	ldr	r3, [pc, #548]	@ (8105980 <CheckSmSettings+0x260>)
 810575c:	881b      	ldrh	r3, [r3, #0]
 810575e:	f642 72fe 	movw	r2, #12286	@ 0x2ffe
 8105762:	4293      	cmp	r3, r2
 8105764:	d801      	bhi.n	810576a <CheckSmSettings+0x4a>
    {
        /*The defines for maximum SM addresses are invalid for the used ESC (change the defines in the file ecat_def.h or the SSC Tool)
        It may be also required to adapt the SM settings in the ESI file*/

        return ALSTATUSCODE_NOVALIDFIRMWARE;
 8105766:	2314      	movs	r3, #20
 8105768:	e1c1      	b.n	8105aee <CheckSmSettings+0x3ce>
    }

    /* check the Sync Manager Parameter for the Receive Mailbox (Sync Manager Channel 0) */
/*ECATCHANGE_START(V5.11) HW1*/
    pSyncMan = GetSyncMan(MAILBOX_WRITE);
 810576a:	2000      	movs	r0, #0
 810576c:	f7ff ff70 	bl	8105650 <GetSyncMan>
 8105770:	60f8      	str	r0, [r7, #12]
/*ECATCHANGE_END(V5.11) HW1*/

    SMLength = pSyncMan->Length;
 8105772:	68fb      	ldr	r3, [r7, #12]
 8105774:	885b      	ldrh	r3, [r3, #2]
 8105776:	82bb      	strh	r3, [r7, #20]
    SMAddress = pSyncMan->PhysicalStartAddress;
 8105778:	68fb      	ldr	r3, [r7, #12]
 810577a:	881b      	ldrh	r3, [r3, #0]
 810577c:	827b      	strh	r3, [r7, #18]

/* ECATCHANGE_START(V5.11) HW2*/
    //Check if the start address and length are even 16Bit addresses
    if ((SMLength & 0x1) > 0)
 810577e:	8abb      	ldrh	r3, [r7, #20]
 8105780:	f003 0301 	and.w	r3, r3, #1
 8105784:	2b00      	cmp	r3, #0
 8105786:	dd01      	ble.n	810578c <CheckSmSettings+0x6c>
        return ALSTATUSCODE_INVALIDSMCFG;
 8105788:	2317      	movs	r3, #23
 810578a:	e1b0      	b.n	8105aee <CheckSmSettings+0x3ce>

    if ((SMAddress & 0x1) > 0)
 810578c:	8a7b      	ldrh	r3, [r7, #18]
 810578e:	f003 0301 	and.w	r3, r3, #1
 8105792:	2b00      	cmp	r3, #0
 8105794:	dd01      	ble.n	810579a <CheckSmSettings+0x7a>
        return ALSTATUSCODE_INVALIDSMCFG;
 8105796:	2317      	movs	r3, #23
 8105798:	e1a9      	b.n	8105aee <CheckSmSettings+0x3ce>
/* ECATCHANGE_END(V5.11) HW2*/

    if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
 810579a:	68fb      	ldr	r3, [r7, #12]
 810579c:	88db      	ldrh	r3, [r3, #6]
 810579e:	f003 0301 	and.w	r3, r3, #1
 81057a2:	2b00      	cmp	r3, #0
 81057a4:	d102      	bne.n	81057ac <CheckSmSettings+0x8c>
        /* receive mailbox is not enabled */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 81057a6:	2316      	movs	r3, #22
 81057a8:	75bb      	strb	r3, [r7, #22]
 81057aa:	e02b      	b.n	8105804 <CheckSmSettings+0xe4>
    else if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_WRITE_VALUE)
 81057ac:	68fb      	ldr	r3, [r7, #12]
 81057ae:	889b      	ldrh	r3, [r3, #4]
 81057b0:	f003 030c 	and.w	r3, r3, #12
 81057b4:	2b04      	cmp	r3, #4
 81057b6:	d002      	beq.n	81057be <CheckSmSettings+0x9e>
       /* receive mailbox is not writable by the master*/
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 81057b8:	2316      	movs	r3, #22
 81057ba:	75bb      	strb	r3, [r7, #22]
 81057bc:	e022      	b.n	8105804 <CheckSmSettings+0xe4>
    else if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE )
 81057be:	68fb      	ldr	r3, [r7, #12]
 81057c0:	889b      	ldrh	r3, [r3, #4]
 81057c2:	f003 0302 	and.w	r3, r3, #2
 81057c6:	2b00      	cmp	r3, #0
 81057c8:	d102      	bne.n	81057d0 <CheckSmSettings+0xb0>
        /* receive mailbox is not in one buffer mode */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 81057ca:	2316      	movs	r3, #22
 81057cc:	75bb      	strb	r3, [r7, #22]
 81057ce:	e019      	b.n	8105804 <CheckSmSettings+0xe4>
    else if ( SMLength < MIN_MBX_SIZE )
 81057d0:	8abb      	ldrh	r3, [r7, #20]
 81057d2:	2b21      	cmp	r3, #33	@ 0x21
 81057d4:	d802      	bhi.n	81057dc <CheckSmSettings+0xbc>
        /* receive mailbox size is too small */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 81057d6:	2316      	movs	r3, #22
 81057d8:	75bb      	strb	r3, [r7, #22]
 81057da:	e013      	b.n	8105804 <CheckSmSettings+0xe4>
    else if ( SMLength > MAX_MBX_SIZE )
 81057dc:	8abb      	ldrh	r3, [r7, #20]
 81057de:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 81057e2:	d902      	bls.n	81057ea <CheckSmSettings+0xca>
        /* receive mailbox size is too great */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 81057e4:	2316      	movs	r3, #22
 81057e6:	75bb      	strb	r3, [r7, #22]
 81057e8:	e00c      	b.n	8105804 <CheckSmSettings+0xe4>
     else if ( SMAddress < MIN_MBX_WRITE_ADDRESS )
 81057ea:	8a7b      	ldrh	r3, [r7, #18]
 81057ec:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 81057f0:	d202      	bcs.n	81057f8 <CheckSmSettings+0xd8>
        /* receive mailbox address is too small */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 81057f2:	2316      	movs	r3, #22
 81057f4:	75bb      	strb	r3, [r7, #22]
 81057f6:	e005      	b.n	8105804 <CheckSmSettings+0xe4>
    else if ( SMAddress > MAX_MBX_WRITE_ADDRESS)
 81057f8:	8a7b      	ldrh	r3, [r7, #18]
 81057fa:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 81057fe:	d301      	bcc.n	8105804 <CheckSmSettings+0xe4>
        /* receive mailbox address is too great */
        result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 8105800:	2316      	movs	r3, #22
 8105802:	75bb      	strb	r3, [r7, #22]


    if ( result == 0 )
 8105804:	7dbb      	ldrb	r3, [r7, #22]
 8105806:	2b00      	cmp	r3, #0
 8105808:	d14c      	bne.n	81058a4 <CheckSmSettings+0x184>
    {
        /* check the Sync Manager Parameter for the Send Mailbox (Sync Manager Channel 1) */
/*ECATCHANGE_START(V5.11) HW1*/
        pSyncMan = GetSyncMan(MAILBOX_READ);
 810580a:	2001      	movs	r0, #1
 810580c:	f7ff ff20 	bl	8105650 <GetSyncMan>
 8105810:	60f8      	str	r0, [r7, #12]
/*ECATCHANGE_END(V5.11) HW1*/

    SMLength = pSyncMan->Length;
 8105812:	68fb      	ldr	r3, [r7, #12]
 8105814:	885b      	ldrh	r3, [r3, #2]
 8105816:	82bb      	strh	r3, [r7, #20]
    SMAddress = pSyncMan->PhysicalStartAddress;
 8105818:	68fb      	ldr	r3, [r7, #12]
 810581a:	881b      	ldrh	r3, [r3, #0]
 810581c:	827b      	strh	r3, [r7, #18]

/* ECATCHANGE_START(V5.11) HW2*/
    //Check if the start address and length are even 16Bit addresses
    if ((SMLength & 0x1) > 0)
 810581e:	8abb      	ldrh	r3, [r7, #20]
 8105820:	f003 0301 	and.w	r3, r3, #1
 8105824:	2b00      	cmp	r3, #0
 8105826:	dd01      	ble.n	810582c <CheckSmSettings+0x10c>
        return ALSTATUSCODE_INVALIDSMCFG;
 8105828:	2317      	movs	r3, #23
 810582a:	e160      	b.n	8105aee <CheckSmSettings+0x3ce>

    if ((SMAddress & 0x1) > 0)
 810582c:	8a7b      	ldrh	r3, [r7, #18]
 810582e:	f003 0301 	and.w	r3, r3, #1
 8105832:	2b00      	cmp	r3, #0
 8105834:	dd01      	ble.n	810583a <CheckSmSettings+0x11a>
        return ALSTATUSCODE_INVALIDSMCFG;
 8105836:	2317      	movs	r3, #23
 8105838:	e159      	b.n	8105aee <CheckSmSettings+0x3ce>
/* ECATCHANGE_END(V5.11) HW2*/

      if (!(pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE))
 810583a:	68fb      	ldr	r3, [r7, #12]
 810583c:	88db      	ldrh	r3, [r3, #6]
 810583e:	f003 0301 	and.w	r3, r3, #1
 8105842:	2b00      	cmp	r3, #0
 8105844:	d102      	bne.n	810584c <CheckSmSettings+0x12c>
            /* send mailbox is not enabled */
            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 8105846:	2316      	movs	r3, #22
 8105848:	75bb      	strb	r3, [r7, #22]
 810584a:	e02b      	b.n	81058a4 <CheckSmSettings+0x184>
        else if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) != SM_SETTING_DIRECTION_READ_VALUE)
 810584c:	68fb      	ldr	r3, [r7, #12]
 810584e:	889b      	ldrh	r3, [r3, #4]
 8105850:	f003 030c 	and.w	r3, r3, #12
 8105854:	2b00      	cmp	r3, #0
 8105856:	d002      	beq.n	810585e <CheckSmSettings+0x13e>
           /* receive mailbox is not readable by the master*/
            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 8105858:	2316      	movs	r3, #22
 810585a:	75bb      	strb	r3, [r7, #22]
 810585c:	e022      	b.n	81058a4 <CheckSmSettings+0x184>
        else if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) != SM_SETTING_MODE_ONE_BUFFER_VALUE )
 810585e:	68fb      	ldr	r3, [r7, #12]
 8105860:	889b      	ldrh	r3, [r3, #4]
 8105862:	f003 0302 	and.w	r3, r3, #2
 8105866:	2b00      	cmp	r3, #0
 8105868:	d102      	bne.n	8105870 <CheckSmSettings+0x150>
            /* receive mailbox is not in one buffer mode */
            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 810586a:	2316      	movs	r3, #22
 810586c:	75bb      	strb	r3, [r7, #22]
 810586e:	e019      	b.n	81058a4 <CheckSmSettings+0x184>
        else if ( SMLength < MIN_MBX_SIZE )
 8105870:	8abb      	ldrh	r3, [r7, #20]
 8105872:	2b21      	cmp	r3, #33	@ 0x21
 8105874:	d802      	bhi.n	810587c <CheckSmSettings+0x15c>
            /* send mailbox size is too small */
            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 8105876:	2316      	movs	r3, #22
 8105878:	75bb      	strb	r3, [r7, #22]
 810587a:	e013      	b.n	81058a4 <CheckSmSettings+0x184>
        else if ( SMLength > MAX_MBX_SIZE )
 810587c:	8abb      	ldrh	r3, [r7, #20]
 810587e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 8105882:	d902      	bls.n	810588a <CheckSmSettings+0x16a>
            /* send mailbox size is too great */
            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 8105884:	2316      	movs	r3, #22
 8105886:	75bb      	strb	r3, [r7, #22]
 8105888:	e00c      	b.n	81058a4 <CheckSmSettings+0x184>
         else if ( SMAddress < MIN_MBX_READ_ADDRESS )
 810588a:	8a7b      	ldrh	r3, [r7, #18]
 810588c:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8105890:	d202      	bcs.n	8105898 <CheckSmSettings+0x178>
            /* send mailbox address is too small */
            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 8105892:	2316      	movs	r3, #22
 8105894:	75bb      	strb	r3, [r7, #22]
 8105896:	e005      	b.n	81058a4 <CheckSmSettings+0x184>
        else if ( SMAddress > MAX_MBX_READ_ADDRESS )
 8105898:	8a7b      	ldrh	r3, [r7, #18]
 810589a:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 810589e:	d301      	bcc.n	81058a4 <CheckSmSettings+0x184>
            /* send mailbox address is too great */
            result = ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 81058a0:	2316      	movs	r3, #22
 81058a2:	75bb      	strb	r3, [r7, #22]

    }

    if ( result == 0 && maxChannel > PROCESS_DATA_IN )
 81058a4:	7dbb      	ldrb	r3, [r7, #22]
 81058a6:	2b00      	cmp	r3, #0
 81058a8:	f040 8082 	bne.w	81059b0 <CheckSmSettings+0x290>
 81058ac:	79fb      	ldrb	r3, [r7, #7]
 81058ae:	2b03      	cmp	r3, #3
 81058b0:	d97e      	bls.n	81059b0 <CheckSmSettings+0x290>
    {
        /* b3BufferMode is only set, if inputs and outputs are running in 3-Buffer-Mode when leaving this function */
        b3BufferMode = TRUE;
 81058b2:	4b34      	ldr	r3, [pc, #208]	@ (8105984 <CheckSmSettings+0x264>)
 81058b4:	2201      	movs	r2, #1
 81058b6:	701a      	strb	r2, [r3, #0]
        /* check the Sync Manager Parameter for the Inputs (Sync Manager Channel 2) */
/*ECATCHANGE_START(V5.11) HW1*/
        pSyncMan = GetSyncMan(PROCESS_DATA_IN);
 81058b8:	2003      	movs	r0, #3
 81058ba:	f7ff fec9 	bl	8105650 <GetSyncMan>
 81058be:	60f8      	str	r0, [r7, #12]
/*ECATCHANGE_END(V5.11) HW1*/

    SMLength = pSyncMan->Length;
 81058c0:	68fb      	ldr	r3, [r7, #12]
 81058c2:	885b      	ldrh	r3, [r3, #2]
 81058c4:	82bb      	strh	r3, [r7, #20]
    SMAddress = pSyncMan->PhysicalStartAddress;
 81058c6:	68fb      	ldr	r3, [r7, #12]
 81058c8:	881b      	ldrh	r3, [r3, #0]
 81058ca:	827b      	strh	r3, [r7, #18]

/* ECATCHANGE_START(V5.11) HW2*/
    //Check if the start address and length are even 16Bit addresses
    if ((SMLength & 0x1) > 0)
 81058cc:	8abb      	ldrh	r3, [r7, #20]
 81058ce:	f003 0301 	and.w	r3, r3, #1
 81058d2:	2b00      	cmp	r3, #0
 81058d4:	dd01      	ble.n	81058da <CheckSmSettings+0x1ba>
        return ALSTATUSCODE_INVALIDSMCFG;
 81058d6:	2317      	movs	r3, #23
 81058d8:	e109      	b.n	8105aee <CheckSmSettings+0x3ce>

    if ((SMAddress & 0x1) > 0)
 81058da:	8a7b      	ldrh	r3, [r7, #18]
 81058dc:	f003 0301 	and.w	r3, r3, #1
 81058e0:	2b00      	cmp	r3, #0
 81058e2:	dd01      	ble.n	81058e8 <CheckSmSettings+0x1c8>
        return ALSTATUSCODE_INVALIDSMCFG;
 81058e4:	2317      	movs	r3, #23
 81058e6:	e102      	b.n	8105aee <CheckSmSettings+0x3ce>
/* ECATCHANGE_END(V5.11) HW2*/

        if ((pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0 )
 81058e8:	68fb      	ldr	r3, [r7, #12]
 81058ea:	88db      	ldrh	r3, [r3, #6]
 81058ec:	f003 0301 	and.w	r3, r3, #1
 81058f0:	2b00      	cmp	r3, #0
 81058f2:	d005      	beq.n	8105900 <CheckSmSettings+0x1e0>
 81058f4:	8abb      	ldrh	r3, [r7, #20]
 81058f6:	2b00      	cmp	r3, #0
 81058f8:	d102      	bne.n	8105900 <CheckSmSettings+0x1e0>
            /* the SM3 size is 0 and the SM3 is active */
            result = SYNCMANCHSETTINGS+1;
 81058fa:	2304      	movs	r3, #4
 81058fc:	75bb      	strb	r3, [r7, #22]
 81058fe:	e052      	b.n	81059a6 <CheckSmSettings+0x286>
        else if (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE)
 8105900:	68fb      	ldr	r3, [r7, #12]
 8105902:	88db      	ldrh	r3, [r3, #6]
 8105904:	f003 0301 	and.w	r3, r3, #1
 8105908:	2b00      	cmp	r3, #0
 810590a:	d043      	beq.n	8105994 <CheckSmSettings+0x274>
        {
            /* Sync Manager Channel 3 is active, input size has to greater 0 */
            if ( SMLength != nPdInputSize || nPdInputSize == 0 || SMLength > MAX_PD_INPUT_SIZE)
 810590c:	4b1e      	ldr	r3, [pc, #120]	@ (8105988 <CheckSmSettings+0x268>)
 810590e:	881b      	ldrh	r3, [r3, #0]
 8105910:	8aba      	ldrh	r2, [r7, #20]
 8105912:	429a      	cmp	r2, r3
 8105914:	d106      	bne.n	8105924 <CheckSmSettings+0x204>
 8105916:	4b1c      	ldr	r3, [pc, #112]	@ (8105988 <CheckSmSettings+0x268>)
 8105918:	881b      	ldrh	r3, [r3, #0]
 810591a:	2b00      	cmp	r3, #0
 810591c:	d002      	beq.n	8105924 <CheckSmSettings+0x204>
 810591e:	8abb      	ldrh	r3, [r7, #20]
 8105920:	2b44      	cmp	r3, #68	@ 0x44
 8105922:	d902      	bls.n	810592a <CheckSmSettings+0x20a>
                /* sizes don't match */
                result = SYNCMANCHSIZE+1;
 8105924:	2303      	movs	r3, #3
 8105926:	75bb      	strb	r3, [r7, #22]
 8105928:	e03d      	b.n	81059a6 <CheckSmSettings+0x286>
            else
                /* sizes matches */
            if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_READ_VALUE )
 810592a:	68fb      	ldr	r3, [r7, #12]
 810592c:	889b      	ldrh	r3, [r3, #4]
 810592e:	f003 030c 	and.w	r3, r3, #12
 8105932:	2b00      	cmp	r3, #0
 8105934:	d121      	bne.n	810597a <CheckSmSettings+0x25a>
            {
                /* settings match */
                if ( ( ( nAlStatus == STATE_PREOP )&&( SMAddress >= MIN_PD_READ_ADDRESS )&&( SMAddress <= MAX_PD_READ_ADDRESS ) )
 8105936:	4b15      	ldr	r3, [pc, #84]	@ (810598c <CheckSmSettings+0x26c>)
 8105938:	781b      	ldrb	r3, [r3, #0]
 810593a:	2b02      	cmp	r3, #2
 810593c:	d107      	bne.n	810594e <CheckSmSettings+0x22e>
 810593e:	8a7b      	ldrh	r3, [r7, #18]
 8105940:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8105944:	d303      	bcc.n	810594e <CheckSmSettings+0x22e>
 8105946:	8a7b      	ldrh	r3, [r7, #18]
 8105948:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 810594c:	d308      	bcc.n	8105960 <CheckSmSettings+0x240>
                   ||( ( nAlStatus != STATE_PREOP )&&( SMAddress == nEscAddrInputData ) )
 810594e:	4b0f      	ldr	r3, [pc, #60]	@ (810598c <CheckSmSettings+0x26c>)
 8105950:	781b      	ldrb	r3, [r3, #0]
 8105952:	2b02      	cmp	r3, #2
 8105954:	d00e      	beq.n	8105974 <CheckSmSettings+0x254>
 8105956:	4b0e      	ldr	r3, [pc, #56]	@ (8105990 <CheckSmSettings+0x270>)
 8105958:	881b      	ldrh	r3, [r3, #0]
 810595a:	8a7a      	ldrh	r2, [r7, #18]
 810595c:	429a      	cmp	r2, r3
 810595e:	d109      	bne.n	8105974 <CheckSmSettings+0x254>
                    )
                {
                    /* addresses match */

                    if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE )
 8105960:	68fb      	ldr	r3, [r7, #12]
 8105962:	889b      	ldrh	r3, [r3, #4]
 8105964:	f003 0302 	and.w	r3, r3, #2
 8105968:	2b00      	cmp	r3, #0
 810596a:	d01c      	beq.n	81059a6 <CheckSmSettings+0x286>
                        /* inputs are running in 1-Buffer-Mode, reset flag b3BufferMode */
                        b3BufferMode = FALSE;
 810596c:	4b05      	ldr	r3, [pc, #20]	@ (8105984 <CheckSmSettings+0x264>)
 810596e:	2200      	movs	r2, #0
 8105970:	701a      	strb	r2, [r3, #0]
                    if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE )
 8105972:	e018      	b.n	81059a6 <CheckSmSettings+0x286>
                }
                else
                    /* input address is out of the allowed area or has changed in SAFEOP or OP */
                    result = SYNCMANCHADDRESS+1;
 8105974:	2302      	movs	r3, #2
 8105976:	75bb      	strb	r3, [r7, #22]
 8105978:	e015      	b.n	81059a6 <CheckSmSettings+0x286>
            }
            else
                /* input settings do not match */
                result = SYNCMANCHSETTINGS+1;
 810597a:	2304      	movs	r3, #4
 810597c:	75bb      	strb	r3, [r7, #22]
 810597e:	e012      	b.n	81059a6 <CheckSmSettings+0x286>
 8105980:	1000085a 	.word	0x1000085a
 8105984:	10000849 	.word	0x10000849
 8105988:	10000854 	.word	0x10000854
 810598c:	1000085c 	.word	0x1000085c
 8105990:	10000862 	.word	0x10000862
        }
        else if ( SMLength != 0 || nPdInputSize != 0 )
 8105994:	8abb      	ldrh	r3, [r7, #20]
 8105996:	2b00      	cmp	r3, #0
 8105998:	d103      	bne.n	81059a2 <CheckSmSettings+0x282>
 810599a:	4b57      	ldr	r3, [pc, #348]	@ (8105af8 <CheckSmSettings+0x3d8>)
 810599c:	881b      	ldrh	r3, [r3, #0]
 810599e:	2b00      	cmp	r3, #0
 81059a0:	d001      	beq.n	81059a6 <CheckSmSettings+0x286>
            /* input size is not zero although the SM3 channel is not enabled */
            result = SYNCMANCHSIZE+1;
 81059a2:	2303      	movs	r3, #3
 81059a4:	75bb      	strb	r3, [r7, #22]



        if ( result != 0 )
 81059a6:	7dbb      	ldrb	r3, [r7, #22]
 81059a8:	2b00      	cmp	r3, #0
 81059aa:	d001      	beq.n	81059b0 <CheckSmSettings+0x290>
        {
            result = ALSTATUSCODE_INVALIDSMINCFG;
 81059ac:	231e      	movs	r3, #30
 81059ae:	75bb      	strb	r3, [r7, #22]
        }
    }


//    else
    if ( result == 0 && maxChannel > PROCESS_DATA_OUT )
 81059b0:	7dbb      	ldrb	r3, [r7, #22]
 81059b2:	2b00      	cmp	r3, #0
 81059b4:	f040 8083 	bne.w	8105abe <CheckSmSettings+0x39e>
 81059b8:	79fb      	ldrb	r3, [r7, #7]
 81059ba:	2b02      	cmp	r3, #2
 81059bc:	d97f      	bls.n	8105abe <CheckSmSettings+0x39e>
    {
        /* check the Sync Manager Parameter for the Outputs (Sync Manager Channel 2) */
/*ECATCHANGE_START(V5.11) HW1*/
        pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
 81059be:	2002      	movs	r0, #2
 81059c0:	f7ff fe46 	bl	8105650 <GetSyncMan>
 81059c4:	60f8      	str	r0, [r7, #12]
/*ECATCHANGE_END(V5.11) HW1*/

    SMLength = pSyncMan->Length;
 81059c6:	68fb      	ldr	r3, [r7, #12]
 81059c8:	885b      	ldrh	r3, [r3, #2]
 81059ca:	82bb      	strh	r3, [r7, #20]
    SMAddress = pSyncMan->PhysicalStartAddress;
 81059cc:	68fb      	ldr	r3, [r7, #12]
 81059ce:	881b      	ldrh	r3, [r3, #0]
 81059d0:	827b      	strh	r3, [r7, #18]

/* ECATCHANGE_START(V5.11) HW2*/
    //Check if the start address and length are even 16Bit addresses
    if ((SMLength & 0x1) > 0)
 81059d2:	8abb      	ldrh	r3, [r7, #20]
 81059d4:	f003 0301 	and.w	r3, r3, #1
 81059d8:	2b00      	cmp	r3, #0
 81059da:	dd01      	ble.n	81059e0 <CheckSmSettings+0x2c0>
        return ALSTATUSCODE_INVALIDSMCFG;
 81059dc:	2317      	movs	r3, #23
 81059de:	e086      	b.n	8105aee <CheckSmSettings+0x3ce>

    if ((SMAddress & 0x1) > 0)
 81059e0:	8a7b      	ldrh	r3, [r7, #18]
 81059e2:	f003 0301 	and.w	r3, r3, #1
 81059e6:	2b00      	cmp	r3, #0
 81059e8:	dd01      	ble.n	81059ee <CheckSmSettings+0x2ce>
        return ALSTATUSCODE_INVALIDSMCFG;
 81059ea:	2317      	movs	r3, #23
 81059ec:	e07f      	b.n	8105aee <CheckSmSettings+0x3ce>
/* ECATCHANGE_END(V5.11) HW2*/

    if ( (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE) != 0 && SMLength == 0 )
 81059ee:	68fb      	ldr	r3, [r7, #12]
 81059f0:	88db      	ldrh	r3, [r3, #6]
 81059f2:	f003 0301 	and.w	r3, r3, #1
 81059f6:	2b00      	cmp	r3, #0
 81059f8:	d005      	beq.n	8105a06 <CheckSmSettings+0x2e6>
 81059fa:	8abb      	ldrh	r3, [r7, #20]
 81059fc:	2b00      	cmp	r3, #0
 81059fe:	d102      	bne.n	8105a06 <CheckSmSettings+0x2e6>
            /* the SM2 size is 0 and the SM2 is active */
            result = SYNCMANCHSETTINGS+1;
 8105a00:	2304      	movs	r3, #4
 8105a02:	75bb      	strb	r3, [r7, #22]
 8105a04:	e056      	b.n	8105ab4 <CheckSmSettings+0x394>
        else if (pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET] & SM_SETTING_ENABLE_VALUE)
 8105a06:	68fb      	ldr	r3, [r7, #12]
 8105a08:	88db      	ldrh	r3, [r3, #6]
 8105a0a:	f003 0301 	and.w	r3, r3, #1
 8105a0e:	2b00      	cmp	r3, #0
 8105a10:	d047      	beq.n	8105aa2 <CheckSmSettings+0x382>
        {
            /* Sync Manager Channel 2 is active, output size has to greater 0 */
            if ( SMLength == nPdOutputSize && nPdOutputSize != 0 && SMLength <= ((UINT16)MAX_PD_OUTPUT_SIZE))
 8105a12:	4b3a      	ldr	r3, [pc, #232]	@ (8105afc <CheckSmSettings+0x3dc>)
 8105a14:	881b      	ldrh	r3, [r3, #0]
 8105a16:	8aba      	ldrh	r2, [r7, #20]
 8105a18:	429a      	cmp	r2, r3
 8105a1a:	d13f      	bne.n	8105a9c <CheckSmSettings+0x37c>
 8105a1c:	4b37      	ldr	r3, [pc, #220]	@ (8105afc <CheckSmSettings+0x3dc>)
 8105a1e:	881b      	ldrh	r3, [r3, #0]
 8105a20:	2b00      	cmp	r3, #0
 8105a22:	d03b      	beq.n	8105a9c <CheckSmSettings+0x37c>
 8105a24:	8abb      	ldrh	r3, [r7, #20]
 8105a26:	2b44      	cmp	r3, #68	@ 0x44
 8105a28:	d838      	bhi.n	8105a9c <CheckSmSettings+0x37c>

            {
                /* sizes match */
                if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_WRITE_VALUE )
 8105a2a:	68fb      	ldr	r3, [r7, #12]
 8105a2c:	889b      	ldrh	r3, [r3, #4]
 8105a2e:	f003 030c 	and.w	r3, r3, #12
 8105a32:	2b04      	cmp	r3, #4
 8105a34:	d12e      	bne.n	8105a94 <CheckSmSettings+0x374>
                {
                    /* settings match */
                    if ( ( ( nAlStatus == STATE_PREOP )&&( SMAddress >= MIN_PD_WRITE_ADDRESS )&&( SMAddress <= MAX_PD_WRITE_ADDRESS ) )
 8105a36:	4b32      	ldr	r3, [pc, #200]	@ (8105b00 <CheckSmSettings+0x3e0>)
 8105a38:	781b      	ldrb	r3, [r3, #0]
 8105a3a:	2b02      	cmp	r3, #2
 8105a3c:	d107      	bne.n	8105a4e <CheckSmSettings+0x32e>
 8105a3e:	8a7b      	ldrh	r3, [r7, #18]
 8105a40:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8105a44:	d303      	bcc.n	8105a4e <CheckSmSettings+0x32e>
 8105a46:	8a7b      	ldrh	r3, [r7, #18]
 8105a48:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
 8105a4c:	d308      	bcc.n	8105a60 <CheckSmSettings+0x340>
                       ||( ( nAlStatus != STATE_PREOP )&&( SMAddress == nEscAddrOutputData ) )
 8105a4e:	4b2c      	ldr	r3, [pc, #176]	@ (8105b00 <CheckSmSettings+0x3e0>)
 8105a50:	781b      	ldrb	r3, [r3, #0]
 8105a52:	2b02      	cmp	r3, #2
 8105a54:	d01b      	beq.n	8105a8e <CheckSmSettings+0x36e>
 8105a56:	4b2b      	ldr	r3, [pc, #172]	@ (8105b04 <CheckSmSettings+0x3e4>)
 8105a58:	881b      	ldrh	r3, [r3, #0]
 8105a5a:	8a7a      	ldrh	r2, [r7, #18]
 8105a5c:	429a      	cmp	r2, r3
 8105a5e:	d116      	bne.n	8105a8e <CheckSmSettings+0x36e>
                        )
                    {
                        /* addresses match */
                        {
                            /* check, if watchdog trigger is enabled */
                            if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_WATCHDOG_VALUE)
 8105a60:	68fb      	ldr	r3, [r7, #12]
 8105a62:	889b      	ldrh	r3, [r3, #4]
 8105a64:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8105a68:	2b00      	cmp	r3, #0
 8105a6a:	d003      	beq.n	8105a74 <CheckSmSettings+0x354>
                            {
                                bWdTrigger = TRUE;
 8105a6c:	4b26      	ldr	r3, [pc, #152]	@ (8105b08 <CheckSmSettings+0x3e8>)
 8105a6e:	2201      	movs	r2, #1
 8105a70:	701a      	strb	r2, [r3, #0]
 8105a72:	e002      	b.n	8105a7a <CheckSmSettings+0x35a>
                            }
                            else
                            {
                                bWdTrigger = FALSE;
 8105a74:	4b24      	ldr	r3, [pc, #144]	@ (8105b08 <CheckSmSettings+0x3e8>)
 8105a76:	2200      	movs	r2, #0
 8105a78:	701a      	strb	r2, [r3, #0]
                            }

                            if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE )
 8105a7a:	68fb      	ldr	r3, [r7, #12]
 8105a7c:	889b      	ldrh	r3, [r3, #4]
 8105a7e:	f003 0302 	and.w	r3, r3, #2
 8105a82:	2b00      	cmp	r3, #0
 8105a84:	d009      	beq.n	8105a9a <CheckSmSettings+0x37a>
                                /* outputs are running in 1-Buffer-Mode, reset flag b3BufferMode */
                                b3BufferMode = FALSE;
 8105a86:	4b21      	ldr	r3, [pc, #132]	@ (8105b0c <CheckSmSettings+0x3ec>)
 8105a88:	2200      	movs	r2, #0
 8105a8a:	701a      	strb	r2, [r3, #0]
                            if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_MASK) == SM_SETTING_MODE_ONE_BUFFER_VALUE )
 8105a8c:	e005      	b.n	8105a9a <CheckSmSettings+0x37a>
                        }
                    }
                    else
                        /* output address is out of the allowed area or has changed in SAFEOP or OP */
                        result = SYNCMANCHADDRESS+1;
 8105a8e:	2302      	movs	r3, #2
 8105a90:	75bb      	strb	r3, [r7, #22]
                if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_WRITE_VALUE )
 8105a92:	e00f      	b.n	8105ab4 <CheckSmSettings+0x394>
                }
                else
                    /* output settings do not match */
                    result = SYNCMANCHSETTINGS+1;
 8105a94:	2304      	movs	r3, #4
 8105a96:	75bb      	strb	r3, [r7, #22]
                if ( (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_DIRECTION_MASK) == SM_SETTING_DIRECTION_WRITE_VALUE )
 8105a98:	e00c      	b.n	8105ab4 <CheckSmSettings+0x394>
 8105a9a:	e00b      	b.n	8105ab4 <CheckSmSettings+0x394>
            }
            else
                /* output sizes don't match */
                result = SYNCMANCHSIZE+1;
 8105a9c:	2303      	movs	r3, #3
 8105a9e:	75bb      	strb	r3, [r7, #22]
 8105aa0:	e008      	b.n	8105ab4 <CheckSmSettings+0x394>
        }
        else if ( SMLength != 0 || nPdOutputSize != 0 )
 8105aa2:	8abb      	ldrh	r3, [r7, #20]
 8105aa4:	2b00      	cmp	r3, #0
 8105aa6:	d103      	bne.n	8105ab0 <CheckSmSettings+0x390>
 8105aa8:	4b14      	ldr	r3, [pc, #80]	@ (8105afc <CheckSmSettings+0x3dc>)
 8105aaa:	881b      	ldrh	r3, [r3, #0]
 8105aac:	2b00      	cmp	r3, #0
 8105aae:	d001      	beq.n	8105ab4 <CheckSmSettings+0x394>
            /* output size is not zero although the SM2 channel is not enabled */
            result = SYNCMANCHSIZE+1;
 8105ab0:	2303      	movs	r3, #3
 8105ab2:	75bb      	strb	r3, [r7, #22]

        if ( result != 0 )
 8105ab4:	7dbb      	ldrb	r3, [r7, #22]
 8105ab6:	2b00      	cmp	r3, #0
 8105ab8:	d001      	beq.n	8105abe <CheckSmSettings+0x39e>
        {
            result = ALSTATUSCODE_INVALIDSMOUTCFG;
 8105aba:	231d      	movs	r3, #29
 8105abc:	75bb      	strb	r3, [r7, #22]
        }
    }


    if ( result == 0 )
 8105abe:	7dbb      	ldrb	r3, [r7, #22]
 8105ac0:	2b00      	cmp	r3, #0
 8105ac2:	d113      	bne.n	8105aec <CheckSmSettings+0x3cc>
    {
        /* the Enable-Byte of the rest of the SM channels has to be read to acknowledge the SM-Change-Interrupt */
        for (i = maxChannel; i < nMaxSyncMan; i++)
 8105ac4:	79fb      	ldrb	r3, [r7, #7]
 8105ac6:	75fb      	strb	r3, [r7, #23]
 8105ac8:	e00b      	b.n	8105ae2 <CheckSmSettings+0x3c2>
        {
/*ECATCHANGE_START(V5.11) HW1*/
            pSyncMan = GetSyncMan(i);
 8105aca:	7dfb      	ldrb	r3, [r7, #23]
 8105acc:	4618      	mov	r0, r3
 8105ace:	f7ff fdbf 	bl	8105650 <GetSyncMan>
 8105ad2:	60f8      	str	r0, [r7, #12]
/*ECATCHANGE_END(V5.11) HW1*/
            SMActivate = pSyncMan->Settings[SM_SETTING_ACTIVATE_OFFSET];
 8105ad4:	68fb      	ldr	r3, [r7, #12]
 8105ad6:	88da      	ldrh	r2, [r3, #6]
 8105ad8:	4b0d      	ldr	r3, [pc, #52]	@ (8105b10 <CheckSmSettings+0x3f0>)
 8105ada:	801a      	strh	r2, [r3, #0]
        for (i = maxChannel; i < nMaxSyncMan; i++)
 8105adc:	7dfb      	ldrb	r3, [r7, #23]
 8105ade:	3301      	adds	r3, #1
 8105ae0:	75fb      	strb	r3, [r7, #23]
 8105ae2:	4b0c      	ldr	r3, [pc, #48]	@ (8105b14 <CheckSmSettings+0x3f4>)
 8105ae4:	781b      	ldrb	r3, [r3, #0]
 8105ae6:	7dfa      	ldrb	r2, [r7, #23]
 8105ae8:	429a      	cmp	r2, r3
 8105aea:	d3ee      	bcc.n	8105aca <CheckSmSettings+0x3aa>
        }
    }
    return result;
 8105aec:	7dbb      	ldrb	r3, [r7, #22]
}
 8105aee:	4618      	mov	r0, r3
 8105af0:	3718      	adds	r7, #24
 8105af2:	46bd      	mov	sp, r7
 8105af4:	bd80      	pop	{r7, pc}
 8105af6:	bf00      	nop
 8105af8:	10000854 	.word	0x10000854
 8105afc:	10000856 	.word	0x10000856
 8105b00:	1000085c 	.word	0x1000085c
 8105b04:	10000860 	.word	0x10000860
 8105b08:	1000082b 	.word	0x1000082b
 8105b0c:	10000849 	.word	0x10000849
 8105b10:	10000868 	.word	0x10000868
 8105b14:	10000858 	.word	0x10000858

08105b18 <StartInputHandler>:
 \brief  and the AL Event Mask register will be set

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 StartInputHandler(void)
{
 8105b18:	b580      	push	{r7, lr}
 8105b1a:	b08c      	sub	sp, #48	@ 0x30
 8105b1c:	af00      	add	r7, sp, #0
    TSYNCMAN ESCMEM * pSyncMan;
    UINT16        dcControl;
    UINT16     wdiv = 0;
 8105b1e:	2300      	movs	r3, #0
 8105b20:	823b      	strh	r3, [r7, #16]
/*ECATCHANGE_START(V5.11) ECAT4*/
    UINT16     wd = 0;
 8105b22:	2300      	movs	r3, #0
 8105b24:	81fb      	strh	r3, [r7, #14]
/*ECATCHANGE_END(V5.11) ECAT4*/
    UINT32     cycleTimeSync0 = 0; /* Sync0 cycle time */
 8105b26:	2300      	movs	r3, #0
 8105b28:	60bb      	str	r3, [r7, #8]
    UINT32     cycleTimeSync1 = 0; /* Delay between the Sync0 and Sycn1 signal. A new Sync1 cycle starts on the next Sync0 signal after Sync1 signal.*/
 8105b2a:	2300      	movs	r3, #0
 8105b2c:	607b      	str	r3, [r7, #4]
    BOOL bSubordinatedCycles = FALSE;
 8105b2e:	2300      	movs	r3, #0
 8105b30:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

    UINT16    nPdInputBuffer = 3;
 8105b34:	2303      	movs	r3, #3
 8105b36:	85bb      	strh	r3, [r7, #44]	@ 0x2c
    UINT16    nPdOutputBuffer = 3;
 8105b38:	2303      	movs	r3, #3
 8105b3a:	857b      	strh	r3, [r7, #42]	@ 0x2a

    UINT16 SyncType0x1C32 = 0; /* Helper variable for sync type for SM2 (required if no CoE is supported or no output process data available)*/
 8105b3c:	2300      	movs	r3, #0
 8105b3e:	853b      	strh	r3, [r7, #40]	@ 0x28
    UINT16 SyncType0x1C33 = 0; /* Helper variable for sync type for SM3 (required if no CoE is supported or no input process data available)*/
 8105b40:	2300      	movs	r3, #0
 8105b42:	84fb      	strh	r3, [r7, #38]	@ 0x26

    UINT16 u16MinSuppSyncType = 0xFFFF;  /* Minimum supported Sync Types */
 8105b44:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8105b48:	84bb      	strh	r3, [r7, #36]	@ 0x24

    u16MinSuppSyncType &= sSyncManOutPar.u16SyncTypesSupported;
 8105b4a:	4b98      	ldr	r3, [pc, #608]	@ (8105dac <StartInputHandler+0x294>)
 8105b4c:	899a      	ldrh	r2, [r3, #12]
 8105b4e:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8105b50:	4013      	ands	r3, r2
 8105b52:	84bb      	strh	r3, [r7, #36]	@ 0x24
    u16MinSuppSyncType &= sSyncManInPar.u16SyncTypesSupported;
 8105b54:	4b96      	ldr	r3, [pc, #600]	@ (8105db0 <StartInputHandler+0x298>)
 8105b56:	899a      	ldrh	r2, [r3, #12]
 8105b58:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8105b5a:	4013      	ands	r3, r2
 8105b5c:	84bb      	strh	r3, [r7, #36]	@ 0x24

    u16ALEventMask = 0;
 8105b5e:	4b95      	ldr	r3, [pc, #596]	@ (8105db4 <StartInputHandler+0x29c>)
 8105b60:	2200      	movs	r2, #0
 8105b62:	801a      	strh	r2, [r3, #0]

    /* 
        --- Check if SyncManager areas overlapping --- 
    */
    bEcatFirstOutputsReceived = FALSE;
 8105b64:	4b94      	ldr	r3, [pc, #592]	@ (8105db8 <StartInputHandler+0x2a0>)
 8105b66:	2200      	movs	r2, #0
 8105b68:	701a      	strb	r2, [r3, #0]

    /* get a pointer to the Sync Manager Channel 2 (Outputs) */
/*ECATCHANGE_START(V5.11) HW1*/
    pSyncMan = GetSyncMan(PROCESS_DATA_OUT);
 8105b6a:	2002      	movs	r0, #2
 8105b6c:	f7ff fd70 	bl	8105650 <GetSyncMan>
 8105b70:	6238      	str	r0, [r7, #32]
/*ECATCHANGE_END(V5.11) HW1*/
    /* store the address of the Sync Manager Channel 2 (Outputs) */
    nEscAddrOutputData = pSyncMan->PhysicalStartAddress;
 8105b72:	6a3b      	ldr	r3, [r7, #32]
 8105b74:	881a      	ldrh	r2, [r3, #0]
 8105b76:	4b91      	ldr	r3, [pc, #580]	@ (8105dbc <StartInputHandler+0x2a4>)
 8105b78:	801a      	strh	r2, [r3, #0]
    /* get the number of output buffer used for calculating the address areas */
    if (pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE)
 8105b7a:	6a3b      	ldr	r3, [r7, #32]
 8105b7c:	889b      	ldrh	r3, [r3, #4]
 8105b7e:	f003 0302 	and.w	r3, r3, #2
 8105b82:	2b00      	cmp	r3, #0
 8105b84:	d001      	beq.n	8105b8a <StartInputHandler+0x72>
    {
       nPdOutputBuffer = 1;
 8105b86:	2301      	movs	r3, #1
 8105b88:	857b      	strh	r3, [r7, #42]	@ 0x2a
    }


    /* get a pointer to the Sync Manager Channel 3 (Inputs) */
/*ECATCHANGE_START(V5.11) HW1*/
    pSyncMan = GetSyncMan(PROCESS_DATA_IN);
 8105b8a:	2003      	movs	r0, #3
 8105b8c:	f7ff fd60 	bl	8105650 <GetSyncMan>
 8105b90:	6238      	str	r0, [r7, #32]
/*ECATCHANGE_END(V5.11) HW1*/
    /* store the address of the Sync Manager Channel 3 (Inputs)*/
    nEscAddrInputData = pSyncMan->PhysicalStartAddress;
 8105b92:	6a3b      	ldr	r3, [r7, #32]
 8105b94:	881a      	ldrh	r2, [r3, #0]
 8105b96:	4b8a      	ldr	r3, [pc, #552]	@ (8105dc0 <StartInputHandler+0x2a8>)
 8105b98:	801a      	strh	r2, [r3, #0]
    
    /* get the number of input buffer used for calculating the address areas */
    if ( pSyncMan->Settings[SM_SETTING_CONTROL_OFFSET] & SM_SETTING_MODE_ONE_BUFFER_VALUE )
 8105b9a:	6a3b      	ldr	r3, [r7, #32]
 8105b9c:	889b      	ldrh	r3, [r3, #4]
 8105b9e:	f003 0302 	and.w	r3, r3, #2
 8105ba2:	2b00      	cmp	r3, #0
 8105ba4:	d001      	beq.n	8105baa <StartInputHandler+0x92>
        nPdInputBuffer = 1;
 8105ba6:	2301      	movs	r3, #1
 8105ba8:	85bb      	strh	r3, [r7, #44]	@ 0x2c

    /* it has be checked if the Sync Manager memory areas for Inputs and Outputs will not overlap
       the Sync Manager memory areas for the Mailbox */

    if (((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrSendMbx && (nEscAddrInputData < (u16EscAddrSendMbx + u16SendMbxSize)))
 8105baa:	4b85      	ldr	r3, [pc, #532]	@ (8105dc0 <StartInputHandler+0x2a8>)
 8105bac:	881b      	ldrh	r3, [r3, #0]
 8105bae:	461a      	mov	r2, r3
 8105bb0:	4b84      	ldr	r3, [pc, #528]	@ (8105dc4 <StartInputHandler+0x2ac>)
 8105bb2:	881b      	ldrh	r3, [r3, #0]
 8105bb4:	4619      	mov	r1, r3
 8105bb6:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 8105bb8:	fb01 f303 	mul.w	r3, r1, r3
 8105bbc:	4413      	add	r3, r2
 8105bbe:	4a82      	ldr	r2, [pc, #520]	@ (8105dc8 <StartInputHandler+0x2b0>)
 8105bc0:	8812      	ldrh	r2, [r2, #0]
 8105bc2:	4293      	cmp	r3, r2
 8105bc4:	dd0a      	ble.n	8105bdc <StartInputHandler+0xc4>
 8105bc6:	4b7e      	ldr	r3, [pc, #504]	@ (8105dc0 <StartInputHandler+0x2a8>)
 8105bc8:	881b      	ldrh	r3, [r3, #0]
 8105bca:	461a      	mov	r2, r3
 8105bcc:	4b7e      	ldr	r3, [pc, #504]	@ (8105dc8 <StartInputHandler+0x2b0>)
 8105bce:	881b      	ldrh	r3, [r3, #0]
 8105bd0:	4619      	mov	r1, r3
 8105bd2:	4b7e      	ldr	r3, [pc, #504]	@ (8105dcc <StartInputHandler+0x2b4>)
 8105bd4:	881b      	ldrh	r3, [r3, #0]
 8105bd6:	440b      	add	r3, r1
 8105bd8:	429a      	cmp	r2, r3
 8105bda:	db18      	blt.n	8105c0e <StartInputHandler+0xf6>
       || ((nEscAddrInputData + nPdInputSize * nPdInputBuffer) > u16EscAddrReceiveMbx && (nEscAddrInputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
 8105bdc:	4b78      	ldr	r3, [pc, #480]	@ (8105dc0 <StartInputHandler+0x2a8>)
 8105bde:	881b      	ldrh	r3, [r3, #0]
 8105be0:	461a      	mov	r2, r3
 8105be2:	4b78      	ldr	r3, [pc, #480]	@ (8105dc4 <StartInputHandler+0x2ac>)
 8105be4:	881b      	ldrh	r3, [r3, #0]
 8105be6:	4619      	mov	r1, r3
 8105be8:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 8105bea:	fb01 f303 	mul.w	r3, r1, r3
 8105bee:	4413      	add	r3, r2
 8105bf0:	4a77      	ldr	r2, [pc, #476]	@ (8105dd0 <StartInputHandler+0x2b8>)
 8105bf2:	8812      	ldrh	r2, [r2, #0]
 8105bf4:	4293      	cmp	r3, r2
 8105bf6:	dd0c      	ble.n	8105c12 <StartInputHandler+0xfa>
 8105bf8:	4b71      	ldr	r3, [pc, #452]	@ (8105dc0 <StartInputHandler+0x2a8>)
 8105bfa:	881b      	ldrh	r3, [r3, #0]
 8105bfc:	461a      	mov	r2, r3
 8105bfe:	4b74      	ldr	r3, [pc, #464]	@ (8105dd0 <StartInputHandler+0x2b8>)
 8105c00:	881b      	ldrh	r3, [r3, #0]
 8105c02:	4619      	mov	r1, r3
 8105c04:	4b73      	ldr	r3, [pc, #460]	@ (8105dd4 <StartInputHandler+0x2bc>)
 8105c06:	881b      	ldrh	r3, [r3, #0]
 8105c08:	440b      	add	r3, r1
 8105c0a:	429a      	cmp	r2, r3
 8105c0c:	da01      	bge.n	8105c12 <StartInputHandler+0xfa>
        )
    {
        return ALSTATUSCODE_INVALIDSMINCFG;
 8105c0e:	231e      	movs	r3, #30
 8105c10:	e314      	b.n	810623c <StartInputHandler+0x724>
    }

    if (
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
 8105c12:	4b6a      	ldr	r3, [pc, #424]	@ (8105dbc <StartInputHandler+0x2a4>)
 8105c14:	881b      	ldrh	r3, [r3, #0]
 8105c16:	461a      	mov	r2, r3
 8105c18:	4b6f      	ldr	r3, [pc, #444]	@ (8105dd8 <StartInputHandler+0x2c0>)
 8105c1a:	881b      	ldrh	r3, [r3, #0]
 8105c1c:	4619      	mov	r1, r3
 8105c1e:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8105c20:	fb01 f303 	mul.w	r3, r1, r3
 8105c24:	4413      	add	r3, r2
 8105c26:	4a68      	ldr	r2, [pc, #416]	@ (8105dc8 <StartInputHandler+0x2b0>)
 8105c28:	8812      	ldrh	r2, [r2, #0]
    if (
 8105c2a:	4293      	cmp	r3, r2
 8105c2c:	dd0a      	ble.n	8105c44 <StartInputHandler+0x12c>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrSendMbx && (nEscAddrOutputData < (u16EscAddrSendMbx + u16SendMbxSize)))
 8105c2e:	4b63      	ldr	r3, [pc, #396]	@ (8105dbc <StartInputHandler+0x2a4>)
 8105c30:	881b      	ldrh	r3, [r3, #0]
 8105c32:	461a      	mov	r2, r3
 8105c34:	4b64      	ldr	r3, [pc, #400]	@ (8105dc8 <StartInputHandler+0x2b0>)
 8105c36:	881b      	ldrh	r3, [r3, #0]
 8105c38:	4619      	mov	r1, r3
 8105c3a:	4b64      	ldr	r3, [pc, #400]	@ (8105dcc <StartInputHandler+0x2b4>)
 8105c3c:	881b      	ldrh	r3, [r3, #0]
 8105c3e:	440b      	add	r3, r1
 8105c40:	429a      	cmp	r2, r3
 8105c42:	db31      	blt.n	8105ca8 <StartInputHandler+0x190>
        ||((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > u16EscAddrReceiveMbx && (nEscAddrOutputData < (u16EscAddrReceiveMbx + u16ReceiveMbxSize)))
 8105c44:	4b5d      	ldr	r3, [pc, #372]	@ (8105dbc <StartInputHandler+0x2a4>)
 8105c46:	881b      	ldrh	r3, [r3, #0]
 8105c48:	461a      	mov	r2, r3
 8105c4a:	4b63      	ldr	r3, [pc, #396]	@ (8105dd8 <StartInputHandler+0x2c0>)
 8105c4c:	881b      	ldrh	r3, [r3, #0]
 8105c4e:	4619      	mov	r1, r3
 8105c50:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8105c52:	fb01 f303 	mul.w	r3, r1, r3
 8105c56:	4413      	add	r3, r2
 8105c58:	4a5d      	ldr	r2, [pc, #372]	@ (8105dd0 <StartInputHandler+0x2b8>)
 8105c5a:	8812      	ldrh	r2, [r2, #0]
 8105c5c:	4293      	cmp	r3, r2
 8105c5e:	dd0a      	ble.n	8105c76 <StartInputHandler+0x15e>
 8105c60:	4b56      	ldr	r3, [pc, #344]	@ (8105dbc <StartInputHandler+0x2a4>)
 8105c62:	881b      	ldrh	r3, [r3, #0]
 8105c64:	461a      	mov	r2, r3
 8105c66:	4b5a      	ldr	r3, [pc, #360]	@ (8105dd0 <StartInputHandler+0x2b8>)
 8105c68:	881b      	ldrh	r3, [r3, #0]
 8105c6a:	4619      	mov	r1, r3
 8105c6c:	4b59      	ldr	r3, [pc, #356]	@ (8105dd4 <StartInputHandler+0x2bc>)
 8105c6e:	881b      	ldrh	r3, [r3, #0]
 8105c70:	440b      	add	r3, r1
 8105c72:	429a      	cmp	r2, r3
 8105c74:	db18      	blt.n	8105ca8 <StartInputHandler+0x190>
        ||
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOutputData < (nEscAddrInputData + nPdInputSize)))
 8105c76:	4b51      	ldr	r3, [pc, #324]	@ (8105dbc <StartInputHandler+0x2a4>)
 8105c78:	881b      	ldrh	r3, [r3, #0]
 8105c7a:	461a      	mov	r2, r3
 8105c7c:	4b56      	ldr	r3, [pc, #344]	@ (8105dd8 <StartInputHandler+0x2c0>)
 8105c7e:	881b      	ldrh	r3, [r3, #0]
 8105c80:	4619      	mov	r1, r3
 8105c82:	8d7b      	ldrh	r3, [r7, #42]	@ 0x2a
 8105c84:	fb01 f303 	mul.w	r3, r1, r3
 8105c88:	4413      	add	r3, r2
 8105c8a:	4a4d      	ldr	r2, [pc, #308]	@ (8105dc0 <StartInputHandler+0x2a8>)
 8105c8c:	8812      	ldrh	r2, [r2, #0]
        ||
 8105c8e:	4293      	cmp	r3, r2
 8105c90:	dd0c      	ble.n	8105cac <StartInputHandler+0x194>
        ((nEscAddrOutputData + nPdOutputSize * nPdOutputBuffer) > nEscAddrInputData && (nEscAddrOutputData < (nEscAddrInputData + nPdInputSize)))
 8105c92:	4b4a      	ldr	r3, [pc, #296]	@ (8105dbc <StartInputHandler+0x2a4>)
 8105c94:	881b      	ldrh	r3, [r3, #0]
 8105c96:	461a      	mov	r2, r3
 8105c98:	4b49      	ldr	r3, [pc, #292]	@ (8105dc0 <StartInputHandler+0x2a8>)
 8105c9a:	881b      	ldrh	r3, [r3, #0]
 8105c9c:	4619      	mov	r1, r3
 8105c9e:	4b49      	ldr	r3, [pc, #292]	@ (8105dc4 <StartInputHandler+0x2ac>)
 8105ca0:	881b      	ldrh	r3, [r3, #0]
 8105ca2:	440b      	add	r3, r1
 8105ca4:	429a      	cmp	r2, r3
 8105ca6:	da01      	bge.n	8105cac <StartInputHandler+0x194>
        )
    {
        /* Sync Manager Channel 2 memory area (Outputs) overlaps the Sync Manager memory areas for the Mailbox
           or the Sync Manager Channel 3 memory area (Inputs) */
        return ALSTATUSCODE_INVALIDSMOUTCFG;
 8105ca8:	231d      	movs	r3, #29
 8105caa:	e2c7      	b.n	810623c <StartInputHandler+0x724>
        --- Check configured synchronisation ---
    */

    /* Get the DC Control/Activation register value*/
    /*Read registers 0x980:0x981 (corresponding masks are adapted)*/
    HW_EscReadWord(dcControl, ESC_DC_UNIT_CONTROL_OFFSET);
 8105cac:	f107 0312 	add.w	r3, r7, #18
 8105cb0:	2202      	movs	r2, #2
 8105cb2:	f44f 6118 	mov.w	r1, #2432	@ 0x980
 8105cb6:	4618      	mov	r0, r3
 8105cb8:	f7fb f9f6 	bl	81010a8 <HW_EscRead>
    dcControl = SWAPWORD(dcControl);
 8105cbc:	8a7b      	ldrh	r3, [r7, #18]
 8105cbe:	827b      	strh	r3, [r7, #18]

    // Cycle time for Sync0
        HW_EscReadDWord(cycleTimeSync0, ESC_DC_SYNC0_CYCLETIME_OFFSET);
 8105cc0:	f107 0308 	add.w	r3, r7, #8
 8105cc4:	2204      	movs	r2, #4
 8105cc6:	f44f 611a 	mov.w	r1, #2464	@ 0x9a0
 8105cca:	4618      	mov	r0, r3
 8105ccc:	f7fb f9ec 	bl	81010a8 <HW_EscRead>
        cycleTimeSync0 = SWAPDWORD(cycleTimeSync0);
 8105cd0:	68bb      	ldr	r3, [r7, #8]
 8105cd2:	60bb      	str	r3, [r7, #8]

    // Cycle time for Sync1
        HW_EscReadDWord(cycleTimeSync1, ESC_DC_SYNC1_CYCLETIME_OFFSET);
 8105cd4:	1d3b      	adds	r3, r7, #4
 8105cd6:	2204      	movs	r2, #4
 8105cd8:	f640 11a4 	movw	r1, #2468	@ 0x9a4
 8105cdc:	4618      	mov	r0, r3
 8105cde:	f7fb f9e3 	bl	81010a8 <HW_EscRead>
        cycleTimeSync1 = SWAPDWORD(cycleTimeSync1);
 8105ce2:	687b      	ldr	r3, [r7, #4]
 8105ce4:	607b      	str	r3, [r7, #4]


    SyncType0x1C32 = sSyncManOutPar.u16SyncType;
 8105ce6:	4b31      	ldr	r3, [pc, #196]	@ (8105dac <StartInputHandler+0x294>)
 8105ce8:	885b      	ldrh	r3, [r3, #2]
 8105cea:	853b      	strh	r3, [r7, #40]	@ 0x28
    SyncType0x1C33 = sSyncManInPar.u16SyncType;
 8105cec:	4b30      	ldr	r3, [pc, #192]	@ (8105db0 <StartInputHandler+0x298>)
 8105cee:	885b      	ldrh	r3, [r3, #2]
 8105cf0:	84fb      	strh	r3, [r7, #38]	@ 0x26
    /* check general DC register plausibility and if configuration is supported
       - 0x981 DC Active
       - 0x9A0:0x9A3 Sync0 Cycle
       - 0x9A4:0x9A7 Sync1 Cycle
    */
    if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) != 0)
 8105cf2:	8a7b      	ldrh	r3, [r7, #18]
 8105cf4:	f403 6310 	and.w	r3, r3, #2304	@ 0x900
 8105cf8:	2b00      	cmp	r3, #0
 8105cfa:	d073      	beq.n	8105de4 <StartInputHandler+0x2cc>
    {
        /* DC unit is active at least one Sync signal shall be generated */
        if((dcControl & (ESC_DC_SYNC0_ACTIVE_MASK | ESC_DC_SYNC1_ACTIVE_MASK)) == 0)
 8105cfc:	8a7b      	ldrh	r3, [r7, #18]
 8105cfe:	f403 63c0 	and.w	r3, r3, #1536	@ 0x600
 8105d02:	2b00      	cmp	r3, #0
 8105d04:	d101      	bne.n	8105d0a <StartInputHandler+0x1f2>
        {
            return ALSTATUSCODE_DCINVALIDSYNCCFG;
 8105d06:	2330      	movs	r3, #48	@ 0x30
 8105d08:	e298      	b.n	810623c <StartInputHandler+0x724>
        }

        /* If Sync1 shall only be active if also Sync0 will be generated*/
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
 8105d0a:	8a7b      	ldrh	r3, [r7, #18]
 8105d0c:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8105d10:	2b00      	cmp	r3, #0
 8105d12:	d106      	bne.n	8105d22 <StartInputHandler+0x20a>
            && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
 8105d14:	8a7b      	ldrh	r3, [r7, #18]
 8105d16:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8105d1a:	2b00      	cmp	r3, #0
 8105d1c:	d001      	beq.n	8105d22 <StartInputHandler+0x20a>
        {
            return ALSTATUSCODE_DCINVALIDSYNCCFG;
 8105d1e:	2330      	movs	r3, #48	@ 0x30
 8105d20:	e28c      	b.n	810623c <StartInputHandler+0x724>
        }

        if(u16MinSuppSyncType != 0)
 8105d22:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8105d24:	2b00      	cmp	r3, #0
 8105d26:	d015      	beq.n	8105d54 <StartInputHandler+0x23c>
        {
/*ECATCHANGE_START(V5.11) ESM2*/
            if((((u16MinSuppSyncType & SYNCTYPE_DCSYNC0SUPP) == 0) && ((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0))
 8105d28:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8105d2a:	f003 0304 	and.w	r3, r3, #4
 8105d2e:	2b00      	cmp	r3, #0
 8105d30:	d104      	bne.n	8105d3c <StartInputHandler+0x224>
 8105d32:	8a7b      	ldrh	r3, [r7, #18]
 8105d34:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8105d38:	2b00      	cmp	r3, #0
 8105d3a:	d109      	bne.n	8105d50 <StartInputHandler+0x238>
                ||(((u16MinSuppSyncType & SYNCTYPE_DCSYNC1SUPP) == 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)))
 8105d3c:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8105d3e:	f003 0308 	and.w	r3, r3, #8
 8105d42:	2b00      	cmp	r3, #0
 8105d44:	d106      	bne.n	8105d54 <StartInputHandler+0x23c>
 8105d46:	8a7b      	ldrh	r3, [r7, #18]
 8105d48:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8105d4c:	2b00      	cmp	r3, #0
 8105d4e:	d001      	beq.n	8105d54 <StartInputHandler+0x23c>
/*ECATCHANGE_END(V5.11) ESM2*/
            {
                /* Sync0 is not supported but will be generated*/
                return ALSTATUSCODE_DCINVALIDSYNCCFG;                   
 8105d50:	2330      	movs	r3, #48	@ 0x30
 8105d52:	e273      	b.n	810623c <StartInputHandler+0x724>
    }
        }

        /*Check if Sync0 cycle time is supported*/
        if ( cycleTimeSync0 != 0 && (cycleTimeSync0 < MIN_PD_CYCLE_TIME || cycleTimeSync0 > MAX_PD_CYCLE_TIME) )
 8105d54:	68bb      	ldr	r3, [r7, #8]
 8105d56:	2b00      	cmp	r3, #0
 8105d58:	d009      	beq.n	8105d6e <StartInputHandler+0x256>
 8105d5a:	68bb      	ldr	r3, [r7, #8]
 8105d5c:	4a1f      	ldr	r2, [pc, #124]	@ (8105ddc <StartInputHandler+0x2c4>)
 8105d5e:	4293      	cmp	r3, r2
 8105d60:	d903      	bls.n	8105d6a <StartInputHandler+0x252>
 8105d62:	68bb      	ldr	r3, [r7, #8]
 8105d64:	4a1e      	ldr	r2, [pc, #120]	@ (8105de0 <StartInputHandler+0x2c8>)
 8105d66:	4293      	cmp	r3, r2
 8105d68:	d901      	bls.n	8105d6e <StartInputHandler+0x256>
            return ALSTATUSCODE_DCSYNC0CYCLETIME;
 8105d6a:	2336      	movs	r3, #54	@ 0x36
 8105d6c:	e266      	b.n	810623c <StartInputHandler+0x724>


        /* Check if Subordinated cycles are configured */
        if(((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0) && ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0))
 8105d6e:	8a7b      	ldrh	r3, [r7, #18]
 8105d70:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8105d74:	2b00      	cmp	r3, #0
 8105d76:	d00e      	beq.n	8105d96 <StartInputHandler+0x27e>
 8105d78:	8a7b      	ldrh	r3, [r7, #18]
 8105d7a:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8105d7e:	2b00      	cmp	r3, #0
 8105d80:	d009      	beq.n	8105d96 <StartInputHandler+0x27e>
        {
            /* For Subordinated cycles both Sync signals shall be active and Sync0 is not configured in single shot (cycle time == 0)*/
/*ECATCHANGE_START(V5.11) ESM1*/
            if((cycleTimeSync1 > 0) && (cycleTimeSync1 >= cycleTimeSync0))
 8105d82:	687b      	ldr	r3, [r7, #4]
 8105d84:	2b00      	cmp	r3, #0
 8105d86:	d006      	beq.n	8105d96 <StartInputHandler+0x27e>
 8105d88:	687a      	ldr	r2, [r7, #4]
 8105d8a:	68bb      	ldr	r3, [r7, #8]
 8105d8c:	429a      	cmp	r2, r3
 8105d8e:	d302      	bcc.n	8105d96 <StartInputHandler+0x27e>
/*ECATCHANGE_END(V5.11) ESM1*/
            {
                bSubordinatedCycles = TRUE;
 8105d90:	2301      	movs	r3, #1
 8105d92:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
            }
        }

        /* Dump an error if subordinated cycles are configured but not supported */
        if(bSubordinatedCycles && ((u16MinSuppSyncType & SYNCTYPE_SUBCYCLESUPP) == 0))
 8105d96:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8105d9a:	2b00      	cmp	r3, #0
 8105d9c:	d022      	beq.n	8105de4 <StartInputHandler+0x2cc>
 8105d9e:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8105da0:	f003 0310 	and.w	r3, r3, #16
 8105da4:	2b00      	cmp	r3, #0
 8105da6:	d11d      	bne.n	8105de4 <StartInputHandler+0x2cc>
        {
             return ALSTATUSCODE_DCINVALIDSYNCCFG;
 8105da8:	2330      	movs	r3, #48	@ 0x30
 8105daa:	e247      	b.n	810623c <StartInputHandler+0x724>
 8105dac:	10000b08 	.word	0x10000b08
 8105db0:	10000b4c 	.word	0x10000b4c
 8105db4:	10000864 	.word	0x10000864
 8105db8:	1000082a 	.word	0x1000082a
 8105dbc:	10000860 	.word	0x10000860
 8105dc0:	10000862 	.word	0x10000862
 8105dc4:	10000854 	.word	0x10000854
 8105dc8:	10000880 	.word	0x10000880
 8105dcc:	1000087a 	.word	0x1000087a
 8105dd0:	1000087e 	.word	0x1000087e
 8105dd4:	1000087c 	.word	0x1000087c
 8105dd8:	10000856 	.word	0x10000856
 8105ddc:	0007a11f 	.word	0x0007a11f
 8105de0:	c3500000 	.word	0xc3500000


    /*
        Check if the user configured Sync Type matches the DC register values (if the Sync Type is supported was already checked in the object write function)
    */
    if(bSyncSetByUser)
 8105de4:	4b8b      	ldr	r3, [pc, #556]	@ (8106014 <StartInputHandler+0x4fc>)
 8105de6:	781b      	ldrb	r3, [r3, #0]
 8105de8:	2b00      	cmp	r3, #0
 8105dea:	d02c      	beq.n	8105e46 <StartInputHandler+0x32e>
    {
        if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
 8105dec:	8a7b      	ldrh	r3, [r7, #18]
 8105dee:	f403 6310 	and.w	r3, r3, #2304	@ 0x900
 8105df2:	2b00      	cmp	r3, #0
 8105df4:	d10d      	bne.n	8105e12 <StartInputHandler+0x2fa>
        {
            /* DC out unit not enabled => no DC mode shall be set */
            if((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
 8105df6:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8105df8:	2b02      	cmp	r3, #2
 8105dfa:	d008      	beq.n	8105e0e <StartInputHandler+0x2f6>
 8105dfc:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8105dfe:	2b03      	cmp	r3, #3
 8105e00:	d005      	beq.n	8105e0e <StartInputHandler+0x2f6>
                ||(SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))
 8105e02:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8105e04:	2b02      	cmp	r3, #2
 8105e06:	d002      	beq.n	8105e0e <StartInputHandler+0x2f6>
 8105e08:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8105e0a:	2b03      	cmp	r3, #3
 8105e0c:	d162      	bne.n	8105ed4 <StartInputHandler+0x3bc>
            {
                return ALSTATUSCODE_DCINVALIDSYNCCFG;
 8105e0e:	2330      	movs	r3, #48	@ 0x30
 8105e10:	e214      	b.n	810623c <StartInputHandler+0x724>
            }
        } //if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
    else
    {
            if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)
 8105e12:	8a7b      	ldrh	r3, [r7, #18]
 8105e14:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8105e18:	2b00      	cmp	r3, #0
 8105e1a:	d107      	bne.n	8105e2c <StartInputHandler+0x314>
            {
                /* No Sync 1 is generated => No Sync1 Sync Type shall configured*/
/*ECATCHANGE_START(V5.11) ESM3*/
                if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC1)
 8105e1c:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8105e1e:	2b03      	cmp	r3, #3
 8105e20:	d002      	beq.n	8105e28 <StartInputHandler+0x310>
                    ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC1))
 8105e22:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8105e24:	2b03      	cmp	r3, #3
 8105e26:	d101      	bne.n	8105e2c <StartInputHandler+0x314>
/*ECATCHANGE_END(V5.11) ESM3*/
                {
                    return ALSTATUSCODE_DCINVALIDSYNCCFG;
 8105e28:	2330      	movs	r3, #48	@ 0x30
 8105e2a:	e207      	b.n	810623c <StartInputHandler+0x724>
                }
            } //if((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) == 0)

            if((dcControl & ESC_DC_SYNC0_ACTIVE_MASK) == 0)
 8105e2c:	8a7b      	ldrh	r3, [r7, #18]
 8105e2e:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8105e32:	2b00      	cmp	r3, #0
 8105e34:	d14e      	bne.n	8105ed4 <StartInputHandler+0x3bc>
            {
                /* No Sync 0 is generated => No Sync0 Sync Type shall configured*/
/*ECATCHANGE_START(V5.11) ESM3*/
                if((SyncType0x1C32 == (UINT16)SYNCTYPE_DCSYNC0)
 8105e36:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8105e38:	2b02      	cmp	r3, #2
 8105e3a:	d002      	beq.n	8105e42 <StartInputHandler+0x32a>
                    ||(SyncType0x1C33 == (UINT16)SYNCTYPE_DCSYNC0))
 8105e3c:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8105e3e:	2b02      	cmp	r3, #2
 8105e40:	d148      	bne.n	8105ed4 <StartInputHandler+0x3bc>
/*ECATCHANGE_END(V5.11) ESM3*/
                {
                    return ALSTATUSCODE_DCINVALIDSYNCCFG;
 8105e42:	2330      	movs	r3, #48	@ 0x30
 8105e44:	e1fa      	b.n	810623c <StartInputHandler+0x724>
        }
    } //if(bSyncSetByUser)
    else
    {
        /* No Sync Type selected by user => Configure Sync Type based on DC register values*/
        if((dcControl & (ESC_DC_SYNC_UNIT_ACTIVE_MASK | ESC_DC_SYNC_UNIT_AUTO_ACTIVE_MASK)) == 0)
 8105e46:	8a7b      	ldrh	r3, [r7, #18]
 8105e48:	f403 6310 	and.w	r3, r3, #2304	@ 0x900
 8105e4c:	2b00      	cmp	r3, #0
 8105e4e:	d120      	bne.n	8105e92 <StartInputHandler+0x37a>
        {
            /* Activation or auto activation of the Sync Out Unit is disabled => Free Run or SM Sync is configured*/

            /* AL Event enabled => Configure SM Sync*/
            if (nPdOutputSize > 0)
 8105e50:	4b71      	ldr	r3, [pc, #452]	@ (8106018 <StartInputHandler+0x500>)
 8105e52:	881b      	ldrh	r3, [r3, #0]
 8105e54:	2b00      	cmp	r3, #0
 8105e56:	d00b      	beq.n	8105e70 <StartInputHandler+0x358>
            {
                SyncType0x1C32 = SYNCTYPE_SM_SYNCHRON;
 8105e58:	2301      	movs	r3, #1
 8105e5a:	853b      	strh	r3, [r7, #40]	@ 0x28
                
                if (nPdInputSize > 0)
 8105e5c:	4b6f      	ldr	r3, [pc, #444]	@ (810601c <StartInputHandler+0x504>)
 8105e5e:	881b      	ldrh	r3, [r3, #0]
 8105e60:	2b00      	cmp	r3, #0
 8105e62:	d002      	beq.n	8105e6a <StartInputHandler+0x352>
                    SyncType0x1C33 = SYNCTYPE_SM2_SYNCHRON;
 8105e64:	2322      	movs	r3, #34	@ 0x22
 8105e66:	84fb      	strh	r3, [r7, #38]	@ 0x26
 8105e68:	e00f      	b.n	8105e8a <StartInputHandler+0x372>
                else
                    SyncType0x1C33 = SYNCTYPE_FREERUN;
 8105e6a:	2300      	movs	r3, #0
 8105e6c:	84fb      	strh	r3, [r7, #38]	@ 0x26
 8105e6e:	e00c      	b.n	8105e8a <StartInputHandler+0x372>
            }
            else if (nPdInputSize > 0)
 8105e70:	4b6a      	ldr	r3, [pc, #424]	@ (810601c <StartInputHandler+0x504>)
 8105e72:	881b      	ldrh	r3, [r3, #0]
 8105e74:	2b00      	cmp	r3, #0
 8105e76:	d004      	beq.n	8105e82 <StartInputHandler+0x36a>
            {
                SyncType0x1C32 = SYNCTYPE_FREERUN;
 8105e78:	2300      	movs	r3, #0
 8105e7a:	853b      	strh	r3, [r7, #40]	@ 0x28
                SyncType0x1C33 = SYNCTYPE_SM_SYNCHRON;
 8105e7c:	2301      	movs	r3, #1
 8105e7e:	84fb      	strh	r3, [r7, #38]	@ 0x26
 8105e80:	e003      	b.n	8105e8a <StartInputHandler+0x372>
            }
            else
            {
                SyncType0x1C32 = SYNCTYPE_FREERUN;
 8105e82:	2300      	movs	r3, #0
 8105e84:	853b      	strh	r3, [r7, #40]	@ 0x28
                SyncType0x1C33 = SYNCTYPE_FREERUN;
 8105e86:	2300      	movs	r3, #0
 8105e88:	84fb      	strh	r3, [r7, #38]	@ 0x26
            }
            sSyncManOutPar.u16GetCycleTime = 1;
 8105e8a:	4b65      	ldr	r3, [pc, #404]	@ (8106020 <StartInputHandler+0x508>)
 8105e8c:	2201      	movs	r2, #1
 8105e8e:	839a      	strh	r2, [r3, #28]
 8105e90:	e020      	b.n	8105ed4 <StartInputHandler+0x3bc>

        }
        else
        {
            if (nPdOutputSize > 0)
 8105e92:	4b61      	ldr	r3, [pc, #388]	@ (8106018 <StartInputHandler+0x500>)
 8105e94:	881b      	ldrh	r3, [r3, #0]
 8105e96:	2b00      	cmp	r3, #0
 8105e98:	d009      	beq.n	8105eae <StartInputHandler+0x396>
            {
                /* Sync Signal generation is active*/
                if (bSubordinatedCycles)
 8105e9a:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8105e9e:	2b00      	cmp	r3, #0
 8105ea0:	d002      	beq.n	8105ea8 <StartInputHandler+0x390>
                {
                    SyncType0x1C32 = SYNCTYPE_DCSYNC1;
 8105ea2:	2303      	movs	r3, #3
 8105ea4:	853b      	strh	r3, [r7, #40]	@ 0x28
 8105ea6:	e004      	b.n	8105eb2 <StartInputHandler+0x39a>
                }
                else
                {
                    SyncType0x1C32 = SYNCTYPE_DCSYNC0;
 8105ea8:	2302      	movs	r3, #2
 8105eaa:	853b      	strh	r3, [r7, #40]	@ 0x28
 8105eac:	e001      	b.n	8105eb2 <StartInputHandler+0x39a>
                }
            }
            else
            {
                SyncType0x1C32 = SYNCTYPE_FREERUN;
 8105eae:	2300      	movs	r3, #0
 8105eb0:	853b      	strh	r3, [r7, #40]	@ 0x28
            }


            if (nPdInputSize > 0)
 8105eb2:	4b5a      	ldr	r3, [pc, #360]	@ (810601c <StartInputHandler+0x504>)
 8105eb4:	881b      	ldrh	r3, [r3, #0]
 8105eb6:	2b00      	cmp	r3, #0
 8105eb8:	d00a      	beq.n	8105ed0 <StartInputHandler+0x3b8>
            {
                if ((dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0)
 8105eba:	8a7b      	ldrh	r3, [r7, #18]
 8105ebc:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 8105ec0:	2b00      	cmp	r3, #0
 8105ec2:	d002      	beq.n	8105eca <StartInputHandler+0x3b2>
                {
                    /* If Sync1 is available the inputs will always be mapped with Sync1 */
                    SyncType0x1C33 = SYNCTYPE_DCSYNC1;
 8105ec4:	2303      	movs	r3, #3
 8105ec6:	84fb      	strh	r3, [r7, #38]	@ 0x26
 8105ec8:	e004      	b.n	8105ed4 <StartInputHandler+0x3bc>
                }
                else
                {
                    /* Map Inputs based on Sync0*/
                    SyncType0x1C33 = SYNCTYPE_DCSYNC0;
 8105eca:	2302      	movs	r3, #2
 8105ecc:	84fb      	strh	r3, [r7, #38]	@ 0x26
 8105ece:	e001      	b.n	8105ed4 <StartInputHandler+0x3bc>
                }
            }
            else
            {
                SyncType0x1C33 = SYNCTYPE_FREERUN;
 8105ed0:	2300      	movs	r3, #0
 8105ed2:	84fb      	strh	r3, [r7, #38]	@ 0x26
            }
        }
    }

    /* Update Cycle time entries if DC Sync Mode enabled */
    if(SyncType0x1C32 == SYNCTYPE_DCSYNC1)
 8105ed4:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8105ed6:	2b03      	cmp	r3, #3
 8105ed8:	d106      	bne.n	8105ee8 <StartInputHandler+0x3d0>
    {
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 8105eda:	68bb      	ldr	r3, [r7, #8]
 8105edc:	4a50      	ldr	r2, [pc, #320]	@ (8106020 <StartInputHandler+0x508>)
 8105ede:	6253      	str	r3, [r2, #36]	@ 0x24

/*ECATCHANGE_START(V5.11) ECAT4*/
        sSyncManInPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 8105ee0:	68bb      	ldr	r3, [r7, #8]
 8105ee2:	4a50      	ldr	r2, [pc, #320]	@ (8106024 <StartInputHandler+0x50c>)
 8105ee4:	6253      	str	r3, [r2, #36]	@ 0x24
 8105ee6:	e00a      	b.n	8105efe <StartInputHandler+0x3e6>
/*ECATCHANGE_END(V5.11) ECAT4*/
    }
    else if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
 8105ee8:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8105eea:	2b02      	cmp	r3, #2
 8105eec:	d107      	bne.n	8105efe <StartInputHandler+0x3e6>
    {
        sSyncManOutPar.u32Sync0CycleTime = (UINT32)cycleTimeSync0;
 8105eee:	68bb      	ldr	r3, [r7, #8]
 8105ef0:	4a4b      	ldr	r2, [pc, #300]	@ (8106020 <StartInputHandler+0x508>)
 8105ef2:	6253      	str	r3, [r2, #36]	@ 0x24

/*ECATCHANGE_START(V5.11) ECAT4*/
        sSyncManInPar.u32Sync0CycleTime = (UINT16)cycleTimeSync0;
 8105ef4:	68bb      	ldr	r3, [r7, #8]
 8105ef6:	b29b      	uxth	r3, r3
 8105ef8:	461a      	mov	r2, r3
 8105efa:	4b4a      	ldr	r3, [pc, #296]	@ (8106024 <StartInputHandler+0x50c>)
 8105efc:	625a      	str	r2, [r3, #36]	@ 0x24
/*ECATCHANGE_END(V5.11) ECAT4*/
    }

    /* Set global flags based on Sync Type */
    if ( !b3BufferMode )
 8105efe:	4b4a      	ldr	r3, [pc, #296]	@ (8106028 <StartInputHandler+0x510>)
 8105f00:	781b      	ldrb	r3, [r3, #0]
 8105f02:	2b00      	cmp	r3, #0
 8105f04:	d107      	bne.n	8105f16 <StartInputHandler+0x3fe>
    {
        /* 1-Buffer-Mode configured => For free run it shall be 3Buffer mode*/
        if (( SyncType0x1C32 == SYNCTYPE_FREERUN ) || ( SyncType0x1C33 == SYNCTYPE_FREERUN ))
 8105f06:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8105f08:	2b00      	cmp	r3, #0
 8105f0a:	d002      	beq.n	8105f12 <StartInputHandler+0x3fa>
 8105f0c:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8105f0e:	2b00      	cmp	r3, #0
 8105f10:	d101      	bne.n	8105f16 <StartInputHandler+0x3fe>
        {
                return ALSTATUSCODE_FREERUNNEEDS3BUFFERMODE;
 8105f12:	2329      	movs	r3, #41	@ 0x29
 8105f14:	e192      	b.n	810623c <StartInputHandler+0x724>
        }
    }

    /* If no free run is supported the EscInt is always enabled*/
        if (( SyncType0x1C32 != SYNCTYPE_FREERUN ) || ( SyncType0x1C33 != SYNCTYPE_FREERUN ))
 8105f16:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8105f18:	2b00      	cmp	r3, #0
 8105f1a:	d102      	bne.n	8105f22 <StartInputHandler+0x40a>
 8105f1c:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8105f1e:	2b00      	cmp	r3, #0
 8105f20:	d002      	beq.n	8105f28 <StartInputHandler+0x410>
        {
        /* ECAT Synchron Mode, the ESC interrupt is enabled */
        bEscIntEnabled = TRUE;
 8105f22:	4b42      	ldr	r3, [pc, #264]	@ (810602c <StartInputHandler+0x514>)
 8105f24:	2201      	movs	r2, #1
 8105f26:	701a      	strb	r2, [r3, #0]
    }

        /* Update value for AL Event Mask register (0x204) */
        if(bEscIntEnabled)
 8105f28:	4b40      	ldr	r3, [pc, #256]	@ (810602c <StartInputHandler+0x514>)
 8105f2a:	781b      	ldrb	r3, [r3, #0]
 8105f2c:	2b00      	cmp	r3, #0
 8105f2e:	d010      	beq.n	8105f52 <StartInputHandler+0x43a>
        {
            if(nPdOutputSize > 0)
 8105f30:	4b39      	ldr	r3, [pc, #228]	@ (8106018 <StartInputHandler+0x500>)
 8105f32:	881b      	ldrh	r3, [r3, #0]
 8105f34:	2b00      	cmp	r3, #0
 8105f36:	d004      	beq.n	8105f42 <StartInputHandler+0x42a>
            {
                u16ALEventMask = PROCESS_OUTPUT_EVENT;
 8105f38:	4b3d      	ldr	r3, [pc, #244]	@ (8106030 <StartInputHandler+0x518>)
 8105f3a:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8105f3e:	801a      	strh	r2, [r3, #0]
 8105f40:	e007      	b.n	8105f52 <StartInputHandler+0x43a>
            }
            else if(nPdInputSize > 0)
 8105f42:	4b36      	ldr	r3, [pc, #216]	@ (810601c <StartInputHandler+0x504>)
 8105f44:	881b      	ldrh	r3, [r3, #0]
 8105f46:	2b00      	cmp	r3, #0
 8105f48:	d003      	beq.n	8105f52 <StartInputHandler+0x43a>
            {
                u16ALEventMask = PROCESS_INPUT_EVENT;
 8105f4a:	4b39      	ldr	r3, [pc, #228]	@ (8106030 <StartInputHandler+0x518>)
 8105f4c:	f44f 6200 	mov.w	r2, #2048	@ 0x800
 8105f50:	801a      	strh	r2, [r3, #0]
            }

        }

        if ((SyncType0x1C32 == SYNCTYPE_DCSYNC0) || (SyncType0x1C32 == SYNCTYPE_DCSYNC1)
 8105f52:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8105f54:	2b02      	cmp	r3, #2
 8105f56:	d008      	beq.n	8105f6a <StartInputHandler+0x452>
 8105f58:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8105f5a:	2b03      	cmp	r3, #3
 8105f5c:	d005      	beq.n	8105f6a <StartInputHandler+0x452>
            || (SyncType0x1C33 == SYNCTYPE_DCSYNC0) || (SyncType0x1C33 == SYNCTYPE_DCSYNC1))/* Sync to Sync0 or Sync1 is enabled*/
 8105f5e:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8105f60:	2b02      	cmp	r3, #2
 8105f62:	d002      	beq.n	8105f6a <StartInputHandler+0x452>
 8105f64:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8105f66:	2b03      	cmp	r3, #3
 8105f68:	d109      	bne.n	8105f7e <StartInputHandler+0x466>
        {
            /* slave is running in DC-mode */
            bDcSyncActive = TRUE;
 8105f6a:	4b32      	ldr	r3, [pc, #200]	@ (8106034 <StartInputHandler+0x51c>)
 8105f6c:	2201      	movs	r2, #1
 8105f6e:	701a      	strb	r2, [r3, #0]

/*ECATCHANGE_START(V5.11) ECAT4*/
            /*In case of an Input only application with DC no PDI Isr handling is required*/
            if (nPdOutputSize == 0)
 8105f70:	4b29      	ldr	r3, [pc, #164]	@ (8106018 <StartInputHandler+0x500>)
 8105f72:	881b      	ldrh	r3, [r3, #0]
 8105f74:	2b00      	cmp	r3, #0
 8105f76:	d102      	bne.n	8105f7e <StartInputHandler+0x466>
            {
               u16ALEventMask = 0;
 8105f78:	4b2d      	ldr	r3, [pc, #180]	@ (8106030 <StartInputHandler+0x518>)
 8105f7a:	2200      	movs	r2, #0
 8105f7c:	801a      	strh	r2, [r3, #0]
            }
/*ECATCHANGE_END(V5.11) ECAT4*/
        }

    sSyncManOutPar.u16SyncType = SyncType0x1C32;
 8105f7e:	4a28      	ldr	r2, [pc, #160]	@ (8106020 <StartInputHandler+0x508>)
 8105f80:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 8105f82:	8053      	strh	r3, [r2, #2]
    sSyncManInPar.u16SyncType = SyncType0x1C33;
 8105f84:	4a27      	ldr	r2, [pc, #156]	@ (8106024 <StartInputHandler+0x50c>)
 8105f86:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8105f88:	8053      	strh	r3, [r2, #2]

    /* Calculate number of Sync0 events within one SM cycle and the Sync0 events on which the inputs has to be latched*/
    LatchInputSync0Value = 0;
 8105f8a:	4b2b      	ldr	r3, [pc, #172]	@ (8106038 <StartInputHandler+0x520>)
 8105f8c:	2200      	movs	r2, #0
 8105f8e:	801a      	strh	r2, [r3, #0]
    LatchInputSync0Counter = 0;
 8105f90:	4b2a      	ldr	r3, [pc, #168]	@ (810603c <StartInputHandler+0x524>)
 8105f92:	2200      	movs	r2, #0
 8105f94:	801a      	strh	r2, [r3, #0]
    u16SmSync0Value = 0;
 8105f96:	4b2a      	ldr	r3, [pc, #168]	@ (8106040 <StartInputHandler+0x528>)
 8105f98:	2200      	movs	r2, #0
 8105f9a:	801a      	strh	r2, [r3, #0]
    u16SmSync0Counter = 0;
 8105f9c:	4b29      	ldr	r3, [pc, #164]	@ (8106044 <StartInputHandler+0x52c>)
 8105f9e:	2200      	movs	r2, #0
 8105fa0:	801a      	strh	r2, [r3, #0]


    if(bSubordinatedCycles == TRUE)
 8105fa2:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8105fa6:	2b01      	cmp	r3, #1
 8105fa8:	d14e      	bne.n	8106048 <StartInputHandler+0x530>
    {
        /* get the number of Sync0 event within on SM cycle */
        if(cycleTimeSync1 >= cycleTimeSync0)
 8105faa:	687a      	ldr	r2, [r7, #4]
 8105fac:	68bb      	ldr	r3, [r7, #8]
 8105fae:	429a      	cmp	r2, r3
 8105fb0:	d316      	bcc.n	8105fe0 <StartInputHandler+0x4c8>
        {
            u16SmSync0Value = (UINT16)(cycleTimeSync1 / cycleTimeSync0);
 8105fb2:	687a      	ldr	r2, [r7, #4]
 8105fb4:	68bb      	ldr	r3, [r7, #8]
 8105fb6:	fbb2 f3f3 	udiv	r3, r2, r3
 8105fba:	b29a      	uxth	r2, r3
 8105fbc:	4b20      	ldr	r3, [pc, #128]	@ (8106040 <StartInputHandler+0x528>)
 8105fbe:	801a      	strh	r2, [r3, #0]
            
            if((cycleTimeSync1 % cycleTimeSync0) == 0)
 8105fc0:	687b      	ldr	r3, [r7, #4]
 8105fc2:	68ba      	ldr	r2, [r7, #8]
 8105fc4:	fbb3 f1f2 	udiv	r1, r3, r2
 8105fc8:	fb01 f202 	mul.w	r2, r1, r2
 8105fcc:	1a9b      	subs	r3, r3, r2
 8105fce:	2b00      	cmp	r3, #0
 8105fd0:	d109      	bne.n	8105fe6 <StartInputHandler+0x4ce>
            {
                /* if the Sync1cycletime/Sync0cycletime ratio is even one additional tick */
                u16SmSync0Value ++;
 8105fd2:	4b1b      	ldr	r3, [pc, #108]	@ (8106040 <StartInputHandler+0x528>)
 8105fd4:	881b      	ldrh	r3, [r3, #0]
 8105fd6:	3301      	adds	r3, #1
 8105fd8:	b29a      	uxth	r2, r3
 8105fda:	4b19      	ldr	r3, [pc, #100]	@ (8106040 <StartInputHandler+0x528>)
 8105fdc:	801a      	strh	r2, [r3, #0]
 8105fde:	e002      	b.n	8105fe6 <StartInputHandler+0x4ce>
        }
        }
        else
        {
            u16SmSync0Value = 1;
 8105fe0:	4b17      	ldr	r3, [pc, #92]	@ (8106040 <StartInputHandler+0x528>)
 8105fe2:	2201      	movs	r2, #1
 8105fe4:	801a      	strh	r2, [r3, #0]
        }

        /* Calculate the Sync0 tick on which the inputs shall be latched (last Sync0 before the next Sync1 event)*/
        LatchInputSync0Value = (UINT16) (cycleTimeSync1 / cycleTimeSync0);
 8105fe6:	687a      	ldr	r2, [r7, #4]
 8105fe8:	68bb      	ldr	r3, [r7, #8]
 8105fea:	fbb2 f3f3 	udiv	r3, r2, r3
 8105fee:	b29a      	uxth	r2, r3
 8105ff0:	4b11      	ldr	r3, [pc, #68]	@ (8106038 <StartInputHandler+0x520>)
 8105ff2:	801a      	strh	r2, [r3, #0]

        if((cycleTimeSync1 % cycleTimeSync0) > 0)
 8105ff4:	687b      	ldr	r3, [r7, #4]
 8105ff6:	68ba      	ldr	r2, [r7, #8]
 8105ff8:	fbb3 f1f2 	udiv	r1, r3, r2
 8105ffc:	fb01 f202 	mul.w	r2, r1, r2
 8106000:	1a9b      	subs	r3, r3, r2
 8106002:	2b00      	cmp	r3, #0
 8106004:	d02c      	beq.n	8106060 <StartInputHandler+0x548>
            LatchInputSync0Value++;
 8106006:	4b0c      	ldr	r3, [pc, #48]	@ (8106038 <StartInputHandler+0x520>)
 8106008:	881b      	ldrh	r3, [r3, #0]
 810600a:	3301      	adds	r3, #1
 810600c:	b29a      	uxth	r2, r3
 810600e:	4b0a      	ldr	r3, [pc, #40]	@ (8106038 <StartInputHandler+0x520>)
 8106010:	801a      	strh	r2, [r3, #0]
 8106012:	e025      	b.n	8106060 <StartInputHandler+0x548>
 8106014:	10000b01 	.word	0x10000b01
 8106018:	10000856 	.word	0x10000856
 810601c:	10000854 	.word	0x10000854
 8106020:	10000b08 	.word	0x10000b08
 8106024:	10000b4c 	.word	0x10000b4c
 8106028:	10000849 	.word	0x10000849
 810602c:	10000848 	.word	0x10000848
 8106030:	10000864 	.word	0x10000864
 8106034:	1000082c 	.word	0x1000082c
 8106038:	10000844 	.word	0x10000844
 810603c:	10000846 	.word	0x10000846
 8106040:	10000834 	.word	0x10000834
 8106044:	10000832 	.word	0x10000832

    }
    else 
    {
        if(SyncType0x1C32 == SYNCTYPE_DCSYNC0)
 8106048:	8d3b      	ldrh	r3, [r7, #40]	@ 0x28
 810604a:	2b02      	cmp	r3, #2
 810604c:	d102      	bne.n	8106054 <StartInputHandler+0x53c>
        {
            /* if SyncType of 0x1C32 is 2 the Sync0 event is trigger once during a SM cycle */
            u16SmSync0Value = 1;
 810604e:	4b7d      	ldr	r3, [pc, #500]	@ (8106244 <StartInputHandler+0x72c>)
 8106050:	2201      	movs	r2, #1
 8106052:	801a      	strh	r2, [r3, #0]
        }   

        if(SyncType0x1C33 != SYNCTYPE_DCSYNC1)
 8106054:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8106056:	2b03      	cmp	r3, #3
 8106058:	d002      	beq.n	8106060 <StartInputHandler+0x548>
        {
            LatchInputSync0Value = 1;
 810605a:	4b7b      	ldr	r3, [pc, #492]	@ (8106248 <StartInputHandler+0x730>)
 810605c:	2201      	movs	r2, #1
 810605e:	801a      	strh	r2, [r3, #0]
    }



    /* reset the error counter indicating synchronization problems */
    sCycleDiag.syncFailedCounter = 0;
 8106060:	4b7a      	ldr	r3, [pc, #488]	@ (810624c <StartInputHandler+0x734>)
 8106062:	2200      	movs	r2, #0
 8106064:	801a      	strh	r2, [r3, #0]
        --- Check watchdog settings ---
    */

    /*get the watchdog time (register 0x420). if value is > 0 watchdog is active*/
/*ECATCHANGE_START(V5.11) ECAT4*/
    HW_EscReadWord(wd, ESC_PD_WD_TIME);
 8106066:	f107 030e 	add.w	r3, r7, #14
 810606a:	2202      	movs	r2, #2
 810606c:	f44f 6184 	mov.w	r1, #1056	@ 0x420
 8106070:	4618      	mov	r0, r3
 8106072:	f7fb f819 	bl	81010a8 <HW_EscRead>
    wd = SWAPWORD(wd);
 8106076:	89fb      	ldrh	r3, [r7, #14]
 8106078:	81fb      	strh	r3, [r7, #14]
/*ECATCHANGE_END(V5.11) ECAT4*/

    if (nPdOutputSize > 0 &&  wd != 0 )
 810607a:	4b75      	ldr	r3, [pc, #468]	@ (8106250 <StartInputHandler+0x738>)
 810607c:	881b      	ldrh	r3, [r3, #0]
 810607e:	2b00      	cmp	r3, #0
 8106080:	d02f      	beq.n	81060e2 <StartInputHandler+0x5ca>
 8106082:	89fb      	ldrh	r3, [r7, #14]
 8106084:	2b00      	cmp	r3, #0
 8106086:	d02c      	beq.n	81060e2 <StartInputHandler+0x5ca>
    {
    /*get watchdog divider (register 0x400)*/
    HW_EscReadWord(wdiv, ESC_WD_DIVIDER_OFFSET);
 8106088:	f107 0310 	add.w	r3, r7, #16
 810608c:	2202      	movs	r2, #2
 810608e:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8106092:	4618      	mov	r0, r3
 8106094:	f7fb f808 	bl	81010a8 <HW_EscRead>
    wdiv = SWAPWORD(wdiv);
 8106098:	8a3b      	ldrh	r3, [r7, #16]
 810609a:	823b      	strh	r3, [r7, #16]
        if ( wdiv != 0 )
 810609c:	8a3b      	ldrh	r3, [r7, #16]
 810609e:	2b00      	cmp	r3, #0
 81060a0:	d019      	beq.n	81060d6 <StartInputHandler+0x5be>
        {
            /* the ESC subtracts 2 in register 0x400 so it has to be added here */
            UINT32 d = wdiv+2;
 81060a2:	8a3b      	ldrh	r3, [r7, #16]
 81060a4:	3302      	adds	r3, #2
 81060a6:	61fb      	str	r3, [r7, #28]

            d *= wd;
 81060a8:	89fb      	ldrh	r3, [r7, #14]
 81060aa:	461a      	mov	r2, r3
 81060ac:	69fb      	ldr	r3, [r7, #28]
 81060ae:	fb02 f303 	mul.w	r3, r2, r3
 81060b2:	61fb      	str	r3, [r7, #28]
            /* store watchdog in ms in variable u16WdValue */
            /* watchdog value has to be rounded up */
            d += 24999;
 81060b4:	69fb      	ldr	r3, [r7, #28]
 81060b6:	f503 43c3 	add.w	r3, r3, #24960	@ 0x6180
 81060ba:	3327      	adds	r3, #39	@ 0x27
 81060bc:	61fb      	str	r3, [r7, #28]
            d /= 25000;
 81060be:	69fb      	ldr	r3, [r7, #28]
 81060c0:	08db      	lsrs	r3, r3, #3
 81060c2:	4a64      	ldr	r2, [pc, #400]	@ (8106254 <StartInputHandler+0x73c>)
 81060c4:	fba2 2303 	umull	r2, r3, r2, r3
 81060c8:	0a1b      	lsrs	r3, r3, #8
 81060ca:	61fb      	str	r3, [r7, #28]
            EcatWdValue = (UINT16) d;
 81060cc:	69fb      	ldr	r3, [r7, #28]
 81060ce:	b29a      	uxth	r2, r3
 81060d0:	4b61      	ldr	r3, [pc, #388]	@ (8106258 <StartInputHandler+0x740>)
 81060d2:	801a      	strh	r2, [r3, #0]
        if ( wdiv != 0 )
 81060d4:	e00a      	b.n	81060ec <StartInputHandler+0x5d4>
        }
        else
        {
            wd = 0;
 81060d6:	2300      	movs	r3, #0
 81060d8:	81fb      	strh	r3, [r7, #14]
            /* wd value has to be set to zero, if the wd is 0 */
            EcatWdValue = 0;
 81060da:	4b5f      	ldr	r3, [pc, #380]	@ (8106258 <StartInputHandler+0x740>)
 81060dc:	2200      	movs	r2, #0
 81060de:	801a      	strh	r2, [r3, #0]
        if ( wdiv != 0 )
 81060e0:	e004      	b.n	81060ec <StartInputHandler+0x5d4>
        }
    }
    else
    {
        /* the watchdog is deactivated or slave has no output process data*/
        wdiv = 0;
 81060e2:	2300      	movs	r3, #0
 81060e4:	823b      	strh	r3, [r7, #16]
        EcatWdValue = 0;
 81060e6:	4b5c      	ldr	r3, [pc, #368]	@ (8106258 <StartInputHandler+0x740>)
 81060e8:	2200      	movs	r2, #0
 81060ea:	801a      	strh	r2, [r3, #0]
    }

    if((EcatWdValue == 0 && bWdTrigger) || (EcatWdValue != 0 && !bWdTrigger))
 81060ec:	4b5a      	ldr	r3, [pc, #360]	@ (8106258 <StartInputHandler+0x740>)
 81060ee:	881b      	ldrh	r3, [r3, #0]
 81060f0:	2b00      	cmp	r3, #0
 81060f2:	d103      	bne.n	81060fc <StartInputHandler+0x5e4>
 81060f4:	4b59      	ldr	r3, [pc, #356]	@ (810625c <StartInputHandler+0x744>)
 81060f6:	781b      	ldrb	r3, [r3, #0]
 81060f8:	2b00      	cmp	r3, #0
 81060fa:	d107      	bne.n	810610c <StartInputHandler+0x5f4>
 81060fc:	4b56      	ldr	r3, [pc, #344]	@ (8106258 <StartInputHandler+0x740>)
 81060fe:	881b      	ldrh	r3, [r3, #0]
 8106100:	2b00      	cmp	r3, #0
 8106102:	d005      	beq.n	8106110 <StartInputHandler+0x5f8>
 8106104:	4b55      	ldr	r3, [pc, #340]	@ (810625c <StartInputHandler+0x744>)
 8106106:	781b      	ldrb	r3, [r3, #0]
 8106108:	2b00      	cmp	r3, #0
 810610a:	d101      	bne.n	8106110 <StartInputHandler+0x5f8>
    {
        /* if the WD-Trigger in the Sync Manager Channel 2 Control-Byte is set (Bit 6 of Register 0x814)
            an error has to be returned */
        return ALSTATUSCODE_INVALIDWDCFG;
 810610c:	231f      	movs	r3, #31
 810610e:	e095      	b.n	810623c <StartInputHandler+0x724>
    }

    if ( bEscIntEnabled && nPdOutputSize != 0 )
 8106110:	4b53      	ldr	r3, [pc, #332]	@ (8106260 <StartInputHandler+0x748>)
 8106112:	781b      	ldrb	r3, [r3, #0]
 8106114:	2b00      	cmp	r3, #0
 8106116:	d00a      	beq.n	810612e <StartInputHandler+0x616>
 8106118:	4b4d      	ldr	r3, [pc, #308]	@ (8106250 <StartInputHandler+0x738>)
 810611a:	881b      	ldrh	r3, [r3, #0]
 810611c:	2b00      	cmp	r3, #0
 810611e:	d006      	beq.n	810612e <StartInputHandler+0x616>
    {
        /* ECAT synchron Mode is active, the Sync Manager Channel 2 event
           has to activated in the AL-Event mask register */
        u16ALEventMask |= PROCESS_OUTPUT_EVENT;
 8106120:	4b50      	ldr	r3, [pc, #320]	@ (8106264 <StartInputHandler+0x74c>)
 8106122:	881b      	ldrh	r3, [r3, #0]
 8106124:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8106128:	b29a      	uxth	r2, r3
 810612a:	4b4e      	ldr	r3, [pc, #312]	@ (8106264 <StartInputHandler+0x74c>)
 810612c:	801a      	strh	r2, [r3, #0]
    }
/*The application ESM function is separated from this function to handle pending transitions*/

    Sync0WdValue = 0;
 810612e:	4b4e      	ldr	r3, [pc, #312]	@ (8106268 <StartInputHandler+0x750>)
 8106130:	2200      	movs	r2, #0
 8106132:	801a      	strh	r2, [r3, #0]
    Sync0WdCounter = 0;
 8106134:	4b4d      	ldr	r3, [pc, #308]	@ (810626c <StartInputHandler+0x754>)
 8106136:	2200      	movs	r2, #0
 8106138:	801a      	strh	r2, [r3, #0]
    Sync1WdCounter = 0;
 810613a:	4b4d      	ldr	r3, [pc, #308]	@ (8106270 <StartInputHandler+0x758>)
 810613c:	2200      	movs	r2, #0
 810613e:	801a      	strh	r2, [r3, #0]
    Sync1WdValue = 0;
 8106140:	4b4c      	ldr	r3, [pc, #304]	@ (8106274 <StartInputHandler+0x75c>)
 8106142:	2200      	movs	r2, #0
 8106144:	801a      	strh	r2, [r3, #0]
    bDcRunning = FALSE;
 8106146:	4b4c      	ldr	r3, [pc, #304]	@ (8106278 <StartInputHandler+0x760>)
 8106148:	2200      	movs	r2, #0
 810614a:	701a      	strb	r2, [r3, #0]
    bSmSyncSequenceValid = FALSE;
 810614c:	4b4b      	ldr	r3, [pc, #300]	@ (810627c <StartInputHandler+0x764>)
 810614e:	2200      	movs	r2, #0
 8106150:	701a      	strb	r2, [r3, #0]
    i16WaitForPllRunningTimeout = 0;
 8106152:	4b4b      	ldr	r3, [pc, #300]	@ (8106280 <StartInputHandler+0x768>)
 8106154:	2200      	movs	r2, #0
 8106156:	801a      	strh	r2, [r3, #0]
/*ECATCHANGE_START(V5.11) ECAT4*/
    sSyncManInPar.u8SyncError = 0;
 8106158:	4b4a      	ldr	r3, [pc, #296]	@ (8106284 <StartInputHandler+0x76c>)
 810615a:	2200      	movs	r2, #0
 810615c:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
/*ECATCHANGE_END(V5.11) ECAT4*/
    sSyncManOutPar.u8SyncError = 0;
 8106160:	4b49      	ldr	r3, [pc, #292]	@ (8106288 <StartInputHandler+0x770>)
 8106162:	2200      	movs	r2, #0
 8106164:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
    sSyncManOutPar.u16SmEventMissedCounter = 0;
 8106168:	4b47      	ldr	r3, [pc, #284]	@ (8106288 <StartInputHandler+0x770>)
 810616a:	2200      	movs	r2, #0
 810616c:	851a      	strh	r2, [r3, #40]	@ 0x28

    /* calculate the Sync0/Sync1 watchdog timeouts */
    if ( (dcControl & ESC_DC_SYNC0_ACTIVE_MASK) != 0 )
 810616e:	8a7b      	ldrh	r3, [r7, #18]
 8106170:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 8106174:	2b00      	cmp	r3, #0
 8106176:	d050      	beq.n	810621a <StartInputHandler+0x702>
    {
        /*calculate the Sync0 Watchdog counter value the minimum value is 1 ms
            if the sync0 cycle is greater 500us the Sync0 Wd value is 2*Sycn0 cycle */
        if(cycleTimeSync0 == 0)
 8106178:	68bb      	ldr	r3, [r7, #8]
 810617a:	2b00      	cmp	r3, #0
 810617c:	d103      	bne.n	8106186 <StartInputHandler+0x66e>
        {
            Sync0WdValue = 0;
 810617e:	4b3a      	ldr	r3, [pc, #232]	@ (8106268 <StartInputHandler+0x750>)
 8106180:	2200      	movs	r2, #0
 8106182:	801a      	strh	r2, [r3, #0]
 8106184:	e018      	b.n	81061b8 <StartInputHandler+0x6a0>
        }
        else
        {
            UINT32 Sync0Cycle = cycleTimeSync0/100000;
 8106186:	68bb      	ldr	r3, [r7, #8]
 8106188:	095b      	lsrs	r3, r3, #5
 810618a:	4a40      	ldr	r2, [pc, #256]	@ (810628c <StartInputHandler+0x774>)
 810618c:	fba2 2303 	umull	r2, r3, r2, r3
 8106190:	09db      	lsrs	r3, r3, #7
 8106192:	61bb      	str	r3, [r7, #24]
            if(Sync0Cycle < 5)
 8106194:	69bb      	ldr	r3, [r7, #24]
 8106196:	2b04      	cmp	r3, #4
 8106198:	d803      	bhi.n	81061a2 <StartInputHandler+0x68a>
            {
                /*Sync0 cycle less than 500us*/
                Sync0WdValue = 1;
 810619a:	4b33      	ldr	r3, [pc, #204]	@ (8106268 <StartInputHandler+0x750>)
 810619c:	2201      	movs	r2, #1
 810619e:	801a      	strh	r2, [r3, #0]
 81061a0:	e00a      	b.n	81061b8 <StartInputHandler+0x6a0>
            }
            else
            {
                Sync0WdValue = (UINT16)(Sync0Cycle*2)/10;
 81061a2:	69bb      	ldr	r3, [r7, #24]
 81061a4:	b29b      	uxth	r3, r3
 81061a6:	005b      	lsls	r3, r3, #1
 81061a8:	b29b      	uxth	r3, r3
 81061aa:	4a39      	ldr	r2, [pc, #228]	@ (8106290 <StartInputHandler+0x778>)
 81061ac:	fba2 2303 	umull	r2, r3, r2, r3
 81061b0:	08db      	lsrs	r3, r3, #3
 81061b2:	b29a      	uxth	r2, r3
 81061b4:	4b2c      	ldr	r3, [pc, #176]	@ (8106268 <StartInputHandler+0x750>)
 81061b6:	801a      	strh	r2, [r3, #0]
            }
        }

        /* Calculate also the watchdog time for Sync1*/
        if ( (dcControl & ESC_DC_SYNC1_ACTIVE_MASK) != 0 )
 81061b8:	8a7b      	ldrh	r3, [r7, #18]
 81061ba:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 81061be:	2b00      	cmp	r3, #0
 81061c0:	d02b      	beq.n	810621a <StartInputHandler+0x702>
        {
            if(cycleTimeSync1 < cycleTimeSync0)
 81061c2:	687a      	ldr	r2, [r7, #4]
 81061c4:	68bb      	ldr	r3, [r7, #8]
 81061c6:	429a      	cmp	r2, r3
 81061c8:	d204      	bcs.n	81061d4 <StartInputHandler+0x6bc>
        {
                /* Sync 1 has the same cycle time than Sync0 (maybe with a shift (cycleTimeSync1 > 0))*/
                Sync1WdValue = Sync0WdValue;
 81061ca:	4b27      	ldr	r3, [pc, #156]	@ (8106268 <StartInputHandler+0x750>)
 81061cc:	881a      	ldrh	r2, [r3, #0]
 81061ce:	4b29      	ldr	r3, [pc, #164]	@ (8106274 <StartInputHandler+0x75c>)
 81061d0:	801a      	strh	r2, [r3, #0]
 81061d2:	e022      	b.n	810621a <StartInputHandler+0x702>
        }
        else
        {
                /* Sync1 cycle is larger than Sync0 (e.g. subordinated Sync0 cycles) */
                UINT32 Sync1Cycle = cycleTimeSync1/100000;
 81061d4:	687b      	ldr	r3, [r7, #4]
 81061d6:	095b      	lsrs	r3, r3, #5
 81061d8:	4a2c      	ldr	r2, [pc, #176]	@ (810628c <StartInputHandler+0x774>)
 81061da:	fba2 2303 	umull	r2, r3, r2, r3
 81061de:	09db      	lsrs	r3, r3, #7
 81061e0:	617b      	str	r3, [r7, #20]
                if(Sync1Cycle < 5)
 81061e2:	697b      	ldr	r3, [r7, #20]
 81061e4:	2b04      	cmp	r3, #4
 81061e6:	d803      	bhi.n	81061f0 <StartInputHandler+0x6d8>
                {
                    /*Sync0 cycle less than 500us*/
                    Sync1WdValue = 1;
 81061e8:	4b22      	ldr	r3, [pc, #136]	@ (8106274 <StartInputHandler+0x75c>)
 81061ea:	2201      	movs	r2, #1
 81061ec:	801a      	strh	r2, [r3, #0]
 81061ee:	e00a      	b.n	8106206 <StartInputHandler+0x6ee>
    }
    else
    {
                    Sync1WdValue = (UINT16)(Sync1Cycle*2)/10;
 81061f0:	697b      	ldr	r3, [r7, #20]
 81061f2:	b29b      	uxth	r3, r3
 81061f4:	005b      	lsls	r3, r3, #1
 81061f6:	b29b      	uxth	r3, r3
 81061f8:	4a25      	ldr	r2, [pc, #148]	@ (8106290 <StartInputHandler+0x778>)
 81061fa:	fba2 2303 	umull	r2, r3, r2, r3
 81061fe:	08db      	lsrs	r3, r3, #3
 8106200:	b29a      	uxth	r2, r3
 8106202:	4b1c      	ldr	r3, [pc, #112]	@ (8106274 <StartInputHandler+0x75c>)
 8106204:	801a      	strh	r2, [r3, #0]
                }

                /* add one Sync0 cycle because the Sync1 cycle starts on the next Sync0 after the Sync1 signal */
                Sync1WdValue += Sync0WdValue/2;
 8106206:	4b18      	ldr	r3, [pc, #96]	@ (8106268 <StartInputHandler+0x750>)
 8106208:	881b      	ldrh	r3, [r3, #0]
 810620a:	085b      	lsrs	r3, r3, #1
 810620c:	b29a      	uxth	r2, r3
 810620e:	4b19      	ldr	r3, [pc, #100]	@ (8106274 <StartInputHandler+0x75c>)
 8106210:	881b      	ldrh	r3, [r3, #0]
 8106212:	4413      	add	r3, r2
 8106214:	b29a      	uxth	r2, r3
 8106216:	4b17      	ldr	r3, [pc, #92]	@ (8106274 <StartInputHandler+0x75c>)
 8106218:	801a      	strh	r2, [r3, #0]





    if(nPdOutputSize > 0)
 810621a:	4b0d      	ldr	r3, [pc, #52]	@ (8106250 <StartInputHandler+0x738>)
 810621c:	881b      	ldrh	r3, [r3, #0]
 810621e:	2b00      	cmp	r3, #0
 8106220:	d002      	beq.n	8106228 <StartInputHandler+0x710>
    {
/*ECATCHANGE_START(V5.11) HW1*/
        EnableSyncManChannel(PROCESS_DATA_OUT);
 8106222:	2002      	movs	r0, #2
 8106224:	f7ff fa54 	bl	81056d0 <EnableSyncManChannel>
/*ECATCHANGE_END(V5.11) HW1*/
    }

    if(nPdInputSize > 0)
 8106228:	4b1a      	ldr	r3, [pc, #104]	@ (8106294 <StartInputHandler+0x77c>)
 810622a:	881b      	ldrh	r3, [r3, #0]
 810622c:	2b00      	cmp	r3, #0
 810622e:	d002      	beq.n	8106236 <StartInputHandler+0x71e>
    {
/*ECATCHANGE_START(V5.11) HW1*/
        EnableSyncManChannel(PROCESS_DATA_IN);
 8106230:	2003      	movs	r0, #3
 8106232:	f7ff fa4d 	bl	81056d0 <EnableSyncManChannel>
/*ECATCHANGE_END(V5.11) HW1*/
    }

    /*write initial input data*/
    PDO_InputMapping();
 8106236:	f7ff f873 	bl	8105320 <PDO_InputMapping>

    return ALSTATUSCODE_NOERROR;
 810623a:	2300      	movs	r3, #0
}
 810623c:	4618      	mov	r0, r3
 810623e:	3730      	adds	r7, #48	@ 0x30
 8106240:	46bd      	mov	sp, r7
 8106242:	bd80      	pop	{r7, pc}
 8106244:	10000834 	.word	0x10000834
 8106248:	10000844 	.word	0x10000844
 810624c:	10000b04 	.word	0x10000b04
 8106250:	10000856 	.word	0x10000856
 8106254:	14f8b589 	.word	0x14f8b589
 8106258:	1000085e 	.word	0x1000085e
 810625c:	1000082b 	.word	0x1000082b
 8106260:	10000848 	.word	0x10000848
 8106264:	10000864 	.word	0x10000864
 8106268:	1000083e 	.word	0x1000083e
 810626c:	1000083c 	.word	0x1000083c
 8106270:	10000840 	.word	0x10000840
 8106274:	10000842 	.word	0x10000842
 8106278:	10000830 	.word	0x10000830
 810627c:	10000836 	.word	0x10000836
 8106280:	10000838 	.word	0x10000838
 8106284:	10000b4c 	.word	0x10000b4c
 8106288:	10000b08 	.word	0x10000b08
 810628c:	0a7c5ac5 	.word	0x0a7c5ac5
 8106290:	cccccccd 	.word	0xcccccccd
 8106294:	10000854 	.word	0x10000854

08106298 <StartOutputHandler>:
 \brief  and the state transition would be refused if outputs are missing

*////////////////////////////////////////////////////////////////////////////////////////

UINT16 StartOutputHandler(void)
{
 8106298:	b480      	push	{r7}
 810629a:	b083      	sub	sp, #12
 810629c:	af00      	add	r7, sp, #0
/*ECATCHANGE_START(V5.11) ESM6*/
    /* by default the SO transition should be completed in AlControlRes().
       required to support also masters which starts to send process data after the SO transition was triggered
       (if the master don't send process data within "SAFEOP2OPTIMEOUT" the transition is rejected)*/
    UINT16 result = NOERROR_INWORK;
 810629e:	23ff      	movs	r3, #255	@ 0xff
 81062a0:	80fb      	strh	r3, [r7, #6]
/*ECATCHANGE_END(V5.11) ESM6*/
    if(bLocalErrorFlag)
 81062a2:	4b0c      	ldr	r3, [pc, #48]	@ (81062d4 <StartOutputHandler+0x3c>)
 81062a4:	781b      	ldrb	r3, [r3, #0]
 81062a6:	2b00      	cmp	r3, #0
 81062a8:	d002      	beq.n	81062b0 <StartOutputHandler+0x18>
    {
        /*Local error still exists => skip state request to OP and response with "u16LocalErrorCode"*/
        return u16LocalErrorCode;
 81062aa:	4b0b      	ldr	r3, [pc, #44]	@ (81062d8 <StartOutputHandler+0x40>)
 81062ac:	881b      	ldrh	r3, [r3, #0]
 81062ae:	e00a      	b.n	81062c6 <StartOutputHandler+0x2e>
    }
/*The application ESM function is separated from this function to handle pending transitions*/


    /*DC synchronisation is active wait until pll is valid*/
    if(bDcSyncActive)
 81062b0:	4b0a      	ldr	r3, [pc, #40]	@ (81062dc <StartOutputHandler+0x44>)
 81062b2:	781b      	ldrb	r3, [r3, #0]
 81062b4:	2b00      	cmp	r3, #0
 81062b6:	d005      	beq.n	81062c4 <StartOutputHandler+0x2c>
    {
        i16WaitForPllRunningTimeout = 200;
 81062b8:	4b09      	ldr	r3, [pc, #36]	@ (81062e0 <StartOutputHandler+0x48>)
 81062ba:	22c8      	movs	r2, #200	@ 0xc8
 81062bc:	801a      	strh	r2, [r3, #0]
        i16WaitForPllRunningCnt = 0;
 81062be:	4b09      	ldr	r3, [pc, #36]	@ (81062e4 <StartOutputHandler+0x4c>)
 81062c0:	2200      	movs	r2, #0
 81062c2:	801a      	strh	r2, [r3, #0]
    }


    return result;
 81062c4:	88fb      	ldrh	r3, [r7, #6]
}
 81062c6:	4618      	mov	r0, r3
 81062c8:	370c      	adds	r7, #12
 81062ca:	46bd      	mov	sp, r7
 81062cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 81062d0:	4770      	bx	lr
 81062d2:	bf00      	nop
 81062d4:	1000084a 	.word	0x1000084a
 81062d8:	1000084c 	.word	0x1000084c
 81062dc:	1000082c 	.word	0x1000082c
 81062e0:	10000838 	.word	0x10000838
 81062e4:	1000083a 	.word	0x1000083a

081062e8 <StopOutputHandler>:
 \brief  the state transition can be delayed by returning NOERROR_INWORK

*////////////////////////////////////////////////////////////////////////////////////////

void StopOutputHandler(void)
{
 81062e8:	b480      	push	{r7}
 81062ea:	af00      	add	r7, sp, #0
    /* reset the flags that outputs were received and that the slave is in OP */
    bEcatFirstOutputsReceived = FALSE;
 81062ec:	4b05      	ldr	r3, [pc, #20]	@ (8106304 <StopOutputHandler+0x1c>)
 81062ee:	2200      	movs	r2, #0
 81062f0:	701a      	strb	r2, [r3, #0]
    bEcatOutputUpdateRunning = FALSE;
 81062f2:	4b05      	ldr	r3, [pc, #20]	@ (8106308 <StopOutputHandler+0x20>)
 81062f4:	2200      	movs	r2, #0
 81062f6:	701a      	strb	r2, [r3, #0]
}
 81062f8:	bf00      	nop
 81062fa:	46bd      	mov	sp, r7
 81062fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 8106300:	4770      	bx	lr
 8106302:	bf00      	nop
 8106304:	1000082a 	.word	0x1000082a
 8106308:	10000828 	.word	0x10000828

0810630c <StopInputHandler>:
  \brief    This function is called in case of the state transition from SAFEOP to PREOP

*////////////////////////////////////////////////////////////////////////////////////////

void StopInputHandler(void)
{
 810630c:	b580      	push	{r7, lr}
 810630e:	b082      	sub	sp, #8
 8106310:	af00      	add	r7, sp, #0
    if(nPdOutputSize > 0)
 8106312:	4b2c      	ldr	r3, [pc, #176]	@ (81063c4 <StopInputHandler+0xb8>)
 8106314:	881b      	ldrh	r3, [r3, #0]
 8106316:	2b00      	cmp	r3, #0
 8106318:	d002      	beq.n	8106320 <StopInputHandler+0x14>
    {
        /* disable the Sync Manager Channel 2 (outputs) */
/*ECATCHANGE_END(V5.11) HW1*/
        DisableSyncManChannel(PROCESS_DATA_OUT);
 810631a:	2002      	movs	r0, #2
 810631c:	f7ff f9b0 	bl	8105680 <DisableSyncManChannel>
/*ECATCHANGE_END(V5.11) HW1*/
    }

    if(nPdInputSize > 0)
 8106320:	4b29      	ldr	r3, [pc, #164]	@ (81063c8 <StopInputHandler+0xbc>)
 8106322:	881b      	ldrh	r3, [r3, #0]
 8106324:	2b00      	cmp	r3, #0
 8106326:	d002      	beq.n	810632e <StopInputHandler+0x22>
    {
        /*disable Sync Manager 3 (inputs) if no outputs available*/
/*ECATCHANGE_START(V5.11) HW1*/
        DisableSyncManChannel(PROCESS_DATA_IN);
 8106328:	2003      	movs	r0, #3
 810632a:	f7ff f9a9 	bl	8105680 <DisableSyncManChannel>
/*ECATCHANGE_END(V5.11) HW1*/
    }

    /* reset the events in the AL Event mask register (0x204) */
    {
        UINT16 ResetMask = SYNC0_EVENT | SYNC1_EVENT;
 810632e:	230c      	movs	r3, #12
 8106330:	80fb      	strh	r3, [r7, #6]
        ResetMask |= PROCESS_OUTPUT_EVENT;
 8106332:	88fb      	ldrh	r3, [r7, #6]
 8106334:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8106338:	80fb      	strh	r3, [r7, #6]
        ResetMask |= PROCESS_INPUT_EVENT;
 810633a:	88fb      	ldrh	r3, [r7, #6]
 810633c:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 8106340:	80fb      	strh	r3, [r7, #6]

/*ECATCHANGE_START(V5.11) HW1*/
    ResetALEventMask( ~(ResetMask) );
 8106342:	88fb      	ldrh	r3, [r7, #6]
 8106344:	43db      	mvns	r3, r3
 8106346:	b29b      	uxth	r3, r3
 8106348:	4618      	mov	r0, r3
 810634a:	f7ff f913 	bl	8105574 <ResetALEventMask>
/*ECATCHANGE_END(V5.11) HW1*/
    }
    /* reset the flags */
    bEcatFirstOutputsReceived = FALSE;
 810634e:	4b1f      	ldr	r3, [pc, #124]	@ (81063cc <StopInputHandler+0xc0>)
 8106350:	2200      	movs	r2, #0
 8106352:	701a      	strb	r2, [r3, #0]
    bEscIntEnabled = FALSE;
 8106354:	4b1e      	ldr	r3, [pc, #120]	@ (81063d0 <StopInputHandler+0xc4>)
 8106356:	2200      	movs	r2, #0
 8106358:	701a      	strb	r2, [r3, #0]
/*The application ESM function is separated from this function to handle pending transitions*/

    bDcSyncActive = FALSE;
 810635a:	4b1e      	ldr	r3, [pc, #120]	@ (81063d4 <StopInputHandler+0xc8>)
 810635c:	2200      	movs	r2, #0
 810635e:	701a      	strb	r2, [r3, #0]
    bDcRunning = FALSE;
 8106360:	4b1d      	ldr	r3, [pc, #116]	@ (81063d8 <StopInputHandler+0xcc>)
 8106362:	2200      	movs	r2, #0
 8106364:	701a      	strb	r2, [r3, #0]
    bSmSyncSequenceValid = FALSE;
 8106366:	4b1d      	ldr	r3, [pc, #116]	@ (81063dc <StopInputHandler+0xd0>)
 8106368:	2200      	movs	r2, #0
 810636a:	701a      	strb	r2, [r3, #0]
    u16SmSync0Value = 0;
 810636c:	4b1c      	ldr	r3, [pc, #112]	@ (81063e0 <StopInputHandler+0xd4>)
 810636e:	2200      	movs	r2, #0
 8106370:	801a      	strh	r2, [r3, #0]
    u16SmSync0Counter = 0;
 8106372:	4b1c      	ldr	r3, [pc, #112]	@ (81063e4 <StopInputHandler+0xd8>)
 8106374:	2200      	movs	r2, #0
 8106376:	801a      	strh	r2, [r3, #0]

    Sync0WdValue = 0;
 8106378:	4b1b      	ldr	r3, [pc, #108]	@ (81063e8 <StopInputHandler+0xdc>)
 810637a:	2200      	movs	r2, #0
 810637c:	801a      	strh	r2, [r3, #0]
    Sync0WdCounter = 0;
 810637e:	4b1b      	ldr	r3, [pc, #108]	@ (81063ec <StopInputHandler+0xe0>)
 8106380:	2200      	movs	r2, #0
 8106382:	801a      	strh	r2, [r3, #0]
    Sync1WdCounter = 0;
 8106384:	4b1a      	ldr	r3, [pc, #104]	@ (81063f0 <StopInputHandler+0xe4>)
 8106386:	2200      	movs	r2, #0
 8106388:	801a      	strh	r2, [r3, #0]
    Sync1WdValue = 0;
 810638a:	4b1a      	ldr	r3, [pc, #104]	@ (81063f4 <StopInputHandler+0xe8>)
 810638c:	2200      	movs	r2, #0
 810638e:	801a      	strh	r2, [r3, #0]
    LatchInputSync0Value = 0;
 8106390:	4b19      	ldr	r3, [pc, #100]	@ (81063f8 <StopInputHandler+0xec>)
 8106392:	2200      	movs	r2, #0
 8106394:	801a      	strh	r2, [r3, #0]
    LatchInputSync0Counter = 0;
 8106396:	4b19      	ldr	r3, [pc, #100]	@ (81063fc <StopInputHandler+0xf0>)
 8106398:	2200      	movs	r2, #0
 810639a:	801a      	strh	r2, [r3, #0]
/*ECATCHANGE_START(V5.11) ECAT4*/
    sSyncManInPar.u8SyncError = 0;
 810639c:	4b18      	ldr	r3, [pc, #96]	@ (8106400 <StopInputHandler+0xf4>)
 810639e:	2200      	movs	r2, #0
 81063a0:	f883 2040 	strb.w	r2, [r3, #64]	@ 0x40
/*ECATCHANGE_END(V5.11) ECAT4*/

    i16WaitForPllRunningTimeout = 0;
 81063a4:	4b17      	ldr	r3, [pc, #92]	@ (8106404 <StopInputHandler+0xf8>)
 81063a6:	2200      	movs	r2, #0
 81063a8:	801a      	strh	r2, [r3, #0]

    bWdTrigger = FALSE;
 81063aa:	4b17      	ldr	r3, [pc, #92]	@ (8106408 <StopInputHandler+0xfc>)
 81063ac:	2200      	movs	r2, #0
 81063ae:	701a      	strb	r2, [r3, #0]
    bEcatInputUpdateRunning = FALSE;
 81063b0:	4b16      	ldr	r3, [pc, #88]	@ (810640c <StopInputHandler+0x100>)
 81063b2:	2200      	movs	r2, #0
 81063b4:	701a      	strb	r2, [r3, #0]

    /*Indicate no user specified Sync mode*/
    bSyncSetByUser = FALSE;
 81063b6:	4b16      	ldr	r3, [pc, #88]	@ (8106410 <StopInputHandler+0x104>)
 81063b8:	2200      	movs	r2, #0
 81063ba:	701a      	strb	r2, [r3, #0]
}
 81063bc:	bf00      	nop
 81063be:	3708      	adds	r7, #8
 81063c0:	46bd      	mov	sp, r7
 81063c2:	bd80      	pop	{r7, pc}
 81063c4:	10000856 	.word	0x10000856
 81063c8:	10000854 	.word	0x10000854
 81063cc:	1000082a 	.word	0x1000082a
 81063d0:	10000848 	.word	0x10000848
 81063d4:	1000082c 	.word	0x1000082c
 81063d8:	10000830 	.word	0x10000830
 81063dc:	10000836 	.word	0x10000836
 81063e0:	10000834 	.word	0x10000834
 81063e4:	10000832 	.word	0x10000832
 81063e8:	1000083e 	.word	0x1000083e
 81063ec:	1000083c 	.word	0x1000083c
 81063f0:	10000840 	.word	0x10000840
 81063f4:	10000842 	.word	0x10000842
 81063f8:	10000844 	.word	0x10000844
 81063fc:	10000846 	.word	0x10000846
 8106400:	10000b4c 	.word	0x10000b4c
 8106404:	10000838 	.word	0x10000838
 8106408:	1000082b 	.word	0x1000082b
 810640c:	10000829 	.word	0x10000829
 8106410:	10000b01 	.word	0x10000b01

08106414 <BackToInitTransition>:
\brief    This function is called when a X to Init transition is completed

*////////////////////////////////////////////////////////////////////////////////////////

void BackToInitTransition(void)
{
 8106414:	b480      	push	{r7}
 8106416:	af00      	add	r7, sp, #0
    /* Reset indication that the user has written a sync mode*/
    bSyncSetByUser = FALSE;
 8106418:	4b03      	ldr	r3, [pc, #12]	@ (8106428 <BackToInitTransition+0x14>)
 810641a:	2200      	movs	r2, #0
 810641c:	701a      	strb	r2, [r3, #0]
}
 810641e:	bf00      	nop
 8106420:	46bd      	mov	sp, r7
 8106422:	f85d 7b04 	ldr.w	r7, [sp], #4
 8106426:	4770      	bx	lr
 8106428:	10000b01 	.word	0x10000b01

0810642c <SetALStatus>:
 \param alStatusCode    New AL Status Code (written to register 0x134)

  \brief  The function changes the state of the EtherCAT ASIC to the requested.
*////////////////////////////////////////////////////////////////////////////////////////
void SetALStatus(UINT8 alStatus, UINT16 alStatusCode)
{
 810642c:	b580      	push	{r7, lr}
 810642e:	b084      	sub	sp, #16
 8106430:	af00      	add	r7, sp, #0
 8106432:	4603      	mov	r3, r0
 8106434:	460a      	mov	r2, r1
 8106436:	71fb      	strb	r3, [r7, #7]
 8106438:	4613      	mov	r3, r2
 810643a:	80bb      	strh	r3, [r7, #4]
    UINT16 Value = alStatusCode;
 810643c:	88bb      	ldrh	r3, [r7, #4]
 810643e:	81fb      	strh	r3, [r7, #14]

    /*update global status variable if required*/
    if(nAlStatus != alStatus)
 8106440:	4b25      	ldr	r3, [pc, #148]	@ (81064d8 <SetALStatus+0xac>)
 8106442:	781b      	ldrb	r3, [r3, #0]
 8106444:	79fa      	ldrb	r2, [r7, #7]
 8106446:	429a      	cmp	r2, r3
 8106448:	d002      	beq.n	8106450 <SetALStatus+0x24>
    {
        nAlStatus = alStatus;
 810644a:	4a23      	ldr	r2, [pc, #140]	@ (81064d8 <SetALStatus+0xac>)
 810644c:	79fb      	ldrb	r3, [r7, #7]
 810644e:	7013      	strb	r3, [r2, #0]
    }


    if (alStatusCode != 0xFFFF)
 8106450:	88bb      	ldrh	r3, [r7, #4]
 8106452:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8106456:	4293      	cmp	r3, r2
 8106458:	d009      	beq.n	810646e <SetALStatus+0x42>
    {
        Value = SWAPWORD(Value);
 810645a:	89fb      	ldrh	r3, [r7, #14]
 810645c:	81fb      	strh	r3, [r7, #14]

        HW_EscWriteWord(Value,ESC_AL_STATUS_CODE_OFFSET);
 810645e:	f107 030e 	add.w	r3, r7, #14
 8106462:	2202      	movs	r2, #2
 8106464:	f44f 719a 	mov.w	r1, #308	@ 0x134
 8106468:	4618      	mov	r0, r3
 810646a:	f7fa fe85 	bl	8101178 <HW_EscWrite>
    }

    Value = nAlStatus;
 810646e:	4b1a      	ldr	r3, [pc, #104]	@ (81064d8 <SetALStatus+0xac>)
 8106470:	781b      	ldrb	r3, [r3, #0]
 8106472:	81fb      	strh	r3, [r7, #14]
    Value = SWAPWORD(Value);
 8106474:	89fb      	ldrh	r3, [r7, #14]
 8106476:	81fb      	strh	r3, [r7, #14]
    HW_EscWriteWord(Value,ESC_AL_STATUS_OFFSET);
 8106478:	f107 030e 	add.w	r3, r7, #14
 810647c:	2202      	movs	r2, #2
 810647e:	f44f 7198 	mov.w	r1, #304	@ 0x130
 8106482:	4618      	mov	r0, r3
 8106484:	f7fa fe78 	bl	8101178 <HW_EscWrite>

    /*The Run LED state is set in Set LED Indication, only the Error LED blink code is set here*/

    /*set Error blink code*/
    if(alStatusCode == 0x00 || !(alStatus & STATE_CHANGE))
 8106488:	88bb      	ldrh	r3, [r7, #4]
 810648a:	2b00      	cmp	r3, #0
 810648c:	d004      	beq.n	8106498 <SetALStatus+0x6c>
 810648e:	79fb      	ldrb	r3, [r7, #7]
 8106490:	f003 0310 	and.w	r3, r3, #16
 8106494:	2b00      	cmp	r3, #0
 8106496:	d103      	bne.n	81064a0 <SetALStatus+0x74>
    {
        u8EcatErrorLed = LED_OFF;
 8106498:	4b10      	ldr	r3, [pc, #64]	@ (81064dc <SetALStatus+0xb0>)
 810649a:	2200      	movs	r2, #0
 810649c:	701a      	strb	r2, [r3, #0]
 810649e:	e017      	b.n	81064d0 <SetALStatus+0xa4>
    }
    else if((alStatusCode == ALSTATUSCODE_NOSYNCERROR) ||
 81064a0:	88bb      	ldrh	r3, [r7, #4]
 81064a2:	2b2d      	cmp	r3, #45	@ 0x2d
 81064a4:	d005      	beq.n	81064b2 <SetALStatus+0x86>
 81064a6:	88bb      	ldrh	r3, [r7, #4]
 81064a8:	2b1a      	cmp	r3, #26
 81064aa:	d002      	beq.n	81064b2 <SetALStatus+0x86>
        (alStatusCode == ALSTATUSCODE_SYNCERROR) ||
 81064ac:	88bb      	ldrh	r3, [r7, #4]
 81064ae:	2b32      	cmp	r3, #50	@ 0x32
 81064b0:	d103      	bne.n	81064ba <SetALStatus+0x8e>
        (alStatusCode == ALSTATUSCODE_DCPLLSYNCERROR))
    {
        u8EcatErrorLed = LED_SINGLEFLASH;
 81064b2:	4b0a      	ldr	r3, [pc, #40]	@ (81064dc <SetALStatus+0xb0>)
 81064b4:	2241      	movs	r2, #65	@ 0x41
 81064b6:	701a      	strb	r2, [r3, #0]
 81064b8:	e00a      	b.n	81064d0 <SetALStatus+0xa4>
    }
    else if((alStatusCode == ALSTATUSCODE_SMWATCHDOG))
 81064ba:	88bb      	ldrh	r3, [r7, #4]
 81064bc:	2b1b      	cmp	r3, #27
 81064be:	d103      	bne.n	81064c8 <SetALStatus+0x9c>
    {
        u8EcatErrorLed = LED_DOUBLEFLASH;
 81064c0:	4b06      	ldr	r3, [pc, #24]	@ (81064dc <SetALStatus+0xb0>)
 81064c2:	2242      	movs	r2, #66	@ 0x42
 81064c4:	701a      	strb	r2, [r3, #0]
    }
    else
    {
        u8EcatErrorLed = LED_BLINKING;
    }
}
 81064c6:	e003      	b.n	81064d0 <SetALStatus+0xa4>
        u8EcatErrorLed = LED_BLINKING;
 81064c8:	4b04      	ldr	r3, [pc, #16]	@ (81064dc <SetALStatus+0xb0>)
 81064ca:	2240      	movs	r2, #64	@ 0x40
 81064cc:	701a      	strb	r2, [r3, #0]
}
 81064ce:	e7ff      	b.n	81064d0 <SetALStatus+0xa4>
 81064d0:	bf00      	nop
 81064d2:	3710      	adds	r7, #16
 81064d4:	46bd      	mov	sp, r7
 81064d6:	bd80      	pop	{r7, pc}
 81064d8:	1000085c 	.word	0x1000085c
 81064dc:	10000852 	.word	0x10000852

081064e0 <AL_ControlInd>:
              alControl contains the requested new state (INIT, PRE_OP or SAFE_OP)

*////////////////////////////////////////////////////////////////////////////////////////

void AL_ControlInd(UINT8 alControl, UINT16 alStatusCode)
{
 81064e0:	b580      	push	{r7, lr}
 81064e2:	b084      	sub	sp, #16
 81064e4:	af00      	add	r7, sp, #0
 81064e6:	4603      	mov	r3, r0
 81064e8:	460a      	mov	r2, r1
 81064ea:	71fb      	strb	r3, [r7, #7]
 81064ec:	4613      	mov	r3, r2
 81064ee:	80bb      	strh	r3, [r7, #4]
    UINT16        result = 0;
 81064f0:	2300      	movs	r3, #0
 81064f2:	81fb      	strh	r3, [r7, #14]
    UINT8            bErrAck = 0;
 81064f4:	2300      	movs	r3, #0
 81064f6:	737b      	strb	r3, [r7, #13]
    UINT8         stateTrans;
    /*deactivate ESM timeout counter*/
    EsmTimeoutCounter = -1;
 81064f8:	4bdb      	ldr	r3, [pc, #876]	@ (8106868 <AL_ControlInd+0x388>)
 81064fa:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 81064fe:	801a      	strh	r2, [r3, #0]
    bApplEsmPending = TRUE;
 8106500:	4bda      	ldr	r3, [pc, #872]	@ (810686c <AL_ControlInd+0x38c>)
 8106502:	2201      	movs	r2, #1
 8106504:	701a      	strb	r2, [r3, #0]

    /* reset the Error Flag in case of acknowledge by the Master */
    if ( alControl & STATE_CHANGE )
 8106506:	79fb      	ldrb	r3, [r7, #7]
 8106508:	f003 0310 	and.w	r3, r3, #16
 810650c:	2b00      	cmp	r3, #0
 810650e:	d009      	beq.n	8106524 <AL_ControlInd+0x44>
    {
        bErrAck = 1;
 8106510:	2301      	movs	r3, #1
 8106512:	737b      	strb	r3, [r7, #13]
        nAlStatus &= ~STATE_CHANGE;
 8106514:	4bd6      	ldr	r3, [pc, #856]	@ (8106870 <AL_ControlInd+0x390>)
 8106516:	781b      	ldrb	r3, [r3, #0]
 8106518:	f023 0310 	bic.w	r3, r3, #16
 810651c:	b2da      	uxtb	r2, r3
 810651e:	4bd4      	ldr	r3, [pc, #848]	@ (8106870 <AL_ControlInd+0x390>)
 8106520:	701a      	strb	r2, [r3, #0]
 8106522:	e012      	b.n	810654a <AL_ControlInd+0x6a>
        /*enable SM2 is moved to state transition block. First check SM Settings.*/
    }
    else if ( (nAlStatus & STATE_CHANGE)
 8106524:	4bd2      	ldr	r3, [pc, #840]	@ (8106870 <AL_ControlInd+0x390>)
 8106526:	781b      	ldrb	r3, [r3, #0]
 8106528:	f003 0310 	and.w	r3, r3, #16
 810652c:	2b00      	cmp	r3, #0
 810652e:	d005      	beq.n	810653c <AL_ControlInd+0x5c>
    // HBu 17.04.08: the error has to be acknowledged before when sending the same (or a higher) state
    //               (the error was acknowledged with the same state before independent of the acknowledge flag)
    /*Error Acknowledge with 0xX1 is allowed*/
           && (alControl & STATE_MASK) != STATE_INIT )
 8106530:	79fb      	ldrb	r3, [r7, #7]
 8106532:	f003 030f 	and.w	r3, r3, #15
 8106536:	2b01      	cmp	r3, #1
 8106538:	f040 8374 	bne.w	8106c24 <AL_ControlInd+0x744>
           is not set in the AL-Control, so the state cannot be set to a higher state
           and the new state request will be ignored */
        return;
    else
    {
        nAlStatus &= STATE_MASK;
 810653c:	4bcc      	ldr	r3, [pc, #816]	@ (8106870 <AL_ControlInd+0x390>)
 810653e:	781b      	ldrb	r3, [r3, #0]
 8106540:	f003 030f 	and.w	r3, r3, #15
 8106544:	b2da      	uxtb	r2, r3
 8106546:	4bca      	ldr	r3, [pc, #808]	@ (8106870 <AL_ControlInd+0x390>)
 8106548:	701a      	strb	r2, [r3, #0]
    }

    /* generate a variable for the state transition
      (Bit 0-3: new state (AL Control), Bit 4-7: old state (AL Status) */
    alControl &= STATE_MASK;
 810654a:	79fb      	ldrb	r3, [r7, #7]
 810654c:	f003 030f 	and.w	r3, r3, #15
 8106550:	71fb      	strb	r3, [r7, #7]
    stateTrans = nAlStatus;
 8106552:	4bc7      	ldr	r3, [pc, #796]	@ (8106870 <AL_ControlInd+0x390>)
 8106554:	781b      	ldrb	r3, [r3, #0]
 8106556:	733b      	strb	r3, [r7, #12]
    stateTrans <<= 4;
 8106558:	7b3b      	ldrb	r3, [r7, #12]
 810655a:	011b      	lsls	r3, r3, #4
 810655c:	733b      	strb	r3, [r7, #12]
    stateTrans += alControl;
 810655e:	7b3a      	ldrb	r2, [r7, #12]
 8106560:	79fb      	ldrb	r3, [r7, #7]
 8106562:	4413      	add	r3, r2
 8106564:	733b      	strb	r3, [r7, #12]


    /* check the SYNCM settings depending on the state transition */
    switch ( stateTrans )
 8106566:	7b3b      	ldrb	r3, [r7, #12]
 8106568:	2b88      	cmp	r3, #136	@ 0x88
 810656a:	d074      	beq.n	8106656 <AL_ControlInd+0x176>
 810656c:	2b88      	cmp	r3, #136	@ 0x88
 810656e:	dc7b      	bgt.n	8106668 <AL_ControlInd+0x188>
 8106570:	2b84      	cmp	r3, #132	@ 0x84
 8106572:	d070      	beq.n	8106656 <AL_ControlInd+0x176>
 8106574:	2b84      	cmp	r3, #132	@ 0x84
 8106576:	dc77      	bgt.n	8106668 <AL_ControlInd+0x188>
 8106578:	2b82      	cmp	r3, #130	@ 0x82
 810657a:	d05d      	beq.n	8106638 <AL_ControlInd+0x158>
 810657c:	2b82      	cmp	r3, #130	@ 0x82
 810657e:	dc73      	bgt.n	8106668 <AL_ControlInd+0x188>
 8106580:	2b12      	cmp	r3, #18
 8106582:	d059      	beq.n	8106638 <AL_ControlInd+0x158>
 8106584:	2b12      	cmp	r3, #18
 8106586:	db6f      	blt.n	8106668 <AL_ControlInd+0x188>
 8106588:	2b48      	cmp	r3, #72	@ 0x48
 810658a:	dc6d      	bgt.n	8106668 <AL_ControlInd+0x188>
 810658c:	2b22      	cmp	r3, #34	@ 0x22
 810658e:	db6b      	blt.n	8106668 <AL_ControlInd+0x188>
 8106590:	3b22      	subs	r3, #34	@ 0x22
 8106592:	2b26      	cmp	r3, #38	@ 0x26
 8106594:	d868      	bhi.n	8106668 <AL_ControlInd+0x188>
 8106596:	a201      	add	r2, pc, #4	@ (adr r2, 810659c <AL_ControlInd+0xbc>)
 8106598:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810659c:	08106639 	.word	0x08106639
 81065a0:	08106669 	.word	0x08106669
 81065a4:	08106645 	.word	0x08106645
 81065a8:	08106669 	.word	0x08106669
 81065ac:	08106669 	.word	0x08106669
 81065b0:	08106669 	.word	0x08106669
 81065b4:	08106669 	.word	0x08106669
 81065b8:	08106669 	.word	0x08106669
 81065bc:	08106669 	.word	0x08106669
 81065c0:	08106669 	.word	0x08106669
 81065c4:	08106669 	.word	0x08106669
 81065c8:	08106669 	.word	0x08106669
 81065cc:	08106669 	.word	0x08106669
 81065d0:	08106669 	.word	0x08106669
 81065d4:	08106669 	.word	0x08106669
 81065d8:	08106669 	.word	0x08106669
 81065dc:	08106669 	.word	0x08106669
 81065e0:	08106669 	.word	0x08106669
 81065e4:	08106669 	.word	0x08106669
 81065e8:	08106669 	.word	0x08106669
 81065ec:	08106669 	.word	0x08106669
 81065f0:	08106669 	.word	0x08106669
 81065f4:	08106669 	.word	0x08106669
 81065f8:	08106669 	.word	0x08106669
 81065fc:	08106669 	.word	0x08106669
 8106600:	08106669 	.word	0x08106669
 8106604:	08106669 	.word	0x08106669
 8106608:	08106669 	.word	0x08106669
 810660c:	08106669 	.word	0x08106669
 8106610:	08106669 	.word	0x08106669
 8106614:	08106669 	.word	0x08106669
 8106618:	08106669 	.word	0x08106669
 810661c:	08106639 	.word	0x08106639
 8106620:	08106669 	.word	0x08106669
 8106624:	08106657 	.word	0x08106657
 8106628:	08106669 	.word	0x08106669
 810662c:	08106669 	.word	0x08106669
 8106630:	08106669 	.word	0x08106669
 8106634:	08106657 	.word	0x08106657
    case SAFEOP_2_PREOP:
    case PREOP_2_PREOP:
        /* in PREOP only the SYNCM settings for SYNCM0 and SYNCM1 (mailbox)
           are checked, if result is unequal 0, the slave will stay in or
           switch to INIT and set the ErrorInd Bit (bit 4) of the AL-Status */
        result = CheckSmSettings(MAILBOX_READ+1);
 8106638:	2002      	movs	r0, #2
 810663a:	f7ff f871 	bl	8105720 <CheckSmSettings>
 810663e:	4603      	mov	r3, r0
 8106640:	81fb      	strh	r3, [r7, #14]
        break;
 8106642:	e011      	b.n	8106668 <AL_ControlInd+0x188>
        /* before checking the SYNCM settings for SYNCM2 and SYNCM3 (process data)
           the expected length of input data (nPdInputSize) and output data (nPdOutputSize)
            could be adapted (changed by PDO-Assign and/or PDO-Mapping)
            if result is unequal 0, the slave will stay in PREOP and set
            the ErrorInd Bit (bit 4) of the AL-Status */
        result = APPL_GenerateMapping(&nPdInputSize,&nPdOutputSize);
 8106644:	498b      	ldr	r1, [pc, #556]	@ (8106874 <AL_ControlInd+0x394>)
 8106646:	488c      	ldr	r0, [pc, #560]	@ (8106878 <AL_ControlInd+0x398>)
 8106648:	f7fa f9a4 	bl	8100994 <APPL_GenerateMapping>
 810664c:	4603      	mov	r3, r0
 810664e:	81fb      	strh	r3, [r7, #14]

        if (result != 0)
 8106650:	89fb      	ldrh	r3, [r7, #14]
 8106652:	2b00      	cmp	r3, #0
 8106654:	d107      	bne.n	8106666 <AL_ControlInd+0x186>
    case SAFEOP_2_SAFEOP:
    case OP_2_OP:
        /* in SAFEOP or OP the SYNCM settings for all SYNCM are checked
           if result is unequal 0, the slave will stay in or
           switch to PREOP and set the ErrorInd Bit (bit 4) of the AL-Status */
        result = CheckSmSettings(nMaxSyncMan);
 8106656:	4b89      	ldr	r3, [pc, #548]	@ (810687c <AL_ControlInd+0x39c>)
 8106658:	781b      	ldrb	r3, [r3, #0]
 810665a:	4618      	mov	r0, r3
 810665c:	f7ff f860 	bl	8105720 <CheckSmSettings>
 8106660:	4603      	mov	r3, r0
 8106662:	81fb      	strh	r3, [r7, #14]
        break;
 8106664:	e000      	b.n	8106668 <AL_ControlInd+0x188>
            break;
 8106666:	bf00      	nop
    }

    if ( result == 0 )
 8106668:	89fb      	ldrh	r3, [r7, #14]
 810666a:	2b00      	cmp	r3, #0
 810666c:	f040 8203 	bne.w	8106a76 <AL_ControlInd+0x596>
    {
        /* execute the corresponding local management service(s) depending on the state transition */
        nEcatStateTrans = 0;
 8106670:	4b83      	ldr	r3, [pc, #524]	@ (8106880 <AL_ControlInd+0x3a0>)
 8106672:	2200      	movs	r2, #0
 8106674:	801a      	strh	r2, [r3, #0]
        switch ( stateTrans )
 8106676:	7b3b      	ldrb	r3, [r7, #12]
 8106678:	3b11      	subs	r3, #17
 810667a:	2b77      	cmp	r3, #119	@ 0x77
 810667c:	f200 81f8 	bhi.w	8106a70 <AL_ControlInd+0x590>
 8106680:	a201      	add	r2, pc, #4	@ (adr r2, 8106688 <AL_ControlInd+0x1a8>)
 8106682:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8106686:	bf00      	nop
 8106688:	08106a1f 	.word	0x08106a1f
 810668c:	08106895 	.word	0x08106895
 8106690:	08106885 	.word	0x08106885
 8106694:	08106a6b 	.word	0x08106a6b
 8106698:	08106a71 	.word	0x08106a71
 810669c:	08106a71 	.word	0x08106a71
 81066a0:	08106a71 	.word	0x08106a71
 81066a4:	08106a6b 	.word	0x08106a6b
 81066a8:	08106a71 	.word	0x08106a71
 81066ac:	08106a71 	.word	0x08106a71
 81066b0:	08106a71 	.word	0x08106a71
 81066b4:	08106a71 	.word	0x08106a71
 81066b8:	08106a71 	.word	0x08106a71
 81066bc:	08106a71 	.word	0x08106a71
 81066c0:	08106a71 	.word	0x08106a71
 81066c4:	08106a71 	.word	0x08106a71
 81066c8:	08106a0d 	.word	0x08106a0d
 81066cc:	08106a23 	.word	0x08106a23
 81066d0:	08106a6b 	.word	0x08106a6b
 81066d4:	081068f7 	.word	0x081068f7
 81066d8:	08106a71 	.word	0x08106a71
 81066dc:	08106a71 	.word	0x08106a71
 81066e0:	08106a71 	.word	0x08106a71
 81066e4:	08106a6b 	.word	0x08106a6b
 81066e8:	08106a71 	.word	0x08106a71
 81066ec:	08106a71 	.word	0x08106a71
 81066f0:	08106a71 	.word	0x08106a71
 81066f4:	08106a71 	.word	0x08106a71
 81066f8:	08106a71 	.word	0x08106a71
 81066fc:	08106a71 	.word	0x08106a71
 8106700:	08106a71 	.word	0x08106a71
 8106704:	08106a71 	.word	0x08106a71
 8106708:	0810688b 	.word	0x0810688b
 810670c:	08106a6b 	.word	0x08106a6b
 8106710:	08106a71 	.word	0x08106a71
 8106714:	08106a6b 	.word	0x08106a6b
 8106718:	08106a71 	.word	0x08106a71
 810671c:	08106a71 	.word	0x08106a71
 8106720:	08106a71 	.word	0x08106a71
 8106724:	08106a6b 	.word	0x08106a6b
 8106728:	08106a71 	.word	0x08106a71
 810672c:	08106a71 	.word	0x08106a71
 8106730:	08106a71 	.word	0x08106a71
 8106734:	08106a71 	.word	0x08106a71
 8106738:	08106a71 	.word	0x08106a71
 810673c:	08106a71 	.word	0x08106a71
 8106740:	08106a71 	.word	0x08106a71
 8106744:	08106a71 	.word	0x08106a71
 8106748:	081069f1 	.word	0x081069f1
 810674c:	081069c5 	.word	0x081069c5
 8106750:	08106a6b 	.word	0x08106a6b
 8106754:	08106a23 	.word	0x08106a23
 8106758:	08106a71 	.word	0x08106a71
 810675c:	08106a71 	.word	0x08106a71
 8106760:	08106a71 	.word	0x08106a71
 8106764:	0810694d 	.word	0x0810694d
 8106768:	08106a71 	.word	0x08106a71
 810676c:	08106a71 	.word	0x08106a71
 8106770:	08106a71 	.word	0x08106a71
 8106774:	08106a71 	.word	0x08106a71
 8106778:	08106a71 	.word	0x08106a71
 810677c:	08106a71 	.word	0x08106a71
 8106780:	08106a71 	.word	0x08106a71
 8106784:	08106a71 	.word	0x08106a71
 8106788:	08106a71 	.word	0x08106a71
 810678c:	08106a71 	.word	0x08106a71
 8106790:	08106a71 	.word	0x08106a71
 8106794:	08106a71 	.word	0x08106a71
 8106798:	08106a71 	.word	0x08106a71
 810679c:	08106a71 	.word	0x08106a71
 81067a0:	08106a71 	.word	0x08106a71
 81067a4:	08106a71 	.word	0x08106a71
 81067a8:	08106a71 	.word	0x08106a71
 81067ac:	08106a71 	.word	0x08106a71
 81067b0:	08106a71 	.word	0x08106a71
 81067b4:	08106a71 	.word	0x08106a71
 81067b8:	08106a71 	.word	0x08106a71
 81067bc:	08106a71 	.word	0x08106a71
 81067c0:	08106a71 	.word	0x08106a71
 81067c4:	08106a71 	.word	0x08106a71
 81067c8:	08106a71 	.word	0x08106a71
 81067cc:	08106a71 	.word	0x08106a71
 81067d0:	08106a71 	.word	0x08106a71
 81067d4:	08106a71 	.word	0x08106a71
 81067d8:	08106a71 	.word	0x08106a71
 81067dc:	08106a71 	.word	0x08106a71
 81067e0:	08106a71 	.word	0x08106a71
 81067e4:	08106a71 	.word	0x08106a71
 81067e8:	08106a71 	.word	0x08106a71
 81067ec:	08106a71 	.word	0x08106a71
 81067f0:	08106a71 	.word	0x08106a71
 81067f4:	08106a71 	.word	0x08106a71
 81067f8:	08106a71 	.word	0x08106a71
 81067fc:	08106a71 	.word	0x08106a71
 8106800:	08106a71 	.word	0x08106a71
 8106804:	08106a71 	.word	0x08106a71
 8106808:	08106a71 	.word	0x08106a71
 810680c:	08106a71 	.word	0x08106a71
 8106810:	08106a71 	.word	0x08106a71
 8106814:	08106a71 	.word	0x08106a71
 8106818:	08106a71 	.word	0x08106a71
 810681c:	08106a71 	.word	0x08106a71
 8106820:	08106a71 	.word	0x08106a71
 8106824:	08106a71 	.word	0x08106a71
 8106828:	08106a71 	.word	0x08106a71
 810682c:	08106a71 	.word	0x08106a71
 8106830:	08106a71 	.word	0x08106a71
 8106834:	08106a71 	.word	0x08106a71
 8106838:	08106a71 	.word	0x08106a71
 810683c:	08106a71 	.word	0x08106a71
 8106840:	08106a71 	.word	0x08106a71
 8106844:	08106a71 	.word	0x08106a71
 8106848:	081069d5 	.word	0x081069d5
 810684c:	081069a7 	.word	0x081069a7
 8106850:	08106a6b 	.word	0x08106a6b
 8106854:	08106997 	.word	0x08106997
 8106858:	08106a71 	.word	0x08106a71
 810685c:	08106a71 	.word	0x08106a71
 8106860:	08106a71 	.word	0x08106a71
 8106864:	08106a23 	.word	0x08106a23
 8106868:	1000082e 	.word	0x1000082e
 810686c:	1000084e 	.word	0x1000084e
 8106870:	1000085c 	.word	0x1000085c
 8106874:	10000856 	.word	0x10000856
 8106878:	10000854 	.word	0x10000854
 810687c:	10000858 	.word	0x10000858
 8106880:	10000850 	.word	0x10000850
        {
        case INIT_2_BOOT    :
            result = ALSTATUSCODE_BOOTNOTSUPP;
 8106884:	2313      	movs	r3, #19
 8106886:	81fb      	strh	r3, [r7, #14]
            break;
 8106888:	e122      	b.n	8106ad0 <AL_ControlInd+0x5f0>

        case BOOT_2_INIT    :
            result = ALSTATUSCODE_BOOTNOTSUPP;
 810688a:	2313      	movs	r3, #19
 810688c:	81fb      	strh	r3, [r7, #14]

            BackToInitTransition();
 810688e:	f7ff fdc1 	bl	8106414 <BackToInitTransition>

            break;
 8106892:	e11d      	b.n	8106ad0 <AL_ControlInd+0x5f0>
        case INIT_2_PREOP :

           UpdateEEPROMLoadedState();
 8106894:	f7fe feb6 	bl	8105604 <UpdateEEPROMLoadedState>

            if (EepromLoaded == FALSE)
 8106898:	4ba5      	ldr	r3, [pc, #660]	@ (8106b30 <AL_ControlInd+0x650>)
 810689a:	781b      	ldrb	r3, [r3, #0]
 810689c:	2b00      	cmp	r3, #0
 810689e:	d101      	bne.n	81068a4 <AL_ControlInd+0x3c4>
            {
                //return an error if the EEPROM was not loaded correct  (device restart is required after the new EEPORM update)
                result = ALSTATUSCODE_EE_ERROR;
 81068a0:	2351      	movs	r3, #81	@ 0x51
 81068a2:	81fb      	strh	r3, [r7, #14]
            }
            if (result == 0)
 81068a4:	89fb      	ldrh	r3, [r7, #14]
 81068a6:	2b00      	cmp	r3, #0
 81068a8:	f040 8107 	bne.w	8106aba <AL_ControlInd+0x5da>
            {
            /* MBX_StartMailboxHandler (in mailbox.c) checks if the areas of the mailbox
               sync managers SYNCM0 and SYNCM1 overlap each other
              if result is unequal 0, the slave will stay in INIT
              and sets the ErrorInd Bit (bit 4) of the AL-Status */
            result = MBX_StartMailboxHandler();
 81068ac:	f000 fdbe 	bl	810742c <MBX_StartMailboxHandler>
 81068b0:	4603      	mov	r3, r0
 81068b2:	81fb      	strh	r3, [r7, #14]
            if (result == 0)
 81068b4:	89fb      	ldrh	r3, [r7, #14]
 81068b6:	2b00      	cmp	r3, #0
 81068b8:	d10c      	bne.n	81068d4 <AL_ControlInd+0x3f4>
            {
                bApplEsmPending = FALSE;
 81068ba:	4b9e      	ldr	r3, [pc, #632]	@ (8106b34 <AL_ControlInd+0x654>)
 81068bc:	2200      	movs	r2, #0
 81068be:	701a      	strb	r2, [r3, #0]
                /* additionally there could be an application specific check (in ecatappl.c)
                   if the state transition from INIT to PREOP should be done
                 if result is unequal 0, the slave will stay in INIT
                 and sets the ErrorInd Bit (bit 4) of the AL-Status */
                result = APPL_StartMailboxHandler();
 81068c0:	f7fa f835 	bl	810092e <APPL_StartMailboxHandler>
 81068c4:	4603      	mov	r3, r0
 81068c6:	81fb      	strh	r3, [r7, #14]
                if ( result == 0 )
 81068c8:	89fb      	ldrh	r3, [r7, #14]
 81068ca:	2b00      	cmp	r3, #0
 81068cc:	d102      	bne.n	81068d4 <AL_ControlInd+0x3f4>
                {
                    bMbxRunning = TRUE;
 81068ce:	4b9a      	ldr	r3, [pc, #616]	@ (8106b38 <AL_ControlInd+0x658>)
 81068d0:	2201      	movs	r2, #1
 81068d2:	701a      	strb	r2, [r3, #0]
                }
            }

            if(result != 0 && result != NOERROR_INWORK)
 81068d4:	89fb      	ldrh	r3, [r7, #14]
 81068d6:	2b00      	cmp	r3, #0
 81068d8:	f000 80ef 	beq.w	8106aba <AL_ControlInd+0x5da>
 81068dc:	89fb      	ldrh	r3, [r7, #14]
 81068de:	2bff      	cmp	r3, #255	@ 0xff
 81068e0:	f000 80eb 	beq.w	8106aba <AL_ControlInd+0x5da>
            {
                /*Stop APPL Mbx handler if APPL Start Mbx handler was called before*/
                if(!bApplEsmPending)
 81068e4:	4b93      	ldr	r3, [pc, #588]	@ (8106b34 <AL_ControlInd+0x654>)
 81068e6:	781b      	ldrb	r3, [r3, #0]
 81068e8:	2b00      	cmp	r3, #0
 81068ea:	d101      	bne.n	81068f0 <AL_ControlInd+0x410>
                    APPL_StopMailboxHandler();
 81068ec:	f7fa f827 	bl	810093e <APPL_StopMailboxHandler>

                 MBX_StopMailboxHandler();
 81068f0:	f000 fe12 	bl	8107518 <MBX_StopMailboxHandler>
            }

            }
            break;
 81068f4:	e0e1      	b.n	8106aba <AL_ControlInd+0x5da>

        case PREOP_2_SAFEOP:
            /* start the input handler (function is defined above) */
            result = StartInputHandler();
 81068f6:	f7ff f90f 	bl	8105b18 <StartInputHandler>
 81068fa:	4603      	mov	r3, r0
 81068fc:	81fb      	strh	r3, [r7, #14]
            if ( result == 0 )
 81068fe:	89fb      	ldrh	r3, [r7, #14]
 8106900:	2b00      	cmp	r3, #0
 8106902:	d112      	bne.n	810692a <AL_ControlInd+0x44a>
            {
                bApplEsmPending = FALSE;
 8106904:	4b8b      	ldr	r3, [pc, #556]	@ (8106b34 <AL_ControlInd+0x654>)
 8106906:	2200      	movs	r2, #0
 8106908:	701a      	strb	r2, [r3, #0]
                result = APPL_StartInputHandler(&u16ALEventMask);
 810690a:	488c      	ldr	r0, [pc, #560]	@ (8106b3c <AL_ControlInd+0x65c>)
 810690c:	f7fa f81f 	bl	810094e <APPL_StartInputHandler>
 8106910:	4603      	mov	r3, r0
 8106912:	81fb      	strh	r3, [r7, #14]

                if(result == 0)
 8106914:	89fb      	ldrh	r3, [r7, #14]
 8106916:	2b00      	cmp	r3, #0
 8106918:	d107      	bne.n	810692a <AL_ControlInd+0x44a>
                {
                    /* initialize the AL Event Mask register (0x204) */
/*ECATCHANGE_START(V5.11) HW1*/
                    SetALEventMask( u16ALEventMask );
 810691a:	4b88      	ldr	r3, [pc, #544]	@ (8106b3c <AL_ControlInd+0x65c>)
 810691c:	881b      	ldrh	r3, [r3, #0]
 810691e:	4618      	mov	r0, r3
 8106920:	f7fe fe4c 	bl	81055bc <SetALEventMask>
/*ECATCHANGE_END(V5.11) HW1*/

                    bEcatInputUpdateRunning = TRUE;
 8106924:	4b86      	ldr	r3, [pc, #536]	@ (8106b40 <AL_ControlInd+0x660>)
 8106926:	2201      	movs	r2, #1
 8106928:	701a      	strb	r2, [r3, #0]
                }
            }

            /*if one start input handler returned an error stop the input handler*/
            if(result != 0 && result != NOERROR_INWORK)
 810692a:	89fb      	ldrh	r3, [r7, #14]
 810692c:	2b00      	cmp	r3, #0
 810692e:	f000 80c6 	beq.w	8106abe <AL_ControlInd+0x5de>
 8106932:	89fb      	ldrh	r3, [r7, #14]
 8106934:	2bff      	cmp	r3, #255	@ 0xff
 8106936:	f000 80c2 	beq.w	8106abe <AL_ControlInd+0x5de>
            {
                if(!bApplEsmPending)
 810693a:	4b7e      	ldr	r3, [pc, #504]	@ (8106b34 <AL_ControlInd+0x654>)
 810693c:	781b      	ldrb	r3, [r3, #0]
 810693e:	2b00      	cmp	r3, #0
 8106940:	d101      	bne.n	8106946 <AL_ControlInd+0x466>
                {
                    /*Call only the APPL stop handler if the APPL start handler was called before*/
                    /*The application can react to the state transition in the function APPL_StopInputHandler */
                    APPL_StopInputHandler();
 8106942:	f7fa f80f 	bl	8100964 <APPL_StopInputHandler>
                }

                StopInputHandler();
 8106946:	f7ff fce1 	bl	810630c <StopInputHandler>
            }
            break;
 810694a:	e0b8      	b.n	8106abe <AL_ControlInd+0x5de>

        case SAFEOP_2_OP:
            /* start the output handler (function is defined above) */
            result = StartOutputHandler();
 810694c:	f7ff fca4 	bl	8106298 <StartOutputHandler>
 8106950:	4603      	mov	r3, r0
 8106952:	81fb      	strh	r3, [r7, #14]
            if(result == 0)
 8106954:	89fb      	ldrh	r3, [r7, #14]
 8106956:	2b00      	cmp	r3, #0
 8106958:	d10c      	bne.n	8106974 <AL_ControlInd+0x494>
            {
                bApplEsmPending = FALSE;
 810695a:	4b76      	ldr	r3, [pc, #472]	@ (8106b34 <AL_ControlInd+0x654>)
 810695c:	2200      	movs	r2, #0
 810695e:	701a      	strb	r2, [r3, #0]
                result = APPL_StartOutputHandler();
 8106960:	f7fa f808 	bl	8100974 <APPL_StartOutputHandler>
 8106964:	4603      	mov	r3, r0
 8106966:	81fb      	strh	r3, [r7, #14]

                if(result == 0)
 8106968:	89fb      	ldrh	r3, [r7, #14]
 810696a:	2b00      	cmp	r3, #0
 810696c:	d102      	bne.n	8106974 <AL_ControlInd+0x494>
                {
                    /*Device is in OPERATINAL*/
                    bEcatOutputUpdateRunning = TRUE;
 810696e:	4b75      	ldr	r3, [pc, #468]	@ (8106b44 <AL_ControlInd+0x664>)
 8106970:	2201      	movs	r2, #1
 8106972:	701a      	strb	r2, [r3, #0]
                }

            }

            if ( result != 0 && result != NOERROR_INWORK)
 8106974:	89fb      	ldrh	r3, [r7, #14]
 8106976:	2b00      	cmp	r3, #0
 8106978:	f000 80a3 	beq.w	8106ac2 <AL_ControlInd+0x5e2>
 810697c:	89fb      	ldrh	r3, [r7, #14]
 810697e:	2bff      	cmp	r3, #255	@ 0xff
 8106980:	f000 809f 	beq.w	8106ac2 <AL_ControlInd+0x5e2>
            {
                if(!bApplEsmPending)
 8106984:	4b6b      	ldr	r3, [pc, #428]	@ (8106b34 <AL_ControlInd+0x654>)
 8106986:	781b      	ldrb	r3, [r3, #0]
 8106988:	2b00      	cmp	r3, #0
 810698a:	d101      	bne.n	8106990 <AL_ControlInd+0x4b0>
                    APPL_StopOutputHandler();
 810698c:	f7f9 fffa 	bl	8100984 <APPL_StopOutputHandler>

                StopOutputHandler();
 8106990:	f7ff fcaa 	bl	81062e8 <StopOutputHandler>
            }

            break;
 8106994:	e095      	b.n	8106ac2 <AL_ControlInd+0x5e2>

        case OP_2_SAFEOP:
            /* stop the output handler (function is defined above) */
            APPL_StopOutputHandler();
 8106996:	f7f9 fff5 	bl	8100984 <APPL_StopOutputHandler>

            StopOutputHandler();
 810699a:	f7ff fca5 	bl	81062e8 <StopOutputHandler>

            bApplEsmPending = FALSE;
 810699e:	4b65      	ldr	r3, [pc, #404]	@ (8106b34 <AL_ControlInd+0x654>)
 81069a0:	2200      	movs	r2, #0
 81069a2:	701a      	strb	r2, [r3, #0]

            break;
 81069a4:	e094      	b.n	8106ad0 <AL_ControlInd+0x5f0>

        case OP_2_PREOP:
            /* stop the output handler (function is defined above) */
            result = APPL_StopOutputHandler();
 81069a6:	f7f9 ffed 	bl	8100984 <APPL_StopOutputHandler>
 81069aa:	4603      	mov	r3, r0
 81069ac:	81fb      	strh	r3, [r7, #14]

            StopOutputHandler();
 81069ae:	f7ff fc9b 	bl	81062e8 <StopOutputHandler>

            bApplEsmPending = FALSE;
 81069b2:	4b60      	ldr	r3, [pc, #384]	@ (8106b34 <AL_ControlInd+0x654>)
 81069b4:	2200      	movs	r2, #0
 81069b6:	701a      	strb	r2, [r3, #0]

            if (result != 0)
 81069b8:	89fb      	ldrh	r3, [r7, #14]
 81069ba:	2b00      	cmp	r3, #0
 81069bc:	f040 8083 	bne.w	8106ac6 <AL_ControlInd+0x5e6>
                break;

            stateTrans = SAFEOP_2_PREOP;
 81069c0:	2342      	movs	r3, #66	@ 0x42
 81069c2:	733b      	strb	r3, [r7, #12]

        case SAFEOP_2_PREOP:
            /* stop the input handler (function is defined above) */
            APPL_StopInputHandler();
 81069c4:	f7f9 ffce 	bl	8100964 <APPL_StopInputHandler>
           
            StopInputHandler();
 81069c8:	f7ff fca0 	bl	810630c <StopInputHandler>

            bApplEsmPending = FALSE;
 81069cc:	4b59      	ldr	r3, [pc, #356]	@ (8106b34 <AL_ControlInd+0x654>)
 81069ce:	2200      	movs	r2, #0
 81069d0:	701a      	strb	r2, [r3, #0]

            break;
 81069d2:	e07d      	b.n	8106ad0 <AL_ControlInd+0x5f0>

        case OP_2_INIT:
            /* stop the output handler (function is defined above) */
            result = APPL_StopOutputHandler();
 81069d4:	f7f9 ffd6 	bl	8100984 <APPL_StopOutputHandler>
 81069d8:	4603      	mov	r3, r0
 81069da:	81fb      	strh	r3, [r7, #14]

            StopOutputHandler();
 81069dc:	f7ff fc84 	bl	81062e8 <StopOutputHandler>

            bApplEsmPending = FALSE;
 81069e0:	4b54      	ldr	r3, [pc, #336]	@ (8106b34 <AL_ControlInd+0x654>)
 81069e2:	2200      	movs	r2, #0
 81069e4:	701a      	strb	r2, [r3, #0]

            if (result != 0)
 81069e6:	89fb      	ldrh	r3, [r7, #14]
 81069e8:	2b00      	cmp	r3, #0
 81069ea:	d16e      	bne.n	8106aca <AL_ControlInd+0x5ea>
                break;
            
            stateTrans = SAFEOP_2_INIT;
 81069ec:	2341      	movs	r3, #65	@ 0x41
 81069ee:	733b      	strb	r3, [r7, #12]

        case SAFEOP_2_INIT:
            /* stop the input handler (function is defined above) */
            result = APPL_StopInputHandler();
 81069f0:	f7f9 ffb8 	bl	8100964 <APPL_StopInputHandler>
 81069f4:	4603      	mov	r3, r0
 81069f6:	81fb      	strh	r3, [r7, #14]
            
            StopInputHandler();
 81069f8:	f7ff fc88 	bl	810630c <StopInputHandler>

            bApplEsmPending = FALSE;
 81069fc:	4b4d      	ldr	r3, [pc, #308]	@ (8106b34 <AL_ControlInd+0x654>)
 81069fe:	2200      	movs	r2, #0
 8106a00:	701a      	strb	r2, [r3, #0]

            if (result != 0)
 8106a02:	89fb      	ldrh	r3, [r7, #14]
 8106a04:	2b00      	cmp	r3, #0
 8106a06:	d162      	bne.n	8106ace <AL_ControlInd+0x5ee>
                break;
            stateTrans = PREOP_2_INIT;
 8106a08:	2321      	movs	r3, #33	@ 0x21
 8106a0a:	733b      	strb	r3, [r7, #12]

        case PREOP_2_INIT:
            MBX_StopMailboxHandler();
 8106a0c:	f000 fd84 	bl	8107518 <MBX_StopMailboxHandler>
            result = APPL_StopMailboxHandler();
 8106a10:	f7f9 ff95 	bl	810093e <APPL_StopMailboxHandler>
 8106a14:	4603      	mov	r3, r0
 8106a16:	81fb      	strh	r3, [r7, #14]

            BackToInitTransition();
 8106a18:	f7ff fcfc 	bl	8106414 <BackToInitTransition>
            break;
 8106a1c:	e058      	b.n	8106ad0 <AL_ControlInd+0x5f0>

        case INIT_2_INIT:
            BackToInitTransition();
 8106a1e:	f7ff fcf9 	bl	8106414 <BackToInitTransition>
        case PREOP_2_PREOP:
        case SAFEOP_2_SAFEOP:
        case OP_2_OP:
            if(bErrAck)
 8106a22:	7b7b      	ldrb	r3, [r7, #13]
 8106a24:	2b00      	cmp	r3, #0
 8106a26:	d004      	beq.n	8106a32 <AL_ControlInd+0x552>
                APPL_AckErrorInd(stateTrans);
 8106a28:	7b3b      	ldrb	r3, [r7, #12]
 8106a2a:	b29b      	uxth	r3, r3
 8106a2c:	4618      	mov	r0, r3
 8106a2e:	f7f9 ff73 	bl	8100918 <APPL_AckErrorInd>

            if(!bLocalErrorFlag)
 8106a32:	4b45      	ldr	r3, [pc, #276]	@ (8106b48 <AL_ControlInd+0x668>)
 8106a34:	781b      	ldrb	r3, [r3, #0]
 8106a36:	2b00      	cmp	r3, #0
 8106a38:	d114      	bne.n	8106a64 <AL_ControlInd+0x584>
            {
                /*no local error flag is currently active, enable SM*/
                if ( nAlStatus & (STATE_SAFEOP | STATE_OP))
 8106a3a:	4b44      	ldr	r3, [pc, #272]	@ (8106b4c <AL_ControlInd+0x66c>)
 8106a3c:	781b      	ldrb	r3, [r3, #0]
 8106a3e:	f003 030c 	and.w	r3, r3, #12
 8106a42:	2b00      	cmp	r3, #0
 8106a44:	d00e      	beq.n	8106a64 <AL_ControlInd+0x584>
                {
                    if(nPdOutputSize > 0)
 8106a46:	4b42      	ldr	r3, [pc, #264]	@ (8106b50 <AL_ControlInd+0x670>)
 8106a48:	881b      	ldrh	r3, [r3, #0]
 8106a4a:	2b00      	cmp	r3, #0
 8106a4c:	d003      	beq.n	8106a56 <AL_ControlInd+0x576>
                    {
/*ECATCHANGE_START(V5.11) HW1*/
                        EnableSyncManChannel(PROCESS_DATA_OUT);
 8106a4e:	2002      	movs	r0, #2
 8106a50:	f7fe fe3e 	bl	81056d0 <EnableSyncManChannel>
 8106a54:	e006      	b.n	8106a64 <AL_ControlInd+0x584>
/*ECATCHANGE_END(V5.11) HW1*/
                    }
                    else 
                    if(nPdInputSize > 0)
 8106a56:	4b3f      	ldr	r3, [pc, #252]	@ (8106b54 <AL_ControlInd+0x674>)
 8106a58:	881b      	ldrh	r3, [r3, #0]
 8106a5a:	2b00      	cmp	r3, #0
 8106a5c:	d002      	beq.n	8106a64 <AL_ControlInd+0x584>
                    {
/*ECATCHANGE_START(V5.11) HW1*/
                        EnableSyncManChannel(PROCESS_DATA_IN);
 8106a5e:	2003      	movs	r0, #3
 8106a60:	f7fe fe36 	bl	81056d0 <EnableSyncManChannel>
/*ECATCHANGE_END(V5.11) HW1*/
                    }
                }
            }
            result = NOERROR_NOSTATECHANGE;
 8106a64:	23fe      	movs	r3, #254	@ 0xfe
 8106a66:	81fb      	strh	r3, [r7, #14]
            break;
 8106a68:	e032      	b.n	8106ad0 <AL_ControlInd+0x5f0>
        case SAFEOP_2_BOOT:
        case OP_2_BOOT:
        case BOOT_2_PREOP:
        case BOOT_2_SAFEOP:
        case BOOT_2_OP:
            result = ALSTATUSCODE_INVALIDALCONTROL;
 8106a6a:	2311      	movs	r3, #17
 8106a6c:	81fb      	strh	r3, [r7, #14]
            break;
 8106a6e:	e02f      	b.n	8106ad0 <AL_ControlInd+0x5f0>

        default:
            result = ALSTATUSCODE_UNKNOWNALCONTROL;
 8106a70:	2312      	movs	r3, #18
 8106a72:	81fb      	strh	r3, [r7, #14]
            break;
 8106a74:	e02c      	b.n	8106ad0 <AL_ControlInd+0x5f0>
    }
    else
    {
        /* the checking of the sync manager settings was not successful
            switch back the state to PREOP or INIT */
        switch (nAlStatus)
 8106a76:	4b35      	ldr	r3, [pc, #212]	@ (8106b4c <AL_ControlInd+0x66c>)
 8106a78:	781b      	ldrb	r3, [r3, #0]
 8106a7a:	2b08      	cmp	r3, #8
 8106a7c:	d006      	beq.n	8106a8c <AL_ControlInd+0x5ac>
 8106a7e:	2b08      	cmp	r3, #8
 8106a80:	dc26      	bgt.n	8106ad0 <AL_ControlInd+0x5f0>
 8106a82:	2b02      	cmp	r3, #2
 8106a84:	d00a      	beq.n	8106a9c <AL_ControlInd+0x5bc>
 8106a86:	2b04      	cmp	r3, #4
 8106a88:	d004      	beq.n	8106a94 <AL_ControlInd+0x5b4>
 8106a8a:	e021      	b.n	8106ad0 <AL_ControlInd+0x5f0>
        {
        case STATE_OP:
            /* stop the output handler (function is defined above) */
            APPL_StopOutputHandler();
 8106a8c:	f7f9 ff7a 	bl	8100984 <APPL_StopOutputHandler>
            StopOutputHandler();
 8106a90:	f7ff fc2a 	bl	81062e8 <StopOutputHandler>
        case STATE_SAFEOP:
            /* stop the input handler (function is defined above) */
            APPL_StopInputHandler();
 8106a94:	f7f9 ff66 	bl	8100964 <APPL_StopInputHandler>

            StopInputHandler();
 8106a98:	f7ff fc38 	bl	810630c <StopInputHandler>

        case STATE_PREOP:

            if ( result == ALSTATUSCODE_INVALIDMBXCFGINPREOP )
 8106a9c:	89fb      	ldrh	r3, [r7, #14]
 8106a9e:	2b16      	cmp	r3, #22
 8106aa0:	d107      	bne.n	8106ab2 <AL_ControlInd+0x5d2>
            {
                /* the mailbox sync manager settings were wrong, switch back to INIT */
                MBX_StopMailboxHandler();
 8106aa2:	f000 fd39 	bl	8107518 <MBX_StopMailboxHandler>
                APPL_StopMailboxHandler();
 8106aa6:	f7f9 ff4a 	bl	810093e <APPL_StopMailboxHandler>

                nAlStatus = STATE_INIT;
 8106aaa:	4b28      	ldr	r3, [pc, #160]	@ (8106b4c <AL_ControlInd+0x66c>)
 8106aac:	2201      	movs	r2, #1
 8106aae:	701a      	strb	r2, [r3, #0]
 8106ab0:	e00e      	b.n	8106ad0 <AL_ControlInd+0x5f0>
            }
            else
                nAlStatus = STATE_PREOP;
 8106ab2:	4b26      	ldr	r3, [pc, #152]	@ (8106b4c <AL_ControlInd+0x66c>)
 8106ab4:	2202      	movs	r2, #2
 8106ab6:	701a      	strb	r2, [r3, #0]
 8106ab8:	e00a      	b.n	8106ad0 <AL_ControlInd+0x5f0>
            break;
 8106aba:	bf00      	nop
 8106abc:	e008      	b.n	8106ad0 <AL_ControlInd+0x5f0>
            break;
 8106abe:	bf00      	nop
 8106ac0:	e006      	b.n	8106ad0 <AL_ControlInd+0x5f0>
            break;
 8106ac2:	bf00      	nop
 8106ac4:	e004      	b.n	8106ad0 <AL_ControlInd+0x5f0>
                break;
 8106ac6:	bf00      	nop
 8106ac8:	e002      	b.n	8106ad0 <AL_ControlInd+0x5f0>
                break;
 8106aca:	bf00      	nop
 8106acc:	e000      	b.n	8106ad0 <AL_ControlInd+0x5f0>
                break;
 8106ace:	bf00      	nop
        }
    }

    if ( result == NOERROR_INWORK )
 8106ad0:	89fb      	ldrh	r3, [r7, #14]
 8106ad2:	2bff      	cmp	r3, #255	@ 0xff
 8106ad4:	d146      	bne.n	8106b64 <AL_ControlInd+0x684>
    {
        /* state transition is still in work
            ECAT_StateChange must be called from the application */
        bEcatWaitForAlControlRes = TRUE;
 8106ad6:	4b20      	ldr	r3, [pc, #128]	@ (8106b58 <AL_ControlInd+0x678>)
 8106ad8:	2201      	movs	r2, #1
 8106ada:	701a      	strb	r2, [r3, #0]
        /* state transition has to be stored */
        nEcatStateTrans = stateTrans;
 8106adc:	7b3b      	ldrb	r3, [r7, #12]
 8106ade:	b29a      	uxth	r2, r3
 8106ae0:	4b1e      	ldr	r3, [pc, #120]	@ (8106b5c <AL_ControlInd+0x67c>)
 8106ae2:	801a      	strh	r2, [r3, #0]

        /*Init ESM timeout counter (will be decremented with the local 1ms timer)*/
        switch(nEcatStateTrans)
 8106ae4:	4b1d      	ldr	r3, [pc, #116]	@ (8106b5c <AL_ControlInd+0x67c>)
 8106ae6:	881b      	ldrh	r3, [r3, #0]
 8106ae8:	2b48      	cmp	r3, #72	@ 0x48
 8106aea:	d00e      	beq.n	8106b0a <AL_ControlInd+0x62a>
 8106aec:	2b48      	cmp	r3, #72	@ 0x48
 8106aee:	dc11      	bgt.n	8106b14 <AL_ControlInd+0x634>
 8106af0:	2b13      	cmp	r3, #19
 8106af2:	dc02      	bgt.n	8106afa <AL_ControlInd+0x61a>
 8106af4:	2b12      	cmp	r3, #18
 8106af6:	da03      	bge.n	8106b00 <AL_ControlInd+0x620>
 8106af8:	e00c      	b.n	8106b14 <AL_ControlInd+0x634>
 8106afa:	2b24      	cmp	r3, #36	@ 0x24
 8106afc:	d005      	beq.n	8106b0a <AL_ControlInd+0x62a>
 8106afe:	e009      	b.n	8106b14 <AL_ControlInd+0x634>
        {
            case INIT_2_PREOP:
            case INIT_2_BOOT:
                EsmTimeoutCounter = PREOPTIMEOUT;
 8106b00:	4b17      	ldr	r3, [pc, #92]	@ (8106b60 <AL_ControlInd+0x680>)
 8106b02:	f44f 62fa 	mov.w	r2, #2000	@ 0x7d0
 8106b06:	801a      	strh	r2, [r3, #0]
            break;
 8106b08:	e008      	b.n	8106b1c <AL_ControlInd+0x63c>
            case PREOP_2_SAFEOP:
            case SAFEOP_2_OP:
                EsmTimeoutCounter = SAFEOP2OPTIMEOUT;
 8106b0a:	4b15      	ldr	r3, [pc, #84]	@ (8106b60 <AL_ControlInd+0x680>)
 8106b0c:	f242 3228 	movw	r2, #9000	@ 0x2328
 8106b10:	801a      	strh	r2, [r3, #0]
                break;
 8106b12:	e003      	b.n	8106b1c <AL_ControlInd+0x63c>
           default:
                EsmTimeoutCounter = 200; //Set default timeout value to 200ms
 8106b14:	4b12      	ldr	r3, [pc, #72]	@ (8106b60 <AL_ControlInd+0x680>)
 8106b16:	22c8      	movs	r2, #200	@ 0xc8
 8106b18:	801a      	strh	r2, [r3, #0]
                break;
 8106b1a:	bf00      	nop
        }
        EsmTimeoutCounter -= 50; //subtract 50ms from the timeout to react before the master runs into a timeout.
 8106b1c:	4b10      	ldr	r3, [pc, #64]	@ (8106b60 <AL_ControlInd+0x680>)
 8106b1e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8106b22:	b29b      	uxth	r3, r3
 8106b24:	3b32      	subs	r3, #50	@ 0x32
 8106b26:	b29b      	uxth	r3, r3
 8106b28:	b21a      	sxth	r2, r3
 8106b2a:	4b0d      	ldr	r3, [pc, #52]	@ (8106b60 <AL_ControlInd+0x680>)
 8106b2c:	801a      	strh	r2, [r3, #0]
 8106b2e:	e07a      	b.n	8106c26 <AL_ControlInd+0x746>
 8106b30:	10000874 	.word	0x10000874
 8106b34:	1000084e 	.word	0x1000084e
 8106b38:	10000877 	.word	0x10000877
 8106b3c:	10000864 	.word	0x10000864
 8106b40:	10000829 	.word	0x10000829
 8106b44:	10000828 	.word	0x10000828
 8106b48:	1000084a 	.word	0x1000084a
 8106b4c:	1000085c 	.word	0x1000085c
 8106b50:	10000856 	.word	0x10000856
 8106b54:	10000854 	.word	0x10000854
 8106b58:	1000084f 	.word	0x1000084f
 8106b5c:	10000850 	.word	0x10000850
 8106b60:	1000082e 	.word	0x1000082e

    }
    else if ( alControl != (nAlStatus & STATE_MASK) )
 8106b64:	79fa      	ldrb	r2, [r7, #7]
 8106b66:	4b31      	ldr	r3, [pc, #196]	@ (8106c2c <AL_ControlInd+0x74c>)
 8106b68:	781b      	ldrb	r3, [r3, #0]
 8106b6a:	f003 030f 	and.w	r3, r3, #15
 8106b6e:	429a      	cmp	r2, r3
 8106b70:	d04e      	beq.n	8106c10 <AL_ControlInd+0x730>
    {
        /* The slave state has changed */

        if ( (result != 0 || alStatusCode != 0) && ((alControl | nAlStatus) & STATE_OP) )
 8106b72:	89fb      	ldrh	r3, [r7, #14]
 8106b74:	2b00      	cmp	r3, #0
 8106b76:	d102      	bne.n	8106b7e <AL_ControlInd+0x69e>
 8106b78:	88bb      	ldrh	r3, [r7, #4]
 8106b7a:	2b00      	cmp	r3, #0
 8106b7c:	d01f      	beq.n	8106bbe <AL_ControlInd+0x6de>
 8106b7e:	4b2b      	ldr	r3, [pc, #172]	@ (8106c2c <AL_ControlInd+0x74c>)
 8106b80:	781a      	ldrb	r2, [r3, #0]
 8106b82:	79fb      	ldrb	r3, [r7, #7]
 8106b84:	4313      	orrs	r3, r2
 8106b86:	b2db      	uxtb	r3, r3
 8106b88:	f003 0308 	and.w	r3, r3, #8
 8106b8c:	2b00      	cmp	r3, #0
 8106b8e:	d016      	beq.n	8106bbe <AL_ControlInd+0x6de>
        {
            /* the local application requested to leave the state OP so we have to disable the SM2
               and make the state change from OP to SAFEOP by calling StopOutputHandler */

            //only execute StopOutputHandler() if Output update is still running
            if(bEcatOutputUpdateRunning)
 8106b90:	4b27      	ldr	r3, [pc, #156]	@ (8106c30 <AL_ControlInd+0x750>)
 8106b92:	781b      	ldrb	r3, [r3, #0]
 8106b94:	2b00      	cmp	r3, #0
 8106b96:	d003      	beq.n	8106ba0 <AL_ControlInd+0x6c0>
            {
                APPL_StopOutputHandler();
 8106b98:	f7f9 fef4 	bl	8100984 <APPL_StopOutputHandler>

                StopOutputHandler();
 8106b9c:	f7ff fba4 	bl	81062e8 <StopOutputHandler>
            }

            if(nPdOutputSize > 0)
 8106ba0:	4b24      	ldr	r3, [pc, #144]	@ (8106c34 <AL_ControlInd+0x754>)
 8106ba2:	881b      	ldrh	r3, [r3, #0]
 8106ba4:	2b00      	cmp	r3, #0
 8106ba6:	d003      	beq.n	8106bb0 <AL_ControlInd+0x6d0>
            {
                /* disable the Sync Manager Channel 2 (outputs) */
/*ECATCHANGE_START(V5.11) HW1*/
                DisableSyncManChannel(PROCESS_DATA_OUT);
 8106ba8:	2002      	movs	r0, #2
 8106baa:	f7fe fd69 	bl	8105680 <DisableSyncManChannel>
 8106bae:	e006      	b.n	8106bbe <AL_ControlInd+0x6de>
/*ECATCHANGE_END(V5.11) HW1*/
            }
            else
                if(nPdInputSize > 0)
 8106bb0:	4b21      	ldr	r3, [pc, #132]	@ (8106c38 <AL_ControlInd+0x758>)
 8106bb2:	881b      	ldrh	r3, [r3, #0]
 8106bb4:	2b00      	cmp	r3, #0
 8106bb6:	d002      	beq.n	8106bbe <AL_ControlInd+0x6de>
            {
                /*disable Sync Manager 3 (inputs) if no outputs available*/
/*ECATCHANGE_START(V5.11) HW1*/
                DisableSyncManChannel(PROCESS_DATA_IN);
 8106bb8:	2003      	movs	r0, #3
 8106bba:	f7fe fd61 	bl	8105680 <DisableSyncManChannel>
/*ECATCHANGE_END(V5.11) HW1*/
            }

        }
        if ( result != 0 )
 8106bbe:	89fb      	ldrh	r3, [r7, #14]
 8106bc0:	2b00      	cmp	r3, #0
 8106bc2:	d00e      	beq.n	8106be2 <AL_ControlInd+0x702>
        {
            if ( nAlStatus == STATE_OP )
 8106bc4:	4b19      	ldr	r3, [pc, #100]	@ (8106c2c <AL_ControlInd+0x74c>)
 8106bc6:	781b      	ldrb	r3, [r3, #0]
 8106bc8:	2b08      	cmp	r3, #8
 8106bca:	d102      	bne.n	8106bd2 <AL_ControlInd+0x6f2>
                nAlStatus = STATE_SAFEOP;
 8106bcc:	4b17      	ldr	r3, [pc, #92]	@ (8106c2c <AL_ControlInd+0x74c>)
 8106bce:	2204      	movs	r2, #4
 8106bd0:	701a      	strb	r2, [r3, #0]
            /* save the failed status to be able to decide, if the AL Status Code shall be
               reset in case of a coming successful state transition */
            nAlStatus |= STATE_CHANGE;
 8106bd2:	4b16      	ldr	r3, [pc, #88]	@ (8106c2c <AL_ControlInd+0x74c>)
 8106bd4:	781b      	ldrb	r3, [r3, #0]
 8106bd6:	f043 0310 	orr.w	r3, r3, #16
 8106bda:	b2da      	uxtb	r2, r3
 8106bdc:	4b13      	ldr	r3, [pc, #76]	@ (8106c2c <AL_ControlInd+0x74c>)
 8106bde:	701a      	strb	r2, [r3, #0]
 8106be0:	e00b      	b.n	8106bfa <AL_ControlInd+0x71a>
        }
        else
        {
            /* state transition was successful */
            if ( alStatusCode != 0 )
 8106be2:	88bb      	ldrh	r3, [r7, #4]
 8106be4:	2b00      	cmp	r3, #0
 8106be6:	d005      	beq.n	8106bf4 <AL_ControlInd+0x714>
            {
                /* state change request from the user */
                result = alStatusCode;
 8106be8:	88bb      	ldrh	r3, [r7, #4]
 8106bea:	81fb      	strh	r3, [r7, #14]
                alControl |= STATE_CHANGE;
 8106bec:	79fb      	ldrb	r3, [r7, #7]
 8106bee:	f043 0310 	orr.w	r3, r3, #16
 8106bf2:	71fb      	strb	r3, [r7, #7]
            }
            /* acknowledge the new state */
            nAlStatus = alControl;
 8106bf4:	4a0d      	ldr	r2, [pc, #52]	@ (8106c2c <AL_ControlInd+0x74c>)
 8106bf6:	79fb      	ldrb	r3, [r7, #7]
 8106bf8:	7013      	strb	r3, [r2, #0]
        }

        bEcatWaitForAlControlRes = FALSE;
 8106bfa:	4b10      	ldr	r3, [pc, #64]	@ (8106c3c <AL_ControlInd+0x75c>)
 8106bfc:	2200      	movs	r2, #0
 8106bfe:	701a      	strb	r2, [r3, #0]

        /* write the AL Status register */
        SetALStatus(nAlStatus, result);
 8106c00:	4b0a      	ldr	r3, [pc, #40]	@ (8106c2c <AL_ControlInd+0x74c>)
 8106c02:	781b      	ldrb	r3, [r3, #0]
 8106c04:	89fa      	ldrh	r2, [r7, #14]
 8106c06:	4611      	mov	r1, r2
 8106c08:	4618      	mov	r0, r3
 8106c0a:	f7ff fc0f 	bl	810642c <SetALStatus>
 8106c0e:	e00a      	b.n	8106c26 <AL_ControlInd+0x746>
    }
    else
    {
        /* Error acknowledgement without a state transition */

         bEcatWaitForAlControlRes = FALSE;
 8106c10:	4b0a      	ldr	r3, [pc, #40]	@ (8106c3c <AL_ControlInd+0x75c>)
 8106c12:	2200      	movs	r2, #0
 8106c14:	701a      	strb	r2, [r3, #0]

        /* AL-Status has to be updated and AL-Status-Code has to be reset
           if the the error bit was acknowledged */
        SetALStatus(nAlStatus, 0);
 8106c16:	4b05      	ldr	r3, [pc, #20]	@ (8106c2c <AL_ControlInd+0x74c>)
 8106c18:	781b      	ldrb	r3, [r3, #0]
 8106c1a:	2100      	movs	r1, #0
 8106c1c:	4618      	mov	r0, r3
 8106c1e:	f7ff fc05 	bl	810642c <SetALStatus>
 8106c22:	e000      	b.n	8106c26 <AL_ControlInd+0x746>
        return;
 8106c24:	bf00      	nop
    }

}
 8106c26:	3710      	adds	r7, #16
 8106c28:	46bd      	mov	sp, r7
 8106c2a:	bd80      	pop	{r7, pc}
 8106c2c:	1000085c 	.word	0x1000085c
 8106c30:	10000828 	.word	0x10000828
 8106c34:	10000856 	.word	0x10000856
 8106c38:	10000854 	.word	0x10000854
 8106c3c:	1000084f 	.word	0x1000084f

08106c40 <AL_ControlRes>:
 \brief    This function is called cyclic if a state transition is pending (bEcatWaitForAlControlRes == TRUE)
 \brief    If the ESM timeout is expired the state transition will be rejected. Otherwise the application specific state transition function is called.
 \brief    If the pending state transition is triggered by the application the transition need to be completed by the application (ECAT_StateChange())
  *////////////////////////////////////////////////////////////////////////////////////////
void AL_ControlRes(void)
{
 8106c40:	b580      	push	{r7, lr}
 8106c42:	b082      	sub	sp, #8
 8106c44:	af00      	add	r7, sp, #0
    if(bEcatWaitForAlControlRes)
 8106c46:	4b93      	ldr	r3, [pc, #588]	@ (8106e94 <AL_ControlRes+0x254>)
 8106c48:	781b      	ldrb	r3, [r3, #0]
 8106c4a:	2b00      	cmp	r3, #0
 8106c4c:	f000 811d 	beq.w	8106e8a <AL_ControlRes+0x24a>
    {
        UINT16 result = 0;
 8106c50:	2300      	movs	r3, #0
 8106c52:	807b      	strh	r3, [r7, #2]
        UINT8 Status = 0;
 8106c54:	2300      	movs	r3, #0
 8106c56:	71fb      	strb	r3, [r7, #7]
        UINT16 StatusCode = 0;
 8106c58:	2300      	movs	r3, #0
 8106c5a:	80bb      	strh	r3, [r7, #4]

        if(EsmTimeoutCounter == 0)
 8106c5c:	4b8e      	ldr	r3, [pc, #568]	@ (8106e98 <AL_ControlRes+0x258>)
 8106c5e:	f9b3 3000 	ldrsh.w	r3, [r3]
 8106c62:	2b00      	cmp	r3, #0
 8106c64:	d166      	bne.n	8106d34 <AL_ControlRes+0xf4>
        {
            Status =  (UINT8)(nEcatStateTrans >> 4);
 8106c66:	4b8d      	ldr	r3, [pc, #564]	@ (8106e9c <AL_ControlRes+0x25c>)
 8106c68:	881b      	ldrh	r3, [r3, #0]
 8106c6a:	091b      	lsrs	r3, r3, #4
 8106c6c:	b29b      	uxth	r3, r3
 8106c6e:	71fb      	strb	r3, [r7, #7]

            /* ESM timeout expired*/
            switch(nEcatStateTrans)
 8106c70:	4b8a      	ldr	r3, [pc, #552]	@ (8106e9c <AL_ControlRes+0x25c>)
 8106c72:	881b      	ldrh	r3, [r3, #0]
 8106c74:	2b48      	cmp	r3, #72	@ 0x48
 8106c76:	d030      	beq.n	8106cda <AL_ControlRes+0x9a>
 8106c78:	2b48      	cmp	r3, #72	@ 0x48
 8106c7a:	f300 80f3 	bgt.w	8106e64 <AL_ControlRes+0x224>
 8106c7e:	2b13      	cmp	r3, #19
 8106c80:	dc02      	bgt.n	8106c88 <AL_ControlRes+0x48>
 8106c82:	2b12      	cmp	r3, #18
 8106c84:	da03      	bge.n	8106c8e <AL_ControlRes+0x4e>
 8106c86:	e0ed      	b.n	8106e64 <AL_ControlRes+0x224>
 8106c88:	2b24      	cmp	r3, #36	@ 0x24
 8106c8a:	d013      	beq.n	8106cb4 <AL_ControlRes+0x74>
 8106c8c:	e0ea      	b.n	8106e64 <AL_ControlRes+0x224>
            {
                case INIT_2_PREOP:
                case INIT_2_BOOT:

                    if(!bApplEsmPending)
 8106c8e:	4b84      	ldr	r3, [pc, #528]	@ (8106ea0 <AL_ControlRes+0x260>)
 8106c90:	781b      	ldrb	r3, [r3, #0]
 8106c92:	2b00      	cmp	r3, #0
 8106c94:	d101      	bne.n	8106c9a <AL_ControlRes+0x5a>
                        APPL_StopMailboxHandler();
 8106c96:	f7f9 fe52 	bl	810093e <APPL_StopMailboxHandler>

                    MBX_StopMailboxHandler();
 8106c9a:	f000 fc3d 	bl	8107518 <MBX_StopMailboxHandler>
                    if(bLocalErrorFlag)
 8106c9e:	4b81      	ldr	r3, [pc, #516]	@ (8106ea4 <AL_ControlRes+0x264>)
 8106ca0:	781b      	ldrb	r3, [r3, #0]
 8106ca2:	2b00      	cmp	r3, #0
 8106ca4:	d003      	beq.n	8106cae <AL_ControlRes+0x6e>
                    {
                        /*Set application specified error*/
                        StatusCode = u16LocalErrorCode;
 8106ca6:	4b80      	ldr	r3, [pc, #512]	@ (8106ea8 <AL_ControlRes+0x268>)
 8106ca8:	881b      	ldrh	r3, [r3, #0]
 8106caa:	80bb      	strh	r3, [r7, #4]
                    else
                    {
                        /*Set unspecified error*/
                        StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
                    }
                break;
 8106cac:	e0da      	b.n	8106e64 <AL_ControlRes+0x224>
                        StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
 8106cae:	2301      	movs	r3, #1
 8106cb0:	80bb      	strh	r3, [r7, #4]
                break;
 8106cb2:	e0d7      	b.n	8106e64 <AL_ControlRes+0x224>
                case PREOP_2_SAFEOP:
                    if(!bApplEsmPending)
 8106cb4:	4b7a      	ldr	r3, [pc, #488]	@ (8106ea0 <AL_ControlRes+0x260>)
 8106cb6:	781b      	ldrb	r3, [r3, #0]
 8106cb8:	2b00      	cmp	r3, #0
 8106cba:	d101      	bne.n	8106cc0 <AL_ControlRes+0x80>
                        APPL_StopInputHandler();
 8106cbc:	f7f9 fe52 	bl	8100964 <APPL_StopInputHandler>

                    StopInputHandler();
 8106cc0:	f7ff fb24 	bl	810630c <StopInputHandler>
                    
                    if(bLocalErrorFlag)
 8106cc4:	4b77      	ldr	r3, [pc, #476]	@ (8106ea4 <AL_ControlRes+0x264>)
 8106cc6:	781b      	ldrb	r3, [r3, #0]
 8106cc8:	2b00      	cmp	r3, #0
 8106cca:	d003      	beq.n	8106cd4 <AL_ControlRes+0x94>
                    {
                        /*Set application specified error*/
                        StatusCode = u16LocalErrorCode;
 8106ccc:	4b76      	ldr	r3, [pc, #472]	@ (8106ea8 <AL_ControlRes+0x268>)
 8106cce:	881b      	ldrh	r3, [r3, #0]
 8106cd0:	80bb      	strh	r3, [r7, #4]
                    else
                    {
                        /*Set unspecified error*/
                        StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
                    }
                break;
 8106cd2:	e0c7      	b.n	8106e64 <AL_ControlRes+0x224>
                        StatusCode = ALSTATUSCODE_UNSPECIFIEDERROR;
 8106cd4:	2301      	movs	r3, #1
 8106cd6:	80bb      	strh	r3, [r7, #4]
                break;
 8106cd8:	e0c4      	b.n	8106e64 <AL_ControlRes+0x224>
                case SAFEOP_2_OP:
                    if(bDcSyncActive)
 8106cda:	4b74      	ldr	r3, [pc, #464]	@ (8106eac <AL_ControlRes+0x26c>)
 8106cdc:	781b      	ldrb	r3, [r3, #0]
 8106cde:	2b00      	cmp	r3, #0
 8106ce0:	d014      	beq.n	8106d0c <AL_ControlRes+0xcc>
                    {
                        /*SafeOP to OP timeout expired check which AL status code need to be written*/
                        if(!bDcRunning)
 8106ce2:	4b73      	ldr	r3, [pc, #460]	@ (8106eb0 <AL_ControlRes+0x270>)
 8106ce4:	781b      	ldrb	r3, [r3, #0]
 8106ce6:	2b00      	cmp	r3, #0
 8106ce8:	d102      	bne.n	8106cf0 <AL_ControlRes+0xb0>
                        {
                            /*no Sync0 signal received*/
                            StatusCode = ALSTATUSCODE_NOSYNCERROR;
 8106cea:	232d      	movs	r3, #45	@ 0x2d
 8106cec:	80bb      	strh	r3, [r7, #4]
 8106cee:	e014      	b.n	8106d1a <AL_ControlRes+0xda>
                        }
/*ECATCHANGE_START(V5.11) ECAT4*/
                        else if(!bEcatFirstOutputsReceived && (nPdOutputSize > 0))
 8106cf0:	4b70      	ldr	r3, [pc, #448]	@ (8106eb4 <AL_ControlRes+0x274>)
 8106cf2:	781b      	ldrb	r3, [r3, #0]
 8106cf4:	2b00      	cmp	r3, #0
 8106cf6:	d106      	bne.n	8106d06 <AL_ControlRes+0xc6>
 8106cf8:	4b6f      	ldr	r3, [pc, #444]	@ (8106eb8 <AL_ControlRes+0x278>)
 8106cfa:	881b      	ldrh	r3, [r3, #0]
 8106cfc:	2b00      	cmp	r3, #0
 8106cfe:	d002      	beq.n	8106d06 <AL_ControlRes+0xc6>
/*ECATCHANGE_END(V5.11) ECAT4*/
                        {
                            /*no process data received*/
                            StatusCode = ALSTATUSCODE_SMWATCHDOG;
 8106d00:	231b      	movs	r3, #27
 8106d02:	80bb      	strh	r3, [r7, #4]
 8106d04:	e009      	b.n	8106d1a <AL_ControlRes+0xda>
                        }
                        else
                        {
                            /*SM/Sync Sequence is not valid*/
                            StatusCode = ALSTATUSCODE_SYNCERROR;
 8106d06:	231a      	movs	r3, #26
 8106d08:	80bb      	strh	r3, [r7, #4]
 8106d0a:	e006      	b.n	8106d1a <AL_ControlRes+0xda>
                    }
                    else
                    {
                        {
                            /*Set valid state transition even if timeout expired*/
                            Status = STATE_OP;
 8106d0c:	2308      	movs	r3, #8
 8106d0e:	71fb      	strb	r3, [r7, #7]
                            StatusCode = 0;
 8106d10:	2300      	movs	r3, #0
 8106d12:	80bb      	strh	r3, [r7, #4]
                            /* Slave is OPERATIONAL */
                            bEcatOutputUpdateRunning = TRUE;
 8106d14:	4b69      	ldr	r3, [pc, #420]	@ (8106ebc <AL_ControlRes+0x27c>)
 8106d16:	2201      	movs	r2, #1
 8106d18:	701a      	strb	r2, [r3, #0]
                        }
                    }

                    /*Stop handler on failed transition*/
                    if(StatusCode != 0)
 8106d1a:	88bb      	ldrh	r3, [r7, #4]
 8106d1c:	2b00      	cmp	r3, #0
 8106d1e:	f000 809a 	beq.w	8106e56 <AL_ControlRes+0x216>
                    {
                        if(!bApplEsmPending)
 8106d22:	4b5f      	ldr	r3, [pc, #380]	@ (8106ea0 <AL_ControlRes+0x260>)
 8106d24:	781b      	ldrb	r3, [r3, #0]
 8106d26:	2b00      	cmp	r3, #0
 8106d28:	d101      	bne.n	8106d2e <AL_ControlRes+0xee>
                            APPL_StopOutputHandler();
 8106d2a:	f7f9 fe2b 	bl	8100984 <APPL_StopOutputHandler>

                        StopOutputHandler();
 8106d2e:	f7ff fadb 	bl	81062e8 <StopOutputHandler>
                    }
                break;
 8106d32:	e090      	b.n	8106e56 <AL_ControlRes+0x216>
            }
        } //ESM timeout
        else
        {
            /*Call application specific transition function and complete transition it the function returns 0*/
            switch(nEcatStateTrans)
 8106d34:	4b59      	ldr	r3, [pc, #356]	@ (8106e9c <AL_ControlRes+0x25c>)
 8106d36:	881b      	ldrh	r3, [r3, #0]
 8106d38:	2b48      	cmp	r3, #72	@ 0x48
 8106d3a:	d047      	beq.n	8106dcc <AL_ControlRes+0x18c>
 8106d3c:	2b48      	cmp	r3, #72	@ 0x48
 8106d3e:	f300 8091 	bgt.w	8106e64 <AL_ControlRes+0x224>
 8106d42:	2b13      	cmp	r3, #19
 8106d44:	dc02      	bgt.n	8106d4c <AL_ControlRes+0x10c>
 8106d46:	2b12      	cmp	r3, #18
 8106d48:	da03      	bge.n	8106d52 <AL_ControlRes+0x112>
 8106d4a:	e08b      	b.n	8106e64 <AL_ControlRes+0x224>
 8106d4c:	2b24      	cmp	r3, #36	@ 0x24
 8106d4e:	d020      	beq.n	8106d92 <AL_ControlRes+0x152>
 8106d50:	e088      	b.n	8106e64 <AL_ControlRes+0x224>
            {
                case INIT_2_PREOP:
                case INIT_2_BOOT:
                    if(bApplEsmPending)
 8106d52:	4b53      	ldr	r3, [pc, #332]	@ (8106ea0 <AL_ControlRes+0x260>)
 8106d54:	781b      	ldrb	r3, [r3, #0]
 8106d56:	2b00      	cmp	r3, #0
 8106d58:	d07f      	beq.n	8106e5a <AL_ControlRes+0x21a>
                    {
                        bApplEsmPending = FALSE;
 8106d5a:	4b51      	ldr	r3, [pc, #324]	@ (8106ea0 <AL_ControlRes+0x260>)
 8106d5c:	2200      	movs	r2, #0
 8106d5e:	701a      	strb	r2, [r3, #0]
                        /*APPL_StartMailboxHandler() need to be called*/
                        result = APPL_StartMailboxHandler();
 8106d60:	f7f9 fde5 	bl	810092e <APPL_StartMailboxHandler>
 8106d64:	4603      	mov	r3, r0
 8106d66:	807b      	strh	r3, [r7, #2]

                        if(result == 0)
 8106d68:	887b      	ldrh	r3, [r7, #2]
 8106d6a:	2b00      	cmp	r3, #0
 8106d6c:	d109      	bne.n	8106d82 <AL_ControlRes+0x142>
                        {
                            /*The application specific transition was successful => set active mailbox handler indication*/
                            bMbxRunning = TRUE;
 8106d6e:	4b54      	ldr	r3, [pc, #336]	@ (8106ec0 <AL_ControlRes+0x280>)
 8106d70:	2201      	movs	r2, #1
 8106d72:	701a      	strb	r2, [r3, #0]
                            Status =  (UINT8)(nEcatStateTrans & STATE_MASK);
 8106d74:	4b49      	ldr	r3, [pc, #292]	@ (8106e9c <AL_ControlRes+0x25c>)
 8106d76:	881b      	ldrh	r3, [r3, #0]
 8106d78:	b2db      	uxtb	r3, r3
 8106d7a:	f003 030f 	and.w	r3, r3, #15
 8106d7e:	71fb      	strb	r3, [r7, #7]
                                APPL_StopMailboxHandler();
                                MBX_StopMailboxHandler();
                            }
                        }
                    }
                break;
 8106d80:	e06b      	b.n	8106e5a <AL_ControlRes+0x21a>
                            if(result != NOERROR_INWORK)
 8106d82:	887b      	ldrh	r3, [r7, #2]
 8106d84:	2bff      	cmp	r3, #255	@ 0xff
 8106d86:	d068      	beq.n	8106e5a <AL_ControlRes+0x21a>
                                APPL_StopMailboxHandler();
 8106d88:	f7f9 fdd9 	bl	810093e <APPL_StopMailboxHandler>
                                MBX_StopMailboxHandler();
 8106d8c:	f000 fbc4 	bl	8107518 <MBX_StopMailboxHandler>
                break;
 8106d90:	e063      	b.n	8106e5a <AL_ControlRes+0x21a>
                case PREOP_2_SAFEOP:
                    if(bApplEsmPending)
 8106d92:	4b43      	ldr	r3, [pc, #268]	@ (8106ea0 <AL_ControlRes+0x260>)
 8106d94:	781b      	ldrb	r3, [r3, #0]
 8106d96:	2b00      	cmp	r3, #0
 8106d98:	d061      	beq.n	8106e5e <AL_ControlRes+0x21e>
                    {
                        bApplEsmPending = FALSE;
 8106d9a:	4b41      	ldr	r3, [pc, #260]	@ (8106ea0 <AL_ControlRes+0x260>)
 8106d9c:	2200      	movs	r2, #0
 8106d9e:	701a      	strb	r2, [r3, #0]
                        result = APPL_StartInputHandler(&u16ALEventMask);
 8106da0:	4848      	ldr	r0, [pc, #288]	@ (8106ec4 <AL_ControlRes+0x284>)
 8106da2:	f7f9 fdd4 	bl	810094e <APPL_StartInputHandler>
 8106da6:	4603      	mov	r3, r0
 8106da8:	807b      	strh	r3, [r7, #2]

                        if(result == 0)
 8106daa:	887b      	ldrh	r3, [r7, #2]
 8106dac:	2b00      	cmp	r3, #0
 8106dae:	d105      	bne.n	8106dbc <AL_ControlRes+0x17c>
                        {
                            bEcatInputUpdateRunning = TRUE;
 8106db0:	4b45      	ldr	r3, [pc, #276]	@ (8106ec8 <AL_ControlRes+0x288>)
 8106db2:	2201      	movs	r2, #1
 8106db4:	701a      	strb	r2, [r3, #0]
                            Status = STATE_SAFEOP;
 8106db6:	2304      	movs	r3, #4
 8106db8:	71fb      	strb	r3, [r7, #7]
                                APPL_StopInputHandler();
                                StopInputHandler();
                            }
                        }
                    }
                break;
 8106dba:	e050      	b.n	8106e5e <AL_ControlRes+0x21e>
                            if(result != NOERROR_INWORK)
 8106dbc:	887b      	ldrh	r3, [r7, #2]
 8106dbe:	2bff      	cmp	r3, #255	@ 0xff
 8106dc0:	d04d      	beq.n	8106e5e <AL_ControlRes+0x21e>
                                APPL_StopInputHandler();
 8106dc2:	f7f9 fdcf 	bl	8100964 <APPL_StopInputHandler>
                                StopInputHandler();
 8106dc6:	f7ff faa1 	bl	810630c <StopInputHandler>
                break;
 8106dca:	e048      	b.n	8106e5e <AL_ControlRes+0x21e>
                case SAFEOP_2_OP:
                   if(bApplEsmPending)
 8106dcc:	4b34      	ldr	r3, [pc, #208]	@ (8106ea0 <AL_ControlRes+0x260>)
 8106dce:	781b      	ldrb	r3, [r3, #0]
 8106dd0:	2b00      	cmp	r3, #0
 8106dd2:	d046      	beq.n	8106e62 <AL_ControlRes+0x222>
                    {
                        if(bDcSyncActive)
 8106dd4:	4b35      	ldr	r3, [pc, #212]	@ (8106eac <AL_ControlRes+0x26c>)
 8106dd6:	781b      	ldrb	r3, [r3, #0]
 8106dd8:	2b00      	cmp	r3, #0
 8106dda:	d027      	beq.n	8106e2c <AL_ControlRes+0x1ec>
                        {
                            if(i16WaitForPllRunningTimeout > 0 && i16WaitForPllRunningTimeout <= i16WaitForPllRunningCnt)
 8106ddc:	4b3b      	ldr	r3, [pc, #236]	@ (8106ecc <AL_ControlRes+0x28c>)
 8106dde:	f9b3 3000 	ldrsh.w	r3, [r3]
 8106de2:	2b00      	cmp	r3, #0
 8106de4:	dd3d      	ble.n	8106e62 <AL_ControlRes+0x222>
 8106de6:	4b39      	ldr	r3, [pc, #228]	@ (8106ecc <AL_ControlRes+0x28c>)
 8106de8:	f9b3 2000 	ldrsh.w	r2, [r3]
 8106dec:	4b38      	ldr	r3, [pc, #224]	@ (8106ed0 <AL_ControlRes+0x290>)
 8106dee:	f9b3 3000 	ldrsh.w	r3, [r3]
 8106df2:	429a      	cmp	r2, r3
 8106df4:	dc35      	bgt.n	8106e62 <AL_ControlRes+0x222>
                            {
                                /*Pll sequence valid for 200ms (set in APPL_StartOutputHandler() )
                                acknowledge state transition to OP */

                                i16WaitForPllRunningTimeout = 0;
 8106df6:	4b35      	ldr	r3, [pc, #212]	@ (8106ecc <AL_ControlRes+0x28c>)
 8106df8:	2200      	movs	r2, #0
 8106dfa:	801a      	strh	r2, [r3, #0]
                                i16WaitForPllRunningCnt = 0;
 8106dfc:	4b34      	ldr	r3, [pc, #208]	@ (8106ed0 <AL_ControlRes+0x290>)
 8106dfe:	2200      	movs	r2, #0
 8106e00:	801a      	strh	r2, [r3, #0]

                                result = APPL_StartOutputHandler();
 8106e02:	f7f9 fdb7 	bl	8100974 <APPL_StartOutputHandler>
 8106e06:	4603      	mov	r3, r0
 8106e08:	807b      	strh	r3, [r7, #2]

                                if(result == 0)
 8106e0a:	887b      	ldrh	r3, [r7, #2]
 8106e0c:	2b00      	cmp	r3, #0
 8106e0e:	d105      	bne.n	8106e1c <AL_ControlRes+0x1dc>
                                {
                                    /* Slave is OPERATIONAL */
                                    bEcatOutputUpdateRunning = TRUE;
 8106e10:	4b2a      	ldr	r3, [pc, #168]	@ (8106ebc <AL_ControlRes+0x27c>)
 8106e12:	2201      	movs	r2, #1
 8106e14:	701a      	strb	r2, [r3, #0]
                                    Status = STATE_OP;
 8106e16:	2308      	movs	r3, #8
 8106e18:	71fb      	strb	r3, [r7, #7]
                                    }
                                }
                            }
                        }       
                    }             
                break;
 8106e1a:	e022      	b.n	8106e62 <AL_ControlRes+0x222>
                                    if(result != NOERROR_INWORK)
 8106e1c:	887b      	ldrh	r3, [r7, #2]
 8106e1e:	2bff      	cmp	r3, #255	@ 0xff
 8106e20:	d01f      	beq.n	8106e62 <AL_ControlRes+0x222>
                                        APPL_StopOutputHandler();
 8106e22:	f7f9 fdaf 	bl	8100984 <APPL_StopOutputHandler>
                                        StopOutputHandler();
 8106e26:	f7ff fa5f 	bl	81062e8 <StopOutputHandler>
                break;
 8106e2a:	e01a      	b.n	8106e62 <AL_ControlRes+0x222>
                                result = APPL_StartOutputHandler();
 8106e2c:	f7f9 fda2 	bl	8100974 <APPL_StartOutputHandler>
 8106e30:	4603      	mov	r3, r0
 8106e32:	807b      	strh	r3, [r7, #2]
                                if(result == 0)
 8106e34:	887b      	ldrh	r3, [r7, #2]
 8106e36:	2b00      	cmp	r3, #0
 8106e38:	d105      	bne.n	8106e46 <AL_ControlRes+0x206>
                                    bEcatOutputUpdateRunning = TRUE;
 8106e3a:	4b20      	ldr	r3, [pc, #128]	@ (8106ebc <AL_ControlRes+0x27c>)
 8106e3c:	2201      	movs	r2, #1
 8106e3e:	701a      	strb	r2, [r3, #0]
                                    Status = STATE_OP;
 8106e40:	2308      	movs	r3, #8
 8106e42:	71fb      	strb	r3, [r7, #7]
                break;
 8106e44:	e00d      	b.n	8106e62 <AL_ControlRes+0x222>
                                    if(result != NOERROR_INWORK)
 8106e46:	887b      	ldrh	r3, [r7, #2]
 8106e48:	2bff      	cmp	r3, #255	@ 0xff
 8106e4a:	d00a      	beq.n	8106e62 <AL_ControlRes+0x222>
                                        APPL_StopOutputHandler();
 8106e4c:	f7f9 fd9a 	bl	8100984 <APPL_StopOutputHandler>
                                        StopOutputHandler();
 8106e50:	f7ff fa4a 	bl	81062e8 <StopOutputHandler>
                break;
 8106e54:	e005      	b.n	8106e62 <AL_ControlRes+0x222>
                break;
 8106e56:	bf00      	nop
 8106e58:	e004      	b.n	8106e64 <AL_ControlRes+0x224>
                break;
 8106e5a:	bf00      	nop
 8106e5c:	e002      	b.n	8106e64 <AL_ControlRes+0x224>
                break;
 8106e5e:	bf00      	nop
 8106e60:	e000      	b.n	8106e64 <AL_ControlRes+0x224>
                break;
 8106e62:	bf00      	nop
            }//Switch - transition
        }

        if(Status != 0)
 8106e64:	79fb      	ldrb	r3, [r7, #7]
 8106e66:	2b00      	cmp	r3, #0
 8106e68:	d00f      	beq.n	8106e8a <AL_ControlRes+0x24a>
        {
            /*Pending state transition finished => write AL Status and AL Status Code*/
            bEcatWaitForAlControlRes = FALSE;
 8106e6a:	4b0a      	ldr	r3, [pc, #40]	@ (8106e94 <AL_ControlRes+0x254>)
 8106e6c:	2200      	movs	r2, #0
 8106e6e:	701a      	strb	r2, [r3, #0]

            if (StatusCode != 0)
 8106e70:	88bb      	ldrh	r3, [r7, #4]
 8106e72:	2b00      	cmp	r3, #0
 8106e74:	d003      	beq.n	8106e7e <AL_ControlRes+0x23e>
            {
                Status |= STATE_CHANGE;
 8106e76:	79fb      	ldrb	r3, [r7, #7]
 8106e78:	f043 0310 	orr.w	r3, r3, #16
 8106e7c:	71fb      	strb	r3, [r7, #7]
            }

            SetALStatus(Status,StatusCode);
 8106e7e:	88ba      	ldrh	r2, [r7, #4]
 8106e80:	79fb      	ldrb	r3, [r7, #7]
 8106e82:	4611      	mov	r1, r2
 8106e84:	4618      	mov	r0, r3
 8106e86:	f7ff fad1 	bl	810642c <SetALStatus>
        }
    }// Pending state transition (bEcatWaitForAlControlRes == true)
}
 8106e8a:	bf00      	nop
 8106e8c:	3708      	adds	r7, #8
 8106e8e:	46bd      	mov	sp, r7
 8106e90:	bd80      	pop	{r7, pc}
 8106e92:	bf00      	nop
 8106e94:	1000084f 	.word	0x1000084f
 8106e98:	1000082e 	.word	0x1000082e
 8106e9c:	10000850 	.word	0x10000850
 8106ea0:	1000084e 	.word	0x1000084e
 8106ea4:	1000084a 	.word	0x1000084a
 8106ea8:	1000084c 	.word	0x1000084c
 8106eac:	1000082c 	.word	0x1000082c
 8106eb0:	10000830 	.word	0x10000830
 8106eb4:	1000082a 	.word	0x1000082a
 8106eb8:	10000856 	.word	0x10000856
 8106ebc:	10000828 	.word	0x10000828
 8106ec0:	10000877 	.word	0x10000877
 8106ec4:	10000864 	.word	0x10000864
 8106ec8:	10000829 	.word	0x10000829
 8106ecc:	10000838 	.word	0x10000838
 8106ed0:	1000083a 	.word	0x1000083a

08106ed4 <CheckIfEcatError>:

 \brief    Checks communication and synchronisation variables and update AL status / AL status code if an error has occurred

*////////////////////////////////////////////////////////////////////////////////////////
void CheckIfEcatError(void)
{
 8106ed4:	b580      	push	{r7, lr}
 8106ed6:	b082      	sub	sp, #8
 8106ed8:	af00      	add	r7, sp, #0
   /*if the watchdog is enabled check the the process data watchdog in the ESC
   and set the AL status code 0x1B if the watchdog expired*/
   if (EcatWdValue != 0)
 8106eda:	4b22      	ldr	r3, [pc, #136]	@ (8106f64 <CheckIfEcatError+0x90>)
 8106edc:	881b      	ldrh	r3, [r3, #0]
 8106ede:	2b00      	cmp	r3, #0
 8106ee0:	d023      	beq.n	8106f2a <CheckIfEcatError+0x56>
   {
      /*watchdog time is set => watchdog is active*/
      UINT16 WdStatusOK = 0;
 8106ee2:	2300      	movs	r3, #0
 8106ee4:	80fb      	strh	r3, [r7, #6]

      HW_EscReadWord(WdStatusOK, ESC_PD_WD_STATE);
 8106ee6:	1dbb      	adds	r3, r7, #6
 8106ee8:	2202      	movs	r2, #2
 8106eea:	f44f 6188 	mov.w	r1, #1088	@ 0x440
 8106eee:	4618      	mov	r0, r3
 8106ef0:	f7fa f8da 	bl	81010a8 <HW_EscRead>
      WdStatusOK = SWAPWORD(WdStatusOK);
 8106ef4:	88fb      	ldrh	r3, [r7, #6]
 8106ef6:	80fb      	strh	r3, [r7, #6]

      /*ECATCHANGE_START(V5.11) ECAT4*/
      if (!(WdStatusOK & ESC_PD_WD_TRIGGER_MASK) && (nPdOutputSize > 0))
 8106ef8:	88fb      	ldrh	r3, [r7, #6]
 8106efa:	f003 0301 	and.w	r3, r3, #1
 8106efe:	2b00      	cmp	r3, #0
 8106f00:	d113      	bne.n	8106f2a <CheckIfEcatError+0x56>
 8106f02:	4b19      	ldr	r3, [pc, #100]	@ (8106f68 <CheckIfEcatError+0x94>)
 8106f04:	881b      	ldrh	r3, [r3, #0]
 8106f06:	2b00      	cmp	r3, #0
 8106f08:	d00f      	beq.n	8106f2a <CheckIfEcatError+0x56>
      {
         /*The device is in OP state*/

         if (bEcatOutputUpdateRunning
 8106f0a:	4b18      	ldr	r3, [pc, #96]	@ (8106f6c <CheckIfEcatError+0x98>)
 8106f0c:	781b      	ldrb	r3, [r3, #0]
 8106f0e:	2b00      	cmp	r3, #0
 8106f10:	d008      	beq.n	8106f24 <CheckIfEcatError+0x50>
            && bEcatFirstOutputsReceived
 8106f12:	4b17      	ldr	r3, [pc, #92]	@ (8106f70 <CheckIfEcatError+0x9c>)
 8106f14:	781b      	ldrb	r3, [r3, #0]
 8106f16:	2b00      	cmp	r3, #0
 8106f18:	d004      	beq.n	8106f24 <CheckIfEcatError+0x50>
            )
         {
            AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SMWATCHDOG);
 8106f1a:	211b      	movs	r1, #27
 8106f1c:	2004      	movs	r0, #4
 8106f1e:	f7ff fadf 	bl	81064e0 <AL_ControlInd>
 8106f22:	e01c      	b.n	8106f5e <CheckIfEcatError+0x8a>
            return;
         }

         else
         {
            bEcatFirstOutputsReceived = FALSE;
 8106f24:	4b12      	ldr	r3, [pc, #72]	@ (8106f70 <CheckIfEcatError+0x9c>)
 8106f26:	2200      	movs	r2, #0
 8106f28:	701a      	strb	r2, [r3, #0]
         }
      }
      /*ECATCHANGE_END(V5.11) ECAT4*/
   }

   if(bDcSyncActive)
 8106f2a:	4b12      	ldr	r3, [pc, #72]	@ (8106f74 <CheckIfEcatError+0xa0>)
 8106f2c:	781b      	ldrb	r3, [r3, #0]
 8106f2e:	2b00      	cmp	r3, #0
 8106f30:	d015      	beq.n	8106f5e <CheckIfEcatError+0x8a>
   {
       if(bEcatOutputUpdateRunning)
 8106f32:	4b0e      	ldr	r3, [pc, #56]	@ (8106f6c <CheckIfEcatError+0x98>)
 8106f34:	781b      	ldrb	r3, [r3, #0]
 8106f36:	2b00      	cmp	r3, #0
 8106f38:	d011      	beq.n	8106f5e <CheckIfEcatError+0x8a>
       {
           /*Slave is in OP state*/
           if(!bDcRunning)
 8106f3a:	4b0f      	ldr	r3, [pc, #60]	@ (8106f78 <CheckIfEcatError+0xa4>)
 8106f3c:	781b      	ldrb	r3, [r3, #0]
 8106f3e:	2b00      	cmp	r3, #0
 8106f40:	d104      	bne.n	8106f4c <CheckIfEcatError+0x78>
           {
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_FATALSYNCERROR);
 8106f42:	212c      	movs	r1, #44	@ 0x2c
 8106f44:	2004      	movs	r0, #4
 8106f46:	f7ff facb 	bl	81064e0 <AL_ControlInd>
               return;
 8106f4a:	e008      	b.n	8106f5e <CheckIfEcatError+0x8a>
           }
           else if(!bSmSyncSequenceValid)
 8106f4c:	4b0b      	ldr	r3, [pc, #44]	@ (8106f7c <CheckIfEcatError+0xa8>)
 8106f4e:	781b      	ldrb	r3, [r3, #0]
 8106f50:	2b00      	cmp	r3, #0
 8106f52:	d104      	bne.n	8106f5e <CheckIfEcatError+0x8a>
           {
               AL_ControlInd(STATE_SAFEOP, ALSTATUSCODE_SYNCERROR);
 8106f54:	211a      	movs	r1, #26
 8106f56:	2004      	movs	r0, #4
 8106f58:	f7ff fac2 	bl	81064e0 <AL_ControlInd>
               return;
 8106f5c:	bf00      	nop
           }
        
       }
   }
}
 8106f5e:	3708      	adds	r7, #8
 8106f60:	46bd      	mov	sp, r7
 8106f62:	bd80      	pop	{r7, pc}
 8106f64:	1000085e 	.word	0x1000085e
 8106f68:	10000856 	.word	0x10000856
 8106f6c:	10000828 	.word	0x10000828
 8106f70:	1000082a 	.word	0x1000082a
 8106f74:	1000082c 	.word	0x1000082c
 8106f78:	10000830 	.word	0x10000830
 8106f7c:	10000836 	.word	0x10000836

08106f80 <ECAT_Init>:

 \brief    This function initialize the EtherCAT Slave Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Init(void)
{
 8106f80:	b580      	push	{r7, lr}
 8106f82:	b082      	sub	sp, #8
 8106f84:	af00      	add	r7, sp, #0
    UINT8 i;

    /*Get Maximum Number of SyncManagers and supported DPRAM size*/
    {
    UINT16 TmpVar = 0;
 8106f86:	2300      	movs	r3, #0
 8106f88:	80bb      	strh	r3, [r7, #4]

    HW_EscReadWord(TmpVar, ESC_COMM_INFO_OFFSET);
 8106f8a:	1d3b      	adds	r3, r7, #4
 8106f8c:	2202      	movs	r2, #2
 8106f8e:	2104      	movs	r1, #4
 8106f90:	4618      	mov	r0, r3
 8106f92:	f7fa f889 	bl	81010a8 <HW_EscRead>

    TmpVar = SWAPWORD(TmpVar);
 8106f96:	88bb      	ldrh	r3, [r7, #4]
 8106f98:	80bb      	strh	r3, [r7, #4]
    nMaxSyncMan = (UINT8) ((TmpVar & ESC_SM_CHANNELS_MASK)>> ESC_SM_CHANNELS_SHIFT);
 8106f9a:	88bb      	ldrh	r3, [r7, #4]
 8106f9c:	0a1b      	lsrs	r3, r3, #8
 8106f9e:	b29b      	uxth	r3, r3
 8106fa0:	b2da      	uxtb	r2, r3
 8106fa2:	4b38      	ldr	r3, [pc, #224]	@ (8107084 <ECAT_Init+0x104>)
 8106fa4:	701a      	strb	r2, [r3, #0]

    HW_EscReadWord(TmpVar, ESC_DPRAM_SIZE_OFFSET);
 8106fa6:	1d3b      	adds	r3, r7, #4
 8106fa8:	2202      	movs	r2, #2
 8106faa:	2106      	movs	r1, #6
 8106fac:	4618      	mov	r0, r3
 8106fae:	f7fa f87b 	bl	81010a8 <HW_EscRead>
    TmpVar = SWAPWORD(TmpVar);
 8106fb2:	88bb      	ldrh	r3, [r7, #4]
 8106fb4:	80bb      	strh	r3, [r7, #4]

    //get max address (register + DPRAM size in Byte (in the register it is stored in KB))
    /* ECATCHANGE_START(V5.11) ESC1*/
    nMaxEscAddress = (UINT16) ((TmpVar & ESC_DPRAM_SIZE_MASK) << 10) + 0xFFF;
 8106fb6:	88bb      	ldrh	r3, [r7, #4]
 8106fb8:	029b      	lsls	r3, r3, #10
 8106fba:	b29b      	uxth	r3, r3
 8106fbc:	f603 73ff 	addw	r3, r3, #4095	@ 0xfff
 8106fc0:	b29a      	uxth	r2, r3
 8106fc2:	4b31      	ldr	r3, [pc, #196]	@ (8107088 <ECAT_Init+0x108>)
 8106fc4:	801a      	strh	r2, [r3, #0]
    /* ECATCHANGE_END(V5.11) ESC1*/
    }

    /* Get EEPROM loaded information */
    UpdateEEPROMLoadedState();
 8106fc6:	f7fe fb1d 	bl	8105604 <UpdateEEPROMLoadedState>

    /* disable all Sync Manager channels */
    for (i = 0; i < nMaxSyncMan; i++)
 8106fca:	2300      	movs	r3, #0
 8106fcc:	71fb      	strb	r3, [r7, #7]
 8106fce:	e006      	b.n	8106fde <ECAT_Init+0x5e>
    {
/*ECATCHANGE_START(V5.11) HW1*/
        DisableSyncManChannel(i);
 8106fd0:	79fb      	ldrb	r3, [r7, #7]
 8106fd2:	4618      	mov	r0, r3
 8106fd4:	f7fe fb54 	bl	8105680 <DisableSyncManChannel>
    for (i = 0; i < nMaxSyncMan; i++)
 8106fd8:	79fb      	ldrb	r3, [r7, #7]
 8106fda:	3301      	adds	r3, #1
 8106fdc:	71fb      	strb	r3, [r7, #7]
 8106fde:	4b29      	ldr	r3, [pc, #164]	@ (8107084 <ECAT_Init+0x104>)
 8106fe0:	781b      	ldrb	r3, [r3, #0]
 8106fe2:	79fa      	ldrb	r2, [r7, #7]
 8106fe4:	429a      	cmp	r2, r3
 8106fe6:	d3f3      	bcc.n	8106fd0 <ECAT_Init+0x50>
/*ECATCHANGE_END(V5.11) HW1*/
    }

    /* initialize the mailbox handler */
    MBX_Init();
 8106fe8:	f000 f9a0 	bl	810732c <MBX_Init>

    /* initialize variables */
    bApplEsmPending = FALSE;
 8106fec:	4b27      	ldr	r3, [pc, #156]	@ (810708c <ECAT_Init+0x10c>)
 8106fee:	2200      	movs	r2, #0
 8106ff0:	701a      	strb	r2, [r3, #0]
    bEcatWaitForAlControlRes = FALSE;
 8106ff2:	4b27      	ldr	r3, [pc, #156]	@ (8107090 <ECAT_Init+0x110>)
 8106ff4:	2200      	movs	r2, #0
 8106ff6:	701a      	strb	r2, [r3, #0]
    bEcatFirstOutputsReceived = FALSE;
 8106ff8:	4b26      	ldr	r3, [pc, #152]	@ (8107094 <ECAT_Init+0x114>)
 8106ffa:	2200      	movs	r2, #0
 8106ffc:	701a      	strb	r2, [r3, #0]
     bEcatOutputUpdateRunning = FALSE;
 8106ffe:	4b26      	ldr	r3, [pc, #152]	@ (8107098 <ECAT_Init+0x118>)
 8107000:	2200      	movs	r2, #0
 8107002:	701a      	strb	r2, [r3, #0]
     bEcatInputUpdateRunning = FALSE;
 8107004:	4b25      	ldr	r3, [pc, #148]	@ (810709c <ECAT_Init+0x11c>)
 8107006:	2200      	movs	r2, #0
 8107008:	701a      	strb	r2, [r3, #0]
    bWdTrigger = FALSE;
 810700a:	4b25      	ldr	r3, [pc, #148]	@ (81070a0 <ECAT_Init+0x120>)
 810700c:	2200      	movs	r2, #0
 810700e:	701a      	strb	r2, [r3, #0]
    EcatWdValue = 0;
 8107010:	4b24      	ldr	r3, [pc, #144]	@ (81070a4 <ECAT_Init+0x124>)
 8107012:	2200      	movs	r2, #0
 8107014:	801a      	strh	r2, [r3, #0]
    Sync0WdCounter = 0;
 8107016:	4b24      	ldr	r3, [pc, #144]	@ (81070a8 <ECAT_Init+0x128>)
 8107018:	2200      	movs	r2, #0
 810701a:	801a      	strh	r2, [r3, #0]
    Sync0WdValue = 0;
 810701c:	4b23      	ldr	r3, [pc, #140]	@ (81070ac <ECAT_Init+0x12c>)
 810701e:	2200      	movs	r2, #0
 8107020:	801a      	strh	r2, [r3, #0]
    Sync1WdCounter = 0;
 8107022:	4b23      	ldr	r3, [pc, #140]	@ (81070b0 <ECAT_Init+0x130>)
 8107024:	2200      	movs	r2, #0
 8107026:	801a      	strh	r2, [r3, #0]
    Sync1WdValue = 0;
 8107028:	4b22      	ldr	r3, [pc, #136]	@ (81070b4 <ECAT_Init+0x134>)
 810702a:	2200      	movs	r2, #0
 810702c:	801a      	strh	r2, [r3, #0]
    bDcSyncActive = FALSE;
 810702e:	4b22      	ldr	r3, [pc, #136]	@ (81070b8 <ECAT_Init+0x138>)
 8107030:	2200      	movs	r2, #0
 8107032:	701a      	strb	r2, [r3, #0]
    bLocalErrorFlag = FALSE;
 8107034:	4b21      	ldr	r3, [pc, #132]	@ (81070bc <ECAT_Init+0x13c>)
 8107036:	2200      	movs	r2, #0
 8107038:	701a      	strb	r2, [r3, #0]
    u16LocalErrorCode = 0x00;
 810703a:	4b21      	ldr	r3, [pc, #132]	@ (81070c0 <ECAT_Init+0x140>)
 810703c:	2200      	movs	r2, #0
 810703e:	801a      	strh	r2, [r3, #0]

    u16ALEventMask = 0;
 8107040:	4b20      	ldr	r3, [pc, #128]	@ (81070c4 <ECAT_Init+0x144>)
 8107042:	2200      	movs	r2, #0
 8107044:	801a      	strh	r2, [r3, #0]
    nPdOutputSize = 0;
 8107046:	4b20      	ldr	r3, [pc, #128]	@ (81070c8 <ECAT_Init+0x148>)
 8107048:	2200      	movs	r2, #0
 810704a:	801a      	strh	r2, [r3, #0]
    nPdInputSize = 0;
 810704c:	4b1f      	ldr	r3, [pc, #124]	@ (81070cc <ECAT_Init+0x14c>)
 810704e:	2200      	movs	r2, #0
 8107050:	801a      	strh	r2, [r3, #0]

    /* initialize the AL Status register */
    nAlStatus    = STATE_INIT;
 8107052:	4b1f      	ldr	r3, [pc, #124]	@ (81070d0 <ECAT_Init+0x150>)
 8107054:	2201      	movs	r2, #1
 8107056:	701a      	strb	r2, [r3, #0]
    SetALStatus(nAlStatus, 0);
 8107058:	4b1d      	ldr	r3, [pc, #116]	@ (81070d0 <ECAT_Init+0x150>)
 810705a:	781b      	ldrb	r3, [r3, #0]
 810705c:	2100      	movs	r1, #0
 810705e:	4618      	mov	r0, r3
 8107060:	f7ff f9e4 	bl	810642c <SetALStatus>
    nEcatStateTrans = 0;
 8107064:	4b1b      	ldr	r3, [pc, #108]	@ (81070d4 <ECAT_Init+0x154>)
 8107066:	2200      	movs	r2, #0
 8107068:	801a      	strh	r2, [r3, #0]
    u8EcatErrorLed = LED_OFF;
 810706a:	4b1b      	ldr	r3, [pc, #108]	@ (81070d8 <ECAT_Init+0x158>)
 810706c:	2200      	movs	r2, #0
 810706e:	701a      	strb	r2, [r3, #0]

/* ECATCHANGE_START(V5.11) ECAT5*/
    bEscIntEnabled = FALSE;
 8107070:	4b1a      	ldr	r3, [pc, #104]	@ (81070dc <ECAT_Init+0x15c>)
 8107072:	2200      	movs	r2, #0
 8107074:	701a      	strb	r2, [r3, #0]
/* ECATCHANGE_END(V5.11) ECAT5*/

    /* initialize the COE part */
    COE_Init();
 8107076:	f7fe fa05 	bl	8105484 <COE_Init>
}
 810707a:	bf00      	nop
 810707c:	3708      	adds	r7, #8
 810707e:	46bd      	mov	sp, r7
 8107080:	bd80      	pop	{r7, pc}
 8107082:	bf00      	nop
 8107084:	10000858 	.word	0x10000858
 8107088:	1000085a 	.word	0x1000085a
 810708c:	1000084e 	.word	0x1000084e
 8107090:	1000084f 	.word	0x1000084f
 8107094:	1000082a 	.word	0x1000082a
 8107098:	10000828 	.word	0x10000828
 810709c:	10000829 	.word	0x10000829
 81070a0:	1000082b 	.word	0x1000082b
 81070a4:	1000085e 	.word	0x1000085e
 81070a8:	1000083c 	.word	0x1000083c
 81070ac:	1000083e 	.word	0x1000083e
 81070b0:	10000840 	.word	0x10000840
 81070b4:	10000842 	.word	0x10000842
 81070b8:	1000082c 	.word	0x1000082c
 81070bc:	1000084a 	.word	0x1000084a
 81070c0:	1000084c 	.word	0x1000084c
 81070c4:	10000864 	.word	0x10000864
 81070c8:	10000856 	.word	0x10000856
 81070cc:	10000854 	.word	0x10000854
 81070d0:	1000085c 	.word	0x1000085c
 81070d4:	10000850 	.word	0x10000850
 81070d8:	10000852 	.word	0x10000852
 81070dc:	10000848 	.word	0x10000848

081070e0 <ECAT_Main>:
/**
 \brief        This function has to be called cyclically.
*////////////////////////////////////////////////////////////////////////////////////////

void ECAT_Main(void)
{
 81070e0:	b580      	push	{r7, lr}
 81070e2:	b082      	sub	sp, #8
 81070e4:	af00      	add	r7, sp, #0
    UINT16 ALEventReg;
    UINT16 EscAlControl = 0x0000;
 81070e6:	2300      	movs	r3, #0
 81070e8:	80bb      	strh	r3, [r7, #4]
    UINT16 sm1Activate = SM_SETTING_ENABLE_VALUE;
 81070ea:	2301      	movs	r3, #1
 81070ec:	807b      	strh	r3, [r7, #2]

    /* check if services are stored in the mailbox */
    MBX_Main();
 81070ee:	f000 fd6f 	bl	8107bd0 <MBX_Main>


    if ( bMbxRunning )
 81070f2:	4b5d      	ldr	r3, [pc, #372]	@ (8107268 <ECAT_Main+0x188>)
 81070f4:	781b      	ldrb	r3, [r3, #0]
 81070f6:	2b00      	cmp	r3, #0
 81070f8:	d008      	beq.n	810710c <ECAT_Main+0x2c>
    {
        /* Slave is at least in PREOP, Mailbox is running */
        /* get the Activate-Byte of SM 1 (Register 0x80E) to check if a mailbox repeat request was received */
        HW_EscReadWord(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
 81070fa:	1cbb      	adds	r3, r7, #2
 81070fc:	2202      	movs	r2, #2
 81070fe:	f640 010e 	movw	r1, #2062	@ 0x80e
 8107102:	4618      	mov	r0, r3
 8107104:	f7f9 ffd0 	bl	81010a8 <HW_EscRead>
        sm1Activate = SWAPWORD(sm1Activate);
 8107108:	887b      	ldrh	r3, [r7, #2]
 810710a:	807b      	strh	r3, [r7, #2]
    }

    /* Read AL Event-Register from ESC */
    ALEventReg = HW_GetALEventRegister();
 810710c:	f7f9 ffc2 	bl	8101094 <HW_GetALEventRegister>
 8107110:	4603      	mov	r3, r0
 8107112:	80fb      	strh	r3, [r7, #6]
    ALEventReg = SWAPWORD(ALEventReg);


    if ((ALEventReg & AL_CONTROL_EVENT) && !bEcatWaitForAlControlRes)
 8107114:	88fb      	ldrh	r3, [r7, #6]
 8107116:	f003 0301 	and.w	r3, r3, #1
 810711a:	2b00      	cmp	r3, #0
 810711c:	d016      	beq.n	810714c <ECAT_Main+0x6c>
 810711e:	4b53      	ldr	r3, [pc, #332]	@ (810726c <ECAT_Main+0x18c>)
 8107120:	781b      	ldrb	r3, [r3, #0]
 8107122:	2b00      	cmp	r3, #0
 8107124:	d112      	bne.n	810714c <ECAT_Main+0x6c>
    {
        /* AL Control event is set, get the AL Control register sent by the Master to acknowledge the event
          (that the corresponding bit in the AL Event register will be reset) */
        HW_EscReadWord( EscAlControl, ESC_AL_CONTROL_OFFSET);
 8107126:	1d3b      	adds	r3, r7, #4
 8107128:	2202      	movs	r2, #2
 810712a:	f44f 7190 	mov.w	r1, #288	@ 0x120
 810712e:	4618      	mov	r0, r3
 8107130:	f7f9 ffba 	bl	81010a8 <HW_EscRead>
        EscAlControl = SWAPWORD(EscAlControl);
 8107134:	88bb      	ldrh	r3, [r7, #4]
 8107136:	80bb      	strh	r3, [r7, #4]


        /* reset AL Control event and the SM Change event (because the Sync Manager settings will be checked
           in AL_ControlInd, too)*/
        ALEventReg &= ~((AL_CONTROL_EVENT) | (SM_CHANGE_EVENT));
 8107138:	88fb      	ldrh	r3, [r7, #6]
 810713a:	f023 0311 	bic.w	r3, r3, #17
 810713e:	80fb      	strh	r3, [r7, #6]

        AL_ControlInd((UINT8)EscAlControl, 0); /* in AL_ControlInd the state transition will be checked and done */
 8107140:	88bb      	ldrh	r3, [r7, #4]
 8107142:	b2db      	uxtb	r3, r3
 8107144:	2100      	movs	r1, #0
 8107146:	4618      	mov	r0, r3
 8107148:	f7ff f9ca 	bl	81064e0 <AL_ControlInd>
        
        /* SM-Change-Event was handled too */
    }

    if ( (ALEventReg & SM_CHANGE_EVENT) && !bEcatWaitForAlControlRes && (nAlStatus & STATE_CHANGE) == 0 && (nAlStatus & ~STATE_CHANGE) != STATE_INIT )
 810714c:	88fb      	ldrh	r3, [r7, #6]
 810714e:	f003 0310 	and.w	r3, r3, #16
 8107152:	2b00      	cmp	r3, #0
 8107154:	d01c      	beq.n	8107190 <ECAT_Main+0xb0>
 8107156:	4b45      	ldr	r3, [pc, #276]	@ (810726c <ECAT_Main+0x18c>)
 8107158:	781b      	ldrb	r3, [r3, #0]
 810715a:	2b00      	cmp	r3, #0
 810715c:	d118      	bne.n	8107190 <ECAT_Main+0xb0>
 810715e:	4b44      	ldr	r3, [pc, #272]	@ (8107270 <ECAT_Main+0x190>)
 8107160:	781b      	ldrb	r3, [r3, #0]
 8107162:	f003 0310 	and.w	r3, r3, #16
 8107166:	2b00      	cmp	r3, #0
 8107168:	d112      	bne.n	8107190 <ECAT_Main+0xb0>
 810716a:	4b41      	ldr	r3, [pc, #260]	@ (8107270 <ECAT_Main+0x190>)
 810716c:	781b      	ldrb	r3, [r3, #0]
 810716e:	f023 0310 	bic.w	r3, r3, #16
 8107172:	2b01      	cmp	r3, #1
 8107174:	d00c      	beq.n	8107190 <ECAT_Main+0xb0>
    {
        /* the SM Change event is set (Bit 4 of Register 0x220), when the Byte 6 (Enable, Lo-Byte of Register 0x806, 0x80E, 0x816,...)
           of a Sync Manager channel was written */
        ALEventReg &= ~(SM_CHANGE_EVENT);
 8107176:	88fb      	ldrh	r3, [r7, #6]
 8107178:	f023 0310 	bic.w	r3, r3, #16
 810717c:	80fb      	strh	r3, [r7, #6]

        /* AL_ControlInd is called with the actual state, so that the correct SM settings will be checked */
        AL_ControlInd(nAlStatus & STATE_MASK, 0);
 810717e:	4b3c      	ldr	r3, [pc, #240]	@ (8107270 <ECAT_Main+0x190>)
 8107180:	781b      	ldrb	r3, [r3, #0]
 8107182:	f003 030f 	and.w	r3, r3, #15
 8107186:	b2db      	uxtb	r3, r3
 8107188:	2100      	movs	r1, #0
 810718a:	4618      	mov	r0, r3
 810718c:	f7ff f9a8 	bl	81064e0 <AL_ControlInd>
    }

    if(bEcatWaitForAlControlRes)
 8107190:	4b36      	ldr	r3, [pc, #216]	@ (810726c <ECAT_Main+0x18c>)
 8107192:	781b      	ldrb	r3, [r3, #0]
 8107194:	2b00      	cmp	r3, #0
 8107196:	d001      	beq.n	810719c <ECAT_Main+0xbc>
    {
        AL_ControlRes();
 8107198:	f7ff fd52 	bl	8106c40 <AL_ControlRes>
        The SM1 activate Byte (Register 0x80E) was read before reading AL Event register.
        1. Handle Mailbox Read event
        2. Handle repeat toggle request
        3. Handle Mailbox write event
    */
    if ( bMbxRunning )
 810719c:	4b32      	ldr	r3, [pc, #200]	@ (8107268 <ECAT_Main+0x188>)
 810719e:	781b      	ldrb	r3, [r3, #0]
 81071a0:	2b00      	cmp	r3, #0
 81071a2:	d05d      	beq.n	8107260 <ECAT_Main+0x180>
    {
        /*SnycManger change event (0x220:4) could be acknowledged by reading the SM1 control register without notification to the local application
        => check if the SyncManger 1 is still enabled*/
        if(!(sm1Activate & SM_SETTING_ENABLE_VALUE))
 81071a4:	887b      	ldrh	r3, [r7, #2]
 81071a6:	f003 0301 	and.w	r3, r3, #1
 81071aa:	2b00      	cmp	r3, #0
 81071ac:	d108      	bne.n	81071c0 <ECAT_Main+0xe0>
            AL_ControlInd(nAlStatus & STATE_MASK, 0);
 81071ae:	4b30      	ldr	r3, [pc, #192]	@ (8107270 <ECAT_Main+0x190>)
 81071b0:	781b      	ldrb	r3, [r3, #0]
 81071b2:	f003 030f 	and.w	r3, r3, #15
 81071b6:	b2db      	uxtb	r3, r3
 81071b8:	2100      	movs	r1, #0
 81071ba:	4618      	mov	r0, r3
 81071bc:	f7ff f990 	bl	81064e0 <AL_ControlInd>

        if ( ALEventReg & (MAILBOX_READ_EVENT) )
 81071c0:	88fb      	ldrh	r3, [r7, #6]
 81071c2:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 81071c6:	2b00      	cmp	r3, #0
 81071c8:	d00f      	beq.n	81071ea <ECAT_Main+0x10a>
        {
            /* SM 1 (Mailbox Read) event is set, when the mailbox was read from the master,
               to acknowledge the event the first byte of the mailbox has to be written,
               by writing the first byte the mailbox is locked, too */
            u16dummy = 0;
 81071ca:	4b2a      	ldr	r3, [pc, #168]	@ (8107274 <ECAT_Main+0x194>)
 81071cc:	2200      	movs	r2, #0
 81071ce:	801a      	strh	r2, [r3, #0]
            HW_EscWriteWord(u16dummy,u16EscAddrSendMbx);
 81071d0:	4b29      	ldr	r3, [pc, #164]	@ (8107278 <ECAT_Main+0x198>)
 81071d2:	881b      	ldrh	r3, [r3, #0]
 81071d4:	2202      	movs	r2, #2
 81071d6:	4619      	mov	r1, r3
 81071d8:	4826      	ldr	r0, [pc, #152]	@ (8107274 <ECAT_Main+0x194>)
 81071da:	f7f9 ffcd 	bl	8101178 <HW_EscWrite>

            /* the Mailbox Read event in the variable ALEventReg shall be reset before calling
               MBX_MailboxReadInd, where a new mailbox datagram (if available) could be stored in the send mailbox */
            ALEventReg &= ~(MAILBOX_READ_EVENT);
 81071de:	88fb      	ldrh	r3, [r7, #6]
 81071e0:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 81071e4:	80fb      	strh	r3, [r7, #6]
            MBX_MailboxReadInd();
 81071e6:	f000 fab5 	bl	8107754 <MBX_MailboxReadInd>
        }

        DISABLE_MBX_INT;
        /* bMbxRepeatToggle holds the last state of the Repeat Bit (Bit 1) */

        if ( ( (sm1Activate & SM_SETTING_REPAET_REQ_MASK) && !bMbxRepeatToggle )
 81071ea:	887b      	ldrh	r3, [r7, #2]
 81071ec:	f003 0302 	and.w	r3, r3, #2
 81071f0:	2b00      	cmp	r3, #0
 81071f2:	d003      	beq.n	81071fc <ECAT_Main+0x11c>
 81071f4:	4b21      	ldr	r3, [pc, #132]	@ (810727c <ECAT_Main+0x19c>)
 81071f6:	781b      	ldrb	r3, [r3, #0]
 81071f8:	2b00      	cmp	r3, #0
 81071fa:	d008      	beq.n	810720e <ECAT_Main+0x12e>
            ||( !(sm1Activate & SM_SETTING_REPAET_REQ_MASK) && bMbxRepeatToggle ))
 81071fc:	887b      	ldrh	r3, [r7, #2]
 81071fe:	f003 0302 	and.w	r3, r3, #2
 8107202:	2b00      	cmp	r3, #0
 8107204:	d11d      	bne.n	8107242 <ECAT_Main+0x162>
 8107206:	4b1d      	ldr	r3, [pc, #116]	@ (810727c <ECAT_Main+0x19c>)
 8107208:	781b      	ldrb	r3, [r3, #0]
 810720a:	2b00      	cmp	r3, #0
 810720c:	d019      	beq.n	8107242 <ECAT_Main+0x162>
        {
            /* Repeat Bit (Bit 1) has toggled, there is a repeat request, in MBX_MailboxRepeatReq the correct
               response will put in the send mailbox again */
            MBX_MailboxRepeatReq();
 810720e:	f000 fb09 	bl	8107824 <MBX_MailboxRepeatReq>
            /* acknowledge the repeat request after the send mailbox was updated by writing the Repeat Bit
               in the Repeat Ack Bit (Bit 1) of the PDI Ctrl-Byte of SM 1 (Register 0x80F) */
            if(bMbxRepeatToggle)
 8107212:	4b1a      	ldr	r3, [pc, #104]	@ (810727c <ECAT_Main+0x19c>)
 8107214:	781b      	ldrb	r3, [r3, #0]
 8107216:	2b00      	cmp	r3, #0
 8107218:	d005      	beq.n	8107226 <ECAT_Main+0x146>
                sm1Activate |= SM_SETTING_REPEAT_ACK; //set repeat acknowledge bit (bit 9)
 810721a:	887b      	ldrh	r3, [r7, #2]
 810721c:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8107220:	b29b      	uxth	r3, r3
 8107222:	807b      	strh	r3, [r7, #2]
 8107224:	e004      	b.n	8107230 <ECAT_Main+0x150>
            else
                sm1Activate &= ~SM_SETTING_REPEAT_ACK; //clear repeat acknowledge bit (bit 9)
 8107226:	887b      	ldrh	r3, [r7, #2]
 8107228:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 810722c:	b29b      	uxth	r3, r3
 810722e:	807b      	strh	r3, [r7, #2]

            sm1Activate = SWAPWORD(sm1Activate);
 8107230:	887b      	ldrh	r3, [r7, #2]
 8107232:	807b      	strh	r3, [r7, #2]
            HW_EscWriteWord(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
 8107234:	1cbb      	adds	r3, r7, #2
 8107236:	2202      	movs	r2, #2
 8107238:	f640 010e 	movw	r1, #2062	@ 0x80e
 810723c:	4618      	mov	r0, r3
 810723e:	f7f9 ff9b 	bl	8101178 <HW_EscWrite>
        }
        ENABLE_MBX_INT;

        /* Reload the AlEvent because it may be changed due to a SM disable, enable in case of an repeat request */
        ALEventReg = HW_GetALEventRegister();
 8107242:	f7f9 ff27 	bl	8101094 <HW_GetALEventRegister>
 8107246:	4603      	mov	r3, r0
 8107248:	80fb      	strh	r3, [r7, #6]
        ALEventReg = SWAPWORD(ALEventReg);

        if ( ALEventReg & (MAILBOX_WRITE_EVENT) )
 810724a:	88fb      	ldrh	r3, [r7, #6]
 810724c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
 8107250:	2b00      	cmp	r3, #0
 8107252:	d005      	beq.n	8107260 <ECAT_Main+0x180>
            /* SM 0 (Mailbox Write) event is set, when the mailbox was written from the master,
               to acknowledge the event the first byte of the mailbox has to be read,
               which will be done in MBX_CheckAndCopyMailbox */
            /* the Mailbox Write event in the variable ALEventReg shall be reset before calling
               MBX_CheckAndCopyMailbox, where the received mailbox datagram will be processed */
            ALEventReg &= ~(MAILBOX_WRITE_EVENT);
 8107254:	88fb      	ldrh	r3, [r7, #6]
 8107256:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 810725a:	80fb      	strh	r3, [r7, #6]
            MBX_CheckAndCopyMailbox();
 810725c:	f000 fb8c 	bl	8107978 <MBX_CheckAndCopyMailbox>

        }
    }
}
 8107260:	bf00      	nop
 8107262:	3708      	adds	r7, #8
 8107264:	46bd      	mov	sp, r7
 8107266:	bd80      	pop	{r7, pc}
 8107268:	10000877 	.word	0x10000877
 810726c:	1000084f 	.word	0x1000084f
 8107270:	1000085c 	.word	0x1000085c
 8107274:	10000866 	.word	0x10000866
 8107278:	10000880 	.word	0x10000880
 810727c:	10000878 	.word	0x10000878

08107280 <PutInMbxQueue>:
//
//    PutInMbxQueue
//

UINT8 PutInMbxQueue(TMBX MBXMEM * pMbx, TMBXQUEUE MBXMEM * pQueue)
{
 8107280:	b480      	push	{r7}
 8107282:	b085      	sub	sp, #20
 8107284:	af00      	add	r7, sp, #0
 8107286:	6078      	str	r0, [r7, #4]
 8107288:	6039      	str	r1, [r7, #0]
    UINT16 lastInQueue;
    ENTER_MBX_CRITICAL;


    lastInQueue = pQueue->lastInQueue+1;
 810728a:	683b      	ldr	r3, [r7, #0]
 810728c:	885b      	ldrh	r3, [r3, #2]
 810728e:	3301      	adds	r3, #1
 8107290:	81fb      	strh	r3, [r7, #14]
    if (lastInQueue == pQueue->maxQueueSize)
 8107292:	683b      	ldr	r3, [r7, #0]
 8107294:	889b      	ldrh	r3, [r3, #4]
 8107296:	89fa      	ldrh	r2, [r7, #14]
 8107298:	429a      	cmp	r2, r3
 810729a:	d101      	bne.n	81072a0 <PutInMbxQueue+0x20>
    {
        // Umbruch der Queue
        lastInQueue = 0;
 810729c:	2300      	movs	r3, #0
 810729e:	81fb      	strh	r3, [r7, #14]
    }

    if (pQueue->firstInQueue == lastInQueue)
 81072a0:	683b      	ldr	r3, [r7, #0]
 81072a2:	881b      	ldrh	r3, [r3, #0]
 81072a4:	89fa      	ldrh	r2, [r7, #14]
 81072a6:	429a      	cmp	r2, r3
 81072a8:	d101      	bne.n	81072ae <PutInMbxQueue+0x2e>
    {
        // Ueberlauf der Queue -> letztes Element wieder herausnehmen
        LEAVE_MBX_CRITICAL;
        return MBXERR_NOMOREMEMORY;
 81072aa:	2307      	movs	r3, #7
 81072ac:	e00b      	b.n	81072c6 <PutInMbxQueue+0x46>
    }

    pQueue->queue[pQueue->lastInQueue] = pMbx;
 81072ae:	683b      	ldr	r3, [r7, #0]
 81072b0:	885b      	ldrh	r3, [r3, #2]
 81072b2:	461a      	mov	r2, r3
 81072b4:	683b      	ldr	r3, [r7, #0]
 81072b6:	3202      	adds	r2, #2
 81072b8:	6879      	ldr	r1, [r7, #4]
 81072ba:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
    pQueue->lastInQueue = lastInQueue;
 81072be:	683b      	ldr	r3, [r7, #0]
 81072c0:	89fa      	ldrh	r2, [r7, #14]
 81072c2:	805a      	strh	r2, [r3, #2]

    LEAVE_MBX_CRITICAL;

    return 0;
 81072c4:	2300      	movs	r3, #0
}
 81072c6:	4618      	mov	r0, r3
 81072c8:	3714      	adds	r7, #20
 81072ca:	46bd      	mov	sp, r7
 81072cc:	f85d 7b04 	ldr.w	r7, [sp], #4
 81072d0:	4770      	bx	lr

081072d2 <GetOutOfMbxQueue>:
//
//    GetOutOfMbxQueue
//

TMBX MBXMEM * GetOutOfMbxQueue(TMBXQUEUE MBXMEM * pQueue)
{
 81072d2:	b480      	push	{r7}
 81072d4:	b085      	sub	sp, #20
 81072d6:	af00      	add	r7, sp, #0
 81072d8:	6078      	str	r0, [r7, #4]
    TMBX MBXMEM * pMbx;
    ENTER_MBX_CRITICAL;

    if (pQueue->firstInQueue != pQueue->lastInQueue)
 81072da:	687b      	ldr	r3, [r7, #4]
 81072dc:	881a      	ldrh	r2, [r3, #0]
 81072de:	687b      	ldr	r3, [r7, #4]
 81072e0:	885b      	ldrh	r3, [r3, #2]
 81072e2:	429a      	cmp	r2, r3
 81072e4:	d018      	beq.n	8107318 <GetOutOfMbxQueue+0x46>
    {
        // Queue ist nicht leer
        UINT16 firstInQueue = pQueue->firstInQueue;
 81072e6:	687b      	ldr	r3, [r7, #4]
 81072e8:	881b      	ldrh	r3, [r3, #0]
 81072ea:	817b      	strh	r3, [r7, #10]
        pMbx = pQueue->queue[firstInQueue];
 81072ec:	897a      	ldrh	r2, [r7, #10]
 81072ee:	687b      	ldr	r3, [r7, #4]
 81072f0:	3202      	adds	r2, #2
 81072f2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 81072f6:	60fb      	str	r3, [r7, #12]
        firstInQueue++;
 81072f8:	897b      	ldrh	r3, [r7, #10]
 81072fa:	3301      	adds	r3, #1
 81072fc:	817b      	strh	r3, [r7, #10]
        pQueue->firstInQueue = firstInQueue;
 81072fe:	687b      	ldr	r3, [r7, #4]
 8107300:	897a      	ldrh	r2, [r7, #10]
 8107302:	801a      	strh	r2, [r3, #0]
        if (pQueue->firstInQueue == pQueue->maxQueueSize)
 8107304:	687b      	ldr	r3, [r7, #4]
 8107306:	881a      	ldrh	r2, [r3, #0]
 8107308:	687b      	ldr	r3, [r7, #4]
 810730a:	889b      	ldrh	r3, [r3, #4]
 810730c:	429a      	cmp	r2, r3
 810730e:	d105      	bne.n	810731c <GetOutOfMbxQueue+0x4a>
        {
            // Umbruch der Queue
            pQueue->firstInQueue = 0;
 8107310:	687b      	ldr	r3, [r7, #4]
 8107312:	2200      	movs	r2, #0
 8107314:	801a      	strh	r2, [r3, #0]
 8107316:	e001      	b.n	810731c <GetOutOfMbxQueue+0x4a>
        }
    }
    else
        pMbx = 0;
 8107318:	2300      	movs	r3, #0
 810731a:	60fb      	str	r3, [r7, #12]


    LEAVE_MBX_CRITICAL;

    return pMbx;
 810731c:	68fb      	ldr	r3, [r7, #12]
}
 810731e:	4618      	mov	r0, r3
 8107320:	3714      	adds	r7, #20
 8107322:	46bd      	mov	sp, r7
 8107324:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107328:	4770      	bx	lr
	...

0810732c <MBX_Init>:
/**
 \brief    This function intialize the Mailbox Interface.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Init(void)
{
 810732c:	b580      	push	{r7, lr}
 810732e:	b082      	sub	sp, #8
 8107330:	af00      	add	r7, sp, #0
    u16ReceiveMbxSize = MIN_MBX_SIZE;
 8107332:	4b2d      	ldr	r3, [pc, #180]	@ (81073e8 <MBX_Init+0xbc>)
 8107334:	2222      	movs	r2, #34	@ 0x22
 8107336:	801a      	strh	r2, [r3, #0]
    u16SendMbxSize = MAX_MBX_SIZE;
 8107338:	4b2c      	ldr	r3, [pc, #176]	@ (81073ec <MBX_Init+0xc0>)
 810733a:	f44f 7280 	mov.w	r2, #256	@ 0x100
 810733e:	801a      	strh	r2, [r3, #0]
    u16EscAddrReceiveMbx = MIN_MBX_WRITE_ADDRESS;
 8107340:	4b2b      	ldr	r3, [pc, #172]	@ (81073f0 <MBX_Init+0xc4>)
 8107342:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 8107346:	801a      	strh	r2, [r3, #0]
    u16EscAddrSendMbx = MIN_MBX_READ_ADDRESS;
 8107348:	4b2a      	ldr	r3, [pc, #168]	@ (81073f4 <MBX_Init+0xc8>)
 810734a:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
 810734e:	801a      	strh	r2, [r3, #0]

    sMbxReceiveQueue.firstInQueue    = 0;
 8107350:	4b29      	ldr	r3, [pc, #164]	@ (81073f8 <MBX_Init+0xcc>)
 8107352:	2200      	movs	r2, #0
 8107354:	801a      	strh	r2, [r3, #0]
    sMbxReceiveQueue.lastInQueue     = 0;
 8107356:	4b28      	ldr	r3, [pc, #160]	@ (81073f8 <MBX_Init+0xcc>)
 8107358:	2200      	movs	r2, #0
 810735a:	805a      	strh	r2, [r3, #2]
    sMbxReceiveQueue.maxQueueSize = MAX_MBX_QUEUE_SIZE;
 810735c:	4b26      	ldr	r3, [pc, #152]	@ (81073f8 <MBX_Init+0xcc>)
 810735e:	220a      	movs	r2, #10
 8107360:	809a      	strh	r2, [r3, #4]
    sMbxSendQueue.firstInQueue        = 0;
 8107362:	4b26      	ldr	r3, [pc, #152]	@ (81073fc <MBX_Init+0xd0>)
 8107364:	2200      	movs	r2, #0
 8107366:	801a      	strh	r2, [r3, #0]
    sMbxSendQueue.lastInQueue         = 0;
 8107368:	4b24      	ldr	r3, [pc, #144]	@ (81073fc <MBX_Init+0xd0>)
 810736a:	2200      	movs	r2, #0
 810736c:	805a      	strh	r2, [r3, #2]
    sMbxSendQueue.maxQueueSize     = MAX_MBX_QUEUE_SIZE;
 810736e:	4b23      	ldr	r3, [pc, #140]	@ (81073fc <MBX_Init+0xd0>)
 8107370:	220a      	movs	r2, #10
 8107372:	809a      	strh	r2, [r3, #4]
    psWriteMbx  = NULL;
 8107374:	4b22      	ldr	r3, [pc, #136]	@ (8107400 <MBX_Init+0xd4>)
 8107376:	2200      	movs	r2, #0
 8107378:	601a      	str	r2, [r3, #0]


    psRepeatMbx = NULL;
 810737a:	4b22      	ldr	r3, [pc, #136]	@ (8107404 <MBX_Init+0xd8>)
 810737c:	2200      	movs	r2, #0
 810737e:	601a      	str	r2, [r3, #0]
    psReadMbx    = NULL;
 8107380:	4b21      	ldr	r3, [pc, #132]	@ (8107408 <MBX_Init+0xdc>)
 8107382:	2200      	movs	r2, #0
 8107384:	601a      	str	r2, [r3, #0]
    psStoreMbx    = NULL;
 8107386:	4b21      	ldr	r3, [pc, #132]	@ (810740c <MBX_Init+0xe0>)
 8107388:	2200      	movs	r2, #0
 810738a:	601a      	str	r2, [r3, #0]

    bMbxRepeatToggle    = FALSE;
 810738c:	4b20      	ldr	r3, [pc, #128]	@ (8107410 <MBX_Init+0xe4>)
 810738e:	2200      	movs	r2, #0
 8107390:	701a      	strb	r2, [r3, #0]
    /*Reset Repeat acknowledge bit of SyncManager1 (0x80F bit 2)*/
    {
        UINT16 sm1Activate = 0;
 8107392:	2300      	movs	r3, #0
 8107394:	80fb      	strh	r3, [r7, #6]
        HW_EscReadWord(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
 8107396:	1dbb      	adds	r3, r7, #6
 8107398:	2202      	movs	r2, #2
 810739a:	f640 010e 	movw	r1, #2062	@ 0x80e
 810739e:	4618      	mov	r0, r3
 81073a0:	f7f9 fe82 	bl	81010a8 <HW_EscRead>
        sm1Activate &= SWAPWORD(~0x0200);
 81073a4:	88fb      	ldrh	r3, [r7, #6]
 81073a6:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 81073aa:	b29b      	uxth	r3, r3
 81073ac:	80fb      	strh	r3, [r7, #6]
        HW_EscWriteWord(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
 81073ae:	1dbb      	adds	r3, r7, #6
 81073b0:	2202      	movs	r2, #2
 81073b2:	f640 010e 	movw	r1, #2062	@ 0x80e
 81073b6:	4618      	mov	r0, r3
 81073b8:	f7f9 fede 	bl	8101178 <HW_EscWrite>
    }
    bMbxRunning = FALSE;
 81073bc:	4b15      	ldr	r3, [pc, #84]	@ (8107414 <MBX_Init+0xe8>)
 81073be:	2200      	movs	r2, #0
 81073c0:	701a      	strb	r2, [r3, #0]
    bSendMbxIsFull = FALSE;
 81073c2:	4b15      	ldr	r3, [pc, #84]	@ (8107418 <MBX_Init+0xec>)
 81073c4:	2200      	movs	r2, #0
 81073c6:	701a      	strb	r2, [r3, #0]
    bReceiveMbxIsLocked = FALSE;
 81073c8:	4b14      	ldr	r3, [pc, #80]	@ (810741c <MBX_Init+0xf0>)
 81073ca:	2200      	movs	r2, #0
 81073cc:	701a      	strb	r2, [r3, #0]
    u8MailboxSendReqStored    = 0;
 81073ce:	4b14      	ldr	r3, [pc, #80]	@ (8107420 <MBX_Init+0xf4>)
 81073d0:	2200      	movs	r2, #0
 81073d2:	701a      	strb	r2, [r3, #0]
    u8MbxWriteCounter = 0;
 81073d4:	4b13      	ldr	r3, [pc, #76]	@ (8107424 <MBX_Init+0xf8>)
 81073d6:	2200      	movs	r2, #0
 81073d8:	701a      	strb	r2, [r3, #0]
    u8MbxReadCounter    = 0;
 81073da:	4b13      	ldr	r3, [pc, #76]	@ (8107428 <MBX_Init+0xfc>)
 81073dc:	2200      	movs	r2, #0
 81073de:	701a      	strb	r2, [r3, #0]
}
 81073e0:	bf00      	nop
 81073e2:	3708      	adds	r7, #8
 81073e4:	46bd      	mov	sp, r7
 81073e6:	bd80      	pop	{r7, pc}
 81073e8:	1000087c 	.word	0x1000087c
 81073ec:	1000087a 	.word	0x1000087a
 81073f0:	1000087e 	.word	0x1000087e
 81073f4:	10000880 	.word	0x10000880
 81073f8:	10000acc 	.word	0x10000acc
 81073fc:	10000a98 	.word	0x10000a98
 8107400:	10000a88 	.word	0x10000a88
 8107404:	10000a90 	.word	0x10000a90
 8107408:	10000a8c 	.word	0x10000a8c
 810740c:	10000a94 	.word	0x10000a94
 8107410:	10000878 	.word	0x10000878
 8107414:	10000877 	.word	0x10000877
 8107418:	10000876 	.word	0x10000876
 810741c:	10000875 	.word	0x10000875
 8107420:	10000a84 	.word	0x10000a84
 8107424:	10000882 	.word	0x10000882
 8107428:	10000883 	.word	0x10000883

0810742c <MBX_StartMailboxHandler>:
 \brief     it is checked if the mailbox areas overlaps each other
 \brief     and the Sync Manager channels 0 and 1 are enabled.
 \brief     This function shall only be called if mailbox is supported.
*////////////////////////////////////////////////////////////////////////////////////////
UINT16 MBX_StartMailboxHandler(void)
{
 810742c:	b580      	push	{r7, lr}
 810742e:	b082      	sub	sp, #8
 8107430:	af00      	add	r7, sp, #0
    UINT16 result = 0;
 8107432:	2300      	movs	r3, #0
 8107434:	80fb      	strh	r3, [r7, #6]
    /* get address of the receive mailbox sync manager (SM0) */
/*ECATCHANGE_START(V5.11) HW1*/
    TSYNCMAN ESCMEM * pSyncMan = (TSYNCMAN ESCMEM *)GetSyncMan(MAILBOX_WRITE);
 8107436:	2000      	movs	r0, #0
 8107438:	f7fe f90a 	bl	8105650 <GetSyncMan>
 810743c:	6038      	str	r0, [r7, #0]
/*ECATCHANGE_END(V5.11) HW1*/
    /* store size of the receive mailbox */
    u16ReceiveMbxSize     = pSyncMan->Length;
 810743e:	683b      	ldr	r3, [r7, #0]
 8107440:	885a      	ldrh	r2, [r3, #2]
 8107442:	4b2f      	ldr	r3, [pc, #188]	@ (8107500 <MBX_StartMailboxHandler+0xd4>)
 8107444:	801a      	strh	r2, [r3, #0]
    /* store the address of the receive mailbox */
    u16EscAddrReceiveMbx = pSyncMan->PhysicalStartAddress;
 8107446:	683b      	ldr	r3, [r7, #0]
 8107448:	881a      	ldrh	r2, [r3, #0]
 810744a:	4b2e      	ldr	r3, [pc, #184]	@ (8107504 <MBX_StartMailboxHandler+0xd8>)
 810744c:	801a      	strh	r2, [r3, #0]

    /* get address of the send mailbox sync manager (SM1) */
/*ECATCHANGE_START(V5.11) HW1*/
    pSyncMan =(TSYNCMAN ESCMEM *) GetSyncMan(MAILBOX_READ);
 810744e:	2001      	movs	r0, #1
 8107450:	f7fe f8fe 	bl	8105650 <GetSyncMan>
 8107454:	6038      	str	r0, [r7, #0]
/*ECATCHANGE_END(V5.11) HW1*/

    /* store the size of the send mailbox */
    u16SendMbxSize = pSyncMan->Length;
 8107456:	683b      	ldr	r3, [r7, #0]
 8107458:	885a      	ldrh	r2, [r3, #2]
 810745a:	4b2b      	ldr	r3, [pc, #172]	@ (8107508 <MBX_StartMailboxHandler+0xdc>)
 810745c:	801a      	strh	r2, [r3, #0]
    /* store the address of the send mailbox */
    u16EscAddrSendMbx = pSyncMan->PhysicalStartAddress;
 810745e:	683b      	ldr	r3, [r7, #0]
 8107460:	881a      	ldrh	r2, [r3, #0]
 8107462:	4b2a      	ldr	r3, [pc, #168]	@ (810750c <MBX_StartMailboxHandler+0xe0>)
 8107464:	801a      	strh	r2, [r3, #0]

    // HBu 02.05.06: it should be checked if there are overlaps in the sync manager areas
    if ((u16EscAddrReceiveMbx + u16ReceiveMbxSize) > u16EscAddrSendMbx && (u16EscAddrReceiveMbx < (u16EscAddrSendMbx + u16SendMbxSize)))
 8107466:	4b27      	ldr	r3, [pc, #156]	@ (8107504 <MBX_StartMailboxHandler+0xd8>)
 8107468:	881b      	ldrh	r3, [r3, #0]
 810746a:	461a      	mov	r2, r3
 810746c:	4b24      	ldr	r3, [pc, #144]	@ (8107500 <MBX_StartMailboxHandler+0xd4>)
 810746e:	881b      	ldrh	r3, [r3, #0]
 8107470:	4413      	add	r3, r2
 8107472:	4a26      	ldr	r2, [pc, #152]	@ (810750c <MBX_StartMailboxHandler+0xe0>)
 8107474:	8812      	ldrh	r2, [r2, #0]
 8107476:	4293      	cmp	r3, r2
 8107478:	dd0c      	ble.n	8107494 <MBX_StartMailboxHandler+0x68>
 810747a:	4b22      	ldr	r3, [pc, #136]	@ (8107504 <MBX_StartMailboxHandler+0xd8>)
 810747c:	881b      	ldrh	r3, [r3, #0]
 810747e:	461a      	mov	r2, r3
 8107480:	4b22      	ldr	r3, [pc, #136]	@ (810750c <MBX_StartMailboxHandler+0xe0>)
 8107482:	881b      	ldrh	r3, [r3, #0]
 8107484:	4619      	mov	r1, r3
 8107486:	4b20      	ldr	r3, [pc, #128]	@ (8107508 <MBX_StartMailboxHandler+0xdc>)
 8107488:	881b      	ldrh	r3, [r3, #0]
 810748a:	440b      	add	r3, r1
 810748c:	429a      	cmp	r2, r3
 810748e:	da01      	bge.n	8107494 <MBX_StartMailboxHandler+0x68>
    {
        return ALSTATUSCODE_INVALIDMBXCFGINPREOP;
 8107490:	2316      	movs	r3, #22
 8107492:	e031      	b.n	81074f8 <MBX_StartMailboxHandler+0xcc>
    }

    /* enable the receive mailbox sync manager channel */
/*ECATCHANGE_START(V5.11) HW1*/
    EnableSyncManChannel(MAILBOX_WRITE);
 8107494:	2000      	movs	r0, #0
 8107496:	f7fe f91b 	bl	81056d0 <EnableSyncManChannel>
    /* enable the send mailbox sync manager channel */
    EnableSyncManChannel(MAILBOX_READ);
 810749a:	2001      	movs	r0, #1
 810749c:	f7fe f918 	bl	81056d0 <EnableSyncManChannel>
/*ECATCHANGE_END(V5.11) HW1*/

/* ECATCHANGE_START(V5.11) MBX2*/
        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
 81074a0:	4b17      	ldr	r3, [pc, #92]	@ (8107500 <MBX_StartMailboxHandler+0xd4>)
 81074a2:	881b      	ldrh	r3, [r3, #0]
 81074a4:	4618      	mov	r0, r3
 81074a6:	f008 fa23 	bl	810f8f0 <malloc>
 81074aa:	4603      	mov	r3, r0
 81074ac:	461a      	mov	r2, r3
 81074ae:	4b18      	ldr	r3, [pc, #96]	@ (8107510 <MBX_StartMailboxHandler+0xe4>)
 81074b0:	601a      	str	r2, [r3, #0]
        if(psWriteMbx == NULL)
 81074b2:	4b17      	ldr	r3, [pc, #92]	@ (8107510 <MBX_StartMailboxHandler+0xe4>)
 81074b4:	681b      	ldr	r3, [r3, #0]
 81074b6:	2b00      	cmp	r3, #0
 81074b8:	d115      	bne.n	81074e6 <MBX_StartMailboxHandler+0xba>
        {
            bNoMbxMemoryAvailable = TRUE;
 81074ba:	4b16      	ldr	r3, [pc, #88]	@ (8107514 <MBX_StartMailboxHandler+0xe8>)
 81074bc:	2201      	movs	r2, #1
 81074be:	701a      	strb	r2, [r3, #0]

            //check if at least enough memory for an mailbox error is available (other wise stop the state transition)
            psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
 81074c0:	200a      	movs	r0, #10
 81074c2:	f008 fa15 	bl	810f8f0 <malloc>
 81074c6:	4603      	mov	r3, r0
 81074c8:	461a      	mov	r2, r3
 81074ca:	4b11      	ldr	r3, [pc, #68]	@ (8107510 <MBX_StartMailboxHandler+0xe4>)
 81074cc:	601a      	str	r2, [r3, #0]
            if(psWriteMbx == NULL)
 81074ce:	4b10      	ldr	r3, [pc, #64]	@ (8107510 <MBX_StartMailboxHandler+0xe4>)
 81074d0:	681b      	ldr	r3, [r3, #0]
 81074d2:	2b00      	cmp	r3, #0
 81074d4:	d101      	bne.n	81074da <MBX_StartMailboxHandler+0xae>
            {
                result = ALSTATUSCODE_NOMEMORY;
 81074d6:	2302      	movs	r3, #2
 81074d8:	80fb      	strh	r3, [r7, #6]
            }
           
            APPL_FreeMailboxBuffer(psWriteMbx);
 81074da:	4b0d      	ldr	r3, [pc, #52]	@ (8107510 <MBX_StartMailboxHandler+0xe4>)
 81074dc:	681b      	ldr	r3, [r3, #0]
 81074de:	4618      	mov	r0, r3
 81074e0:	f008 fa0e 	bl	810f900 <free>
 81074e4:	e007      	b.n	81074f6 <MBX_StartMailboxHandler+0xca>
        }
        else
        {
            bNoMbxMemoryAvailable = FALSE;
 81074e6:	4b0b      	ldr	r3, [pc, #44]	@ (8107514 <MBX_StartMailboxHandler+0xe8>)
 81074e8:	2200      	movs	r2, #0
 81074ea:	701a      	strb	r2, [r3, #0]
            APPL_FreeMailboxBuffer(psWriteMbx);
 81074ec:	4b08      	ldr	r3, [pc, #32]	@ (8107510 <MBX_StartMailboxHandler+0xe4>)
 81074ee:	681b      	ldr	r3, [r3, #0]
 81074f0:	4618      	mov	r0, r3
 81074f2:	f008 fa05 	bl	810f900 <free>
        }
/* ECATCHANGE_END(V5.11) MBX2*/

    return result;
 81074f6:	88fb      	ldrh	r3, [r7, #6]
}
 81074f8:	4618      	mov	r0, r3
 81074fa:	3708      	adds	r7, #8
 81074fc:	46bd      	mov	sp, r7
 81074fe:	bd80      	pop	{r7, pc}
 8107500:	1000087c 	.word	0x1000087c
 8107504:	1000087e 	.word	0x1000087e
 8107508:	1000087a 	.word	0x1000087a
 810750c:	10000880 	.word	0x10000880
 8107510:	10000a88 	.word	0x10000a88
 8107514:	10000b00 	.word	0x10000b00

08107518 <MBX_StopMailboxHandler>:
 \brief  local management service Stop Mailbox Handler
 \brief  the Sync Manager channels 0 and 1 are disabled
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_StopMailboxHandler(void)
{
 8107518:	b580      	push	{r7, lr}
 810751a:	b082      	sub	sp, #8
 810751c:	af00      	add	r7, sp, #0
    TMBX MBXMEM * pMbx;

    /* mailbox handler is stopped */
    bMbxRunning = FALSE;
 810751e:	4b44      	ldr	r3, [pc, #272]	@ (8107630 <MBX_StopMailboxHandler+0x118>)
 8107520:	2200      	movs	r2, #0
 8107522:	701a      	strb	r2, [r3, #0]
    /* disable the receive mailbox sync manager channel */
/*ECATCHANGE_START(V5.11) HW1*/
    DisableSyncManChannel(MAILBOX_WRITE);
 8107524:	2000      	movs	r0, #0
 8107526:	f7fe f8ab 	bl	8105680 <DisableSyncManChannel>
    /* disable the send mailbox sync manager channel */
    DisableSyncManChannel(MAILBOX_READ);
 810752a:	2001      	movs	r0, #1
 810752c:	f7fe f8a8 	bl	8105680 <DisableSyncManChannel>
/*ECATCHANGE_END(V5.11) HW1*/
    /* initialize variables again */


    if (psRepeatMbx != NULL)
 8107530:	4b40      	ldr	r3, [pc, #256]	@ (8107634 <MBX_StopMailboxHandler+0x11c>)
 8107532:	681b      	ldr	r3, [r3, #0]
 8107534:	2b00      	cmp	r3, #0
 8107536:	d004      	beq.n	8107542 <MBX_StopMailboxHandler+0x2a>
        APPL_FreeMailboxBuffer(psRepeatMbx);
 8107538:	4b3e      	ldr	r3, [pc, #248]	@ (8107634 <MBX_StopMailboxHandler+0x11c>)
 810753a:	681b      	ldr	r3, [r3, #0]
 810753c:	4618      	mov	r0, r3
 810753e:	f008 f9df 	bl	810f900 <free>

    if (psStoreMbx != NULL && psStoreMbx != psRepeatMbx)
 8107542:	4b3d      	ldr	r3, [pc, #244]	@ (8107638 <MBX_StopMailboxHandler+0x120>)
 8107544:	681b      	ldr	r3, [r3, #0]
 8107546:	2b00      	cmp	r3, #0
 8107548:	d00a      	beq.n	8107560 <MBX_StopMailboxHandler+0x48>
 810754a:	4b3b      	ldr	r3, [pc, #236]	@ (8107638 <MBX_StopMailboxHandler+0x120>)
 810754c:	681a      	ldr	r2, [r3, #0]
 810754e:	4b39      	ldr	r3, [pc, #228]	@ (8107634 <MBX_StopMailboxHandler+0x11c>)
 8107550:	681b      	ldr	r3, [r3, #0]
 8107552:	429a      	cmp	r2, r3
 8107554:	d004      	beq.n	8107560 <MBX_StopMailboxHandler+0x48>
        APPL_FreeMailboxBuffer(psStoreMbx);
 8107556:	4b38      	ldr	r3, [pc, #224]	@ (8107638 <MBX_StopMailboxHandler+0x120>)
 8107558:	681b      	ldr	r3, [r3, #0]
 810755a:	4618      	mov	r0, r3
 810755c:	f008 f9d0 	bl	810f900 <free>

    if (psReadMbx != NULL && psReadMbx != psRepeatMbx && psReadMbx != psStoreMbx)
 8107560:	4b36      	ldr	r3, [pc, #216]	@ (810763c <MBX_StopMailboxHandler+0x124>)
 8107562:	681b      	ldr	r3, [r3, #0]
 8107564:	2b00      	cmp	r3, #0
 8107566:	d010      	beq.n	810758a <MBX_StopMailboxHandler+0x72>
 8107568:	4b34      	ldr	r3, [pc, #208]	@ (810763c <MBX_StopMailboxHandler+0x124>)
 810756a:	681a      	ldr	r2, [r3, #0]
 810756c:	4b31      	ldr	r3, [pc, #196]	@ (8107634 <MBX_StopMailboxHandler+0x11c>)
 810756e:	681b      	ldr	r3, [r3, #0]
 8107570:	429a      	cmp	r2, r3
 8107572:	d00a      	beq.n	810758a <MBX_StopMailboxHandler+0x72>
 8107574:	4b31      	ldr	r3, [pc, #196]	@ (810763c <MBX_StopMailboxHandler+0x124>)
 8107576:	681a      	ldr	r2, [r3, #0]
 8107578:	4b2f      	ldr	r3, [pc, #188]	@ (8107638 <MBX_StopMailboxHandler+0x120>)
 810757a:	681b      	ldr	r3, [r3, #0]
 810757c:	429a      	cmp	r2, r3
 810757e:	d004      	beq.n	810758a <MBX_StopMailboxHandler+0x72>
        APPL_FreeMailboxBuffer(psReadMbx);
 8107580:	4b2e      	ldr	r3, [pc, #184]	@ (810763c <MBX_StopMailboxHandler+0x124>)
 8107582:	681b      	ldr	r3, [r3, #0]
 8107584:	4618      	mov	r0, r3
 8107586:	f008 f9bb 	bl	810f900 <free>


    psRepeatMbx = NULL;
 810758a:	4b2a      	ldr	r3, [pc, #168]	@ (8107634 <MBX_StopMailboxHandler+0x11c>)
 810758c:	2200      	movs	r2, #0
 810758e:	601a      	str	r2, [r3, #0]
    psReadMbx = NULL;
 8107590:	4b2a      	ldr	r3, [pc, #168]	@ (810763c <MBX_StopMailboxHandler+0x124>)
 8107592:	2200      	movs	r2, #0
 8107594:	601a      	str	r2, [r3, #0]
    psStoreMbx = NULL;
 8107596:	4b28      	ldr	r3, [pc, #160]	@ (8107638 <MBX_StopMailboxHandler+0x120>)
 8107598:	2200      	movs	r2, #0
 810759a:	601a      	str	r2, [r3, #0]

    bMbxRepeatToggle    = FALSE;
 810759c:	4b28      	ldr	r3, [pc, #160]	@ (8107640 <MBX_StopMailboxHandler+0x128>)
 810759e:	2200      	movs	r2, #0
 81075a0:	701a      	strb	r2, [r3, #0]
    /*Reset Repeat acknowledge bit of SyncManager1 (0x080F bit 2)*/
    {
        UINT16 sm1Activate = 0;
 81075a2:	2300      	movs	r3, #0
 81075a4:	807b      	strh	r3, [r7, #2]
        HW_EscReadWord(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
 81075a6:	1cbb      	adds	r3, r7, #2
 81075a8:	2202      	movs	r2, #2
 81075aa:	f640 010e 	movw	r1, #2062	@ 0x80e
 81075ae:	4618      	mov	r0, r3
 81075b0:	f7f9 fd7a 	bl	81010a8 <HW_EscRead>
        sm1Activate &= SWAPWORD(~0x0200);
 81075b4:	887b      	ldrh	r3, [r7, #2]
 81075b6:	f423 7300 	bic.w	r3, r3, #512	@ 0x200
 81075ba:	b29b      	uxth	r3, r3
 81075bc:	807b      	strh	r3, [r7, #2]
        HW_EscWriteWord(sm1Activate,(ESC_SYNCMAN_ACTIVE_OFFSET + SIZEOF_SM_REGISTER));
 81075be:	1cbb      	adds	r3, r7, #2
 81075c0:	2202      	movs	r2, #2
 81075c2:	f640 010e 	movw	r1, #2062	@ 0x80e
 81075c6:	4618      	mov	r0, r3
 81075c8:	f7f9 fdd6 	bl	8101178 <HW_EscWrite>
    }
    bSendMbxIsFull         = FALSE;
 81075cc:	4b1d      	ldr	r3, [pc, #116]	@ (8107644 <MBX_StopMailboxHandler+0x12c>)
 81075ce:	2200      	movs	r2, #0
 81075d0:	701a      	strb	r2, [r3, #0]
    bReceiveMbxIsLocked = FALSE;
 81075d2:	4b1d      	ldr	r3, [pc, #116]	@ (8107648 <MBX_StopMailboxHandler+0x130>)
 81075d4:	2200      	movs	r2, #0
 81075d6:	701a      	strb	r2, [r3, #0]
    u8MailboxSendReqStored    = 0;
 81075d8:	4b1c      	ldr	r3, [pc, #112]	@ (810764c <MBX_StopMailboxHandler+0x134>)
 81075da:	2200      	movs	r2, #0
 81075dc:	701a      	strb	r2, [r3, #0]
    u8MbxWriteCounter         = 0;
 81075de:	4b1c      	ldr	r3, [pc, #112]	@ (8107650 <MBX_StopMailboxHandler+0x138>)
 81075e0:	2200      	movs	r2, #0
 81075e2:	701a      	strb	r2, [r3, #0]
    u8MbxReadCounter        = 0;
 81075e4:	4b1b      	ldr	r3, [pc, #108]	@ (8107654 <MBX_StopMailboxHandler+0x13c>)
 81075e6:	2200      	movs	r2, #0
 81075e8:	701a      	strb	r2, [r3, #0]

    do
    {
        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
 81075ea:	481b      	ldr	r0, [pc, #108]	@ (8107658 <MBX_StopMailboxHandler+0x140>)
 81075ec:	f7ff fe71 	bl	81072d2 <GetOutOfMbxQueue>
 81075f0:	6078      	str	r0, [r7, #4]
        if (pMbx)
 81075f2:	687b      	ldr	r3, [r7, #4]
 81075f4:	2b00      	cmp	r3, #0
 81075f6:	d004      	beq.n	8107602 <MBX_StopMailboxHandler+0xea>
        {
            APPL_FreeMailboxBuffer(pMbx);
 81075f8:	6878      	ldr	r0, [r7, #4]
 81075fa:	f008 f981 	bl	810f900 <free>
            pMbx = NULL;
 81075fe:	2300      	movs	r3, #0
 8107600:	607b      	str	r3, [r7, #4]
        }
    } while (pMbx != NULL);
 8107602:	687b      	ldr	r3, [r7, #4]
 8107604:	2b00      	cmp	r3, #0
 8107606:	d1f0      	bne.n	81075ea <MBX_StopMailboxHandler+0xd2>
    do
    {
        pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
 8107608:	4814      	ldr	r0, [pc, #80]	@ (810765c <MBX_StopMailboxHandler+0x144>)
 810760a:	f7ff fe62 	bl	81072d2 <GetOutOfMbxQueue>
 810760e:	6078      	str	r0, [r7, #4]
        if (pMbx)
 8107610:	687b      	ldr	r3, [r7, #4]
 8107612:	2b00      	cmp	r3, #0
 8107614:	d004      	beq.n	8107620 <MBX_StopMailboxHandler+0x108>
        {
            APPL_FreeMailboxBuffer(pMbx);
 8107616:	6878      	ldr	r0, [r7, #4]
 8107618:	f008 f972 	bl	810f900 <free>
            pMbx = NULL;
 810761c:	2300      	movs	r3, #0
 810761e:	607b      	str	r3, [r7, #4]
        }
    } while (pMbx != NULL);
 8107620:	687b      	ldr	r3, [r7, #4]
 8107622:	2b00      	cmp	r3, #0
 8107624:	d1f0      	bne.n	8107608 <MBX_StopMailboxHandler+0xf0>

}
 8107626:	bf00      	nop
 8107628:	bf00      	nop
 810762a:	3708      	adds	r7, #8
 810762c:	46bd      	mov	sp, r7
 810762e:	bd80      	pop	{r7, pc}
 8107630:	10000877 	.word	0x10000877
 8107634:	10000a90 	.word	0x10000a90
 8107638:	10000a94 	.word	0x10000a94
 810763c:	10000a8c 	.word	0x10000a8c
 8107640:	10000878 	.word	0x10000878
 8107644:	10000876 	.word	0x10000876
 8107648:	10000875 	.word	0x10000875
 810764c:	10000a84 	.word	0x10000a84
 8107650:	10000882 	.word	0x10000882
 8107654:	10000883 	.word	0x10000883
 8107658:	10000acc 	.word	0x10000acc
 810765c:	10000a98 	.word	0x10000a98

08107660 <MailboxServiceInd>:
 \brief    The function checks the mailbox header for the requested service and calls the
 \brief    corresponding XXXX_ServiceInd-function
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 MailboxServiceInd(TMBX MBXMEM *pMbx)
{
 8107660:	b580      	push	{r7, lr}
 8107662:	b084      	sub	sp, #16
 8107664:	af00      	add	r7, sp, #0
 8107666:	6078      	str	r0, [r7, #4]
    UINT8 result;


    switch ( (pMbx->MbxHeader.Flags[MBX_OFFS_TYPE] & MBX_MASK_TYPE) >> MBX_SHIFT_TYPE )
 8107668:	687b      	ldr	r3, [r7, #4]
 810766a:	889b      	ldrh	r3, [r3, #4]
 810766c:	121b      	asrs	r3, r3, #8
 810766e:	f003 030f 	and.w	r3, r3, #15
 8107672:	2b03      	cmp	r3, #3
 8107674:	d105      	bne.n	8107682 <MailboxServiceInd+0x22>
    {
    case MBX_TYPE_COE:
        /* CoE datagram received */
        result = COE_ServiceInd((TCOEMBX MBXMEM *) pMbx);
 8107676:	6878      	ldr	r0, [r7, #4]
 8107678:	f7fd ff16 	bl	81054a8 <COE_ServiceInd>
 810767c:	4603      	mov	r3, r0
 810767e:	73fb      	strb	r3, [r7, #15]
        break;
 8107680:	e002      	b.n	8107688 <MailboxServiceInd+0x28>

    default:

        result = MBXERR_UNSUPPORTEDPROTOCOL;
 8107682:	2302      	movs	r3, #2
 8107684:	73fb      	strb	r3, [r7, #15]
        break;
 8107686:	bf00      	nop
    }

    return result;
 8107688:	7bfb      	ldrb	r3, [r7, #15]
}
 810768a:	4618      	mov	r0, r3
 810768c:	3710      	adds	r7, #16
 810768e:	46bd      	mov	sp, r7
 8107690:	bd80      	pop	{r7, pc}
	...

08107694 <MBX_MailboxWriteInd>:
 \brief    The function checks the mailbox header for the requested service and calls the
 \brief    corresponding XXXX_ServiceInd-function
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_MailboxWriteInd(TMBX MBXMEM *pMbx)
{
 8107694:	b580      	push	{r7, lr}
 8107696:	b084      	sub	sp, #16
 8107698:	af00      	add	r7, sp, #0
 810769a:	6078      	str	r0, [r7, #4]
    UINT8 result = 0;
 810769c:	2300      	movs	r3, #0
 810769e:	73fb      	strb	r3, [r7, #15]
    UINT8 mbxCounter = pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] >> MBX_SHIFT_COUNTER;
 81076a0:	687b      	ldr	r3, [r7, #4]
 81076a2:	889b      	ldrh	r3, [r3, #4]
 81076a4:	0b1b      	lsrs	r3, r3, #12
 81076a6:	b29b      	uxth	r3, r3
 81076a8:	73bb      	strb	r3, [r7, #14]
    UINT16 MbxLen = SWAPWORD(pMbx->MbxHeader.Length);
 81076aa:	687b      	ldr	r3, [r7, #4]
 81076ac:	881b      	ldrh	r3, [r3, #0]
 81076ae:	81bb      	strh	r3, [r7, #12]

    if(MbxLen > MAX_MBX_SIZE)
 81076b0:	89bb      	ldrh	r3, [r7, #12]
 81076b2:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
 81076b6:	d914      	bls.n	81076e2 <MBX_MailboxWriteInd+0x4e>
    {
        /* Mailbox error response: size specified in mailbox header too large*/
        pMbx->MbxHeader.Length     = 4;
 81076b8:	687b      	ldr	r3, [r7, #4]
 81076ba:	2204      	movs	r2, #4
 81076bc:	801a      	strh	r2, [r3, #0]
        pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
 81076be:	687b      	ldr	r3, [r7, #4]
 81076c0:	889b      	ldrh	r3, [r3, #4]
 81076c2:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 81076c6:	b29a      	uxth	r2, r3
 81076c8:	687b      	ldr	r3, [r7, #4]
 81076ca:	809a      	strh	r2, [r3, #4]
        pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
 81076cc:	687b      	ldr	r3, [r7, #4]
 81076ce:	2201      	movs	r2, #1
 81076d0:	80da      	strh	r2, [r3, #6]
        pMbx->Data[1]                        = SWAPWORD(MBXERR_INVALIDSIZE);
 81076d2:	687b      	ldr	r3, [r7, #4]
 81076d4:	2208      	movs	r2, #8
 81076d6:	811a      	strh	r2, [r3, #8]
        MBX_MailboxSendReq(pMbx, 0);
 81076d8:	2100      	movs	r1, #0
 81076da:	6878      	ldr	r0, [r7, #4]
 81076dc:	f000 f8e0 	bl	81078a0 <MBX_MailboxSendReq>
    else
    {
        APPL_FreeMailboxBuffer(pMbx);
        pMbx = NULL;
    }
}
 81076e0:	e02f      	b.n	8107742 <MBX_MailboxWriteInd+0xae>
    if ( mbxCounter == 0 || mbxCounter != u8MbxWriteCounter )
 81076e2:	7bbb      	ldrb	r3, [r7, #14]
 81076e4:	2b00      	cmp	r3, #0
 81076e6:	d004      	beq.n	81076f2 <MBX_MailboxWriteInd+0x5e>
 81076e8:	4b18      	ldr	r3, [pc, #96]	@ (810774c <MBX_MailboxWriteInd+0xb8>)
 81076ea:	781b      	ldrb	r3, [r3, #0]
 81076ec:	7bba      	ldrb	r2, [r7, #14]
 81076ee:	429a      	cmp	r2, r3
 81076f0:	d021      	beq.n	8107736 <MBX_MailboxWriteInd+0xa2>
        u8MbxWriteCounter = mbxCounter;
 81076f2:	4a16      	ldr	r2, [pc, #88]	@ (810774c <MBX_MailboxWriteInd+0xb8>)
 81076f4:	7bbb      	ldrb	r3, [r7, #14]
 81076f6:	7013      	strb	r3, [r2, #0]
            result = PutInMbxQueue(pMbx, &sMbxReceiveQueue);
 81076f8:	4915      	ldr	r1, [pc, #84]	@ (8107750 <MBX_MailboxWriteInd+0xbc>)
 81076fa:	6878      	ldr	r0, [r7, #4]
 81076fc:	f7ff fdc0 	bl	8107280 <PutInMbxQueue>
 8107700:	4603      	mov	r3, r0
 8107702:	73fb      	strb	r3, [r7, #15]
        if ( result != 0 )
 8107704:	7bfb      	ldrb	r3, [r7, #15]
 8107706:	2b00      	cmp	r3, #0
 8107708:	d01b      	beq.n	8107742 <MBX_MailboxWriteInd+0xae>
            pMbx->MbxHeader.Length     = 4;
 810770a:	687b      	ldr	r3, [r7, #4]
 810770c:	2204      	movs	r2, #4
 810770e:	801a      	strh	r2, [r3, #0]
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~MBX_MASK_TYPE;
 8107710:	687b      	ldr	r3, [r7, #4]
 8107712:	889b      	ldrh	r3, [r3, #4]
 8107714:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 8107718:	b29a      	uxth	r2, r3
 810771a:	687b      	ldr	r3, [r7, #4]
 810771c:	809a      	strh	r2, [r3, #4]
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
 810771e:	687b      	ldr	r3, [r7, #4]
 8107720:	2201      	movs	r2, #1
 8107722:	80da      	strh	r2, [r3, #6]
            pMbx->Data[1]                        = SWAPWORD(result);
 8107724:	7bfb      	ldrb	r3, [r7, #15]
 8107726:	b29a      	uxth	r2, r3
 8107728:	687b      	ldr	r3, [r7, #4]
 810772a:	811a      	strh	r2, [r3, #8]
            MBX_MailboxSendReq(pMbx, 0);
 810772c:	2100      	movs	r1, #0
 810772e:	6878      	ldr	r0, [r7, #4]
 8107730:	f000 f8b6 	bl	81078a0 <MBX_MailboxSendReq>
        if ( result != 0 )
 8107734:	e005      	b.n	8107742 <MBX_MailboxWriteInd+0xae>
        APPL_FreeMailboxBuffer(pMbx);
 8107736:	6878      	ldr	r0, [r7, #4]
 8107738:	f008 f8e2 	bl	810f900 <free>
        pMbx = NULL;
 810773c:	2300      	movs	r3, #0
 810773e:	607b      	str	r3, [r7, #4]
}
 8107740:	e7ff      	b.n	8107742 <MBX_MailboxWriteInd+0xae>
 8107742:	bf00      	nop
 8107744:	3710      	adds	r7, #16
 8107746:	46bd      	mov	sp, r7
 8107748:	bd80      	pop	{r7, pc}
 810774a:	bf00      	nop
 810774c:	10000882 	.word	0x10000882
 8107750:	10000acc 	.word	0x10000acc

08107754 <MBX_MailboxReadInd>:
/**
 \brief This function is called when the Master has read the Send-Mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_MailboxReadInd(void)
{
 8107754:	b580      	push	{r7, lr}
 8107756:	b082      	sub	sp, #8
 8107758:	af00      	add	r7, sp, #0
    bSendMbxIsFull = FALSE;
 810775a:	4b2b      	ldr	r3, [pc, #172]	@ (8107808 <MBX_MailboxReadInd+0xb4>)
 810775c:	2200      	movs	r2, #0
 810775e:	701a      	strb	r2, [r3, #0]
    // HBu 02.05.06: the pointer psRepeatMbx is only free if there is no stored
    //               mailbox service from the last repeat
    if ( psRepeatMbx && psStoreMbx == NULL )
 8107760:	4b2a      	ldr	r3, [pc, #168]	@ (810780c <MBX_MailboxReadInd+0xb8>)
 8107762:	681b      	ldr	r3, [r3, #0]
 8107764:	2b00      	cmp	r3, #0
 8107766:	d00b      	beq.n	8107780 <MBX_MailboxReadInd+0x2c>
 8107768:	4b29      	ldr	r3, [pc, #164]	@ (8107810 <MBX_MailboxReadInd+0xbc>)
 810776a:	681b      	ldr	r3, [r3, #0]
 810776c:	2b00      	cmp	r3, #0
 810776e:	d107      	bne.n	8107780 <MBX_MailboxReadInd+0x2c>
    {
    /* the last sent service is not stored for repeat any longer */
        APPL_FreeMailboxBuffer(psRepeatMbx);
 8107770:	4b26      	ldr	r3, [pc, #152]	@ (810780c <MBX_MailboxReadInd+0xb8>)
 8107772:	681b      	ldr	r3, [r3, #0]
 8107774:	4618      	mov	r0, r3
 8107776:	f008 f8c3 	bl	810f900 <free>
        psRepeatMbx = NULL;
 810777a:	4b24      	ldr	r3, [pc, #144]	@ (810780c <MBX_MailboxReadInd+0xb8>)
 810777c:	2200      	movs	r2, #0
 810777e:	601a      	str	r2, [r3, #0]
    }

    /* the actual sent service has to be stored for repeat */
    psRepeatMbx = psReadMbx;
 8107780:	4b24      	ldr	r3, [pc, #144]	@ (8107814 <MBX_MailboxReadInd+0xc0>)
 8107782:	681b      	ldr	r3, [r3, #0]
 8107784:	4a21      	ldr	r2, [pc, #132]	@ (810780c <MBX_MailboxReadInd+0xb8>)
 8107786:	6013      	str	r3, [r2, #0]

      if ( psStoreMbx )
 8107788:	4b21      	ldr	r3, [pc, #132]	@ (8107810 <MBX_MailboxReadInd+0xbc>)
 810778a:	681b      	ldr	r3, [r3, #0]
 810778c:	2b00      	cmp	r3, #0
 810778e:	d008      	beq.n	81077a2 <MBX_MailboxReadInd+0x4e>
      {
        /* there was a buffer stored */
        MBX_CopyToSendMailbox(psStoreMbx);
 8107790:	4b1f      	ldr	r3, [pc, #124]	@ (8107810 <MBX_MailboxReadInd+0xbc>)
 8107792:	681b      	ldr	r3, [r3, #0]
 8107794:	4618      	mov	r0, r3
 8107796:	f000 f991 	bl	8107abc <MBX_CopyToSendMailbox>
        /* no more buffer to be stored any more */
        psStoreMbx = NULL;
 810779a:	4b1d      	ldr	r3, [pc, #116]	@ (8107810 <MBX_MailboxReadInd+0xbc>)
 810779c:	2200      	movs	r2, #0
 810779e:	601a      	str	r2, [r3, #0]
 81077a0:	e009      	b.n	81077b6 <MBX_MailboxReadInd+0x62>
      }
      else
    {
        TMBX MBXMEM *pMbx = GetOutOfMbxQueue(&sMbxSendQueue);
 81077a2:	481d      	ldr	r0, [pc, #116]	@ (8107818 <MBX_MailboxReadInd+0xc4>)
 81077a4:	f7ff fd95 	bl	81072d2 <GetOutOfMbxQueue>
 81077a8:	6078      	str	r0, [r7, #4]
        if (pMbx)
 81077aa:	687b      	ldr	r3, [r7, #4]
 81077ac:	2b00      	cmp	r3, #0
 81077ae:	d002      	beq.n	81077b6 <MBX_MailboxReadInd+0x62>
        {
            MBX_CopyToSendMailbox(pMbx);
 81077b0:	6878      	ldr	r0, [r7, #4]
 81077b2:	f000 f983 	bl	8107abc <MBX_CopyToSendMailbox>
        }
    }

      if ( u8MailboxSendReqStored )
 81077b6:	4b19      	ldr	r3, [pc, #100]	@ (810781c <MBX_MailboxReadInd+0xc8>)
 81077b8:	781b      	ldrb	r3, [r3, #0]
 81077ba:	2b00      	cmp	r3, #0
 81077bc:	d01f      	beq.n	81077fe <MBX_MailboxReadInd+0xaa>
    {
        /* there are mailbox services stored to be sent */
        if ( u8MailboxSendReqStored & COE_SERVICE )
 81077be:	4b17      	ldr	r3, [pc, #92]	@ (810781c <MBX_MailboxReadInd+0xc8>)
 81077c0:	781b      	ldrb	r3, [r3, #0]
 81077c2:	f003 0302 	and.w	r3, r3, #2
 81077c6:	2b00      	cmp	r3, #0
 81077c8:	d019      	beq.n	81077fe <MBX_MailboxReadInd+0xaa>
        {
           UINT8 result = 0;
 81077ca:	2300      	movs	r3, #0
 81077cc:	70fb      	strb	r3, [r7, #3]
            /* reset the flag indicating that CoE service to be sent was stored */
            u8MailboxSendReqStored &= ~COE_SERVICE;
 81077ce:	4b13      	ldr	r3, [pc, #76]	@ (810781c <MBX_MailboxReadInd+0xc8>)
 81077d0:	781b      	ldrb	r3, [r3, #0]
 81077d2:	f023 0302 	bic.w	r3, r3, #2
 81077d6:	b2da      	uxtb	r2, r3
 81077d8:	4b10      	ldr	r3, [pc, #64]	@ (810781c <MBX_MailboxReadInd+0xc8>)
 81077da:	701a      	strb	r2, [r3, #0]

            /* call CoE function that will send the stored CoE service */
            result = COE_ContinueInd(psWriteMbx);
 81077dc:	4b10      	ldr	r3, [pc, #64]	@ (8107820 <MBX_MailboxReadInd+0xcc>)
 81077de:	681b      	ldr	r3, [r3, #0]
 81077e0:	4618      	mov	r0, r3
 81077e2:	f7fd fe99 	bl	8105518 <COE_ContinueInd>
 81077e6:	4603      	mov	r3, r0
 81077e8:	70fb      	strb	r3, [r7, #3]

            if (result != 0)
 81077ea:	78fb      	ldrb	r3, [r7, #3]
 81077ec:	2b00      	cmp	r3, #0
 81077ee:	d006      	beq.n	81077fe <MBX_MailboxReadInd+0xaa>
            {
                /*Set the pending CoE indication is an error occurred during the continue indication*/
                u8MailboxSendReqStored |= COE_SERVICE;
 81077f0:	4b0a      	ldr	r3, [pc, #40]	@ (810781c <MBX_MailboxReadInd+0xc8>)
 81077f2:	781b      	ldrb	r3, [r3, #0]
 81077f4:	f043 0302 	orr.w	r3, r3, #2
 81077f8:	b2da      	uxtb	r2, r3
 81077fa:	4b08      	ldr	r3, [pc, #32]	@ (810781c <MBX_MailboxReadInd+0xc8>)
 81077fc:	701a      	strb	r2, [r3, #0]
        }
        else
        {
        }
    }
}
 81077fe:	bf00      	nop
 8107800:	3708      	adds	r7, #8
 8107802:	46bd      	mov	sp, r7
 8107804:	bd80      	pop	{r7, pc}
 8107806:	bf00      	nop
 8107808:	10000876 	.word	0x10000876
 810780c:	10000a90 	.word	0x10000a90
 8107810:	10000a94 	.word	0x10000a94
 8107814:	10000a8c 	.word	0x10000a8c
 8107818:	10000a98 	.word	0x10000a98
 810781c:	10000a84 	.word	0x10000a84
 8107820:	10000a88 	.word	0x10000a88

08107824 <MBX_MailboxRepeatReq>:
 \brief This function is called if the Master has requested a resending of the last
 \brief sent mailbox
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_MailboxRepeatReq(void)
{
 8107824:	b580      	push	{r7, lr}
 8107826:	b082      	sub	sp, #8
 8107828:	af00      	add	r7, sp, #0
    if (psRepeatMbx)
 810782a:	4b18      	ldr	r3, [pc, #96]	@ (810788c <MBX_MailboxRepeatReq+0x68>)
 810782c:	681b      	ldr	r3, [r3, #0]
 810782e:	2b00      	cmp	r3, #0
 8107830:	d01d      	beq.n	810786e <MBX_MailboxRepeatReq+0x4a>
    {
        TMBX MBXMEM *pMbx = psRepeatMbx;
 8107832:	4b16      	ldr	r3, [pc, #88]	@ (810788c <MBX_MailboxRepeatReq+0x68>)
 8107834:	681b      	ldr	r3, [r3, #0]
 8107836:	607b      	str	r3, [r7, #4]
        /* HBu 13.10.06: if a repeat request is received (again) before the previously repeated mailbox telegram
           was read from the master (psStoreMbx != NULL) the next mailbox telegram to be sent is still in the
            read mailbox so it has not to updated exchanged */
        ENTER_MBX_CRITICAL;

       if (bSendMbxIsFull && psStoreMbx == NULL)
 8107838:	4b15      	ldr	r3, [pc, #84]	@ (8107890 <MBX_MailboxRepeatReq+0x6c>)
 810783a:	781b      	ldrb	r3, [r3, #0]
 810783c:	2b00      	cmp	r3, #0
 810783e:	d010      	beq.n	8107862 <MBX_MailboxRepeatReq+0x3e>
 8107840:	4b14      	ldr	r3, [pc, #80]	@ (8107894 <MBX_MailboxRepeatReq+0x70>)
 8107842:	681b      	ldr	r3, [r3, #0]
 8107844:	2b00      	cmp	r3, #0
 8107846:	d10c      	bne.n	8107862 <MBX_MailboxRepeatReq+0x3e>
        {
            /* mailbox is full, take the buffer off */
/*ECATCHANGE_START(V5.11) HW1*/
            DisableSyncManChannel(MAILBOX_READ);
 8107848:	2001      	movs	r0, #1
 810784a:	f7fd ff19 	bl	8105680 <DisableSyncManChannel>

            /* store the buffer to be sent next */
            psStoreMbx = psReadMbx;
 810784e:	4b12      	ldr	r3, [pc, #72]	@ (8107898 <MBX_MailboxRepeatReq+0x74>)
 8107850:	681b      	ldr	r3, [r3, #0]
 8107852:	4a10      	ldr	r2, [pc, #64]	@ (8107894 <MBX_MailboxRepeatReq+0x70>)
 8107854:	6013      	str	r3, [r2, #0]
            /* enable the mailbox again */
            EnableSyncManChannel(MAILBOX_READ);
 8107856:	2001      	movs	r0, #1
 8107858:	f7fd ff3a 	bl	81056d0 <EnableSyncManChannel>
/*ECATCHANGE_END(V5.11) HW1*/

            /* HBu 15.02.06: flag has to be reset otherwise the mailbox service
                             will not be copied by MBX_CopyToSendMailbox */
            bSendMbxIsFull = FALSE;
 810785c:	4b0c      	ldr	r3, [pc, #48]	@ (8107890 <MBX_MailboxRepeatReq+0x6c>)
 810785e:	2200      	movs	r2, #0
 8107860:	701a      	strb	r2, [r3, #0]
        }


        MBX_CopyToSendMailbox(pMbx);
 8107862:	6878      	ldr	r0, [r7, #4]
 8107864:	f000 f92a 	bl	8107abc <MBX_CopyToSendMailbox>
        // HBu 17.06.06: psRepeatMbx has to be set to 0, when it was repeated, otherwise it would be returned twice
        // to the empty queue (MAILBOX_QUEUE=1) or a buffer get lost, if the the next repeat request will happen before
        // the repeated buffer was read
        psRepeatMbx = NULL;
 8107868:	4b08      	ldr	r3, [pc, #32]	@ (810788c <MBX_MailboxRepeatReq+0x68>)
 810786a:	2200      	movs	r2, #0
 810786c:	601a      	str	r2, [r3, #0]
        LEAVE_MBX_CRITICAL;
    }

    // Repeat was finished, toggle the acknowledge bit
    bMbxRepeatToggle = !bMbxRepeatToggle;
 810786e:	4b0b      	ldr	r3, [pc, #44]	@ (810789c <MBX_MailboxRepeatReq+0x78>)
 8107870:	781b      	ldrb	r3, [r3, #0]
 8107872:	2b00      	cmp	r3, #0
 8107874:	bf0c      	ite	eq
 8107876:	2301      	moveq	r3, #1
 8107878:	2300      	movne	r3, #0
 810787a:	b2db      	uxtb	r3, r3
 810787c:	461a      	mov	r2, r3
 810787e:	4b07      	ldr	r3, [pc, #28]	@ (810789c <MBX_MailboxRepeatReq+0x78>)
 8107880:	701a      	strb	r2, [r3, #0]
}
 8107882:	bf00      	nop
 8107884:	3708      	adds	r7, #8
 8107886:	46bd      	mov	sp, r7
 8107888:	bd80      	pop	{r7, pc}
 810788a:	bf00      	nop
 810788c:	10000a90 	.word	0x10000a90
 8107890:	10000876 	.word	0x10000876
 8107894:	10000a94 	.word	0x10000a94
 8107898:	10000a8c 	.word	0x10000a8c
 810789c:	10000878 	.word	0x10000878

081078a0 <MBX_MailboxSendReq>:

 \brief        This function puts a new Mailbox service in the Send Mailbox
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 MBX_MailboxSendReq( TMBX MBXMEM * pMbx, UINT8 flags )
{
 81078a0:	b580      	push	{r7, lr}
 81078a2:	b084      	sub	sp, #16
 81078a4:	af00      	add	r7, sp, #0
 81078a6:	6078      	str	r0, [r7, #4]
 81078a8:	460b      	mov	r3, r1
 81078aa:	70fb      	strb	r3, [r7, #3]
    UINT8 result = 0;
 81078ac:	2300      	movs	r3, #0
 81078ae:	73fb      	strb	r3, [r7, #15]

    /* HBu 06.02.06: in INIT-state a mailbox send request shall be refused */
    if ( (nAlStatus & STATE_MASK) == STATE_INIT )
 81078b0:	4b2d      	ldr	r3, [pc, #180]	@ (8107968 <MBX_MailboxSendReq+0xc8>)
 81078b2:	781b      	ldrb	r3, [r3, #0]
 81078b4:	f003 030f 	and.w	r3, r3, #15
 81078b8:	2b01      	cmp	r3, #1
 81078ba:	d101      	bne.n	81078c0 <MBX_MailboxSendReq+0x20>
        return ERROR_INVALIDSTATE;
 81078bc:	23f0      	movs	r3, #240	@ 0xf0
 81078be:	e04e      	b.n	810795e <MBX_MailboxSendReq+0xbe>
    ENTER_MBX_CRITICAL;
    DISABLE_MBX_INT;

    /* the counter in the mailbox header has to be incremented with every new mailbox service to be sent
       if the mailbox data link layer is supported (software switch MAILBOX_REPEAT_SUPPORTED set)*/
    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] &= ~MBX_MASK_COUNTER;
 81078c0:	687b      	ldr	r3, [r7, #4]
 81078c2:	889b      	ldrh	r3, [r3, #4]
 81078c4:	f3c3 030b 	ubfx	r3, r3, #0, #12
 81078c8:	b29a      	uxth	r2, r3
 81078ca:	687b      	ldr	r3, [r7, #4]
 81078cc:	809a      	strh	r2, [r3, #4]
    /* HBu 13.02.06: Repeat-Counter was incremented too much if the mailbox service could not be sent */
    /* u8MbxCounter holds the actual counter for the mailbox header, only the values
       1-7 are allowed if the mailbox data link layer is supported  */
    if ( (u8MbxReadCounter & 0x07) == 0 )
 81078ce:	4b27      	ldr	r3, [pc, #156]	@ (810796c <MBX_MailboxSendReq+0xcc>)
 81078d0:	781b      	ldrb	r3, [r3, #0]
 81078d2:	f003 0307 	and.w	r3, r3, #7
 81078d6:	2b00      	cmp	r3, #0
 81078d8:	d102      	bne.n	81078e0 <MBX_MailboxSendReq+0x40>
        u8MbxReadCounter = 1;
 81078da:	4b24      	ldr	r3, [pc, #144]	@ (810796c <MBX_MailboxSendReq+0xcc>)
 81078dc:	2201      	movs	r2, #1
 81078de:	701a      	strb	r2, [r3, #0]

    pMbx->MbxHeader.Flags[MBX_OFFS_COUNTER] |= u8MbxReadCounter << MBX_SHIFT_COUNTER;
 81078e0:	687b      	ldr	r3, [r7, #4]
 81078e2:	889b      	ldrh	r3, [r3, #4]
 81078e4:	b21a      	sxth	r2, r3
 81078e6:	4b21      	ldr	r3, [pc, #132]	@ (810796c <MBX_MailboxSendReq+0xcc>)
 81078e8:	781b      	ldrb	r3, [r3, #0]
 81078ea:	031b      	lsls	r3, r3, #12
 81078ec:	b21b      	sxth	r3, r3
 81078ee:	4313      	orrs	r3, r2
 81078f0:	b21b      	sxth	r3, r3
 81078f2:	b29a      	uxth	r2, r3
 81078f4:	687b      	ldr	r3, [r7, #4]
 81078f6:	809a      	strh	r2, [r3, #4]

    /* try to copy the mailbox command in the ESC */
    if ( MBX_CopyToSendMailbox(pMbx) != 0 )
 81078f8:	6878      	ldr	r0, [r7, #4]
 81078fa:	f000 f8df 	bl	8107abc <MBX_CopyToSendMailbox>
 81078fe:	4603      	mov	r3, r0
 8107900:	2b00      	cmp	r3, #0
 8107902:	d014      	beq.n	810792e <MBX_MailboxSendReq+0x8e>
    {
        /* no success, send mailbox was full, set flag  */
        result = PutInMbxQueue(pMbx, &sMbxSendQueue);
 8107904:	491a      	ldr	r1, [pc, #104]	@ (8107970 <MBX_MailboxSendReq+0xd0>)
 8107906:	6878      	ldr	r0, [r7, #4]
 8107908:	f7ff fcba 	bl	8107280 <PutInMbxQueue>
 810790c:	4603      	mov	r3, r0
 810790e:	73fb      	strb	r3, [r7, #15]
        if (result != 0)
 8107910:	7bfb      	ldrb	r3, [r7, #15]
 8107912:	2b00      	cmp	r3, #0
 8107914:	d004      	beq.n	8107920 <MBX_MailboxSendReq+0x80>
            flags |= FRAGMENTS_FOLLOW;
 8107916:	78fb      	ldrb	r3, [r7, #3]
 8107918:	f063 037f 	orn	r3, r3, #127	@ 0x7f
 810791c:	70fb      	strb	r3, [r7, #3]
 810791e:	e00c      	b.n	810793a <MBX_MailboxSendReq+0x9a>
        else
            u8MbxReadCounter++;
 8107920:	4b12      	ldr	r3, [pc, #72]	@ (810796c <MBX_MailboxSendReq+0xcc>)
 8107922:	781b      	ldrb	r3, [r3, #0]
 8107924:	3301      	adds	r3, #1
 8107926:	b2da      	uxtb	r2, r3
 8107928:	4b10      	ldr	r3, [pc, #64]	@ (810796c <MBX_MailboxSendReq+0xcc>)
 810792a:	701a      	strb	r2, [r3, #0]
 810792c:	e005      	b.n	810793a <MBX_MailboxSendReq+0x9a>
    }
    /* HBu 13.02.06: Repeat-Counter was incremented too much if the mailbox service could not be sent */
    else
    {
        u8MbxReadCounter++;
 810792e:	4b0f      	ldr	r3, [pc, #60]	@ (810796c <MBX_MailboxSendReq+0xcc>)
 8107930:	781b      	ldrb	r3, [r3, #0]
 8107932:	3301      	adds	r3, #1
 8107934:	b2da      	uxtb	r2, r3
 8107936:	4b0d      	ldr	r3, [pc, #52]	@ (810796c <MBX_MailboxSendReq+0xcc>)
 8107938:	701a      	strb	r2, [r3, #0]
    }

    if ( flags & FRAGMENTS_FOLLOW )
 810793a:	f997 3003 	ldrsb.w	r3, [r7, #3]
 810793e:	2b00      	cmp	r3, #0
 8107940:	da0c      	bge.n	810795c <MBX_MailboxSendReq+0xbc>
    {
        /* store the mailbox service that the corresponding XXX_ContinueInd function will
           be called when the send mailbox will have been read by the master because there
           are mailbox commands to be sent for this service */
        u8MailboxSendReqStored |= (flags & ((UINT8) ~FRAGMENTS_FOLLOW));
 8107942:	f997 3003 	ldrsb.w	r3, [r7, #3]
 8107946:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 810794a:	b25a      	sxtb	r2, r3
 810794c:	4b09      	ldr	r3, [pc, #36]	@ (8107974 <MBX_MailboxSendReq+0xd4>)
 810794e:	781b      	ldrb	r3, [r3, #0]
 8107950:	b25b      	sxtb	r3, r3
 8107952:	4313      	orrs	r3, r2
 8107954:	b25b      	sxtb	r3, r3
 8107956:	b2da      	uxtb	r2, r3
 8107958:	4b06      	ldr	r3, [pc, #24]	@ (8107974 <MBX_MailboxSendReq+0xd4>)
 810795a:	701a      	strb	r2, [r3, #0]
    }

    ENABLE_MBX_INT;
    LEAVE_MBX_CRITICAL;

    return result;
 810795c:	7bfb      	ldrb	r3, [r7, #15]
}
 810795e:	4618      	mov	r0, r3
 8107960:	3710      	adds	r7, #16
 8107962:	46bd      	mov	sp, r7
 8107964:	bd80      	pop	{r7, pc}
 8107966:	bf00      	nop
 8107968:	1000085c 	.word	0x1000085c
 810796c:	10000883 	.word	0x10000883
 8107970:	10000a98 	.word	0x10000a98
 8107974:	10000a84 	.word	0x10000a84

08107978 <MBX_CheckAndCopyMailbox>:

        Also the contents of the Receive Mailbox will be copied in the variable sMbx.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_CheckAndCopyMailbox( void )
{
 8107978:	b580      	push	{r7, lr}
 810797a:	b082      	sub	sp, #8
 810797c:	af00      	add	r7, sp, #0
    UINT16 mbxLen;

    /* get the size of the received mailbox command and acknowledge the event*/
    HW_EscReadWord(mbxLen,u16EscAddrReceiveMbx);
 810797e:	4b47      	ldr	r3, [pc, #284]	@ (8107a9c <MBX_CheckAndCopyMailbox+0x124>)
 8107980:	8819      	ldrh	r1, [r3, #0]
 8107982:	1cbb      	adds	r3, r7, #2
 8107984:	2202      	movs	r2, #2
 8107986:	4618      	mov	r0, r3
 8107988:	f7f9 fb8e 	bl	81010a8 <HW_EscRead>
    
    /* the size has to be swapped here, all other bytes of the mailbox service will be swapped later */
    mbxLen = SWAPWORD(mbxLen);
 810798c:	887b      	ldrh	r3, [r7, #2]
 810798e:	807b      	strh	r3, [r7, #2]

/* ECATCHANGE_START(V5.11) MBX2*/
    if(bNoMbxMemoryAvailable == TRUE)
 8107990:	4b43      	ldr	r3, [pc, #268]	@ (8107aa0 <MBX_CheckAndCopyMailbox+0x128>)
 8107992:	781b      	ldrb	r3, [r3, #0]
 8107994:	2b01      	cmp	r3, #1
 8107996:	d123      	bne.n	81079e0 <MBX_CheckAndCopyMailbox+0x68>
    {
        /* Return a no memory error in case of any mailbox request*/
        TMBX MBXMEM *pMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(10); /* a mailbox error datagram length*/
 8107998:	200a      	movs	r0, #10
 810799a:	f007 ffa9 	bl	810f8f0 <malloc>
 810799e:	4603      	mov	r3, r0
 81079a0:	607b      	str	r3, [r7, #4]

        if(pMbx != NULL)
 81079a2:	687b      	ldr	r3, [r7, #4]
 81079a4:	2b00      	cmp	r3, #0
 81079a6:	d01b      	beq.n	81079e0 <MBX_CheckAndCopyMailbox+0x68>
        {
            HMEMSET(pMbx,0x00,10);
 81079a8:	220a      	movs	r2, #10
 81079aa:	2100      	movs	r1, #0
 81079ac:	6878      	ldr	r0, [r7, #4]
 81079ae:	f008 f974 	bl	810fc9a <memset>

            /* Mailbox error response: type 0 (mailbox service protocol) */
            pMbx->MbxHeader.Length     = 4;
 81079b2:	687b      	ldr	r3, [r7, #4]
 81079b4:	2204      	movs	r2, #4
 81079b6:	801a      	strh	r2, [r3, #0]
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
 81079b8:	687b      	ldr	r3, [r7, #4]
 81079ba:	889b      	ldrh	r3, [r3, #4]
 81079bc:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 81079c0:	b29a      	uxth	r2, r3
 81079c2:	687b      	ldr	r3, [r7, #4]
 81079c4:	809a      	strh	r2, [r3, #4]
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
 81079c6:	687b      	ldr	r3, [r7, #4]
 81079c8:	2201      	movs	r2, #1
 81079ca:	80da      	strh	r2, [r3, #6]
            pMbx->Data[1]                        = SWAPWORD(MBXERR_NOMOREMEMORY);
 81079cc:	687b      	ldr	r3, [r7, #4]
 81079ce:	2207      	movs	r2, #7
 81079d0:	811a      	strh	r2, [r3, #8]
            MBX_MailboxSendReq(pMbx, 0);
 81079d2:	2100      	movs	r1, #0
 81079d4:	6878      	ldr	r0, [r7, #4]
 81079d6:	f7ff ff63 	bl	81078a0 <MBX_MailboxSendReq>

            APPL_FreeMailboxBuffer(pMbx);
 81079da:	6878      	ldr	r0, [r7, #4]
 81079dc:	f007 ff90 	bl	810f900 <free>
        }
    }
/* ECATCHANGE_END(V5.11) MBX2*/
    /* the length of the mailbox data is in the first two bytes of the mailbox,
       so the length of the mailbox header has to be added */
    mbxLen += MBX_HEADER_SIZE;
 81079e0:	887b      	ldrh	r3, [r7, #2]
 81079e2:	3306      	adds	r3, #6
 81079e4:	b29b      	uxth	r3, r3
 81079e6:	807b      	strh	r3, [r7, #2]

    /* in this example there are only two mailbox buffers available in the firmware (one for processing and
       one to stored the last sent response for a possible repeat request), so a
       received mailbox service can only be processed if a free buffer is available */
    if ( ( bSendMbxIsFull )                /* a received mailbox service will not be processed
 81079e8:	4b2e      	ldr	r3, [pc, #184]	@ (8107aa4 <MBX_CheckAndCopyMailbox+0x12c>)
 81079ea:	781b      	ldrb	r3, [r3, #0]
 81079ec:	2b00      	cmp	r3, #0
 81079ee:	d103      	bne.n	81079f8 <MBX_CheckAndCopyMailbox+0x80>
                                                    as long as the send mailbox is still full
                                                    (waits to be read from the master) */
        ||( u8MailboxSendReqStored )    /* a mailbox service to be sent is still stored
 81079f0:	4b2d      	ldr	r3, [pc, #180]	@ (8107aa8 <MBX_CheckAndCopyMailbox+0x130>)
 81079f2:	781b      	ldrb	r3, [r3, #0]
 81079f4:	2b00      	cmp	r3, #0
 81079f6:	d003      	beq.n	8107a00 <MBX_CheckAndCopyMailbox+0x88>
                                                    until all stored mailbox services are sent */
        )
    {
        /* set flag that the processing of the mailbox service will be checked in the
            function MBX_Main (called from ECAT_Main) */
        bReceiveMbxIsLocked = TRUE;
 81079f8:	4b2c      	ldr	r3, [pc, #176]	@ (8107aac <MBX_CheckAndCopyMailbox+0x134>)
 81079fa:	2201      	movs	r2, #1
 81079fc:	701a      	strb	r2, [r3, #0]
 81079fe:	e04a      	b.n	8107a96 <MBX_CheckAndCopyMailbox+0x11e>
    }
    else
    {
        /* received mailbox command can be processed, reset flag */
        bReceiveMbxIsLocked = FALSE;
 8107a00:	4b2a      	ldr	r3, [pc, #168]	@ (8107aac <MBX_CheckAndCopyMailbox+0x134>)
 8107a02:	2200      	movs	r2, #0
 8107a04:	701a      	strb	r2, [r3, #0]

        /* if the read mailbox size is too big for the buffer, set the copy size to the maximum buffer size, otherwise
           memory could be overwritten,
           the evaluation of the mailbox size will be done in the mailbox protocols called from MBX_WriteMailboxInd */

        if (mbxLen > u16ReceiveMbxSize)
 8107a06:	887a      	ldrh	r2, [r7, #2]
 8107a08:	4b29      	ldr	r3, [pc, #164]	@ (8107ab0 <MBX_CheckAndCopyMailbox+0x138>)
 8107a0a:	881b      	ldrh	r3, [r3, #0]
 8107a0c:	429a      	cmp	r2, r3
 8107a0e:	d902      	bls.n	8107a16 <MBX_CheckAndCopyMailbox+0x9e>
            mbxLen = u16ReceiveMbxSize;
 8107a10:	4b27      	ldr	r3, [pc, #156]	@ (8107ab0 <MBX_CheckAndCopyMailbox+0x138>)
 8107a12:	881b      	ldrh	r3, [r3, #0]
 8107a14:	807b      	strh	r3, [r7, #2]

        psWriteMbx = (TMBX MBXMEM *) APPL_AllocMailboxBuffer(u16ReceiveMbxSize);
 8107a16:	4b26      	ldr	r3, [pc, #152]	@ (8107ab0 <MBX_CheckAndCopyMailbox+0x138>)
 8107a18:	881b      	ldrh	r3, [r3, #0]
 8107a1a:	4618      	mov	r0, r3
 8107a1c:	f007 ff68 	bl	810f8f0 <malloc>
 8107a20:	4603      	mov	r3, r0
 8107a22:	461a      	mov	r2, r3
 8107a24:	4b23      	ldr	r3, [pc, #140]	@ (8107ab4 <MBX_CheckAndCopyMailbox+0x13c>)
 8107a26:	601a      	str	r2, [r3, #0]

        /* if there is no more memory for mailbox buffer, the mailbox should not be read */
        if (psWriteMbx == NULL)
 8107a28:	4b22      	ldr	r3, [pc, #136]	@ (8107ab4 <MBX_CheckAndCopyMailbox+0x13c>)
 8107a2a:	681b      	ldr	r3, [r3, #0]
 8107a2c:	2b00      	cmp	r3, #0
 8107a2e:	d103      	bne.n	8107a38 <MBX_CheckAndCopyMailbox+0xc0>
        {
            /* set flag that the processing of the mailbox service will be checked in the
                function MBX_Main (called from ECAT_Main) */
            bReceiveMbxIsLocked = TRUE;
 8107a30:	4b1e      	ldr	r3, [pc, #120]	@ (8107aac <MBX_CheckAndCopyMailbox+0x134>)
 8107a32:	2201      	movs	r2, #1
 8107a34:	701a      	strb	r2, [r3, #0]
 8107a36:	e02e      	b.n	8107a96 <MBX_CheckAndCopyMailbox+0x11e>
            return;
        }
        /* copy the mailbox header and data*/
        HW_EscReadMbxMem((MEM_ADDR MBXMEM *) psWriteMbx,u16EscAddrReceiveMbx,mbxLen);
 8107a38:	4b1e      	ldr	r3, [pc, #120]	@ (8107ab4 <MBX_CheckAndCopyMailbox+0x13c>)
 8107a3a:	681b      	ldr	r3, [r3, #0]
 8107a3c:	4a17      	ldr	r2, [pc, #92]	@ (8107a9c <MBX_CheckAndCopyMailbox+0x124>)
 8107a3e:	8811      	ldrh	r1, [r2, #0]
 8107a40:	887a      	ldrh	r2, [r7, #2]
 8107a42:	4618      	mov	r0, r3
 8107a44:	f7f9 fb30 	bl	81010a8 <HW_EscRead>


        {
        /*Read Control and Status of SyncManager 0 to check if the buffer is unlocked*/
        VARVOLATILE UINT16 smstate = 0x00;
 8107a48:	2300      	movs	r3, #0
 8107a4a:	803b      	strh	r3, [r7, #0]
        HW_EscReadWord(smstate,ESC_SYNCMAN_CONTROL_OFFSET);
 8107a4c:	463b      	mov	r3, r7
 8107a4e:	2202      	movs	r2, #2
 8107a50:	f640 0104 	movw	r1, #2052	@ 0x804
 8107a54:	4618      	mov	r0, r3
 8107a56:	f7f9 fb27 	bl	81010a8 <HW_EscRead>
/*ECATCHANGE_START(V5.11) ECAT7*/
        smstate = SWAPWORD(smstate);
 8107a5a:	883b      	ldrh	r3, [r7, #0]
 8107a5c:	b29b      	uxth	r3, r3
 8107a5e:	803b      	strh	r3, [r7, #0]
/*ECATCHANGE_END(V5.11) ECAT7*/

        if(smstate & SM_STATUS_MBX_BUFFER_FULL)
 8107a60:	883b      	ldrh	r3, [r7, #0]
 8107a62:	b29b      	uxth	r3, r3
 8107a64:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8107a68:	2b00      	cmp	r3, #0
 8107a6a:	d00f      	beq.n	8107a8c <MBX_CheckAndCopyMailbox+0x114>
        {
            /*Unlock the mailbox SyncManger buffer*/
            u16dummy = 0;
 8107a6c:	4b12      	ldr	r3, [pc, #72]	@ (8107ab8 <MBX_CheckAndCopyMailbox+0x140>)
 8107a6e:	2200      	movs	r2, #0
 8107a70:	801a      	strh	r2, [r3, #0]
            HW_EscReadWord(u16dummy,(u16EscAddrReceiveMbx + u16ReceiveMbxSize - 2));
 8107a72:	4b0a      	ldr	r3, [pc, #40]	@ (8107a9c <MBX_CheckAndCopyMailbox+0x124>)
 8107a74:	881a      	ldrh	r2, [r3, #0]
 8107a76:	4b0e      	ldr	r3, [pc, #56]	@ (8107ab0 <MBX_CheckAndCopyMailbox+0x138>)
 8107a78:	881b      	ldrh	r3, [r3, #0]
 8107a7a:	4413      	add	r3, r2
 8107a7c:	b29b      	uxth	r3, r3
 8107a7e:	3b02      	subs	r3, #2
 8107a80:	b29b      	uxth	r3, r3
 8107a82:	2202      	movs	r2, #2
 8107a84:	4619      	mov	r1, r3
 8107a86:	480c      	ldr	r0, [pc, #48]	@ (8107ab8 <MBX_CheckAndCopyMailbox+0x140>)
 8107a88:	f7f9 fb0e 	bl	81010a8 <HW_EscRead>
        }

        }

        /* in MBX_MailboxWriteInd the mailbox protocol will be processed */
        MBX_MailboxWriteInd( psWriteMbx );
 8107a8c:	4b09      	ldr	r3, [pc, #36]	@ (8107ab4 <MBX_CheckAndCopyMailbox+0x13c>)
 8107a8e:	681b      	ldr	r3, [r3, #0]
 8107a90:	4618      	mov	r0, r3
 8107a92:	f7ff fdff 	bl	8107694 <MBX_MailboxWriteInd>

    }
}
 8107a96:	3708      	adds	r7, #8
 8107a98:	46bd      	mov	sp, r7
 8107a9a:	bd80      	pop	{r7, pc}
 8107a9c:	1000087e 	.word	0x1000087e
 8107aa0:	10000b00 	.word	0x10000b00
 8107aa4:	10000876 	.word	0x10000876
 8107aa8:	10000a84 	.word	0x10000a84
 8107aac:	10000875 	.word	0x10000875
 8107ab0:	1000087c 	.word	0x1000087c
 8107ab4:	10000a88 	.word	0x10000a88
 8107ab8:	10000866 	.word	0x10000866

08107abc <MBX_CopyToSendMailbox>:

 \brief    This function copies data to the Send Mailbox.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 MBX_CopyToSendMailbox( TMBX MBXMEM *pMbx )
{
 8107abc:	b580      	push	{r7, lr}
 8107abe:	b086      	sub	sp, #24
 8107ac0:	af00      	add	r7, sp, #0
 8107ac2:	6078      	str	r0, [r7, #4]
    if ( (nAlStatus & STATE_MASK) == STATE_INIT)
 8107ac4:	4b39      	ldr	r3, [pc, #228]	@ (8107bac <MBX_CopyToSendMailbox+0xf0>)
 8107ac6:	781b      	ldrb	r3, [r3, #0]
 8107ac8:	f003 030f 	and.w	r3, r3, #15
 8107acc:	2b01      	cmp	r3, #1
 8107ace:	d101      	bne.n	8107ad4 <MBX_CopyToSendMailbox+0x18>
    {
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
 8107ad0:	23f0      	movs	r3, #240	@ 0xf0
 8107ad2:	e067      	b.n	8107ba4 <MBX_CopyToSendMailbox+0xe8>
    }


    if ( !bMbxRunning )
 8107ad4:	4b36      	ldr	r3, [pc, #216]	@ (8107bb0 <MBX_CopyToSendMailbox+0xf4>)
 8107ad6:	781b      	ldrb	r3, [r3, #0]
 8107ad8:	2b00      	cmp	r3, #0
 8107ada:	d101      	bne.n	8107ae0 <MBX_CopyToSendMailbox+0x24>
    {
        /* the mailbox is disabled if the slave is in the INIT state */
        return( ERROR_INVALIDSTATE );
 8107adc:	23f0      	movs	r3, #240	@ 0xf0
 8107ade:	e061      	b.n	8107ba4 <MBX_CopyToSendMailbox+0xe8>
    }

    if ( bSendMbxIsFull )
 8107ae0:	4b34      	ldr	r3, [pc, #208]	@ (8107bb4 <MBX_CopyToSendMailbox+0xf8>)
 8107ae2:	781b      	ldrb	r3, [r3, #0]
 8107ae4:	2b00      	cmp	r3, #0
 8107ae6:	d001      	beq.n	8107aec <MBX_CopyToSendMailbox+0x30>
    {
        /* mailbox service cannot be sent because the send mailbox is still full */
        return MBXERR_NOMOREMEMORY;
 8107ae8:	2307      	movs	r3, #7
 8107aea:	e05b      	b.n	8107ba4 <MBX_CopyToSendMailbox+0xe8>
    }
    else
    {
        /* the variable mbxSize contains the size of the mailbox data to be sent */
        UINT16 mbxSize = pMbx->MbxHeader.Length;
 8107aec:	687b      	ldr	r3, [r7, #4]
 8107aee:	881b      	ldrh	r3, [r3, #0]
 8107af0:	82fb      	strh	r3, [r7, #22]
        HW_EscWriteMbxMem((MEM_ADDR *)pMbx, u16EscAddrSendMbx, (mbxSize + MBX_HEADER_SIZE));
 8107af2:	4b31      	ldr	r3, [pc, #196]	@ (8107bb8 <MBX_CopyToSendMailbox+0xfc>)
 8107af4:	8819      	ldrh	r1, [r3, #0]
 8107af6:	8afb      	ldrh	r3, [r7, #22]
 8107af8:	3306      	adds	r3, #6
 8107afa:	b29b      	uxth	r3, r3
 8107afc:	461a      	mov	r2, r3
 8107afe:	6878      	ldr	r0, [r7, #4]
 8107b00:	f7f9 fb3a 	bl	8101178 <HW_EscWrite>
/* ECATCHANGE_HW(V5.10) HW1*/

        {
        /*Read Control and Status of SyncManager 1 to check if the buffer is still marked as empty*/
        VARVOLATILE UINT16 smstate = 0x00;
 8107b04:	2300      	movs	r3, #0
 8107b06:	81fb      	strh	r3, [r7, #14]
        HW_EscReadWord(smstate,(ESC_SYNCMAN_CONTROL_OFFSET + SIZEOF_SM_REGISTER));
 8107b08:	f107 030e 	add.w	r3, r7, #14
 8107b0c:	2202      	movs	r2, #2
 8107b0e:	f640 010c 	movw	r1, #2060	@ 0x80c
 8107b12:	4618      	mov	r0, r3
 8107b14:	f7f9 fac8 	bl	81010a8 <HW_EscRead>
/*ECATCHANGE_START(V5.11) ECAT7*/
        smstate = SWAPWORD(smstate);
 8107b18:	89fb      	ldrh	r3, [r7, #14]
 8107b1a:	b29b      	uxth	r3, r3
 8107b1c:	81fb      	strh	r3, [r7, #14]
/*ECATCHANGE_END(V5.11) ECAT7*/

        if(!(smstate & SM_STATUS_MBX_BUFFER_FULL))
 8107b1e:	89fb      	ldrh	r3, [r7, #14]
 8107b20:	b29b      	uxth	r3, r3
 8107b22:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
 8107b26:	2b00      	cmp	r3, #0
 8107b28:	d12a      	bne.n	8107b80 <MBX_CopyToSendMailbox+0xc4>
        {
            UINT8 BytesLeft = u16SendMbxSize - (mbxSize + MBX_HEADER_SIZE);
 8107b2a:	4b24      	ldr	r3, [pc, #144]	@ (8107bbc <MBX_CopyToSendMailbox+0x100>)
 8107b2c:	881b      	ldrh	r3, [r3, #0]
 8107b2e:	b2da      	uxtb	r2, r3
 8107b30:	8afb      	ldrh	r3, [r7, #22]
 8107b32:	b2db      	uxtb	r3, r3
 8107b34:	1ad3      	subs	r3, r2, r3
 8107b36:	b2db      	uxtb	r3, r3
 8107b38:	3b06      	subs	r3, #6
 8107b3a:	757b      	strb	r3, [r7, #21]

            /*Write last Byte to trigger mailbox full flag*/
            /*Read last 2 Bytes and write them again (required if low Byte of the WORD were written before)*/
            u16dummy = 0;
 8107b3c:	4b20      	ldr	r3, [pc, #128]	@ (8107bc0 <MBX_CopyToSendMailbox+0x104>)
 8107b3e:	2200      	movs	r2, #0
 8107b40:	801a      	strh	r2, [r3, #0]
            if(BytesLeft < 2)
 8107b42:	7d7b      	ldrb	r3, [r7, #21]
 8107b44:	2b01      	cmp	r3, #1
 8107b46:	d80e      	bhi.n	8107b66 <MBX_CopyToSendMailbox+0xaa>
            {
                /*The last 2Bytes are overlapping the already written buffer*/
                                
                /*Get the valid 16Bit address*/
                UINT32 LastDataAddress = ((mbxSize + MBX_HEADER_SIZE)/2)*2;
 8107b48:	8afb      	ldrh	r3, [r7, #22]
 8107b4a:	3306      	adds	r3, #6
 8107b4c:	f023 0301 	bic.w	r3, r3, #1
 8107b50:	613b      	str	r3, [r7, #16]
            
                /*Copy the buffer to overwrite*/
                MEMCPY((UINT16 *)&u16dummy,(((UINT8 *)pMbx) + LastDataAddress),(2 - BytesLeft));
 8107b52:	687a      	ldr	r2, [r7, #4]
 8107b54:	693b      	ldr	r3, [r7, #16]
 8107b56:	18d1      	adds	r1, r2, r3
 8107b58:	7d7b      	ldrb	r3, [r7, #21]
 8107b5a:	f1c3 0302 	rsb	r3, r3, #2
 8107b5e:	461a      	mov	r2, r3
 8107b60:	4817      	ldr	r0, [pc, #92]	@ (8107bc0 <MBX_CopyToSendMailbox+0x104>)
 8107b62:	f008 f94a 	bl	810fdfa <memcpy>
            }
            
            HW_EscWriteWord(u16dummy,(u16EscAddrSendMbx + u16SendMbxSize - 2));
 8107b66:	4b14      	ldr	r3, [pc, #80]	@ (8107bb8 <MBX_CopyToSendMailbox+0xfc>)
 8107b68:	881a      	ldrh	r2, [r3, #0]
 8107b6a:	4b14      	ldr	r3, [pc, #80]	@ (8107bbc <MBX_CopyToSendMailbox+0x100>)
 8107b6c:	881b      	ldrh	r3, [r3, #0]
 8107b6e:	4413      	add	r3, r2
 8107b70:	b29b      	uxth	r3, r3
 8107b72:	3b02      	subs	r3, #2
 8107b74:	b29b      	uxth	r3, r3
 8107b76:	2202      	movs	r2, #2
 8107b78:	4619      	mov	r1, r3
 8107b7a:	4811      	ldr	r0, [pc, #68]	@ (8107bc0 <MBX_CopyToSendMailbox+0x104>)
 8107b7c:	f7f9 fafc 	bl	8101178 <HW_EscWrite>
            the other one the actual service to be sent (psReadMbx),
            there is no buffer available for a mailbox receive service
            until the last sent buffer was read from the master
            the exception is after the INIT2PREOP transition, in that
            case there is no last sent service (psReadMbx = 0) */
        if ( psReadMbx )
 8107b80:	4b10      	ldr	r3, [pc, #64]	@ (8107bc4 <MBX_CopyToSendMailbox+0x108>)
 8107b82:	681b      	ldr	r3, [r3, #0]
 8107b84:	2b00      	cmp	r3, #0
 8107b86:	d003      	beq.n	8107b90 <MBX_CopyToSendMailbox+0xd4>
            psWriteMbx = NULL;
 8107b88:	4b0f      	ldr	r3, [pc, #60]	@ (8107bc8 <MBX_CopyToSendMailbox+0x10c>)
 8107b8a:	2200      	movs	r2, #0
 8107b8c:	601a      	str	r2, [r3, #0]
 8107b8e:	e002      	b.n	8107b96 <MBX_CopyToSendMailbox+0xda>
        else
        {
            /* only the first time after the INIT2PREOP-transition */
            psWriteMbx = &asMbx[1];
 8107b90:	4b0d      	ldr	r3, [pc, #52]	@ (8107bc8 <MBX_CopyToSendMailbox+0x10c>)
 8107b92:	4a0e      	ldr	r2, [pc, #56]	@ (8107bcc <MBX_CopyToSendMailbox+0x110>)
 8107b94:	601a      	str	r2, [r3, #0]
        }
        // HBu 17.06.06: psRepeatMbx was already updated in MBX_MailboxReadInd
        // psRepeatMbx = psReadMbx;
        psReadMbx = pMbx;
 8107b96:	4a0b      	ldr	r2, [pc, #44]	@ (8107bc4 <MBX_CopyToSendMailbox+0x108>)
 8107b98:	687b      	ldr	r3, [r7, #4]
 8107b9a:	6013      	str	r3, [r2, #0]

        /* set flag that send mailbox is full now */
        bSendMbxIsFull = TRUE;
 8107b9c:	4b05      	ldr	r3, [pc, #20]	@ (8107bb4 <MBX_CopyToSendMailbox+0xf8>)
 8107b9e:	2201      	movs	r2, #1
 8107ba0:	701a      	strb	r2, [r3, #0]


        return 0;
 8107ba2:	2300      	movs	r3, #0
    }
}
 8107ba4:	4618      	mov	r0, r3
 8107ba6:	3718      	adds	r7, #24
 8107ba8:	46bd      	mov	sp, r7
 8107baa:	bd80      	pop	{r7, pc}
 8107bac:	1000085c 	.word	0x1000085c
 8107bb0:	10000877 	.word	0x10000877
 8107bb4:	10000876 	.word	0x10000876
 8107bb8:	10000880 	.word	0x10000880
 8107bbc:	1000087a 	.word	0x1000087a
 8107bc0:	10000866 	.word	0x10000866
 8107bc4:	10000a8c 	.word	0x10000a8c
 8107bc8:	10000a88 	.word	0x10000a88
 8107bcc:	10000984 	.word	0x10000984

08107bd0 <MBX_Main>:
 \brief    This function is called cyclically to check if a received Mailbox service was
             stored.
*////////////////////////////////////////////////////////////////////////////////////////

void MBX_Main(void)
{
 8107bd0:	b580      	push	{r7, lr}
 8107bd2:	b082      	sub	sp, #8
 8107bd4:	af00      	add	r7, sp, #0
    TMBX MBXMEM *pMbx = NULL;
 8107bd6:	2300      	movs	r3, #0
 8107bd8:	603b      	str	r3, [r7, #0]

    do
    {
        UINT8 result = 0;
 8107bda:	2300      	movs	r3, #0
 8107bdc:	71fb      	strb	r3, [r7, #7]

        pMbx = GetOutOfMbxQueue(&sMbxReceiveQueue);
 8107bde:	4818      	ldr	r0, [pc, #96]	@ (8107c40 <MBX_Main+0x70>)
 8107be0:	f7ff fb77 	bl	81072d2 <GetOutOfMbxQueue>
 8107be4:	6038      	str	r0, [r7, #0]
        if ( pMbx )
 8107be6:	683b      	ldr	r3, [r7, #0]
 8107be8:	2b00      	cmp	r3, #0
 8107bea:	d004      	beq.n	8107bf6 <MBX_Main+0x26>
            result = MailboxServiceInd(pMbx);
 8107bec:	6838      	ldr	r0, [r7, #0]
 8107bee:	f7ff fd37 	bl	8107660 <MailboxServiceInd>
 8107bf2:	4603      	mov	r3, r0
 8107bf4:	71fb      	strb	r3, [r7, #7]

        if ( result != 0 )
 8107bf6:	79fb      	ldrb	r3, [r7, #7]
 8107bf8:	2b00      	cmp	r3, #0
 8107bfa:	d014      	beq.n	8107c26 <MBX_Main+0x56>
        {
            /* Mailbox error response: type 0 (mailbox service protocol) */
            pMbx->MbxHeader.Length     = 4;
 8107bfc:	683b      	ldr	r3, [r7, #0]
 8107bfe:	2204      	movs	r2, #4
 8107c00:	801a      	strh	r2, [r3, #0]
            pMbx->MbxHeader.Flags[MBX_OFFS_TYPE]        &= ~(MBX_MASK_TYPE);
 8107c02:	683b      	ldr	r3, [r7, #0]
 8107c04:	889b      	ldrh	r3, [r3, #4]
 8107c06:	f423 6370 	bic.w	r3, r3, #3840	@ 0xf00
 8107c0a:	b29a      	uxth	r2, r3
 8107c0c:	683b      	ldr	r3, [r7, #0]
 8107c0e:	809a      	strh	r2, [r3, #4]
            pMbx->Data[0]                        = SWAPWORD(MBXSERVICE_MBXERRORCMD);
 8107c10:	683b      	ldr	r3, [r7, #0]
 8107c12:	2201      	movs	r2, #1
 8107c14:	80da      	strh	r2, [r3, #6]
            pMbx->Data[1]                        = SWAPWORD(result);
 8107c16:	79fb      	ldrb	r3, [r7, #7]
 8107c18:	b29a      	uxth	r2, r3
 8107c1a:	683b      	ldr	r3, [r7, #0]
 8107c1c:	811a      	strh	r2, [r3, #8]
            MBX_MailboxSendReq(pMbx, 0);
 8107c1e:	2100      	movs	r1, #0
 8107c20:	6838      	ldr	r0, [r7, #0]
 8107c22:	f7ff fe3d 	bl	81078a0 <MBX_MailboxSendReq>
        }
    }
    while ( pMbx != NULL );
 8107c26:	683b      	ldr	r3, [r7, #0]
 8107c28:	2b00      	cmp	r3, #0
 8107c2a:	d1d6      	bne.n	8107bda <MBX_Main+0xa>



      if ( bReceiveMbxIsLocked )
 8107c2c:	4b05      	ldr	r3, [pc, #20]	@ (8107c44 <MBX_Main+0x74>)
 8107c2e:	781b      	ldrb	r3, [r3, #0]
 8107c30:	2b00      	cmp	r3, #0
 8107c32:	d001      	beq.n	8107c38 <MBX_Main+0x68>
      {
          /* the work on the receive mailbox is locked, check if it can be unlocked (if all
             mailbox commands has been sent */
          MBX_CheckAndCopyMailbox();
 8107c34:	f7ff fea0 	bl	8107978 <MBX_CheckAndCopyMailbox>
      }
}
 8107c38:	bf00      	nop
 8107c3a:	3708      	adds	r7, #8
 8107c3c:	46bd      	mov	sp, r7
 8107c3e:	bd80      	pop	{r7, pc}
 8107c40:	10000acc 	.word	0x10000acc
 8107c44:	10000875 	.word	0x10000875

08107c48 <OBJ_GetObjectHandle>:
             and returns a handle if found.

*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TOBJECT OBJMEM *  OBJ_GetObjectHandle( UINT16 index )
{
 8107c48:	b580      	push	{r7, lr}
 8107c4a:	b084      	sub	sp, #16
 8107c4c:	af00      	add	r7, sp, #0
 8107c4e:	4603      	mov	r3, r0
 8107c50:	80fb      	strh	r3, [r7, #6]
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
 8107c52:	f7fd f951 	bl	8104ef8 <COE_GetObjectDictionary>
 8107c56:	60f8      	str	r0, [r7, #12]

    while (pObjEntry!= NULL)
 8107c58:	e009      	b.n	8107c6e <OBJ_GetObjectHandle+0x26>
    {
        if (pObjEntry->Index == index)
 8107c5a:	68fb      	ldr	r3, [r7, #12]
 8107c5c:	891b      	ldrh	r3, [r3, #8]
 8107c5e:	88fa      	ldrh	r2, [r7, #6]
 8107c60:	429a      	cmp	r2, r3
 8107c62:	d101      	bne.n	8107c68 <OBJ_GetObjectHandle+0x20>
            return pObjEntry;
 8107c64:	68fb      	ldr	r3, [r7, #12]
 8107c66:	e006      	b.n	8107c76 <OBJ_GetObjectHandle+0x2e>
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
 8107c68:	68fb      	ldr	r3, [r7, #12]
 8107c6a:	685b      	ldr	r3, [r3, #4]
 8107c6c:	60fb      	str	r3, [r7, #12]
    while (pObjEntry!= NULL)
 8107c6e:	68fb      	ldr	r3, [r7, #12]
 8107c70:	2b00      	cmp	r3, #0
 8107c72:	d1f2      	bne.n	8107c5a <OBJ_GetObjectHandle+0x12>
    }
    return 0;
 8107c74:	2300      	movs	r3, #0
}
 8107c76:	4618      	mov	r0, r3
 8107c78:	3710      	adds	r7, #16
 8107c7a:	46bd      	mov	sp, r7
 8107c7c:	bd80      	pop	{r7, pc}

08107c7e <OBJ_GetObjectLength>:

 \brief     This function returns the size of the requested entry. If bCompleteaccess is set the size of the complete object is returned (the returned size is byte packed, gaps based on the used platform/compiler are not taken into account)

*////////////////////////////////////////////////////////////////////////////////////////
UINT32 OBJ_GetObjectLength( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 bCompleteAccess)
{
 8107c7e:	b480      	push	{r7}
 8107c80:	b085      	sub	sp, #20
 8107c82:	af00      	add	r7, sp, #0
 8107c84:	603a      	str	r2, [r7, #0]
 8107c86:	461a      	mov	r2, r3
 8107c88:	4603      	mov	r3, r0
 8107c8a:	80fb      	strh	r3, [r7, #6]
 8107c8c:	460b      	mov	r3, r1
 8107c8e:	717b      	strb	r3, [r7, #5]
 8107c90:	4613      	mov	r3, r2
 8107c92:	713b      	strb	r3, [r7, #4]
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 8107c94:	683b      	ldr	r3, [r7, #0]
 8107c96:	899b      	ldrh	r3, [r3, #12]
 8107c98:	121b      	asrs	r3, r3, #8
 8107c9a:	b2db      	uxtb	r3, r3
 8107c9c:	f003 030f 	and.w	r3, r3, #15
 8107ca0:	72bb      	strb	r3, [r7, #10]
    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
 8107ca2:	683b      	ldr	r3, [r7, #0]
 8107ca4:	899b      	ldrh	r3, [r3, #12]
 8107ca6:	727b      	strb	r3, [r7, #9]
    UINT32 size = 0;
 8107ca8:	2300      	movs	r3, #0
 8107caa:	60fb      	str	r3, [r7, #12]

    if ( bCompleteAccess )
 8107cac:	793b      	ldrb	r3, [r7, #4]
 8107cae:	2b00      	cmp	r3, #0
 8107cb0:	d043      	beq.n	8107d3a <OBJ_GetObjectLength+0xbc>
    {
        if ( objCode == OBJCODE_VAR )
 8107cb2:	7abb      	ldrb	r3, [r7, #10]
 8107cb4:	2b07      	cmp	r3, #7
 8107cb6:	d101      	bne.n	8107cbc <OBJ_GetObjectLength+0x3e>
            return 0;
 8107cb8:	2300      	movs	r3, #0
 8107cba:	e061      	b.n	8107d80 <OBJ_GetObjectLength+0x102>
        else if ((objCode == OBJCODE_ARR)
 8107cbc:	7abb      	ldrb	r3, [r7, #10]
 8107cbe:	2b08      	cmp	r3, #8
 8107cc0:	d118      	bne.n	8107cf4 <OBJ_GetObjectLength+0x76>
            )
        {

            /* we have to get the maxSubindex from the actual value of subindex 0,
                which is stored as UINT16 at the beginning of the object's variable */
            maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
 8107cc2:	683b      	ldr	r3, [r7, #0]
 8107cc4:	699b      	ldr	r3, [r3, #24]
 8107cc6:	881b      	ldrh	r3, [r3, #0]
 8107cc8:	727b      	strb	r3, [r7, #9]


            size = pObjEntry->pEntryDesc[1].BitLength *maxSubindex;
 8107cca:	683b      	ldr	r3, [r7, #0]
 8107ccc:	691b      	ldr	r3, [r3, #16]
 8107cce:	3306      	adds	r3, #6
 8107cd0:	885b      	ldrh	r3, [r3, #2]
 8107cd2:	461a      	mov	r2, r3
 8107cd4:	7a7b      	ldrb	r3, [r7, #9]
 8107cd6:	fb02 f303 	mul.w	r3, r2, r3
 8107cda:	60fb      	str	r3, [r7, #12]

/* no padding required: Bit entries within an array object may overlap byte borders*/

            /* we have to convert the size in bytes */
            size = BIT2BYTE(size);
 8107cdc:	68fb      	ldr	r3, [r7, #12]
 8107cde:	3307      	adds	r3, #7
 8107ce0:	08db      	lsrs	r3, r3, #3
 8107ce2:	60fb      	str	r3, [r7, #12]

            if ( subindex == 0 )
 8107ce4:	797b      	ldrb	r3, [r7, #5]
 8107ce6:	2b00      	cmp	r3, #0
 8107ce8:	d102      	bne.n	8107cf0 <OBJ_GetObjectLength+0x72>
            {
                /* add size for subindex 0 (is transmitted as UINT16) */
                size += 2;
 8107cea:	68fb      	ldr	r3, [r7, #12]
 8107cec:	3302      	adds	r3, #2
 8107cee:	60fb      	str	r3, [r7, #12]
            }
            return size;
 8107cf0:	68fb      	ldr	r3, [r7, #12]
 8107cf2:	e045      	b.n	8107d80 <OBJ_GetObjectLength+0x102>
        else
        {
            UINT8 i;

            /* add the sizes of all entries */
            for (i = 1; i <= maxSubindex; i++)
 8107cf4:	2301      	movs	r3, #1
 8107cf6:	72fb      	strb	r3, [r7, #11]
 8107cf8:	e00f      	b.n	8107d1a <OBJ_GetObjectLength+0x9c>
            {
                size += pObjEntry->pEntryDesc[i].BitLength;
 8107cfa:	683b      	ldr	r3, [r7, #0]
 8107cfc:	6919      	ldr	r1, [r3, #16]
 8107cfe:	7afa      	ldrb	r2, [r7, #11]
 8107d00:	4613      	mov	r3, r2
 8107d02:	005b      	lsls	r3, r3, #1
 8107d04:	4413      	add	r3, r2
 8107d06:	005b      	lsls	r3, r3, #1
 8107d08:	440b      	add	r3, r1
 8107d0a:	885b      	ldrh	r3, [r3, #2]
 8107d0c:	461a      	mov	r2, r3
 8107d0e:	68fb      	ldr	r3, [r7, #12]
 8107d10:	4413      	add	r3, r2
 8107d12:	60fb      	str	r3, [r7, #12]
            for (i = 1; i <= maxSubindex; i++)
 8107d14:	7afb      	ldrb	r3, [r7, #11]
 8107d16:	3301      	adds	r3, #1
 8107d18:	72fb      	strb	r3, [r7, #11]
 8107d1a:	7afa      	ldrb	r2, [r7, #11]
 8107d1c:	7a7b      	ldrb	r3, [r7, #9]
 8107d1e:	429a      	cmp	r2, r3
 8107d20:	d9eb      	bls.n	8107cfa <OBJ_GetObjectLength+0x7c>
            }
            /* we have to convert the size in bytes */
            size = BIT2BYTE(size);
 8107d22:	68fb      	ldr	r3, [r7, #12]
 8107d24:	3307      	adds	r3, #7
 8107d26:	08db      	lsrs	r3, r3, #3
 8107d28:	60fb      	str	r3, [r7, #12]

            if ( subindex == 0 )
 8107d2a:	797b      	ldrb	r3, [r7, #5]
 8107d2c:	2b00      	cmp	r3, #0
 8107d2e:	d102      	bne.n	8107d36 <OBJ_GetObjectLength+0xb8>
            {
                /* add size for subindex 0 (is transmitted as UINT16) */
                size += 2;
 8107d30:	68fb      	ldr	r3, [r7, #12]
 8107d32:	3302      	adds	r3, #2
 8107d34:	60fb      	str	r3, [r7, #12]
            }
            return size;
 8107d36:	68fb      	ldr	r3, [r7, #12]
 8107d38:	e022      	b.n	8107d80 <OBJ_GetObjectLength+0x102>
        }
    }
    else
    {
        if ( objCode == OBJCODE_VAR )
 8107d3a:	7abb      	ldrb	r3, [r7, #10]
 8107d3c:	2b07      	cmp	r3, #7
 8107d3e:	d105      	bne.n	8107d4c <OBJ_GetObjectLength+0xce>
        {
            return (BIT2BYTE(pObjEntry->pEntryDesc->BitLength));
 8107d40:	683b      	ldr	r3, [r7, #0]
 8107d42:	691b      	ldr	r3, [r3, #16]
 8107d44:	885b      	ldrh	r3, [r3, #2]
 8107d46:	3307      	adds	r3, #7
 8107d48:	10db      	asrs	r3, r3, #3
 8107d4a:	e019      	b.n	8107d80 <OBJ_GetObjectLength+0x102>

        }
        else if ( subindex == 0 )
 8107d4c:	797b      	ldrb	r3, [r7, #5]
 8107d4e:	2b00      	cmp	r3, #0
 8107d50:	d101      	bne.n	8107d56 <OBJ_GetObjectLength+0xd8>
        {
            /* for single access subindex 0 is transmitted as UINT8 */
            return 1;
 8107d52:	2301      	movs	r3, #1
 8107d54:	e014      	b.n	8107d80 <OBJ_GetObjectLength+0x102>
        }
        else if((objCode == OBJCODE_ARR)
 8107d56:	7abb      	ldrb	r3, [r7, #10]
 8107d58:	2b08      	cmp	r3, #8
 8107d5a:	d106      	bne.n	8107d6a <OBJ_GetObjectLength+0xec>
            )
        {
            return (BIT2BYTE(pObjEntry->pEntryDesc[1].BitLength));
 8107d5c:	683b      	ldr	r3, [r7, #0]
 8107d5e:	691b      	ldr	r3, [r3, #16]
 8107d60:	3306      	adds	r3, #6
 8107d62:	885b      	ldrh	r3, [r3, #2]
 8107d64:	3307      	adds	r3, #7
 8107d66:	10db      	asrs	r3, r3, #3
 8107d68:	e00a      	b.n	8107d80 <OBJ_GetObjectLength+0x102>
        }
        else
        {
                return (BIT2BYTE(pObjEntry->pEntryDesc[subindex].BitLength));
 8107d6a:	683b      	ldr	r3, [r7, #0]
 8107d6c:	6919      	ldr	r1, [r3, #16]
 8107d6e:	797a      	ldrb	r2, [r7, #5]
 8107d70:	4613      	mov	r3, r2
 8107d72:	005b      	lsls	r3, r3, #1
 8107d74:	4413      	add	r3, r2
 8107d76:	005b      	lsls	r3, r3, #1
 8107d78:	440b      	add	r3, r1
 8107d7a:	885b      	ldrh	r3, [r3, #2]
 8107d7c:	3307      	adds	r3, #7
 8107d7e:	10db      	asrs	r3, r3, #3
        }
    }
}
 8107d80:	4618      	mov	r0, r3
 8107d82:	3714      	adds	r7, #20
 8107d84:	46bd      	mov	sp, r7
 8107d86:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107d8a:	4770      	bx	lr

08107d8c <OBJ_CopyNumberToString>:
         which shall be initialized with 000

*////////////////////////////////////////////////////////////////////////////////////////

void OBJ_CopyNumberToString(UCHAR MBXMEM *pStr, UINT8 Number)
{
 8107d8c:	b480      	push	{r7}
 8107d8e:	b085      	sub	sp, #20
 8107d90:	af00      	add	r7, sp, #0
 8107d92:	6078      	str	r0, [r7, #4]
 8107d94:	460b      	mov	r3, r1
 8107d96:	70fb      	strb	r3, [r7, #3]
    UINT8 Modulo;

    pStr[2] = '0';
 8107d98:	687b      	ldr	r3, [r7, #4]
 8107d9a:	3302      	adds	r3, #2
 8107d9c:	2230      	movs	r2, #48	@ 0x30
 8107d9e:	701a      	strb	r2, [r3, #0]
    pStr[0] += (Number / 100);
 8107da0:	687b      	ldr	r3, [r7, #4]
 8107da2:	781a      	ldrb	r2, [r3, #0]
 8107da4:	78fb      	ldrb	r3, [r7, #3]
 8107da6:	491d      	ldr	r1, [pc, #116]	@ (8107e1c <OBJ_CopyNumberToString+0x90>)
 8107da8:	fba1 1303 	umull	r1, r3, r1, r3
 8107dac:	095b      	lsrs	r3, r3, #5
 8107dae:	b2db      	uxtb	r3, r3
 8107db0:	4413      	add	r3, r2
 8107db2:	b2da      	uxtb	r2, r3
 8107db4:	687b      	ldr	r3, [r7, #4]
 8107db6:	701a      	strb	r2, [r3, #0]
    Modulo = Number % 100;
 8107db8:	78fb      	ldrb	r3, [r7, #3]
 8107dba:	4a18      	ldr	r2, [pc, #96]	@ (8107e1c <OBJ_CopyNumberToString+0x90>)
 8107dbc:	fba2 1203 	umull	r1, r2, r2, r3
 8107dc0:	0952      	lsrs	r2, r2, #5
 8107dc2:	2164      	movs	r1, #100	@ 0x64
 8107dc4:	fb01 f202 	mul.w	r2, r1, r2
 8107dc8:	1a9b      	subs	r3, r3, r2
 8107dca:	73fb      	strb	r3, [r7, #15]
    pStr[1] += (Modulo / 10);
 8107dcc:	687b      	ldr	r3, [r7, #4]
 8107dce:	3301      	adds	r3, #1
 8107dd0:	7819      	ldrb	r1, [r3, #0]
 8107dd2:	7bfb      	ldrb	r3, [r7, #15]
 8107dd4:	4a12      	ldr	r2, [pc, #72]	@ (8107e20 <OBJ_CopyNumberToString+0x94>)
 8107dd6:	fba2 2303 	umull	r2, r3, r2, r3
 8107dda:	08db      	lsrs	r3, r3, #3
 8107ddc:	b2da      	uxtb	r2, r3
 8107dde:	687b      	ldr	r3, [r7, #4]
 8107de0:	3301      	adds	r3, #1
 8107de2:	440a      	add	r2, r1
 8107de4:	b2d2      	uxtb	r2, r2
 8107de6:	701a      	strb	r2, [r3, #0]
    pStr[2] += (Modulo % 10);
 8107de8:	687b      	ldr	r3, [r7, #4]
 8107dea:	3302      	adds	r3, #2
 8107dec:	7818      	ldrb	r0, [r3, #0]
 8107dee:	7bfa      	ldrb	r2, [r7, #15]
 8107df0:	4b0b      	ldr	r3, [pc, #44]	@ (8107e20 <OBJ_CopyNumberToString+0x94>)
 8107df2:	fba3 1302 	umull	r1, r3, r3, r2
 8107df6:	08d9      	lsrs	r1, r3, #3
 8107df8:	460b      	mov	r3, r1
 8107dfa:	009b      	lsls	r3, r3, #2
 8107dfc:	440b      	add	r3, r1
 8107dfe:	005b      	lsls	r3, r3, #1
 8107e00:	1ad3      	subs	r3, r2, r3
 8107e02:	b2da      	uxtb	r2, r3
 8107e04:	687b      	ldr	r3, [r7, #4]
 8107e06:	3302      	adds	r3, #2
 8107e08:	4402      	add	r2, r0
 8107e0a:	b2d2      	uxtb	r2, r2
 8107e0c:	701a      	strb	r2, [r3, #0]
}
 8107e0e:	bf00      	nop
 8107e10:	3714      	adds	r7, #20
 8107e12:	46bd      	mov	sp, r7
 8107e14:	f85d 7b04 	ldr.w	r7, [sp], #4
 8107e18:	4770      	bx	lr
 8107e1a:	bf00      	nop
 8107e1c:	51eb851f 	.word	0x51eb851f
 8107e20:	cccccccd 	.word	0xcccccccd

08107e24 <OBJ_GetNoOfObjects>:
 \brief    The function counts the number of objects of the requested list type

*////////////////////////////////////////////////////////////////////////////////////////

UINT16    OBJ_GetNoOfObjects(UINT8 listType)
{
 8107e24:	b580      	push	{r7, lr}
 8107e26:	b086      	sub	sp, #24
 8107e28:	af00      	add	r7, sp, #0
 8107e2a:	4603      	mov	r3, r0
 8107e2c:	71fb      	strb	r3, [r7, #7]
    /* the variable listFlags contains the mask used for the ObjAccess in the Entry-Desc
       see the structure TSDOINFOENTRYDESC in sdoserv.h, listType = 0 indicates that
       all objects has to be counted */
    
    UINT16 listFlags = 0x0020 << listType;
 8107e2e:	79fb      	ldrb	r3, [r7, #7]
 8107e30:	2220      	movs	r2, #32
 8107e32:	fa02 f303 	lsl.w	r3, r2, r3
 8107e36:	81bb      	strh	r3, [r7, #12]
    
    /* set pObjEntry to the beginning of the object dictionary */
    OBJCONST TOBJECT OBJMEM * pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
 8107e38:	f7fd f85e 	bl	8104ef8 <COE_GetObjectDictionary>
 8107e3c:	6178      	str	r0, [r7, #20]
    UINT16 n = 0;
 8107e3e:	2300      	movs	r3, #0
 8107e40:	827b      	strh	r3, [r7, #18]


    while (pObjEntry != NULL)
 8107e42:	e032      	b.n	8107eaa <OBJ_GetNoOfObjects+0x86>
    {
        /* count the objects of the requested list type */
        if ( pObjEntry->Index >= 0x1000 )
 8107e44:	697b      	ldr	r3, [r7, #20]
 8107e46:	891b      	ldrh	r3, [r3, #8]
 8107e48:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8107e4c:	d32a      	bcc.n	8107ea4 <OBJ_GetNoOfObjects+0x80>
        {
            UINT8 t = listType;
 8107e4e:	79fb      	ldrb	r3, [r7, #7]
 8107e50:	747b      	strb	r3, [r7, #17]
            if ( t )
 8107e52:	7c7b      	ldrb	r3, [r7, #17]
 8107e54:	2b00      	cmp	r3, #0
 8107e56:	d01f      	beq.n	8107e98 <OBJ_GetNoOfObjects+0x74>
            {
                UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
 8107e58:	697b      	ldr	r3, [r7, #20]
 8107e5a:	899b      	ldrh	r3, [r3, #12]
 8107e5c:	72fb      	strb	r3, [r7, #11]
                UINT16 i = 0;
 8107e5e:	2300      	movs	r3, #0
 8107e60:	81fb      	strh	r3, [r7, #14]

                while ( t && i <= maxSubindex )
 8107e62:	e011      	b.n	8107e88 <OBJ_GetNoOfObjects+0x64>
                {
                    if ( OBJ_GetEntryDesc(pObjEntry,(UINT8) i)->ObjAccess & listFlags )
 8107e64:	89fb      	ldrh	r3, [r7, #14]
 8107e66:	b2db      	uxtb	r3, r3
 8107e68:	4619      	mov	r1, r3
 8107e6a:	6978      	ldr	r0, [r7, #20]
 8107e6c:	f000 f936 	bl	81080dc <OBJ_GetEntryDesc>
 8107e70:	4603      	mov	r3, r0
 8107e72:	889a      	ldrh	r2, [r3, #4]
 8107e74:	89bb      	ldrh	r3, [r7, #12]
 8107e76:	4013      	ands	r3, r2
 8107e78:	b29b      	uxth	r3, r3
 8107e7a:	2b00      	cmp	r3, #0
 8107e7c:	d001      	beq.n	8107e82 <OBJ_GetNoOfObjects+0x5e>
                        t = 0;
 8107e7e:	2300      	movs	r3, #0
 8107e80:	747b      	strb	r3, [r7, #17]
                    i++;
 8107e82:	89fb      	ldrh	r3, [r7, #14]
 8107e84:	3301      	adds	r3, #1
 8107e86:	81fb      	strh	r3, [r7, #14]
                while ( t && i <= maxSubindex )
 8107e88:	7c7b      	ldrb	r3, [r7, #17]
 8107e8a:	2b00      	cmp	r3, #0
 8107e8c:	d004      	beq.n	8107e98 <OBJ_GetNoOfObjects+0x74>
 8107e8e:	7afb      	ldrb	r3, [r7, #11]
 8107e90:	b29b      	uxth	r3, r3
 8107e92:	89fa      	ldrh	r2, [r7, #14]
 8107e94:	429a      	cmp	r2, r3
 8107e96:	d9e5      	bls.n	8107e64 <OBJ_GetNoOfObjects+0x40>
                }
            }
            if ( !t )
 8107e98:	7c7b      	ldrb	r3, [r7, #17]
 8107e9a:	2b00      	cmp	r3, #0
 8107e9c:	d102      	bne.n	8107ea4 <OBJ_GetNoOfObjects+0x80>
            {
                /* object from listType found */
                n++;
 8107e9e:	8a7b      	ldrh	r3, [r7, #18]
 8107ea0:	3301      	adds	r3, #1
 8107ea2:	827b      	strh	r3, [r7, #18]
            }
        }
        /* next object in object dictionary */
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
 8107ea4:	697b      	ldr	r3, [r7, #20]
 8107ea6:	685b      	ldr	r3, [r3, #4]
 8107ea8:	617b      	str	r3, [r7, #20]
    while (pObjEntry != NULL)
 8107eaa:	697b      	ldr	r3, [r7, #20]
 8107eac:	2b00      	cmp	r3, #0
 8107eae:	d1c9      	bne.n	8107e44 <OBJ_GetNoOfObjects+0x20>
    }

    return n;
 8107eb0:	8a7b      	ldrh	r3, [r7, #18]
}
 8107eb2:	4618      	mov	r0, r3
 8107eb4:	3718      	adds	r7, #24
 8107eb6:	46bd      	mov	sp, r7
 8107eb8:	bd80      	pop	{r7, pc}
	...

08107ebc <OBJ_GetObjectList>:

 \brief    The function copies (the part of) the object list in the mailbox buffer

*////////////////////////////////////////////////////////////////////////////////////////
UINT16    OBJ_GetObjectList(UINT16 listType, UINT16 *pIndex, UINT16 size, UINT16 MBXMEM *pData,UINT8 *pAbort)
{
 8107ebc:	b580      	push	{r7, lr}
 8107ebe:	b088      	sub	sp, #32
 8107ec0:	af00      	add	r7, sp, #0
 8107ec2:	60b9      	str	r1, [r7, #8]
 8107ec4:	607b      	str	r3, [r7, #4]
 8107ec6:	4603      	mov	r3, r0
 8107ec8:	81fb      	strh	r3, [r7, #14]
 8107eca:	4613      	mov	r3, r2
 8107ecc:	81bb      	strh	r3, [r7, #12]
    /* the variable listFlags contains the mask used for the ObjAccess in the Entry-Desc
       see the structure TSDOINFOENTRYDESC in sdoserv.h, listType = 0 indicates that
       all objects has to be counted */
    UINT16 listFlags = 0x0020 << listType;
 8107ece:	89fb      	ldrh	r3, [r7, #14]
 8107ed0:	2220      	movs	r2, #32
 8107ed2:	fa02 f303 	lsl.w	r3, r2, r3
 8107ed6:	82fb      	strh	r3, [r7, #22]
    OBJCONST TOBJECT OBJMEM * pObjEntry;


    if ( pIndex[0] == 0x1000 )
 8107ed8:	68bb      	ldr	r3, [r7, #8]
 8107eda:	881b      	ldrh	r3, [r3, #0]
 8107edc:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8107ee0:	d10c      	bne.n	8107efc <OBJ_GetObjectList+0x40>
    {
        /* beginning of object list, set pObjEntry to the beginning of the object dictionary */
       pObjEntry = (OBJCONST TOBJECT OBJMEM *) COE_GetObjectDictionary();
 8107ee2:	f7fd f809 	bl	8104ef8 <COE_GetObjectDictionary>
 8107ee6:	61f8      	str	r0, [r7, #28]
        // set abort code if no object dictionary is available
        if((pObjEntry == NULL) && (pAbort != NULL))
 8107ee8:	69fb      	ldr	r3, [r7, #28]
 8107eea:	2b00      	cmp	r3, #0
 8107eec:	d109      	bne.n	8107f02 <OBJ_GetObjectList+0x46>
 8107eee:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8107ef0:	2b00      	cmp	r3, #0
 8107ef2:	d006      	beq.n	8107f02 <OBJ_GetObjectList+0x46>
        {
            *pAbort = ABORTIDX_NO_OBJECT_DICTIONARY_IS_PRESENT;
 8107ef4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8107ef6:	221b      	movs	r2, #27
 8107ef8:	701a      	strb	r2, [r3, #0]
 8107efa:	e002      	b.n	8107f02 <OBJ_GetObjectList+0x46>
        }
    }
    else
    {
        /* next fragment, the next object to be handled was stored in pSdoInfoObjEntry */
        pObjEntry = pSdoInfoObjEntry;
 8107efc:	4b2c      	ldr	r3, [pc, #176]	@ (8107fb0 <OBJ_GetObjectList+0xf4>)
 8107efe:	681b      	ldr	r3, [r3, #0]
 8107f00:	61fb      	str	r3, [r7, #28]
    }

    if ( pObjEntry != NULL )
 8107f02:	69fb      	ldr	r3, [r7, #28]
 8107f04:	2b00      	cmp	r3, #0
 8107f06:	d03e      	beq.n	8107f86 <OBJ_GetObjectList+0xca>
    {
        while (pObjEntry != NULL && size > 1 )
 8107f08:	e037      	b.n	8107f7a <OBJ_GetObjectList+0xbe>
        {
            /* get the next index of the requested object list if there is enough space in the mailbox buffer */
            if ( pObjEntry->Index >= 0x1000 )
 8107f0a:	69fb      	ldr	r3, [r7, #28]
 8107f0c:	891b      	ldrh	r3, [r3, #8]
 8107f0e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 8107f12:	d32f      	bcc.n	8107f74 <OBJ_GetObjectList+0xb8>
            {
                /* UINT8 was changed to UINT16 */
                UINT16 t = listType;
 8107f14:	89fb      	ldrh	r3, [r7, #14]
 8107f16:	837b      	strh	r3, [r7, #26]
                if ( t )
 8107f18:	8b7b      	ldrh	r3, [r7, #26]
 8107f1a:	2b00      	cmp	r3, #0
 8107f1c:	d01d      	beq.n	8107f5a <OBJ_GetObjectList+0x9e>
                {
                    UINT8 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
 8107f1e:	69fb      	ldr	r3, [r7, #28]
 8107f20:	899b      	ldrh	r3, [r3, #12]
 8107f22:	757b      	strb	r3, [r7, #21]
                    UINT8 i = 0;
 8107f24:	2300      	movs	r3, #0
 8107f26:	767b      	strb	r3, [r7, #25]

                    while ( t && i <= maxSubindex )
 8107f28:	e010      	b.n	8107f4c <OBJ_GetObjectList+0x90>
                    {
                        if ( OBJ_GetEntryDesc(pObjEntry, i)->ObjAccess & listFlags )
 8107f2a:	7e7b      	ldrb	r3, [r7, #25]
 8107f2c:	4619      	mov	r1, r3
 8107f2e:	69f8      	ldr	r0, [r7, #28]
 8107f30:	f000 f8d4 	bl	81080dc <OBJ_GetEntryDesc>
 8107f34:	4603      	mov	r3, r0
 8107f36:	889a      	ldrh	r2, [r3, #4]
 8107f38:	8afb      	ldrh	r3, [r7, #22]
 8107f3a:	4013      	ands	r3, r2
 8107f3c:	b29b      	uxth	r3, r3
 8107f3e:	2b00      	cmp	r3, #0
 8107f40:	d001      	beq.n	8107f46 <OBJ_GetObjectList+0x8a>
                            t = 0;
 8107f42:	2300      	movs	r3, #0
 8107f44:	837b      	strh	r3, [r7, #26]
                        i++;
 8107f46:	7e7b      	ldrb	r3, [r7, #25]
 8107f48:	3301      	adds	r3, #1
 8107f4a:	767b      	strb	r3, [r7, #25]
                    while ( t && i <= maxSubindex )
 8107f4c:	8b7b      	ldrh	r3, [r7, #26]
 8107f4e:	2b00      	cmp	r3, #0
 8107f50:	d003      	beq.n	8107f5a <OBJ_GetObjectList+0x9e>
 8107f52:	7e7a      	ldrb	r2, [r7, #25]
 8107f54:	7d7b      	ldrb	r3, [r7, #21]
 8107f56:	429a      	cmp	r2, r3
 8107f58:	d9e7      	bls.n	8107f2a <OBJ_GetObjectList+0x6e>
                    }
                }
                if ( !t )
 8107f5a:	8b7b      	ldrh	r3, [r7, #26]
 8107f5c:	2b00      	cmp	r3, #0
 8107f5e:	d109      	bne.n	8107f74 <OBJ_GetObjectList+0xb8>
                {
                    /* store the index in the mailbox buffer */
                    *pData = SWAPWORD(pObjEntry->Index);
 8107f60:	69fb      	ldr	r3, [r7, #28]
 8107f62:	891a      	ldrh	r2, [r3, #8]
 8107f64:	687b      	ldr	r3, [r7, #4]
 8107f66:	801a      	strh	r2, [r3, #0]
                    pData++;
 8107f68:	687b      	ldr	r3, [r7, #4]
 8107f6a:	3302      	adds	r3, #2
 8107f6c:	607b      	str	r3, [r7, #4]
                    size -= 2;
 8107f6e:	89bb      	ldrh	r3, [r7, #12]
 8107f70:	3b02      	subs	r3, #2
 8107f72:	81bb      	strh	r3, [r7, #12]
                }
            }
        pObjEntry = (TOBJECT OBJMEM *) pObjEntry->pNext;
 8107f74:	69fb      	ldr	r3, [r7, #28]
 8107f76:	685b      	ldr	r3, [r3, #4]
 8107f78:	61fb      	str	r3, [r7, #28]
        while (pObjEntry != NULL && size > 1 )
 8107f7a:	69fb      	ldr	r3, [r7, #28]
 8107f7c:	2b00      	cmp	r3, #0
 8107f7e:	d002      	beq.n	8107f86 <OBJ_GetObjectList+0xca>
 8107f80:	89bb      	ldrh	r3, [r7, #12]
 8107f82:	2b01      	cmp	r3, #1
 8107f84:	d8c1      	bhi.n	8107f0a <OBJ_GetObjectList+0x4e>
        }
    }

        /* return the next Index to be handled */
        if(pObjEntry != NULL)
 8107f86:	69fb      	ldr	r3, [r7, #28]
 8107f88:	2b00      	cmp	r3, #0
 8107f8a:	d004      	beq.n	8107f96 <OBJ_GetObjectList+0xda>
        {
            pIndex[0] = pObjEntry->Index;
 8107f8c:	69fb      	ldr	r3, [r7, #28]
 8107f8e:	891a      	ldrh	r2, [r3, #8]
 8107f90:	68bb      	ldr	r3, [r7, #8]
 8107f92:	801a      	strh	r2, [r3, #0]
 8107f94:	e003      	b.n	8107f9e <OBJ_GetObjectList+0xe2>
        }
        else
        {
            /*last entry reached*/
            pIndex[0] = 0xFFFF;
 8107f96:	68bb      	ldr	r3, [r7, #8]
 8107f98:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8107f9c:	801a      	strh	r2, [r3, #0]
        }

    /* store object description pointer and index for next fragment */
    pSdoInfoObjEntry = pObjEntry;
 8107f9e:	4a04      	ldr	r2, [pc, #16]	@ (8107fb0 <OBJ_GetObjectList+0xf4>)
 8107fa0:	69fb      	ldr	r3, [r7, #28]
 8107fa2:	6013      	str	r3, [r2, #0]

    /* return the size of the available mailbox buffer which was not copied to */
    return size;
 8107fa4:	89bb      	ldrh	r3, [r7, #12]
}
 8107fa6:	4618      	mov	r0, r3
 8107fa8:	3720      	adds	r7, #32
 8107faa:	46bd      	mov	sp, r7
 8107fac:	bd80      	pop	{r7, pc}
 8107fae:	bf00      	nop
 8107fb0:	10000bbc 	.word	0x10000bbc

08107fb4 <OBJ_GetDesc>:
                0xFF                                            <br>
            }
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 OBJ_GetDesc( UINT16 index, UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData )
{
 8107fb4:	b590      	push	{r4, r7, lr}
 8107fb6:	b08d      	sub	sp, #52	@ 0x34
 8107fb8:	af00      	add	r7, sp, #0
 8107fba:	60ba      	str	r2, [r7, #8]
 8107fbc:	607b      	str	r3, [r7, #4]
 8107fbe:	4603      	mov	r3, r0
 8107fc0:	81fb      	strh	r3, [r7, #14]
 8107fc2:	460b      	mov	r3, r1
 8107fc4:	737b      	strb	r3, [r7, #13]
    UINT16 strSize = 0;
 8107fc6:	2300      	movs	r3, #0
 8107fc8:	85fb      	strh	r3, [r7, #46]	@ 0x2e
    OBJCONST UCHAR OBJMEM * pDesc = (OBJCONST UCHAR OBJMEM *) pObjEntry->pName;
 8107fca:	68bb      	ldr	r3, [r7, #8]
 8107fcc:	695b      	ldr	r3, [r3, #20]
 8107fce:	627b      	str	r3, [r7, #36]	@ 0x24
/* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 8107fd0:	68bb      	ldr	r3, [r7, #8]
 8107fd2:	899b      	ldrh	r3, [r3, #12]
 8107fd4:	121b      	asrs	r3, r3, #8
 8107fd6:	b2db      	uxtb	r3, r3
 8107fd8:	f003 030f 	and.w	r3, r3, #15
 8107fdc:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23

    if ( (subindex == 0) || (objCode == OBJCODE_VAR) )
 8107fe0:	7b7b      	ldrb	r3, [r7, #13]
 8107fe2:	2b00      	cmp	r3, #0
 8107fe4:	d003      	beq.n	8107fee <OBJ_GetDesc+0x3a>
 8107fe6:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8107fea:	2b07      	cmp	r3, #7
 8107fec:	d10e      	bne.n	810800c <OBJ_GetDesc+0x58>
    {
        // Get object description length
        strSize = OBJSTRLEN( (OBJCONST CHAR OBJMEM *) pDesc );
 8107fee:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 8107ff0:	f7f8 f980 	bl	81002f4 <strlen>
 8107ff4:	4603      	mov	r3, r0
 8107ff6:	85fb      	strh	r3, [r7, #46]	@ 0x2e

        // If there is a pointer given, copy data:
        if ( pData )
 8107ff8:	687b      	ldr	r3, [r7, #4]
 8107ffa:	2b00      	cmp	r3, #0
 8107ffc:	d067      	beq.n	81080ce <OBJ_GetDesc+0x11a>
        {
            OBJTOMBXSTRCPY( pData, pDesc, strSize );
 8107ffe:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 8108000:	461a      	mov	r2, r3
 8108002:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 8108004:	6878      	ldr	r0, [r7, #4]
 8108006:	f007 fef8 	bl	810fdfa <memcpy>
        if ( pData )
 810800a:	e060      	b.n	81080ce <OBJ_GetDesc+0x11a>
        }
    }
    else
    {
        if ( objCode == OBJCODE_REC )
 810800c:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8108010:	2b09      	cmp	r3, #9
 8108012:	d13c      	bne.n	810808e <OBJ_GetDesc+0xda>
        {
            {
            // get pointer to description of subindex 1 :
            // 16bit variable to avoid overflow if subindex 0xFF is read
            UINT16 i = 1;
 8108014:	2301      	movs	r3, #1
 8108016:	85bb      	strh	r3, [r7, #44]	@ 0x2c
            UINT16 tmpSubindex = subindex;
 8108018:	7b7b      	ldrb	r3, [r7, #13]
 810801a:	843b      	strh	r3, [r7, #32]

            {

            OBJCONST UCHAR OBJMEM * pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pDesc );
 810801c:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 810801e:	f7f8 f969 	bl	81002f4 <strlen>
 8108022:	4603      	mov	r3, r0
 8108024:	3301      	adds	r3, #1
 8108026:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8108028:	4413      	add	r3, r2
 810802a:	62bb      	str	r3, [r7, #40]	@ 0x28
            while (( i <= tmpSubindex )
 810802c:	e023      	b.n	8108076 <OBJ_GetDesc+0xc2>
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE ))
            {
                if ( i == tmpSubindex )
 810802e:	8dba      	ldrh	r2, [r7, #44]	@ 0x2c
 8108030:	8c3b      	ldrh	r3, [r7, #32]
 8108032:	429a      	cmp	r2, r3
 8108034:	d114      	bne.n	8108060 <OBJ_GetDesc+0xac>
                {
                    strSize = OBJSTRLEN( (OBJCONST CHAR OBJMEM *) pSubDesc );
 8108036:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8108038:	f7f8 f95c 	bl	81002f4 <strlen>
 810803c:	4603      	mov	r3, r0
 810803e:	85fb      	strh	r3, [r7, #46]	@ 0x2e
                    if ( pData && strSize )
 8108040:	687b      	ldr	r3, [r7, #4]
 8108042:	2b00      	cmp	r3, #0
 8108044:	d009      	beq.n	810805a <OBJ_GetDesc+0xa6>
 8108046:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 8108048:	2b00      	cmp	r3, #0
 810804a:	d006      	beq.n	810805a <OBJ_GetDesc+0xa6>
                        OBJTOMBXSTRCPY( pData, pSubDesc, strSize );
 810804c:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 810804e:	461a      	mov	r2, r3
 8108050:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
 8108052:	6878      	ldr	r0, [r7, #4]
 8108054:	f007 fed1 	bl	810fdfa <memcpy>
/* ECATCHANGE_START(V5.11) SDO6*/
                    else
                        strSize = 0;
/* ECATCHANGE_END(V5.11) SDO6*/

                    break;
 8108058:	e019      	b.n	810808e <OBJ_GetDesc+0xda>
                        strSize = 0;
 810805a:	2300      	movs	r3, #0
 810805c:	85fb      	strh	r3, [r7, #46]	@ 0x2e
                    break;
 810805e:	e016      	b.n	810808e <OBJ_GetDesc+0xda>
                }
                else
                {
                    i++;
 8108060:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 8108062:	3301      	adds	r3, #1
 8108064:	85bb      	strh	r3, [r7, #44]	@ 0x2c
                    pSubDesc = (OBJCONST UCHAR OBJMEM *) OBJGETNEXTSTR( pSubDesc );
 8108066:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 8108068:	f7f8 f944 	bl	81002f4 <strlen>
 810806c:	4603      	mov	r3, r0
 810806e:	3301      	adds	r3, #1
 8108070:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8108072:	4413      	add	r3, r2
 8108074:	62bb      	str	r3, [r7, #40]	@ 0x28
                &&( pSubDesc[0] != 0xFF && pSubDesc[0] != 0xFE ))
 8108076:	8dba      	ldrh	r2, [r7, #44]	@ 0x2c
 8108078:	8c3b      	ldrh	r3, [r7, #32]
 810807a:	429a      	cmp	r2, r3
 810807c:	d807      	bhi.n	810808e <OBJ_GetDesc+0xda>
 810807e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8108080:	781b      	ldrb	r3, [r3, #0]
 8108082:	2bff      	cmp	r3, #255	@ 0xff
 8108084:	d003      	beq.n	810808e <OBJ_GetDesc+0xda>
 8108086:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8108088:	781b      	ldrb	r3, [r3, #0]
 810808a:	2bfe      	cmp	r3, #254	@ 0xfe
 810808c:	d1cf      	bne.n	810802e <OBJ_GetDesc+0x7a>
            }
            }
            }
        }

        if ( strSize == 0 )
 810808e:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 8108090:	2b00      	cmp	r3, #0
 8108092:	d11c      	bne.n	81080ce <OBJ_GetDesc+0x11a>
        {
            // no string found for subindex x -> name is Subindex x
            strSize =    12;
 8108094:	230c      	movs	r3, #12
 8108096:	85fb      	strh	r3, [r7, #46]	@ 0x2e

            if ( pData )
 8108098:	687b      	ldr	r3, [r7, #4]
 810809a:	2b00      	cmp	r3, #0
 810809c:	d017      	beq.n	81080ce <OBJ_GetDesc+0x11a>
            {
                UCHAR OBJMEM         TmpDescr[13];
                OBJSTRCPY(TmpDescr,aSubindexDesc,SIZEOF(TmpDescr));
 810809e:	4b0e      	ldr	r3, [pc, #56]	@ (81080d8 <OBJ_GetDesc+0x124>)
 81080a0:	f107 0410 	add.w	r4, r7, #16
 81080a4:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 81080a6:	c407      	stmia	r4!, {r0, r1, r2}
 81080a8:	7023      	strb	r3, [r4, #0]
                
                OBJ_CopyNumberToString( &TmpDescr[9], subindex );
 81080aa:	7b7a      	ldrb	r2, [r7, #13]
 81080ac:	f107 0310 	add.w	r3, r7, #16
 81080b0:	3309      	adds	r3, #9
 81080b2:	4611      	mov	r1, r2
 81080b4:	4618      	mov	r0, r3
 81080b6:	f7ff fe69 	bl	8107d8c <OBJ_CopyNumberToString>
                MBXSTRCPY( pData, TmpDescr, SIZEOF(TmpDescr) );
 81080ba:	687b      	ldr	r3, [r7, #4]
 81080bc:	461c      	mov	r4, r3
 81080be:	f107 0310 	add.w	r3, r7, #16
 81080c2:	cb07      	ldmia	r3!, {r0, r1, r2}
 81080c4:	6020      	str	r0, [r4, #0]
 81080c6:	6061      	str	r1, [r4, #4]
 81080c8:	60a2      	str	r2, [r4, #8]
 81080ca:	781b      	ldrb	r3, [r3, #0]
 81080cc:	7323      	strb	r3, [r4, #12]
            }
        }
    }

    return strSize;
 81080ce:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
}
 81080d0:	4618      	mov	r0, r3
 81080d2:	3734      	adds	r7, #52	@ 0x34
 81080d4:	46bd      	mov	sp, r7
 81080d6:	bd90      	pop	{r4, r7, pc}
 81080d8:	10000480 	.word	0x10000480

081080dc <OBJ_GetEntryDesc>:
         to define the object dictionary independent of the sdoserv-files

*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOENTRYDESC OBJMEM * OBJ_GetEntryDesc(OBJCONST TOBJECT OBJMEM * pObjEntry, UINT8 Subindex)
{
 81080dc:	b480      	push	{r7}
 81080de:	b085      	sub	sp, #20
 81080e0:	af00      	add	r7, sp, #0
 81080e2:	6078      	str	r0, [r7, #4]
 81080e4:	460b      	mov	r3, r1
 81080e6:	70fb      	strb	r3, [r7, #3]
    OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 81080e8:	687b      	ldr	r3, [r7, #4]
 81080ea:	899b      	ldrh	r3, [r3, #12]
 81080ec:	121b      	asrs	r3, r3, #8
 81080ee:	b2db      	uxtb	r3, r3
 81080f0:	f003 030f 	and.w	r3, r3, #15
 81080f4:	72fb      	strb	r3, [r7, #11]

    if ((objCode == OBJCODE_ARR)
 81080f6:	7afb      	ldrb	r3, [r7, #11]
 81080f8:	2b08      	cmp	r3, #8
 81080fa:	d10b      	bne.n	8108114 <OBJ_GetEntryDesc+0x38>
        )
    {
        /* object is an array */
        if ( Subindex == 0 )
 81080fc:	78fb      	ldrb	r3, [r7, #3]
 81080fe:	2b00      	cmp	r3, #0
 8108100:	d103      	bne.n	810810a <OBJ_GetEntryDesc+0x2e>
            /* subindex 0 has a description */
            pEntry = &pObjEntry->pEntryDesc[0];
 8108102:	687b      	ldr	r3, [r7, #4]
 8108104:	691b      	ldr	r3, [r3, #16]
 8108106:	60fb      	str	r3, [r7, #12]
 8108108:	e00d      	b.n	8108126 <OBJ_GetEntryDesc+0x4a>
        else
            /* and all other elements have the same description */
            pEntry = &pObjEntry->pEntryDesc[1];
 810810a:	687b      	ldr	r3, [r7, #4]
 810810c:	691b      	ldr	r3, [r3, #16]
 810810e:	3306      	adds	r3, #6
 8108110:	60fb      	str	r3, [r7, #12]
 8108112:	e008      	b.n	8108126 <OBJ_GetEntryDesc+0x4a>
    }
    else
    {
        {
            /* object is a variable or a record return the corresponding entry */
            pEntry = &pObjEntry->pEntryDesc[Subindex];
 8108114:	687b      	ldr	r3, [r7, #4]
 8108116:	6919      	ldr	r1, [r3, #16]
 8108118:	78fa      	ldrb	r2, [r7, #3]
 810811a:	4613      	mov	r3, r2
 810811c:	005b      	lsls	r3, r3, #1
 810811e:	4413      	add	r3, r2
 8108120:	005b      	lsls	r3, r3, #1
 8108122:	440b      	add	r3, r1
 8108124:	60fb      	str	r3, [r7, #12]
        }
    }

    return pEntry;
 8108126:	68fb      	ldr	r3, [r7, #12]
}
 8108128:	4618      	mov	r0, r3
 810812a:	3714      	adds	r7, #20
 810812c:	46bd      	mov	sp, r7
 810812e:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108132:	4770      	bx	lr

08108134 <OBJ_GetObjDesc>:
         to define the object dictionary independent of the sdoserv-files

*////////////////////////////////////////////////////////////////////////////////////////

OBJCONST TSDOINFOOBJDESC OBJMEM * OBJ_GetObjDesc(OBJCONST TOBJECT OBJMEM * pObjEntry)
{
 8108134:	b480      	push	{r7}
 8108136:	b083      	sub	sp, #12
 8108138:	af00      	add	r7, sp, #0
 810813a:	6078      	str	r0, [r7, #4]
    return &pObjEntry->ObjDesc;
 810813c:	687b      	ldr	r3, [r7, #4]
 810813e:	330a      	adds	r3, #10
}
 8108140:	4618      	mov	r0, r3
 8108142:	370c      	adds	r7, #12
 8108144:	46bd      	mov	sp, r7
 8108146:	f85d 7b04 	ldr.w	r7, [sp], #4
 810814a:	4770      	bx	lr

0810814c <OBJ_GetEntryOffset>:

 \brief    This function calculates the bit offset of the entry in the object's variable
*////////////////////////////////////////////////////////////////////////////////////////

UINT16 OBJ_GetEntryOffset(UINT8 subindex, OBJCONST TOBJECT OBJMEM * pObjEntry)
{
 810814c:	b480      	push	{r7}
 810814e:	b087      	sub	sp, #28
 8108150:	af00      	add	r7, sp, #0
 8108152:	4603      	mov	r3, r0
 8108154:	6039      	str	r1, [r7, #0]
 8108156:	71fb      	strb	r3, [r7, #7]
    UINT16 i;
    /* bitOffset will be initialized with the bit offset of subindex 1 */
/*ECATCHANGE_START(V5.11) OBJ1*/
    UINT16 bitOffset = 0;
 8108158:	2300      	movs	r3, #0
 810815a:	82bb      	strh	r3, [r7, #20]
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 810815c:	683b      	ldr	r3, [r7, #0]
 810815e:	899b      	ldrh	r3, [r3, #12]
 8108160:	121b      	asrs	r3, r3, #8
 8108162:	b2db      	uxtb	r3, r3
 8108164:	f003 030f 	and.w	r3, r3, #15
 8108168:	73fb      	strb	r3, [r7, #15]
    OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;

    if(subindex > 0)
 810816a:	79fb      	ldrb	r3, [r7, #7]
 810816c:	2b00      	cmp	r3, #0
 810816e:	d002      	beq.n	8108176 <OBJ_GetEntryOffset+0x2a>
    {
        /*subindex 1 has an offset of 16Bit (even if Si0 is only an UINT8) */
        bitOffset +=16;
 8108170:	8abb      	ldrh	r3, [r7, #20]
 8108172:	3310      	adds	r3, #16
 8108174:	82bb      	strh	r3, [r7, #20]
    }
/*ECATCHANGE_END(V5.11) OBJ1*/

    if (objCode == OBJCODE_VAR)
 8108176:	7bfb      	ldrb	r3, [r7, #15]
 8108178:	2b07      	cmp	r3, #7
 810817a:	d101      	bne.n	8108180 <OBJ_GetEntryOffset+0x34>
        return 0;
 810817c:	2300      	movs	r3, #0
 810817e:	e0c5      	b.n	810830c <OBJ_GetEntryOffset+0x1c0>

    for (i = 1; i <= subindex; i++)
 8108180:	2301      	movs	r3, #1
 8108182:	82fb      	strh	r3, [r7, #22]
 8108184:	e0bb      	b.n	81082fe <OBJ_GetEntryOffset+0x1b2>
    {
        /* get the entry description */
        if ((objCode == OBJCODE_ARR)
 8108186:	7bfb      	ldrb	r3, [r7, #15]
 8108188:	2b08      	cmp	r3, #8
 810818a:	d104      	bne.n	8108196 <OBJ_GetEntryOffset+0x4a>
           )
            pEntry = &pObjEntry->pEntryDesc[1];
 810818c:	683b      	ldr	r3, [r7, #0]
 810818e:	691b      	ldr	r3, [r3, #16]
 8108190:	3306      	adds	r3, #6
 8108192:	613b      	str	r3, [r7, #16]
 8108194:	e008      	b.n	81081a8 <OBJ_GetEntryOffset+0x5c>
        else
        {
            pEntry = &pObjEntry->pEntryDesc[i];
 8108196:	683b      	ldr	r3, [r7, #0]
 8108198:	6919      	ldr	r1, [r3, #16]
 810819a:	8afa      	ldrh	r2, [r7, #22]
 810819c:	4613      	mov	r3, r2
 810819e:	005b      	lsls	r3, r3, #1
 81081a0:	4413      	add	r3, r2
 81081a2:	005b      	lsls	r3, r3, #1
 81081a4:	440b      	add	r3, r1
 81081a6:	613b      	str	r3, [r7, #16]
        }

        switch (pEntry->DataType)
 81081a8:	693b      	ldr	r3, [r7, #16]
 81081aa:	881b      	ldrh	r3, [r3, #0]
 81081ac:	f5b3 7f19 	cmp.w	r3, #612	@ 0x264
 81081b0:	f280 8092 	bge.w	81082d8 <OBJ_GetEntryOffset+0x18c>
 81081b4:	f240 2262 	movw	r2, #610	@ 0x262
 81081b8:	4293      	cmp	r3, r2
 81081ba:	da6c      	bge.n	8108296 <OBJ_GetEntryOffset+0x14a>
 81081bc:	f5b3 7f18 	cmp.w	r3, #608	@ 0x260
 81081c0:	d04c      	beq.n	810825c <OBJ_GetEntryOffset+0x110>
 81081c2:	f5b3 7f18 	cmp.w	r3, #608	@ 0x260
 81081c6:	f300 8087 	bgt.w	81082d8 <OBJ_GetEntryOffset+0x18c>
 81081ca:	2b0b      	cmp	r3, #11
 81081cc:	dc41      	bgt.n	8108252 <OBJ_GetEntryOffset+0x106>
 81081ce:	2b03      	cmp	r3, #3
 81081d0:	da28      	bge.n	8108224 <OBJ_GetEntryOffset+0xd8>
 81081d2:	e081      	b.n	81082d8 <OBJ_GetEntryOffset+0x18c>
 81081d4:	3b1f      	subs	r3, #31
 81081d6:	2b10      	cmp	r3, #16
 81081d8:	d87e      	bhi.n	81082d8 <OBJ_GetEntryOffset+0x18c>
 81081da:	a201      	add	r2, pc, #4	@ (adr r2, 81081e0 <OBJ_GetEntryOffset+0x94>)
 81081dc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 81081e0:	0810825d 	.word	0x0810825d
 81081e4:	08108297 	.word	0x08108297
 81081e8:	081082d9 	.word	0x081082d9
 81081ec:	081082d9 	.word	0x081082d9
 81081f0:	081082d9 	.word	0x081082d9
 81081f4:	081082d9 	.word	0x081082d9
 81081f8:	081082d9 	.word	0x081082d9
 81081fc:	081082d9 	.word	0x081082d9
 8108200:	081082d9 	.word	0x081082d9
 8108204:	081082d9 	.word	0x081082d9
 8108208:	081082d9 	.word	0x081082d9
 810820c:	081082d9 	.word	0x081082d9
 8108210:	081082d9 	.word	0x081082d9
 8108214:	081082d9 	.word	0x081082d9
 8108218:	081082d9 	.word	0x081082d9
 810821c:	0810825d 	.word	0x0810825d
 8108220:	08108297 	.word	0x08108297
 8108224:	3b03      	subs	r3, #3
 8108226:	2201      	movs	r2, #1
 8108228:	409a      	lsls	r2, r3
 810822a:	f002 0332 	and.w	r3, r2, #50	@ 0x32
 810822e:	2b00      	cmp	r3, #0
 8108230:	bf14      	ite	ne
 8108232:	2301      	movne	r3, #1
 8108234:	2300      	moveq	r3, #0
 8108236:	b2db      	uxtb	r3, r3
 8108238:	2b00      	cmp	r3, #0
 810823a:	d12c      	bne.n	8108296 <OBJ_GetEntryOffset+0x14a>
 810823c:	f240 1309 	movw	r3, #265	@ 0x109
 8108240:	4013      	ands	r3, r2
 8108242:	2b00      	cmp	r3, #0
 8108244:	bf14      	ite	ne
 8108246:	2301      	movne	r3, #1
 8108248:	2300      	moveq	r3, #0
 810824a:	b2db      	uxtb	r3, r3
 810824c:	2b00      	cmp	r3, #0
 810824e:	d105      	bne.n	810825c <OBJ_GetEntryOffset+0x110>
 8108250:	e042      	b.n	81082d8 <OBJ_GetEntryOffset+0x18c>
 8108252:	2b2f      	cmp	r3, #47	@ 0x2f
 8108254:	dc40      	bgt.n	81082d8 <OBJ_GetEntryOffset+0x18c>
 8108256:	2b1f      	cmp	r3, #31
 8108258:	dabc      	bge.n	81081d4 <OBJ_GetEntryOffset+0x88>
 810825a:	e03d      	b.n	81082d8 <OBJ_GetEntryOffset+0x18c>
/*ECATCHANGE_END(V5.11) SDO9*/

#if OBJ_WORD_ALIGN    || OBJ_DWORD_ALIGN
            /* the 16-bit variables in the structure are word-aligned,
               align the actual bitOffset to a word */
            bitOffset = (bitOffset+15) & 0xFFF0;
 810825c:	8abb      	ldrh	r3, [r7, #20]
 810825e:	330f      	adds	r3, #15
 8108260:	b29b      	uxth	r3, r3
 8108262:	f023 030f 	bic.w	r3, r3, #15
 8108266:	82bb      	strh	r3, [r7, #20]
#endif


/*ECATCHANGE_START(V5.11) SDO9*/
            if (i < subindex)
 8108268:	79fb      	ldrb	r3, [r7, #7]
 810826a:	b29b      	uxth	r3, r3
 810826c:	8afa      	ldrh	r2, [r7, #22]
 810826e:	429a      	cmp	r2, r3
 8108270:	d23d      	bcs.n	81082ee <OBJ_GetEntryOffset+0x1a2>
            {
                if((pEntry->DataType == DEFTYPE_UNICODE_STRING)
 8108272:	693b      	ldr	r3, [r7, #16]
 8108274:	881b      	ldrh	r3, [r3, #0]
 8108276:	2b0b      	cmp	r3, #11
 8108278:	d004      	beq.n	8108284 <OBJ_GetEntryOffset+0x138>
                    ||(pEntry->DataType == DEFTYPE_ARRAY_OF_INT))
 810827a:	693b      	ldr	r3, [r7, #16]
 810827c:	881b      	ldrh	r3, [r3, #0]
 810827e:	f5b3 7f18 	cmp.w	r3, #608	@ 0x260
 8108282:	d104      	bne.n	810828e <OBJ_GetEntryOffset+0x142>
                {
                    bitOffset += pEntry->BitLength;
 8108284:	693b      	ldr	r3, [r7, #16]
 8108286:	885a      	ldrh	r2, [r3, #2]
 8108288:	8abb      	ldrh	r3, [r7, #20]
 810828a:	4413      	add	r3, r2
 810828c:	82bb      	strh	r3, [r7, #20]
                }

                bitOffset += 16;
 810828e:	8abb      	ldrh	r3, [r7, #20]
 8108290:	3310      	adds	r3, #16
 8108292:	82bb      	strh	r3, [r7, #20]
            }
/*ECATCHANGE_END(V5.11) SDO9*/
            break;
 8108294:	e02b      	b.n	81082ee <OBJ_GetEntryOffset+0x1a2>
        case    DEFTYPE_ARRAY_OF_UDINT:
/*ECATCHANGE_END(V5.11) SDO9*/
#if OBJ_DWORD_ALIGN
            /* the 32-bit variables in the structure are dword-aligned,
               align the actual bitOffset to a dword */
            bitOffset = (bitOffset+31) & 0xFFE0;
 8108296:	8abb      	ldrh	r3, [r7, #20]
 8108298:	331f      	adds	r3, #31
 810829a:	b29b      	uxth	r3, r3
 810829c:	f023 031f 	bic.w	r3, r3, #31
 81082a0:	82bb      	strh	r3, [r7, #20]
               align the actual bitOffset to a word */
            bitOffset = (bitOffset+15) & 0xFFF0;
#endif

/*ECATCHANGE_START(V5.11) SDO9*/
            if (i < subindex)
 81082a2:	79fb      	ldrb	r3, [r7, #7]
 81082a4:	b29b      	uxth	r3, r3
 81082a6:	8afa      	ldrh	r2, [r7, #22]
 81082a8:	429a      	cmp	r2, r3
 81082aa:	d222      	bcs.n	81082f2 <OBJ_GetEntryOffset+0x1a6>
            {
                if((pEntry->DataType == DEFTYPE_ARRAY_OF_DINT)
 81082ac:	693b      	ldr	r3, [r7, #16]
 81082ae:	881b      	ldrh	r3, [r3, #0]
 81082b0:	f240 2262 	movw	r2, #610	@ 0x262
 81082b4:	4293      	cmp	r3, r2
 81082b6:	d005      	beq.n	81082c4 <OBJ_GetEntryOffset+0x178>
                    ||(pEntry->DataType == DEFTYPE_ARRAY_OF_UDINT))
 81082b8:	693b      	ldr	r3, [r7, #16]
 81082ba:	881b      	ldrh	r3, [r3, #0]
 81082bc:	f240 2263 	movw	r2, #611	@ 0x263
 81082c0:	4293      	cmp	r3, r2
 81082c2:	d105      	bne.n	81082d0 <OBJ_GetEntryOffset+0x184>
                {
                    bitOffset += pEntry->BitLength;
 81082c4:	693b      	ldr	r3, [r7, #16]
 81082c6:	885a      	ldrh	r2, [r3, #2]
 81082c8:	8abb      	ldrh	r3, [r7, #20]
 81082ca:	4413      	add	r3, r2
 81082cc:	82bb      	strh	r3, [r7, #20]
                }
                else
                   bitOffset += 32;
            }
/*ECATCHANGE_END(V5.11) SDO9*/
            break;
 81082ce:	e010      	b.n	81082f2 <OBJ_GetEntryOffset+0x1a6>
                   bitOffset += 32;
 81082d0:	8abb      	ldrh	r3, [r7, #20]
 81082d2:	3320      	adds	r3, #32
 81082d4:	82bb      	strh	r3, [r7, #20]
            break;
 81082d6:	e00c      	b.n	81082f2 <OBJ_GetEntryOffset+0x1a6>
        default:
            /* align the actual bitOffset to a byte */
            if (i < subindex)
 81082d8:	79fb      	ldrb	r3, [r7, #7]
 81082da:	b29b      	uxth	r3, r3
 81082dc:	8afa      	ldrh	r2, [r7, #22]
 81082de:	429a      	cmp	r2, r3
 81082e0:	d209      	bcs.n	81082f6 <OBJ_GetEntryOffset+0x1aa>
                bitOffset += pEntry->BitLength;
 81082e2:	693b      	ldr	r3, [r7, #16]
 81082e4:	885a      	ldrh	r2, [r3, #2]
 81082e6:	8abb      	ldrh	r3, [r7, #20]
 81082e8:	4413      	add	r3, r2
 81082ea:	82bb      	strh	r3, [r7, #20]
            break;
 81082ec:	e003      	b.n	81082f6 <OBJ_GetEntryOffset+0x1aa>
            break;
 81082ee:	bf00      	nop
 81082f0:	e002      	b.n	81082f8 <OBJ_GetEntryOffset+0x1ac>
            break;
 81082f2:	bf00      	nop
 81082f4:	e000      	b.n	81082f8 <OBJ_GetEntryOffset+0x1ac>
            break;
 81082f6:	bf00      	nop
    for (i = 1; i <= subindex; i++)
 81082f8:	8afb      	ldrh	r3, [r7, #22]
 81082fa:	3301      	adds	r3, #1
 81082fc:	82fb      	strh	r3, [r7, #22]
 81082fe:	79fb      	ldrb	r3, [r7, #7]
 8108300:	b29b      	uxth	r3, r3
 8108302:	8afa      	ldrh	r2, [r7, #22]
 8108304:	429a      	cmp	r2, r3
 8108306:	f67f af3e 	bls.w	8108186 <OBJ_GetEntryOffset+0x3a>
        }
    }

    return bitOffset;
 810830a:	8abb      	ldrh	r3, [r7, #20]
}
 810830c:	4618      	mov	r0, r3
 810830e:	371c      	adds	r7, #28
 8108310:	46bd      	mov	sp, r7
 8108312:	f85d 7b04 	ldr.w	r7, [sp], #4
 8108316:	4770      	bx	lr

08108318 <CheckSyncTypeValue>:
 \return    result                Result of the value validation

 \brief    Checks if the new Sync type value is valid
*////////////////////////////////////////////////////////////////////////////////////////
UINT8 CheckSyncTypeValue(UINT16 index, UINT16 NewSyncType)
{
 8108318:	b480      	push	{r7}
 810831a:	b083      	sub	sp, #12
 810831c:	af00      	add	r7, sp, #0
 810831e:	4603      	mov	r3, r0
 8108320:	460a      	mov	r2, r1
 8108322:	80fb      	strh	r3, [r7, #6]
 8108324:	4613      	mov	r3, r2
 8108326:	80bb      	strh	r3, [r7, #4]
    /*ECATCHANGE_START(V5.11) ESM7*/
    switch (NewSyncType)
 8108328:	88bb      	ldrh	r3, [r7, #4]
 810832a:	2b22      	cmp	r3, #34	@ 0x22
 810832c:	f200 80be 	bhi.w	81084ac <CheckSyncTypeValue+0x194>
 8108330:	a201      	add	r2, pc, #4	@ (adr r2, 8108338 <CheckSyncTypeValue+0x20>)
 8108332:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8108336:	bf00      	nop
 8108338:	081083c5 	.word	0x081083c5
 810833c:	081083c9 	.word	0x081083c9
 8108340:	08108437 	.word	0x08108437
 8108344:	0810846b 	.word	0x0810846b
 8108348:	081084ad 	.word	0x081084ad
 810834c:	081084ad 	.word	0x081084ad
 8108350:	081084ad 	.word	0x081084ad
 8108354:	081084ad 	.word	0x081084ad
 8108358:	081084ad 	.word	0x081084ad
 810835c:	081084ad 	.word	0x081084ad
 8108360:	081084ad 	.word	0x081084ad
 8108364:	081084ad 	.word	0x081084ad
 8108368:	081084ad 	.word	0x081084ad
 810836c:	081084ad 	.word	0x081084ad
 8108370:	081084ad 	.word	0x081084ad
 8108374:	081084ad 	.word	0x081084ad
 8108378:	081084ad 	.word	0x081084ad
 810837c:	081084ad 	.word	0x081084ad
 8108380:	081084ad 	.word	0x081084ad
 8108384:	081084ad 	.word	0x081084ad
 8108388:	081084ad 	.word	0x081084ad
 810838c:	081084ad 	.word	0x081084ad
 8108390:	081084ad 	.word	0x081084ad
 8108394:	081084ad 	.word	0x081084ad
 8108398:	081084ad 	.word	0x081084ad
 810839c:	081084ad 	.word	0x081084ad
 81083a0:	081084ad 	.word	0x081084ad
 81083a4:	081084ad 	.word	0x081084ad
 81083a8:	081084ad 	.word	0x081084ad
 81083ac:	081084ad 	.word	0x081084ad
 81083b0:	081084ad 	.word	0x081084ad
 81083b4:	081084ad 	.word	0x081084ad
 81083b8:	081084ad 	.word	0x081084ad
 81083bc:	081084ad 	.word	0x081084ad
 81083c0:	08108415 	.word	0x08108415
    {
    case SYNCTYPE_FREERUN:
        return 0; //free run sync mode is always accepted
 81083c4:	2300      	movs	r3, #0
 81083c6:	e072      	b.n	81084ae <CheckSyncTypeValue+0x196>
        break;

    case SYNCTYPE_SM_SYNCHRON:
        if ((index == 0x1C32) 
 81083c8:	88fb      	ldrh	r3, [r7, #6]
 81083ca:	f641 4232 	movw	r2, #7218	@ 0x1c32
 81083ce:	4293      	cmp	r3, r2
 81083d0:	d10b      	bne.n	81083ea <CheckSyncTypeValue+0xd2>
            && (nPdOutputSize > 0) 
 81083d2:	4b3a      	ldr	r3, [pc, #232]	@ (81084bc <CheckSyncTypeValue+0x1a4>)
 81083d4:	881b      	ldrh	r3, [r3, #0]
 81083d6:	2b00      	cmp	r3, #0
 81083d8:	d007      	beq.n	81083ea <CheckSyncTypeValue+0xd2>
            && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0))
 81083da:	4b39      	ldr	r3, [pc, #228]	@ (81084c0 <CheckSyncTypeValue+0x1a8>)
 81083dc:	899b      	ldrh	r3, [r3, #12]
 81083de:	f003 0302 	and.w	r3, r3, #2
 81083e2:	2b00      	cmp	r3, #0
 81083e4:	dd01      	ble.n	81083ea <CheckSyncTypeValue+0xd2>
        {
            /*SyncManager sync mode is supported and output process data is configured*/
            return 0;
 81083e6:	2300      	movs	r3, #0
 81083e8:	e061      	b.n	81084ae <CheckSyncTypeValue+0x196>
        }
        else
        if ((index == 0x1C33) 
 81083ea:	88fb      	ldrh	r3, [r7, #6]
 81083ec:	f641 4233 	movw	r2, #7219	@ 0x1c33
 81083f0:	4293      	cmp	r3, r2
 81083f2:	d154      	bne.n	810849e <CheckSyncTypeValue+0x186>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
 81083f4:	4b33      	ldr	r3, [pc, #204]	@ (81084c4 <CheckSyncTypeValue+0x1ac>)
 81083f6:	899b      	ldrh	r3, [r3, #12]
 81083f8:	f003 0302 	and.w	r3, r3, #2
 81083fc:	2b00      	cmp	r3, #0
 81083fe:	dd4e      	ble.n	810849e <CheckSyncTypeValue+0x186>
            && (nPdOutputSize == 0) 
 8108400:	4b2e      	ldr	r3, [pc, #184]	@ (81084bc <CheckSyncTypeValue+0x1a4>)
 8108402:	881b      	ldrh	r3, [r3, #0]
 8108404:	2b00      	cmp	r3, #0
 8108406:	d14a      	bne.n	810849e <CheckSyncTypeValue+0x186>
            && (nPdInputSize > 0))
 8108408:	4b2f      	ldr	r3, [pc, #188]	@ (81084c8 <CheckSyncTypeValue+0x1b0>)
 810840a:	881b      	ldrh	r3, [r3, #0]
 810840c:	2b00      	cmp	r3, #0
 810840e:	d046      	beq.n	810849e <CheckSyncTypeValue+0x186>
            {
                /*SyncManager sync mode is supported and input only shall be configured*/
                return 0;
 8108410:	2300      	movs	r3, #0
 8108412:	e04c      	b.n	81084ae <CheckSyncTypeValue+0x196>
            }
        break;

    case SYNCTYPE_SM2_SYNCHRON:
        if ((index == 0x1C33) 
 8108414:	88fb      	ldrh	r3, [r7, #6]
 8108416:	f641 4233 	movw	r2, #7219	@ 0x1c33
 810841a:	4293      	cmp	r3, r2
 810841c:	d141      	bne.n	81084a2 <CheckSyncTypeValue+0x18a>
            && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_SYNCHRONSUPP) > 0)
 810841e:	4b29      	ldr	r3, [pc, #164]	@ (81084c4 <CheckSyncTypeValue+0x1ac>)
 8108420:	899b      	ldrh	r3, [r3, #12]
 8108422:	f003 0302 	and.w	r3, r3, #2
 8108426:	2b00      	cmp	r3, #0
 8108428:	dd3b      	ble.n	81084a2 <CheckSyncTypeValue+0x18a>
            && (nPdOutputSize > 0))
 810842a:	4b24      	ldr	r3, [pc, #144]	@ (81084bc <CheckSyncTypeValue+0x1a4>)
 810842c:	881b      	ldrh	r3, [r3, #0]
 810842e:	2b00      	cmp	r3, #0
 8108430:	d037      	beq.n	81084a2 <CheckSyncTypeValue+0x18a>
            {
                /*SyncManager sync mode is supported and outputs are defined*/
                return 0;
 8108432:	2300      	movs	r3, #0
 8108434:	e03b      	b.n	81084ae <CheckSyncTypeValue+0x196>
            }
        break;

    case SYNCTYPE_DCSYNC0:
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
 8108436:	88fb      	ldrh	r3, [r7, #6]
 8108438:	f641 4232 	movw	r2, #7218	@ 0x1c32
 810843c:	4293      	cmp	r3, r2
 810843e:	d107      	bne.n	8108450 <CheckSyncTypeValue+0x138>
 8108440:	4b1f      	ldr	r3, [pc, #124]	@ (81084c0 <CheckSyncTypeValue+0x1a8>)
 8108442:	899b      	ldrh	r3, [r3, #12]
 8108444:	f003 0304 	and.w	r3, r3, #4
 8108448:	2b00      	cmp	r3, #0
 810844a:	dd01      	ble.n	8108450 <CheckSyncTypeValue+0x138>
        {
            return 0;
 810844c:	2300      	movs	r3, #0
 810844e:	e02e      	b.n	81084ae <CheckSyncTypeValue+0x196>
        }
        else
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC0SUPP) > 0))
 8108450:	88fb      	ldrh	r3, [r7, #6]
 8108452:	f641 4233 	movw	r2, #7219	@ 0x1c33
 8108456:	4293      	cmp	r3, r2
 8108458:	d125      	bne.n	81084a6 <CheckSyncTypeValue+0x18e>
 810845a:	4b1a      	ldr	r3, [pc, #104]	@ (81084c4 <CheckSyncTypeValue+0x1ac>)
 810845c:	899b      	ldrh	r3, [r3, #12]
 810845e:	f003 0304 	and.w	r3, r3, #4
 8108462:	2b00      	cmp	r3, #0
 8108464:	dd1f      	ble.n	81084a6 <CheckSyncTypeValue+0x18e>
        {
            return 0;
 8108466:	2300      	movs	r3, #0
 8108468:	e021      	b.n	81084ae <CheckSyncTypeValue+0x196>
        }
        break;

    case SYNCTYPE_DCSYNC1:
        if ((index == 0x1C32) && ((sSyncManOutPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
 810846a:	88fb      	ldrh	r3, [r7, #6]
 810846c:	f641 4232 	movw	r2, #7218	@ 0x1c32
 8108470:	4293      	cmp	r3, r2
 8108472:	d107      	bne.n	8108484 <CheckSyncTypeValue+0x16c>
 8108474:	4b12      	ldr	r3, [pc, #72]	@ (81084c0 <CheckSyncTypeValue+0x1a8>)
 8108476:	899b      	ldrh	r3, [r3, #12]
 8108478:	f003 0308 	and.w	r3, r3, #8
 810847c:	2b00      	cmp	r3, #0
 810847e:	dd01      	ble.n	8108484 <CheckSyncTypeValue+0x16c>
        {
            return 0;
 8108480:	2300      	movs	r3, #0
 8108482:	e014      	b.n	81084ae <CheckSyncTypeValue+0x196>
        }
        else
        if ((index == 0x1C33) && ((sSyncManInPar.u16SyncTypesSupported & SYNCTYPE_DCSYNC1SUPP) > 0))
 8108484:	88fb      	ldrh	r3, [r7, #6]
 8108486:	f641 4233 	movw	r2, #7219	@ 0x1c33
 810848a:	4293      	cmp	r3, r2
 810848c:	d10d      	bne.n	81084aa <CheckSyncTypeValue+0x192>
 810848e:	4b0d      	ldr	r3, [pc, #52]	@ (81084c4 <CheckSyncTypeValue+0x1ac>)
 8108490:	899b      	ldrh	r3, [r3, #12]
 8108492:	f003 0308 	and.w	r3, r3, #8
 8108496:	2b00      	cmp	r3, #0
 8108498:	dd07      	ble.n	81084aa <CheckSyncTypeValue+0x192>
        {
            return 0;
 810849a:	2300      	movs	r3, #0
 810849c:	e007      	b.n	81084ae <CheckSyncTypeValue+0x196>
        break;
 810849e:	bf00      	nop
 81084a0:	e004      	b.n	81084ac <CheckSyncTypeValue+0x194>
        break;
 81084a2:	bf00      	nop
 81084a4:	e002      	b.n	81084ac <CheckSyncTypeValue+0x194>
        break;
 81084a6:	bf00      	nop
 81084a8:	e000      	b.n	81084ac <CheckSyncTypeValue+0x194>
        }
        break;
 81084aa:	bf00      	nop
    } //switch 
/*ECATCHANGE_END(V5.11) ESM7*/
    return ABORTIDX_VALUE_EXCEEDED;
 81084ac:	2312      	movs	r3, #18

}
 81084ae:	4618      	mov	r0, r3
 81084b0:	370c      	adds	r7, #12
 81084b2:	46bd      	mov	sp, r7
 81084b4:	f85d 7b04 	ldr.w	r7, [sp], #4
 81084b8:	4770      	bx	lr
 81084ba:	bf00      	nop
 81084bc:	10000856 	.word	0x10000856
 81084c0:	10000b08 	.word	0x10000b08
 81084c4:	10000b4c 	.word	0x10000b4c
 81084c8:	10000854 	.word	0x10000854

081084cc <OBJ_Read>:

 \brief    This function reads the requested object
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 OBJ_Read( UINT16 index, UINT8 subindex, UINT32 objSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
 81084cc:	b590      	push	{r4, r7, lr}
 81084ce:	b093      	sub	sp, #76	@ 0x4c
 81084d0:	af02      	add	r7, sp, #8
 81084d2:	60ba      	str	r2, [r7, #8]
 81084d4:	607b      	str	r3, [r7, #4]
 81084d6:	4603      	mov	r3, r0
 81084d8:	81fb      	strh	r3, [r7, #14]
 81084da:	460b      	mov	r3, r1
 81084dc:	737b      	strb	r3, [r7, #13]
    UINT16 i = subindex;
 81084de:	7b7b      	ldrb	r3, [r7, #13]
 81084e0:	87fb      	strh	r3, [r7, #62]	@ 0x3e
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 81084e2:	687b      	ldr	r3, [r7, #4]
 81084e4:	899b      	ldrh	r3, [r3, #12]
 81084e6:	121b      	asrs	r3, r3, #8
 81084e8:	b2db      	uxtb	r3, r3
 81084ea:	f003 030f 	and.w	r3, r3, #15
 81084ee:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
    UINT16 maxSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
 81084f2:	687b      	ldr	r3, [r7, #4]
 81084f4:	899b      	ldrh	r3, [r3, #12]
 81084f6:	b2db      	uxtb	r3, r3
 81084f8:	87bb      	strh	r3, [r7, #60]	@ 0x3c
    OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
    /* lastSubindex is used for complete access to make loop over the requested entries
    to be read, we initialize this variable with the requested subindex that only
    one loop will be done for a single access */
    UINT16 lastSubindex = subindex;
 81084fa:	7b7b      	ldrb	r3, [r7, #13]
 81084fc:	877b      	strh	r3, [r7, #58]	@ 0x3a

    if ( objCode != OBJCODE_VAR && index >= 0x1000 )
 81084fe:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 8108502:	2b07      	cmp	r3, #7
 8108504:	d008      	beq.n	8108518 <OBJ_Read+0x4c>
 8108506:	89fb      	ldrh	r3, [r7, #14]
 8108508:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 810850c:	d304      	bcc.n	8108518 <OBJ_Read+0x4c>
    {
        /* if the object is an array or record we have to get the maxSubindex from the
        actual value of subindex 0, which is stored as UINT16 at the beginning of the
        object's variable */
        maxSubindex = (*((UINT16 *) (pObjEntry->pVarPtr))) & 0x00FF;
 810850e:	687b      	ldr	r3, [r7, #4]
 8108510:	699b      	ldr	r3, [r3, #24]
 8108512:	881b      	ldrh	r3, [r3, #0]
 8108514:	b2db      	uxtb	r3, r3
 8108516:	87bb      	strh	r3, [r7, #60]	@ 0x3c

    }

    if ( bCompleteAccess )
 8108518:	f897 3054 	ldrb.w	r3, [r7, #84]	@ 0x54
 810851c:	2b00      	cmp	r3, #0
 810851e:	d00c      	beq.n	810853a <OBJ_Read+0x6e>
    {
        if ( objCode == OBJCODE_VAR || index < 0x1000 )
 8108520:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 8108524:	2b07      	cmp	r3, #7
 8108526:	d003      	beq.n	8108530 <OBJ_Read+0x64>
 8108528:	89fb      	ldrh	r3, [r7, #14]
 810852a:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 810852e:	d201      	bcs.n	8108534 <OBJ_Read+0x68>
        {
            /* complete access is not supported with simple objects or ENUM descriptions */
            return ABORTIDX_UNSUPPORTED_ACCESS;
 8108530:	2305      	movs	r3, #5
 8108532:	e32f      	b.n	8108b94 <OBJ_Read+0x6c8>
        }

        /* we read until the maximum subindex */
        lastSubindex = maxSubindex;
 8108534:	8fbb      	ldrh	r3, [r7, #60]	@ 0x3c
 8108536:	877b      	strh	r3, [r7, #58]	@ 0x3a
 8108538:	e028      	b.n	810858c <OBJ_Read+0xc0>
    }
    else
        if ( subindex > maxSubindex )
 810853a:	7b7b      	ldrb	r3, [r7, #13]
 810853c:	b29b      	uxth	r3, r3
 810853e:	8fba      	ldrh	r2, [r7, #60]	@ 0x3c
 8108540:	429a      	cmp	r2, r3
 8108542:	d201      	bcs.n	8108548 <OBJ_Read+0x7c>
        {
            /* the maximum subindex is reached */
            return ABORTIDX_SUBINDEX_NOT_EXISTING;
 8108544:	2311      	movs	r3, #17
 8108546:	e325      	b.n	8108b94 <OBJ_Read+0x6c8>
        }
        else
        {
            /* get the corresponding entry description */
            pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
 8108548:	8ffb      	ldrh	r3, [r7, #62]	@ 0x3e
 810854a:	b2db      	uxtb	r3, r3
 810854c:	4619      	mov	r1, r3
 810854e:	6878      	ldr	r0, [r7, #4]
 8108550:	f7ff fdc4 	bl	81080dc <OBJ_GetEntryDesc>
 8108554:	6278      	str	r0, [r7, #36]	@ 0x24

            /*Check access only for non-align entries*/
            if(pEntry->ObjAccess != 0x0)
 8108556:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108558:	889b      	ldrh	r3, [r3, #4]
 810855a:	2b00      	cmp	r3, #0
 810855c:	d016      	beq.n	810858c <OBJ_Read+0xc0>
            {
                /* check if we have read access (bits 0-2 (PREOP, SAFEOP, OP) of ObjAccess)
                by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
                if ( ((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) < (nAlStatus & STATE_MASK) )
 810855e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108560:	889b      	ldrh	r3, [r3, #4]
 8108562:	b2db      	uxtb	r3, r3
 8108564:	005b      	lsls	r3, r3, #1
 8108566:	b2db      	uxtb	r3, r3
 8108568:	f003 020e 	and.w	r2, r3, #14
 810856c:	4b88      	ldr	r3, [pc, #544]	@ (8108790 <OBJ_Read+0x2c4>)
 810856e:	781b      	ldrb	r3, [r3, #0]
 8108570:	f003 030f 	and.w	r3, r3, #15
 8108574:	429a      	cmp	r2, r3
 8108576:	da09      	bge.n	810858c <OBJ_Read+0xc0>
                {
                    /* we don't have read access */
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
 8108578:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810857a:	889b      	ldrh	r3, [r3, #4]
 810857c:	f003 0307 	and.w	r3, r3, #7
 8108580:	2b00      	cmp	r3, #0
 8108582:	d101      	bne.n	8108588 <OBJ_Read+0xbc>
                    {
                        /* it is a write only entry */
                        return ABORTIDX_WRITE_ONLY_ENTRY;
 8108584:	2306      	movs	r3, #6
 8108586:	e305      	b.n	8108b94 <OBJ_Read+0x6c8>
                    }
                    else
                    {
                        /* we don't have read access in this state */
                        return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
 8108588:	231a      	movs	r3, #26
 810858a:	e303      	b.n	8108b94 <OBJ_Read+0x6c8>
                    }
                }
            }
        }
        if ( pObjEntry->Read != NULL )
 810858c:	687b      	ldr	r3, [r7, #4]
 810858e:	69db      	ldr	r3, [r3, #28]
 8108590:	2b00      	cmp	r3, #0
 8108592:	d00b      	beq.n	81085ac <OBJ_Read+0xe0>
        {
            /* Read function is defined, we call the object specific read function */
            return pObjEntry->Read(index, subindex, objSize, pData, bCompleteAccess);
 8108594:	687b      	ldr	r3, [r7, #4]
 8108596:	69dc      	ldr	r4, [r3, #28]
 8108598:	7b79      	ldrb	r1, [r7, #13]
 810859a:	89f8      	ldrh	r0, [r7, #14]
 810859c:	f897 3054 	ldrb.w	r3, [r7, #84]	@ 0x54
 81085a0:	9300      	str	r3, [sp, #0]
 81085a2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 81085a4:	68ba      	ldr	r2, [r7, #8]
 81085a6:	47a0      	blx	r4
 81085a8:	4603      	mov	r3, r0
 81085aa:	e2f3      	b.n	8108b94 <OBJ_Read+0x6c8>
        }
        else if ( index < 0x1000 && subindex != 0 )
 81085ac:	89fb      	ldrh	r3, [r7, #14]
 81085ae:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 81085b2:	d27d      	bcs.n	81086b0 <OBJ_Read+0x1e4>
 81085b4:	7b7b      	ldrb	r3, [r7, #13]
 81085b6:	2b00      	cmp	r3, #0
 81085b8:	d07a      	beq.n	81086b0 <OBJ_Read+0x1e4>
        {
            /* an ENUM description is read */
            UINT16 size;
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
 81085ba:	687b      	ldr	r3, [r7, #4]
 81085bc:	699b      	ldr	r3, [r3, #24]
 81085be:	637b      	str	r3, [r7, #52]	@ 0x34
            CHAR **p;

            /* we get the corresponding entry description */
            pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
 81085c0:	7b7b      	ldrb	r3, [r7, #13]
 81085c2:	4619      	mov	r1, r3
 81085c4:	6878      	ldr	r0, [r7, #4]
 81085c6:	f7ff fd89 	bl	81080dc <OBJ_GetEntryDesc>
 81085ca:	6278      	str	r0, [r7, #36]	@ 0x24
            size = BIT2BYTE(pEntry->BitLength);
 81085cc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 81085ce:	885b      	ldrh	r3, [r3, #2]
 81085d0:	3307      	adds	r3, #7
 81085d2:	10db      	asrs	r3, r3, #3
 81085d4:	847b      	strh	r3, [r7, #34]	@ 0x22

            p = (CHAR **) pVarPtr;
 81085d6:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 81085d8:	61fb      	str	r3, [r7, #28]
            pVarPtr = (UINT16 MBXMEM *)p[subindex-1];
 81085da:	7b7b      	ldrb	r3, [r7, #13]
 81085dc:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 81085e0:	3b01      	subs	r3, #1
 81085e2:	009b      	lsls	r3, r3, #2
 81085e4:	69fa      	ldr	r2, [r7, #28]
 81085e6:	4413      	add	r3, r2
 81085e8:	681b      	ldr	r3, [r3, #0]
 81085ea:	637b      	str	r3, [r7, #52]	@ 0x34

            if((((UINT16)pVarPtr) & 0x1) == 0x1)
 81085ec:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 81085ee:	b29b      	uxth	r3, r3
 81085f0:	f003 0301 	and.w	r3, r3, #1
 81085f4:	2b00      	cmp	r3, #0
 81085f6:	d044      	beq.n	8108682 <OBJ_Read+0x1b6>
            {
                /*enum is stored at an odd address*/
                UINT16 cnt = 0;
 81085f8:	2300      	movs	r3, #0
 81085fa:	867b      	strh	r3, [r7, #50]	@ 0x32

                //get last even WORD address
/*ECATCHANGE_START(V5.11) SDO3*/
                pVarPtr = (UINT16 MBXMEM *)(((MEM_ADDR)pVarPtr)& ~(MEM_ADDR)0x1);
 81085fc:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 81085fe:	b29b      	uxth	r3, r3
 8108600:	f023 0301 	bic.w	r3, r3, #1
 8108604:	637b      	str	r3, [r7, #52]	@ 0x34
/*ECATCHANGE_END(V5.11) SDO3*/

                for(cnt = 0; cnt < (size / 2);cnt++)
 8108606:	2300      	movs	r3, #0
 8108608:	867b      	strh	r3, [r7, #50]	@ 0x32
 810860a:	e01b      	b.n	8108644 <OBJ_Read+0x178>
                {
                    //clear destination buffer
                    pData[0] = (pVarPtr[0] & 0xFF00) >> 8;
 810860c:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810860e:	881b      	ldrh	r3, [r3, #0]
 8108610:	0a1b      	lsrs	r3, r3, #8
 8108612:	b29a      	uxth	r2, r3
 8108614:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108616:	801a      	strh	r2, [r3, #0]
                    pData[0] |= (pVarPtr[1] & 0xFF) << 8;
 8108618:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 810861a:	881b      	ldrh	r3, [r3, #0]
 810861c:	b21a      	sxth	r2, r3
 810861e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8108620:	3302      	adds	r3, #2
 8108622:	881b      	ldrh	r3, [r3, #0]
 8108624:	021b      	lsls	r3, r3, #8
 8108626:	b21b      	sxth	r3, r3
 8108628:	4313      	orrs	r3, r2
 810862a:	b21b      	sxth	r3, r3
 810862c:	b29a      	uxth	r2, r3
 810862e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108630:	801a      	strh	r2, [r3, #0]

                    pData++;
 8108632:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108634:	3302      	adds	r3, #2
 8108636:	653b      	str	r3, [r7, #80]	@ 0x50
                    pVarPtr++;
 8108638:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810863a:	3302      	adds	r3, #2
 810863c:	637b      	str	r3, [r7, #52]	@ 0x34
                for(cnt = 0; cnt < (size / 2);cnt++)
 810863e:	8e7b      	ldrh	r3, [r7, #50]	@ 0x32
 8108640:	3301      	adds	r3, #1
 8108642:	867b      	strh	r3, [r7, #50]	@ 0x32
 8108644:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 8108646:	085b      	lsrs	r3, r3, #1
 8108648:	b29b      	uxth	r3, r3
 810864a:	8e7a      	ldrh	r2, [r7, #50]	@ 0x32
 810864c:	429a      	cmp	r2, r3
 810864e:	d3dd      	bcc.n	810860c <OBJ_Read+0x140>
                }

                if((size % 2) == 1)
 8108650:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 8108652:	f003 0301 	and.w	r3, r3, #1
 8108656:	b29b      	uxth	r3, r3
 8108658:	2b00      	cmp	r3, #0
 810865a:	f000 8299 	beq.w	8108b90 <OBJ_Read+0x6c4>
                {
                    pData[0] &= 0xFF00; //Clear last Byte
 810865e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108660:	881b      	ldrh	r3, [r3, #0]
 8108662:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 8108666:	b29a      	uxth	r2, r3
 8108668:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 810866a:	801a      	strh	r2, [r3, #0]
                    pData[0] |= (pVarPtr[0] & 0xFF00) >> 8; //Write last byte
 810866c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 810866e:	881a      	ldrh	r2, [r3, #0]
 8108670:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8108672:	881b      	ldrh	r3, [r3, #0]
 8108674:	0a1b      	lsrs	r3, r3, #8
 8108676:	b29b      	uxth	r3, r3
 8108678:	4313      	orrs	r3, r2
 810867a:	b29a      	uxth	r2, r3
 810867c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 810867e:	801a      	strh	r2, [r3, #0]
        {
 8108680:	e286      	b.n	8108b90 <OBJ_Read+0x6c4>
                }
            }
            else
            {
            // Get enum value (first 32Bit)
            pData[0] = pVarPtr[0];
 8108682:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 8108684:	881a      	ldrh	r2, [r3, #0]
 8108686:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108688:	801a      	strh	r2, [r3, #0]
            pData[1] = pVarPtr[1];
 810868a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 810868c:	3302      	adds	r3, #2
 810868e:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 8108690:	8852      	ldrh	r2, [r2, #2]
 8108692:	801a      	strh	r2, [r3, #0]
            pData += 2;
 8108694:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108696:	3304      	adds	r3, #4
 8108698:	653b      	str	r3, [r7, #80]	@ 0x50
            pVarPtr += 2;
 810869a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810869c:	3304      	adds	r3, #4
 810869e:	637b      	str	r3, [r7, #52]	@ 0x34

            // Get enum description
            OBJTOMBXSTRCPY(pData,pVarPtr,size-4);
 81086a0:	8c7b      	ldrh	r3, [r7, #34]	@ 0x22
 81086a2:	3b04      	subs	r3, #4
 81086a4:	461a      	mov	r2, r3
 81086a6:	6b79      	ldr	r1, [r7, #52]	@ 0x34
 81086a8:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 81086aa:	f007 fba6 	bl	810fdfa <memcpy>
        {
 81086ae:	e26f      	b.n	8108b90 <OBJ_Read+0x6c4>
            }
        }
        else
        {
            UINT8 bRead = 0x0;
 81086b0:	2300      	movs	r3, #0
 81086b2:	f887 3031 	strb.w	r3, [r7, #49]	@ 0x31
            UINT8 result = 0;
 81086b6:	2300      	movs	r3, #0
 81086b8:	f887 3030 	strb.w	r3, [r7, #48]	@ 0x30


            /* a variable object is read */
            for (i = subindex; i <= lastSubindex; i++)
 81086bc:	7b7b      	ldrb	r3, [r7, #13]
 81086be:	87fb      	strh	r3, [r7, #62]	@ 0x3e
 81086c0:	e25a      	b.n	8108b78 <OBJ_Read+0x6ac>
            {
                /* if only a single entry is requested, this loop will only be done once */
                UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
 81086c2:	687b      	ldr	r3, [r7, #4]
 81086c4:	699b      	ldr	r3, [r3, #24]
 81086c6:	61bb      	str	r3, [r7, #24]
                UINT16 bitOffset = 0;
 81086c8:	2300      	movs	r3, #0
 81086ca:	85fb      	strh	r3, [r7, #46]	@ 0x2e

                if (i == 0)
 81086cc:	8ffb      	ldrh	r3, [r7, #62]	@ 0x3e
 81086ce:	2b00      	cmp	r3, #0
 81086d0:	d00b      	beq.n	81086ea <OBJ_Read+0x21e>
                {
                    /* subindex 0 is requested, the entry's data is at the beginning of the object's variable */
                }
                else if ( index >= 0x1000 )
 81086d2:	89fb      	ldrh	r3, [r7, #14]
 81086d4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 81086d8:	d307      	bcc.n	81086ea <OBJ_Read+0x21e>
                {
                    /* subindex 1-n of an variable object is requested, we get the offset of the variable here */
                    bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
 81086da:	8ffb      	ldrh	r3, [r7, #62]	@ 0x3e
 81086dc:	b2db      	uxtb	r3, r3
 81086de:	6879      	ldr	r1, [r7, #4]
 81086e0:	4618      	mov	r0, r3
 81086e2:	f7ff fd33 	bl	810814c <OBJ_GetEntryOffset>
 81086e6:	4603      	mov	r3, r0
 81086e8:	85fb      	strh	r3, [r7, #46]	@ 0x2e
                }

                /* we increment the variable pointer to the corresponding word address */
                pVarPtr += (bitOffset >> 4);
 81086ea:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 81086ec:	091b      	lsrs	r3, r3, #4
 81086ee:	b29b      	uxth	r3, r3
 81086f0:	005b      	lsls	r3, r3, #1
 81086f2:	69ba      	ldr	r2, [r7, #24]
 81086f4:	4413      	add	r3, r2
 81086f6:	61bb      	str	r3, [r7, #24]

                /* get the corresponding entry description */
                pEntry = OBJ_GetEntryDesc(pObjEntry, (UINT8)i);
 81086f8:	8ffb      	ldrh	r3, [r7, #62]	@ 0x3e
 81086fa:	b2db      	uxtb	r3, r3
 81086fc:	4619      	mov	r1, r3
 81086fe:	6878      	ldr	r0, [r7, #4]
 8108700:	f7ff fcec 	bl	81080dc <OBJ_GetEntryDesc>
 8108704:	6278      	str	r0, [r7, #36]	@ 0x24

                if ( ((UINT8) ((pEntry->ObjAccess & ACCESS_READ)<<1)) >= (nAlStatus & STATE_MASK) )
 8108706:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108708:	889b      	ldrh	r3, [r3, #4]
 810870a:	b2db      	uxtb	r3, r3
 810870c:	005b      	lsls	r3, r3, #1
 810870e:	b2db      	uxtb	r3, r3
 8108710:	f003 020e 	and.w	r2, r3, #14
 8108714:	4b1e      	ldr	r3, [pc, #120]	@ (8108790 <OBJ_Read+0x2c4>)
 8108716:	781b      	ldrb	r3, [r3, #0]
 8108718:	f003 030f 	and.w	r3, r3, #15
 810871c:	429a      	cmp	r2, r3
 810871e:	f2c0 81e3 	blt.w	8108ae8 <OBJ_Read+0x61c>
                {
                    if ( i == subindex                                     /* requested entry */
 8108722:	7b7b      	ldrb	r3, [r7, #13]
 8108724:	b29b      	uxth	r3, r3
 8108726:	8ffa      	ldrh	r2, [r7, #62]	@ 0x3e
 8108728:	429a      	cmp	r2, r3
 810872a:	d00a      	beq.n	8108742 <OBJ_Read+0x276>
                        || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
 810872c:	f897 3054 	ldrb.w	r3, [r7, #84]	@ 0x54
 8108730:	2b00      	cmp	r3, #0
 8108732:	f000 821e 	beq.w	8108b72 <OBJ_Read+0x6a6>
 8108736:	7b7b      	ldrb	r3, [r7, #13]
 8108738:	b29b      	uxth	r3, r3
 810873a:	8ffa      	ldrh	r2, [r7, #62]	@ 0x3e
 810873c:	429a      	cmp	r2, r3
 810873e:	f0c0 8218 	bcc.w	8108b72 <OBJ_Read+0x6a6>
                    {
                        UINT16 bitMask;

                        /* we have to copy the entry */
                        if ( i == 0 && objCode != OBJCODE_VAR )
 8108742:	8ffb      	ldrh	r3, [r7, #62]	@ 0x3e
 8108744:	2b00      	cmp	r3, #0
 8108746:	d10a      	bne.n	810875e <OBJ_Read+0x292>
 8108748:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
 810874c:	2b07      	cmp	r3, #7
 810874e:	d006      	beq.n	810875e <OBJ_Read+0x292>
                        {
                            /* we read subindex 0 of an array or record */
                            {
                                pData[0] = SWAPWORD((UINT16)maxSubindex);
 8108750:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108752:	8fba      	ldrh	r2, [r7, #60]	@ 0x3c
 8108754:	801a      	strh	r2, [r3, #0]
                            }

                            /* we increment the destination pointer by 2 because the subindex 0 will be
                            transmitted as UINT16 for a complete access */
                            pData++;
 8108756:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108758:	3302      	adds	r3, #2
 810875a:	653b      	str	r3, [r7, #80]	@ 0x50
 810875c:	e209      	b.n	8108b72 <OBJ_Read+0x6a6>
                        }
                        else
                        {
                            UINT16 dataType = pEntry->DataType;
 810875e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108760:	881b      	ldrh	r3, [r3, #0]
 8108762:	85bb      	strh	r3, [r7, #44]	@ 0x2c
                            if (pEntry->DataType >= 0x700)
 8108764:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108766:	881b      	ldrh	r3, [r3, #0]
 8108768:	f5b3 6fe0 	cmp.w	r3, #1792	@ 0x700
 810876c:	d318      	bcc.n	81087a0 <OBJ_Read+0x2d4>
                            {
                                /* the ENUM data types are defined from index 0x700 in this example
                                convert in standard data type for the read access */
                                if ( pEntry->BitLength <= 8 )
 810876e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108770:	885b      	ldrh	r3, [r3, #2]
 8108772:	2b08      	cmp	r3, #8
 8108774:	d804      	bhi.n	8108780 <OBJ_Read+0x2b4>
                                    dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
 8108776:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108778:	885b      	ldrh	r3, [r3, #2]
 810877a:	332f      	adds	r3, #47	@ 0x2f
 810877c:	85bb      	strh	r3, [r7, #44]	@ 0x2c
 810877e:	e00f      	b.n	81087a0 <OBJ_Read+0x2d4>
                                else if ( pEntry->BitLength == 16 )
 8108780:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108782:	885b      	ldrh	r3, [r3, #2]
 8108784:	2b10      	cmp	r3, #16
 8108786:	d105      	bne.n	8108794 <OBJ_Read+0x2c8>
                                    dataType = DEFTYPE_UNSIGNED16;
 8108788:	2306      	movs	r3, #6
 810878a:	85bb      	strh	r3, [r7, #44]	@ 0x2c
 810878c:	e008      	b.n	81087a0 <OBJ_Read+0x2d4>
 810878e:	bf00      	nop
 8108790:	1000085c 	.word	0x1000085c
                                else if ( pEntry->BitLength == 32 )
 8108794:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108796:	885b      	ldrh	r3, [r3, #2]
 8108798:	2b20      	cmp	r3, #32
 810879a:	d101      	bne.n	81087a0 <OBJ_Read+0x2d4>
                                    dataType = DEFTYPE_UNSIGNED32;
 810879c:	2307      	movs	r3, #7
 810879e:	85bb      	strh	r3, [r7, #44]	@ 0x2c
                            }

                            switch (dataType)
 81087a0:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 81087a2:	f5b3 7f19 	cmp.w	r3, #612	@ 0x264
 81087a6:	f280 8194 	bge.w	8108ad2 <OBJ_Read+0x606>
 81087aa:	f5b3 7f18 	cmp.w	r3, #608	@ 0x260
 81087ae:	f280 813a 	bge.w	8108a26 <OBJ_Read+0x55a>
 81087b2:	2b37      	cmp	r3, #55	@ 0x37
 81087b4:	f300 818d 	bgt.w	8108ad2 <OBJ_Read+0x606>
 81087b8:	2b1e      	cmp	r3, #30
 81087ba:	da0f      	bge.n	81087dc <OBJ_Read+0x310>
 81087bc:	2b1b      	cmp	r3, #27
 81087be:	f300 8188 	bgt.w	8108ad2 <OBJ_Read+0x606>
 81087c2:	2b09      	cmp	r3, #9
 81087c4:	da2d      	bge.n	8108822 <OBJ_Read+0x356>
 81087c6:	2b00      	cmp	r3, #0
 81087c8:	d078      	beq.n	81088bc <OBJ_Read+0x3f0>
 81087ca:	2b00      	cmp	r3, #0
 81087cc:	f2c0 8181 	blt.w	8108ad2 <OBJ_Read+0x606>
 81087d0:	2b08      	cmp	r3, #8
 81087d2:	f300 817e 	bgt.w	8108ad2 <OBJ_Read+0x606>
 81087d6:	2b00      	cmp	r3, #0
 81087d8:	dc50      	bgt.n	810887c <OBJ_Read+0x3b0>
 81087da:	e17a      	b.n	8108ad2 <OBJ_Read+0x606>
 81087dc:	3b1e      	subs	r3, #30
 81087de:	2201      	movs	r2, #1
 81087e0:	fa02 f303 	lsl.w	r3, r2, r3
 81087e4:	4a93      	ldr	r2, [pc, #588]	@ (8108a34 <OBJ_Read+0x568>)
 81087e6:	401a      	ands	r2, r3
 81087e8:	2a00      	cmp	r2, #0
 81087ea:	bf14      	ite	ne
 81087ec:	2201      	movne	r2, #1
 81087ee:	2200      	moveq	r2, #0
 81087f0:	b2d2      	uxtb	r2, r2
 81087f2:	2a00      	cmp	r2, #0
 81087f4:	f040 8084 	bne.w	8108900 <OBJ_Read+0x434>
 81087f8:	4a8f      	ldr	r2, [pc, #572]	@ (8108a38 <OBJ_Read+0x56c>)
 81087fa:	401a      	ands	r2, r3
 81087fc:	2a00      	cmp	r2, #0
 81087fe:	bf14      	ite	ne
 8108800:	2201      	movne	r2, #1
 8108802:	2200      	moveq	r2, #0
 8108804:	b2d2      	uxtb	r2, r2
 8108806:	2a00      	cmp	r2, #0
 8108808:	f040 80db 	bne.w	81089c2 <OBJ_Read+0x4f6>
 810880c:	4a8b      	ldr	r2, [pc, #556]	@ (8108a3c <OBJ_Read+0x570>)
 810880e:	401a      	ands	r2, r3
 8108810:	2a00      	cmp	r2, #0
 8108812:	bf14      	ite	ne
 8108814:	2301      	movne	r3, #1
 8108816:	2300      	moveq	r3, #0
 8108818:	b2db      	uxtb	r3, r3
 810881a:	2b00      	cmp	r3, #0
 810881c:	f040 80c2 	bne.w	81089a4 <OBJ_Read+0x4d8>
 8108820:	e157      	b.n	8108ad2 <OBJ_Read+0x606>
 8108822:	3b09      	subs	r3, #9
 8108824:	2b12      	cmp	r3, #18
 8108826:	f200 8154 	bhi.w	8108ad2 <OBJ_Read+0x606>
 810882a:	a201      	add	r2, pc, #4	@ (adr r2, 8108830 <OBJ_Read+0x364>)
 810882c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8108830:	08108a85 	.word	0x08108a85
 8108834:	08108a27 	.word	0x08108a27
 8108838:	08108a27 	.word	0x08108a27
 810883c:	08108ad3 	.word	0x08108ad3
 8108840:	08108ad3 	.word	0x08108ad3
 8108844:	08108ad3 	.word	0x08108ad3
 8108848:	08108ad3 	.word	0x08108ad3
 810884c:	08108ad3 	.word	0x08108ad3
 8108850:	081089eb 	.word	0x081089eb
 8108854:	08108ad3 	.word	0x08108ad3
 8108858:	08108ad3 	.word	0x08108ad3
 810885c:	08108ad3 	.word	0x08108ad3
 8108860:	081089eb 	.word	0x081089eb
 8108864:	08108ad3 	.word	0x08108ad3
 8108868:	08108ad3 	.word	0x08108ad3
 810886c:	08108ad3 	.word	0x08108ad3
 8108870:	08108ad3 	.word	0x08108ad3
 8108874:	08108ad3 	.word	0x08108ad3
 8108878:	081089eb 	.word	0x081089eb
 810887c:	461a      	mov	r2, r3
 810887e:	2301      	movs	r3, #1
 8108880:	4093      	lsls	r3, r2
 8108882:	f403 72c8 	and.w	r2, r3, #400	@ 0x190
 8108886:	2a00      	cmp	r2, #0
 8108888:	bf14      	ite	ne
 810888a:	2201      	movne	r2, #1
 810888c:	2200      	moveq	r2, #0
 810888e:	b2d2      	uxtb	r2, r2
 8108890:	2a00      	cmp	r2, #0
 8108892:	f040 8096 	bne.w	81089c2 <OBJ_Read+0x4f6>
 8108896:	f003 0226 	and.w	r2, r3, #38	@ 0x26
 810889a:	2a00      	cmp	r2, #0
 810889c:	bf14      	ite	ne
 810889e:	2201      	movne	r2, #1
 81088a0:	2200      	moveq	r2, #0
 81088a2:	b2d2      	uxtb	r2, r2
 81088a4:	2a00      	cmp	r2, #0
 81088a6:	d12b      	bne.n	8108900 <OBJ_Read+0x434>
 81088a8:	f003 0348 	and.w	r3, r3, #72	@ 0x48
 81088ac:	2b00      	cmp	r3, #0
 81088ae:	bf14      	ite	ne
 81088b0:	2301      	movne	r3, #1
 81088b2:	2300      	moveq	r3, #0
 81088b4:	b2db      	uxtb	r3, r3
 81088b6:	2b00      	cmp	r3, #0
 81088b8:	d174      	bne.n	81089a4 <OBJ_Read+0x4d8>
 81088ba:	e10a      	b.n	8108ad2 <OBJ_Read+0x606>
                            {
                            case DEFTYPE_NULL:
                                if(bCompleteAccess)
 81088bc:	f897 3054 	ldrb.w	r3, [r7, #84]	@ 0x54
 81088c0:	2b00      	cmp	r3, #0
 81088c2:	d01b      	beq.n	81088fc <OBJ_Read+0x430>
                                {
                                    /*Handle alignment entry*/
                                    if (((pEntry->BitLength & 0xF) > 0)
 81088c4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 81088c6:	885b      	ldrh	r3, [r3, #2]
 81088c8:	f003 030f 	and.w	r3, r3, #15
 81088cc:	2b00      	cmp	r3, #0
 81088ce:	dd0b      	ble.n	81088e8 <OBJ_Read+0x41c>
                                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 81088d0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 81088d2:	885a      	ldrh	r2, [r3, #2]
 81088d4:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 81088d6:	4413      	add	r3, r2
 81088d8:	b29b      	uxth	r3, r3
 81088da:	f003 030f 	and.w	r3, r3, #15
 81088de:	2b00      	cmp	r3, #0
 81088e0:	d102      	bne.n	81088e8 <OBJ_Read+0x41c>
                                    {
                                        /* we have reached the UINT16 border */
                                        pData++;
 81088e2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 81088e4:	3302      	adds	r3, #2
 81088e6:	653b      	str	r3, [r7, #80]	@ 0x50
                                    }

                                    /*increment WORD offset*/
                                    pData += ((pEntry->BitLength & 0xF0) >> 4);
 81088e8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 81088ea:	885b      	ldrh	r3, [r3, #2]
 81088ec:	111b      	asrs	r3, r3, #4
 81088ee:	f003 030f 	and.w	r3, r3, #15
 81088f2:	005b      	lsls	r3, r3, #1
 81088f4:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 81088f6:	4413      	add	r3, r2
 81088f8:	653b      	str	r3, [r7, #80]	@ 0x50
                                }
                                else
                                {
                                    return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
                                }
                                break;
 81088fa:	e0f1      	b.n	8108ae0 <OBJ_Read+0x614>
                                    return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 81088fc:	2318      	movs	r3, #24
 81088fe:	e149      	b.n	8108b94 <OBJ_Read+0x6c8>
/*ECATCHANGE_START(V5.11) SDO9*/
                            case    DEFTYPE_BYTE :
/*ECATCHANGE_END(V5.11) SDO9*/
                                {
                                    /* depending on the bitOffset we have to copy the Hi or the Lo-Byte */
                                    UINT16 TmpValue = 0x0000;
 8108900:	2300      	movs	r3, #0
 8108902:	82fb      	strh	r3, [r7, #22]

                                    bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
 8108904:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108906:	885b      	ldrh	r3, [r3, #2]
 8108908:	461a      	mov	r2, r3
 810890a:	4b4d      	ldr	r3, [pc, #308]	@ (8108a40 <OBJ_Read+0x574>)
 810890c:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8108910:	461a      	mov	r2, r3
 8108912:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 8108914:	f003 030f 	and.w	r3, r3, #15
 8108918:	fa02 f303 	lsl.w	r3, r2, r3
 810891c:	82bb      	strh	r3, [r7, #20]

                                    /*Swap object data (if required); all masks and offsets are defined for little endian format*/
                                    TmpValue = SWAPWORD(pVarPtr[0]);
 810891e:	69bb      	ldr	r3, [r7, #24]
 8108920:	881b      	ldrh	r3, [r3, #0]
 8108922:	82fb      	strh	r3, [r7, #22]

                                    /*Clear pData if the first bits within the WORD memory will be copied*/
                                    if ((bitOffset & 0x0F) == 0) 
 8108924:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 8108926:	f003 030f 	and.w	r3, r3, #15
 810892a:	2b00      	cmp	r3, #0
 810892c:	d102      	bne.n	8108934 <OBJ_Read+0x468>
                                    {
                                        pData[0] = 0;
 810892e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108930:	2200      	movs	r2, #0
 8108932:	801a      	strh	r2, [r3, #0]
                                    }

/* ECATCHANGE_START(V5.11) SDO7*/
                                    pData[0] = SWAPWORD(pData[0]);
 8108934:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108936:	881a      	ldrh	r2, [r3, #0]
 8108938:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 810893a:	801a      	strh	r2, [r3, #0]

                                    if (bCompleteAccess) 
 810893c:	f897 3054 	ldrb.w	r3, [r7, #84]	@ 0x54
 8108940:	2b00      	cmp	r3, #0
 8108942:	d00a      	beq.n	810895a <OBJ_Read+0x48e>
                                    {
                                        /*shifting is not required for Complete access because the bits are set to the correct offset by the master*/
                                        pData[0] |= TmpValue & bitMask;
 8108944:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108946:	881a      	ldrh	r2, [r3, #0]
 8108948:	8af9      	ldrh	r1, [r7, #22]
 810894a:	8abb      	ldrh	r3, [r7, #20]
 810894c:	400b      	ands	r3, r1
 810894e:	b29b      	uxth	r3, r3
 8108950:	4313      	orrs	r3, r2
 8108952:	b29a      	uxth	r2, r3
 8108954:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108956:	801a      	strh	r2, [r3, #0]
 8108958:	e012      	b.n	8108980 <OBJ_Read+0x4b4>
                                    }
                                    else
                                    {
                                        /*Shift Bits to the beginning of the mailbox memory*/
                                        pData[0] |= ((TmpValue & bitMask) >> (bitOffset & 0x0F));
 810895a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 810895c:	881b      	ldrh	r3, [r3, #0]
 810895e:	b21a      	sxth	r2, r3
 8108960:	8af9      	ldrh	r1, [r7, #22]
 8108962:	8abb      	ldrh	r3, [r7, #20]
 8108964:	400b      	ands	r3, r1
 8108966:	b29b      	uxth	r3, r3
 8108968:	4619      	mov	r1, r3
 810896a:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 810896c:	f003 030f 	and.w	r3, r3, #15
 8108970:	fa41 f303 	asr.w	r3, r1, r3
 8108974:	b21b      	sxth	r3, r3
 8108976:	4313      	orrs	r3, r2
 8108978:	b21b      	sxth	r3, r3
 810897a:	b29a      	uxth	r2, r3
 810897c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 810897e:	801a      	strh	r2, [r3, #0]
                                    }

                                    pData[0] = SWAPWORD(pData[0]);
 8108980:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108982:	881a      	ldrh	r2, [r3, #0]
 8108984:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108986:	801a      	strh	r2, [r3, #0]
/* ECATCHANGE_END(V5.11) SDO7*/
                                    if ( ((bitOffset + pEntry->BitLength) & 0x0F) == 0 )
 8108988:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810898a:	885a      	ldrh	r2, [r3, #2]
 810898c:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 810898e:	4413      	add	r3, r2
 8108990:	b29b      	uxth	r3, r3
 8108992:	f003 030f 	and.w	r3, r3, #15
 8108996:	2b00      	cmp	r3, #0
 8108998:	f040 809d 	bne.w	8108ad6 <OBJ_Read+0x60a>
                                    {
                                        /* we have reached the UINT16 border */
                                        pData++;
 810899c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 810899e:	3302      	adds	r3, #2
 81089a0:	653b      	str	r3, [r7, #80]	@ 0x50
                                    }

                                }
                                break;
 81089a2:	e098      	b.n	8108ad6 <OBJ_Read+0x60a>
                            case    DEFTYPE_BITARR16:
/*ECATCHANGE_START(V5.11) SDO9*/
                            case    DEFTYPE_WORD:
/*ECATCHANGE_END(V5.11) SDO9*/
/*ECATCHANGE_START(V5.11) SDO1*/
                                if(bitOffset & 0xF)
 81089a4:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 81089a6:	f003 030f 	and.w	r3, r3, #15
 81089aa:	2b00      	cmp	r3, #0
 81089ac:	d001      	beq.n	81089b2 <OBJ_Read+0x4e6>
                                {
                                    /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                    return ABORTIDX_UNSUPPORTED_ACCESS;
 81089ae:	2305      	movs	r3, #5
 81089b0:	e0f0      	b.n	8108b94 <OBJ_Read+0x6c8>
                                }
/*ECATCHANGE_END(V5.11) SDO1*/
                                /* in this example the objects are defined in that way,
                                that the 16 bit type are always starting at an exact WORD offset */
                                pData[0] = SWAPWORD(pVarPtr[0]);
 81089b2:	69bb      	ldr	r3, [r7, #24]
 81089b4:	881a      	ldrh	r2, [r3, #0]
 81089b6:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 81089b8:	801a      	strh	r2, [r3, #0]
                                pData++;
 81089ba:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 81089bc:	3302      	adds	r3, #2
 81089be:	653b      	str	r3, [r7, #80]	@ 0x50
                                break;
 81089c0:	e08e      	b.n	8108ae0 <OBJ_Read+0x614>
                            case    DEFTYPE_BITARR32:
/*ECATCHANGE_START(V5.11) SDO9*/
                            case    DEFTYPE_DWORD:
/*ECATCHANGE_END(V5.11) SDO9*/
/*ECATCHANGE_START(V5.11) SDO1*/
                                if(bitOffset & 0xF)
 81089c2:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 81089c4:	f003 030f 	and.w	r3, r3, #15
 81089c8:	2b00      	cmp	r3, #0
 81089ca:	d001      	beq.n	81089d0 <OBJ_Read+0x504>
                                {
                                    /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                    return ABORTIDX_UNSUPPORTED_ACCESS;
 81089cc:	2305      	movs	r3, #5
 81089ce:	e0e1      	b.n	8108b94 <OBJ_Read+0x6c8>
                                }
/*ECATCHANGE_END(V5.11) SDO1*/

                                /* in this example the objects are defined in that way,
                                that the 32 bit type are always starting at an exact WORD offset */
                                pData[0] = pVarPtr[0];
 81089d0:	69bb      	ldr	r3, [r7, #24]
 81089d2:	881a      	ldrh	r2, [r3, #0]
 81089d4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 81089d6:	801a      	strh	r2, [r3, #0]
                                pData[1] = pVarPtr[1];
 81089d8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 81089da:	3302      	adds	r3, #2
 81089dc:	69ba      	ldr	r2, [r7, #24]
 81089de:	8852      	ldrh	r2, [r2, #2]
 81089e0:	801a      	strh	r2, [r3, #0]
                                pData += 2;
 81089e2:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 81089e4:	3304      	adds	r3, #4
 81089e6:	653b      	str	r3, [r7, #80]	@ 0x50
                                break;
 81089e8:	e07a      	b.n	8108ae0 <OBJ_Read+0x614>
                            case    DEFTYPE_REAL64:
                            case 	DEFTYPE_INTEGER64:
                            case    DEFTYPE_UNSIGNED64:
/*ECATCHANGE_START(V5.11) SDO1*/
                                if(bitOffset & 0xF)
 81089ea:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 81089ec:	f003 030f 	and.w	r3, r3, #15
 81089f0:	2b00      	cmp	r3, #0
 81089f2:	d001      	beq.n	81089f8 <OBJ_Read+0x52c>
                                {
                                    /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                    return ABORTIDX_UNSUPPORTED_ACCESS;
 81089f4:	2305      	movs	r3, #5
 81089f6:	e0cd      	b.n	8108b94 <OBJ_Read+0x6c8>
                                }
/*ECATCHANGE_END(V5.11) SDO1*/

                                /* in this example the objects are defined in that way,
                                that the 64 bit type are always starting at an exact WORD offset */
                                pData[0] = pVarPtr[0];
 81089f8:	69bb      	ldr	r3, [r7, #24]
 81089fa:	881a      	ldrh	r2, [r3, #0]
 81089fc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 81089fe:	801a      	strh	r2, [r3, #0]
                                pData[1] = pVarPtr[1];
 8108a00:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108a02:	3302      	adds	r3, #2
 8108a04:	69ba      	ldr	r2, [r7, #24]
 8108a06:	8852      	ldrh	r2, [r2, #2]
 8108a08:	801a      	strh	r2, [r3, #0]
                                pData[2] = pVarPtr[2];
 8108a0a:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108a0c:	3304      	adds	r3, #4
 8108a0e:	69ba      	ldr	r2, [r7, #24]
 8108a10:	8892      	ldrh	r2, [r2, #4]
 8108a12:	801a      	strh	r2, [r3, #0]
                                pData[3] = pVarPtr[3];
 8108a14:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108a16:	3306      	adds	r3, #6
 8108a18:	69ba      	ldr	r2, [r7, #24]
 8108a1a:	88d2      	ldrh	r2, [r2, #6]
 8108a1c:	801a      	strh	r2, [r3, #0]
                                pData += 4;
 8108a1e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108a20:	3308      	adds	r3, #8
 8108a22:	653b      	str	r3, [r7, #80]	@ 0x50
                                break;
 8108a24:	e05c      	b.n	8108ae0 <OBJ_Read+0x614>
                            case DEFTYPE_ARRAY_OF_SINT :
                            case DEFTYPE_ARRAY_OF_DINT :
                            case DEFTYPE_ARRAY_OF_UDINT:
/*ECATCHANGE_END(V5.11) SDO9*/
/*ECATCHANGE_START(V5.11) SDO1*/
                                if(bitOffset & 0xF)
 8108a26:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 8108a28:	f003 030f 	and.w	r3, r3, #15
 8108a2c:	2b00      	cmp	r3, #0
 8108a2e:	d009      	beq.n	8108a44 <OBJ_Read+0x578>
                                {
                                    /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                    return ABORTIDX_UNSUPPORTED_ACCESS;
 8108a30:	2305      	movs	r3, #5
 8108a32:	e0af      	b.n	8108b94 <OBJ_Read+0x6c8>
 8108a34:	03fc8001 	.word	0x03fc8001
 8108a38:	00020004 	.word	0x00020004
 8108a3c:	00010002 	.word	0x00010002
 8108a40:	08111280 	.word	0x08111280
                                }
/*ECATCHANGE_END(V5.11) SDO1*/

                                OBJTOMBXMEMCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
 8108a44:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108a46:	885b      	ldrh	r3, [r3, #2]
 8108a48:	3307      	adds	r3, #7
 8108a4a:	10db      	asrs	r3, r3, #3
 8108a4c:	461a      	mov	r2, r3
 8108a4e:	69b9      	ldr	r1, [r7, #24]
 8108a50:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8108a52:	f007 f9d2 	bl	810fdfa <memcpy>

/*ECATCHANGE_START(V5.11) SDO2*/
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
 8108a56:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108a58:	885b      	ldrh	r3, [r3, #2]
 8108a5a:	f023 030f 	bic.w	r3, r3, #15
 8108a5e:	330f      	adds	r3, #15
 8108a60:	111b      	asrs	r3, r3, #4
 8108a62:	005b      	lsls	r3, r3, #1
 8108a64:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8108a66:	4413      	add	r3, r2
 8108a68:	653b      	str	r3, [r7, #80]	@ 0x50
                                
                                if((pEntry->BitLength & 0xF) != 0)
 8108a6a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108a6c:	885b      	ldrh	r3, [r3, #2]
 8108a6e:	f003 030f 	and.w	r3, r3, #15
 8108a72:	2b00      	cmp	r3, #0
 8108a74:	d031      	beq.n	8108ada <OBJ_Read+0x60e>
                                {
                                    /*current entry has an odd word length => clear last byte of next word*/
                                    *pData &= 0xFF;
 8108a76:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108a78:	881b      	ldrh	r3, [r3, #0]
 8108a7a:	b2db      	uxtb	r3, r3
 8108a7c:	b29a      	uxth	r2, r3
 8108a7e:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108a80:	801a      	strh	r2, [r3, #0]
                                }
/*ECATCHANGE_END(V5.11) SDO2*/

                                break;
 8108a82:	e02a      	b.n	8108ada <OBJ_Read+0x60e>
                            case    DEFTYPE_VISIBLESTRING:
/*ECATCHANGE_START(V5.11) SDO1*/
                                if(bitOffset & 0xF)
 8108a84:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 8108a86:	f003 030f 	and.w	r3, r3, #15
 8108a8a:	2b00      	cmp	r3, #0
 8108a8c:	d001      	beq.n	8108a92 <OBJ_Read+0x5c6>
                                {
                                    /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                    return ABORTIDX_UNSUPPORTED_ACCESS;
 8108a8e:	2305      	movs	r3, #5
 8108a90:	e080      	b.n	8108b94 <OBJ_Read+0x6c8>
                                }
/*ECATCHANGE_END(V5.11) SDO1*/

                                /* in this example the objects are defined in that way,
                                that these types are always starting at an even WORD offset */
                                OBJTOMBXSTRCPY(pData, pVarPtr, BIT2BYTE(pEntry->BitLength));
 8108a92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108a94:	885b      	ldrh	r3, [r3, #2]
 8108a96:	3307      	adds	r3, #7
 8108a98:	10db      	asrs	r3, r3, #3
 8108a9a:	461a      	mov	r2, r3
 8108a9c:	69b9      	ldr	r1, [r7, #24]
 8108a9e:	6d38      	ldr	r0, [r7, #80]	@ 0x50
 8108aa0:	f007 f9ab 	bl	810fdfa <memcpy>
/*ECATCHANGE_START(V5.11) SDO2*/
                                pData += BIT2WORD((pEntry->BitLength & ~0xF));
 8108aa4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108aa6:	885b      	ldrh	r3, [r3, #2]
 8108aa8:	f023 030f 	bic.w	r3, r3, #15
 8108aac:	330f      	adds	r3, #15
 8108aae:	111b      	asrs	r3, r3, #4
 8108ab0:	005b      	lsls	r3, r3, #1
 8108ab2:	6d3a      	ldr	r2, [r7, #80]	@ 0x50
 8108ab4:	4413      	add	r3, r2
 8108ab6:	653b      	str	r3, [r7, #80]	@ 0x50

                                if((pEntry->BitLength & 0xF) != 0)
 8108ab8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108aba:	885b      	ldrh	r3, [r3, #2]
 8108abc:	f003 030f 	and.w	r3, r3, #15
 8108ac0:	2b00      	cmp	r3, #0
 8108ac2:	d00c      	beq.n	8108ade <OBJ_Read+0x612>
                                {
                                    /*current entry has an odd word length => clear last byte of next word*/
                                    *pData &= 0xFF;
 8108ac4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108ac6:	881b      	ldrh	r3, [r3, #0]
 8108ac8:	b2db      	uxtb	r3, r3
 8108aca:	b29a      	uxth	r2, r3
 8108acc:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108ace:	801a      	strh	r2, [r3, #0]
                                }
/*ECATCHANGE_END(V5.11) SDO2*/
                                
                                break;
 8108ad0:	e005      	b.n	8108ade <OBJ_Read+0x612>
                            default:
                                /* other data types are not supported from this example */
                                return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 8108ad2:	2318      	movs	r3, #24
 8108ad4:	e05e      	b.n	8108b94 <OBJ_Read+0x6c8>
                                break;
 8108ad6:	bf00      	nop
 8108ad8:	e002      	b.n	8108ae0 <OBJ_Read+0x614>
                                break;
 8108ada:	bf00      	nop
 8108adc:	e000      	b.n	8108ae0 <OBJ_Read+0x614>
                                break;
 8108ade:	bf00      	nop
                            } //switch (deftype)

                            bRead = 1;
 8108ae0:	2301      	movs	r3, #1
 8108ae2:	f887 3031 	strb.w	r3, [r7, #49]	@ 0x31
 8108ae6:	e044      	b.n	8108b72 <OBJ_Read+0x6a6>
                    }
                }
                else
                {
                    /*No access to current object entry => shift pData if required*/
                    UINT8 cnt = 0;
 8108ae8:	2300      	movs	r3, #0
 8108aea:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b

                    /*If this entry is the first in the 16Bit block clear the memory*/
                    if ((bitOffset & 0x0F) == 0) 
 8108aee:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 8108af0:	f003 030f 	and.w	r3, r3, #15
 8108af4:	2b00      	cmp	r3, #0
 8108af6:	d102      	bne.n	8108afe <OBJ_Read+0x632>
                    {
                        *pData = 0;
 8108af8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108afa:	2200      	movs	r2, #0
 8108afc:	801a      	strh	r2, [r3, #0]
                    }

                    /*Handle Bit/Byte Offset*/
                    if (((pEntry->BitLength & 0xF) > 0)
 8108afe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108b00:	885b      	ldrh	r3, [r3, #2]
 8108b02:	f003 030f 	and.w	r3, r3, #15
 8108b06:	2b00      	cmp	r3, #0
 8108b08:	dd0e      	ble.n	8108b28 <OBJ_Read+0x65c>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 8108b0a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108b0c:	885a      	ldrh	r2, [r3, #2]
 8108b0e:	8dfb      	ldrh	r3, [r7, #46]	@ 0x2e
 8108b10:	4413      	add	r3, r2
 8108b12:	b29b      	uxth	r3, r3
 8108b14:	f003 030f 	and.w	r3, r3, #15
 8108b18:	2b00      	cmp	r3, #0
 8108b1a:	d105      	bne.n	8108b28 <OBJ_Read+0x65c>
                    {
                        /* we have reached the UINT16 border */
                        pData++;
 8108b1c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108b1e:	3302      	adds	r3, #2
 8108b20:	653b      	str	r3, [r7, #80]	@ 0x50
                        
                        /*Clear new buffer*/
                        *pData = 0;
 8108b22:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108b24:	2200      	movs	r2, #0
 8108b26:	801a      	strh	r2, [r3, #0]
                    }

                    /*increment WORD offset*/
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
 8108b28:	2300      	movs	r3, #0
 8108b2a:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
 8108b2e:	e00a      	b.n	8108b46 <OBJ_Read+0x67a>
                    {
                        /*current 16Bit are skipped => clear current buffer */
                        pData++;
 8108b30:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108b32:	3302      	adds	r3, #2
 8108b34:	653b      	str	r3, [r7, #80]	@ 0x50

                        /*Clear new buffer*/
                        *pData = 0;
 8108b36:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
 8108b38:	2200      	movs	r2, #0
 8108b3a:	801a      	strh	r2, [r3, #0]
                    for(cnt = 0; cnt <((pEntry->BitLength & 0xF0) >> 4); cnt++)
 8108b3c:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 8108b40:	3301      	adds	r3, #1
 8108b42:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
 8108b46:	f897 202b 	ldrb.w	r2, [r7, #43]	@ 0x2b
 8108b4a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108b4c:	885b      	ldrh	r3, [r3, #2]
 8108b4e:	111b      	asrs	r3, r3, #4
 8108b50:	f003 030f 	and.w	r3, r3, #15
 8108b54:	429a      	cmp	r2, r3
 8108b56:	dbeb      	blt.n	8108b30 <OBJ_Read+0x664>


                    

                    /* we don't have read access */
                    if ( (pEntry->ObjAccess & ACCESS_READ) == 0 )
 8108b58:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8108b5a:	889b      	ldrh	r3, [r3, #4]
 8108b5c:	f003 0307 	and.w	r3, r3, #7
 8108b60:	2b00      	cmp	r3, #0
 8108b62:	d103      	bne.n	8108b6c <OBJ_Read+0x6a0>
                    {
                        /* it is a write only entry */
                        result = ABORTIDX_WRITE_ONLY_ENTRY;
 8108b64:	2306      	movs	r3, #6
 8108b66:	f887 3030 	strb.w	r3, [r7, #48]	@ 0x30
 8108b6a:	e002      	b.n	8108b72 <OBJ_Read+0x6a6>
                    }
                    else
                    {
                        /* we don't have read access in this state */
                        result = ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
 8108b6c:	231a      	movs	r3, #26
 8108b6e:	f887 3030 	strb.w	r3, [r7, #48]	@ 0x30
            for (i = subindex; i <= lastSubindex; i++)
 8108b72:	8ffb      	ldrh	r3, [r7, #62]	@ 0x3e
 8108b74:	3301      	adds	r3, #1
 8108b76:	87fb      	strh	r3, [r7, #62]	@ 0x3e
 8108b78:	8ffa      	ldrh	r2, [r7, #62]	@ 0x3e
 8108b7a:	8f7b      	ldrh	r3, [r7, #58]	@ 0x3a
 8108b7c:	429a      	cmp	r2, r3
 8108b7e:	f67f ada0 	bls.w	81086c2 <OBJ_Read+0x1f6>
                    }
                }
            }

            if(bRead == 0)
 8108b82:	f897 3031 	ldrb.w	r3, [r7, #49]	@ 0x31
 8108b86:	2b00      	cmp	r3, #0
 8108b88:	d103      	bne.n	8108b92 <OBJ_Read+0x6c6>
                return result;
 8108b8a:	f897 3030 	ldrb.w	r3, [r7, #48]	@ 0x30
 8108b8e:	e001      	b.n	8108b94 <OBJ_Read+0x6c8>
        {
 8108b90:	bf00      	nop
        }

    return 0;
 8108b92:	2300      	movs	r3, #0
}
 8108b94:	4618      	mov	r0, r3
 8108b96:	3744      	adds	r7, #68	@ 0x44
 8108b98:	46bd      	mov	sp, r7
 8108b9a:	bd90      	pop	{r4, r7, pc}

08108b9c <OBJ_Write>:

 \brief    This function writes the requested object
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 OBJ_Write( UINT16 index, UINT8 subindex, UINT32 dataSize, OBJCONST TOBJECT OBJMEM * pObjEntry, UINT16 MBXMEM * pData, UINT8 bCompleteAccess )
{
 8108b9c:	b590      	push	{r4, r7, lr}
 8108b9e:	b091      	sub	sp, #68	@ 0x44
 8108ba0:	af02      	add	r7, sp, #8
 8108ba2:	60ba      	str	r2, [r7, #8]
 8108ba4:	607b      	str	r3, [r7, #4]
 8108ba6:	4603      	mov	r3, r0
 8108ba8:	81fb      	strh	r3, [r7, #14]
 8108baa:	460b      	mov	r3, r1
 8108bac:	737b      	strb	r3, [r7, #13]
    UINT16 i = subindex;
 8108bae:	7b7b      	ldrb	r3, [r7, #13]
 8108bb0:	86fb      	strh	r3, [r7, #54]	@ 0x36
    /* get the information of ObjCode and MaxSubindex in local variables to support different types of microcontroller */
    UINT8 objCode = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 8108bb2:	687b      	ldr	r3, [r7, #4]
 8108bb4:	899b      	ldrh	r3, [r3, #12]
 8108bb6:	121b      	asrs	r3, r3, #8
 8108bb8:	b2db      	uxtb	r3, r3
 8108bba:	f003 030f 	and.w	r3, r3, #15
 8108bbe:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
    UINT16 maxSubindex = 0;
 8108bc2:	2300      	movs	r3, #0
 8108bc4:	86bb      	strh	r3, [r7, #52]	@ 0x34
    UINT16 maxConfiguredSubindex = (pObjEntry->ObjDesc.ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT; //required to check if value for Subindex0 is valid
 8108bc6:	687b      	ldr	r3, [r7, #4]
 8108bc8:	899b      	ldrh	r3, [r3, #12]
 8108bca:	b2db      	uxtb	r3, r3
 8108bcc:	843b      	strh	r3, [r7, #32]
    OBJCONST TSDOINFOENTRYDESC OBJMEM *pEntry;
    BOOL bClearSubindex0Required = FALSE;
 8108bce:	2300      	movs	r3, #0
 8108bd0:	f887 3033 	strb.w	r3, [r7, #51]	@ 0x33
    /* lastSubindex is used for complete access to make loop over the requested entries
       to be read, we initialize this variable with the requested subindex that only
       one loop will be done for a single access */
    UINT16 lastSubindex = subindex;
 8108bd4:	7b7b      	ldrb	r3, [r7, #13]
 8108bd6:	863b      	strh	r3, [r7, #48]	@ 0x30

    /* if subindex 0 is writable, the maximum subindex should be checked in an object specific function,
        because for the PDO mapping and PDO assign the object shall only be written if subindex 0 is 0. */
    if ( objCode != OBJCODE_VAR )
 8108bd8:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8108bdc:	2b07      	cmp	r3, #7
 8108bde:	d023      	beq.n	8108c28 <OBJ_Write+0x8c>
    {
        /* if the object is an array or record we have to get the maxSubindex from the
           actual value of subindex 0, which is stored as UINT16 at the beginning of the
            object's variable */
        maxSubindex = (UINT8) ((UINT16 MBXMEM *) (pObjEntry->pVarPtr))[0];
 8108be0:	687b      	ldr	r3, [r7, #4]
 8108be2:	699b      	ldr	r3, [r3, #24]
 8108be4:	881b      	ldrh	r3, [r3, #0]
 8108be6:	b2db      	uxtb	r3, r3
 8108be8:	86bb      	strh	r3, [r7, #52]	@ 0x34

        /*If the subindex0 of a PDO assign or PDO mapping object is 0 the maximum subindex is specified by the object description*/
        if(maxSubindex == 0 && (IS_PDO_ASSIGN(index) || IS_RX_PDO(index) || IS_TX_PDO(index)))
 8108bea:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 8108bec:	2b00      	cmp	r3, #0
 8108bee:	d11b      	bne.n	8108c28 <OBJ_Write+0x8c>
 8108bf0:	89fb      	ldrh	r3, [r7, #14]
 8108bf2:	f641 420f 	movw	r2, #7183	@ 0x1c0f
 8108bf6:	4293      	cmp	r3, r2
 8108bf8:	d904      	bls.n	8108c04 <OBJ_Write+0x68>
 8108bfa:	89fb      	ldrh	r3, [r7, #14]
 8108bfc:	f641 422f 	movw	r2, #7215	@ 0x1c2f
 8108c00:	4293      	cmp	r3, r2
 8108c02:	d90f      	bls.n	8108c24 <OBJ_Write+0x88>
 8108c04:	89fb      	ldrh	r3, [r7, #14]
 8108c06:	f5b3 5fb0 	cmp.w	r3, #5632	@ 0x1600
 8108c0a:	d303      	bcc.n	8108c14 <OBJ_Write+0x78>
 8108c0c:	89fb      	ldrh	r3, [r7, #14]
 8108c0e:	f5b3 5fc0 	cmp.w	r3, #6144	@ 0x1800
 8108c12:	d307      	bcc.n	8108c24 <OBJ_Write+0x88>
 8108c14:	89fb      	ldrh	r3, [r7, #14]
 8108c16:	f5b3 5fd0 	cmp.w	r3, #6656	@ 0x1a00
 8108c1a:	d305      	bcc.n	8108c28 <OBJ_Write+0x8c>
 8108c1c:	89fb      	ldrh	r3, [r7, #14]
 8108c1e:	f5b3 5fe0 	cmp.w	r3, #7168	@ 0x1c00
 8108c22:	d201      	bcs.n	8108c28 <OBJ_Write+0x8c>
        {
            maxSubindex = maxConfiguredSubindex;
 8108c24:	8c3b      	ldrh	r3, [r7, #32]
 8108c26:	86bb      	strh	r3, [r7, #52]	@ 0x34
        }
    }


    if ( bCompleteAccess )
 8108c28:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
 8108c2c:	2b00      	cmp	r3, #0
 8108c2e:	d012      	beq.n	8108c56 <OBJ_Write+0xba>
    {
        if ( objCode == OBJCODE_VAR )
 8108c30:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8108c34:	2b07      	cmp	r3, #7
 8108c36:	d101      	bne.n	8108c3c <OBJ_Write+0xa0>
            /* complete access is not supported with simple objects */
            return ABORTIDX_UNSUPPORTED_ACCESS;
 8108c38:	2305      	movs	r3, #5
 8108c3a:	e31b      	b.n	8109274 <OBJ_Write+0x6d8>

        if ((subindex == 0) && (dataSize > 0))
 8108c3c:	7b7b      	ldrb	r3, [r7, #13]
 8108c3e:	2b00      	cmp	r3, #0
 8108c40:	d106      	bne.n	8108c50 <OBJ_Write+0xb4>
 8108c42:	68bb      	ldr	r3, [r7, #8]
 8108c44:	2b00      	cmp	r3, #0
 8108c46:	d003      	beq.n	8108c50 <OBJ_Write+0xb4>
        {
            /* we change the subindex 0 */
            maxSubindex = (UINT8) SWAPWORD(pData[0]);
 8108c48:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8108c4a:	881b      	ldrh	r3, [r3, #0]
 8108c4c:	b2db      	uxtb	r3, r3
 8108c4e:	86bb      	strh	r3, [r7, #52]	@ 0x34
        }

        /* we write until the maximum subindex */
        lastSubindex = maxSubindex;
 8108c50:	8ebb      	ldrh	r3, [r7, #52]	@ 0x34
 8108c52:	863b      	strh	r3, [r7, #48]	@ 0x30
 8108c54:	e022      	b.n	8108c9c <OBJ_Write+0x100>
    }
    else
    if (subindex > maxSubindex)
 8108c56:	7b7b      	ldrb	r3, [r7, #13]
 8108c58:	b29b      	uxth	r3, r3
 8108c5a:	8eba      	ldrh	r2, [r7, #52]	@ 0x34
 8108c5c:	429a      	cmp	r2, r3
 8108c5e:	d201      	bcs.n	8108c64 <OBJ_Write+0xc8>
    {
        /* the maximum subindex is reached */
        return ABORTIDX_SUBINDEX_NOT_EXISTING;
 8108c60:	2311      	movs	r3, #17
 8108c62:	e307      	b.n	8109274 <OBJ_Write+0x6d8>
    {
        /* we check the write access for single accesses here, a complete write access
           is allowed if at least one entry is writable (in this case the values for the
            read only entries shall be ignored) */
        /* we get the corresponding entry description */
        pEntry = OBJ_GetEntryDesc(pObjEntry, subindex);
 8108c64:	7b7b      	ldrb	r3, [r7, #13]
 8108c66:	4619      	mov	r1, r3
 8108c68:	6878      	ldr	r0, [r7, #4]
 8108c6a:	f7ff fa37 	bl	81080dc <OBJ_GetEntryDesc>
 8108c6e:	61f8      	str	r0, [r7, #28]

        /* check if we have write access (bits 3-5 (PREOP, SAFEOP, OP) of ObjAccess)
           by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
        if ( ((UINT8) ((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) < (nAlStatus & STATE_MASK) )
 8108c70:	69fb      	ldr	r3, [r7, #28]
 8108c72:	889b      	ldrh	r3, [r3, #4]
 8108c74:	109b      	asrs	r3, r3, #2
 8108c76:	b2db      	uxtb	r3, r3
 8108c78:	f003 020e 	and.w	r2, r3, #14
 8108c7c:	4b9b      	ldr	r3, [pc, #620]	@ (8108eec <OBJ_Write+0x350>)
 8108c7e:	781b      	ldrb	r3, [r3, #0]
 8108c80:	f003 030f 	and.w	r3, r3, #15
 8108c84:	429a      	cmp	r2, r3
 8108c86:	da09      	bge.n	8108c9c <OBJ_Write+0x100>
        {
            /* we don't have write access */
            if ( (pEntry->ObjAccess & ACCESS_WRITE) == 0 )
 8108c88:	69fb      	ldr	r3, [r7, #28]
 8108c8a:	889b      	ldrh	r3, [r3, #4]
 8108c8c:	f003 0338 	and.w	r3, r3, #56	@ 0x38
 8108c90:	2b00      	cmp	r3, #0
 8108c92:	d101      	bne.n	8108c98 <OBJ_Write+0xfc>
            {
                /* it is a read only entry */
                return ABORTIDX_READ_ONLY_ENTRY;
 8108c94:	2307      	movs	r3, #7
 8108c96:	e2ed      	b.n	8109274 <OBJ_Write+0x6d8>
            }
            else
            {
                /* we don't have write access in this state */
                return ABORTIDX_IN_THIS_STATE_DATA_CANNOT_BE_READ_OR_STORED;
 8108c98:	231a      	movs	r3, #26
 8108c9a:	e2eb      	b.n	8109274 <OBJ_Write+0x6d8>
        }
    }

    /* Subindex 0 shall be set to zero if a single PDO / PDO assign entry is written
    or a complete access without subindex0 is requested */
    if((subindex > 0) &&
 8108c9c:	7b7b      	ldrb	r3, [r7, #13]
 8108c9e:	2b00      	cmp	r3, #0
 8108ca0:	d024      	beq.n	8108cec <OBJ_Write+0x150>
 8108ca2:	89fb      	ldrh	r3, [r7, #14]
 8108ca4:	f641 420f 	movw	r2, #7183	@ 0x1c0f
 8108ca8:	4293      	cmp	r3, r2
 8108caa:	d904      	bls.n	8108cb6 <OBJ_Write+0x11a>
        (IS_PDO_ASSIGN(index) || IS_RX_PDO(index)|| IS_TX_PDO(index))
 8108cac:	89fb      	ldrh	r3, [r7, #14]
 8108cae:	f641 422f 	movw	r2, #7215	@ 0x1c2f
 8108cb2:	4293      	cmp	r3, r2
 8108cb4:	d90f      	bls.n	8108cd6 <OBJ_Write+0x13a>
 8108cb6:	89fb      	ldrh	r3, [r7, #14]
 8108cb8:	f5b3 5fb0 	cmp.w	r3, #5632	@ 0x1600
 8108cbc:	d303      	bcc.n	8108cc6 <OBJ_Write+0x12a>
 8108cbe:	89fb      	ldrh	r3, [r7, #14]
 8108cc0:	f5b3 5fc0 	cmp.w	r3, #6144	@ 0x1800
 8108cc4:	d307      	bcc.n	8108cd6 <OBJ_Write+0x13a>
 8108cc6:	89fb      	ldrh	r3, [r7, #14]
 8108cc8:	f5b3 5fd0 	cmp.w	r3, #6656	@ 0x1a00
 8108ccc:	d30e      	bcc.n	8108cec <OBJ_Write+0x150>
 8108cce:	89fb      	ldrh	r3, [r7, #14]
 8108cd0:	f5b3 5fe0 	cmp.w	r3, #7168	@ 0x1c00
 8108cd4:	d20a      	bcs.n	8108cec <OBJ_Write+0x150>
        )
    {
        /*Check if Subindex0 was cleared before*/
        UINT16 Subindex0 = (*(UINT16 *)pObjEntry->pVarPtr) & 0x00FF;
 8108cd6:	687b      	ldr	r3, [r7, #4]
 8108cd8:	699b      	ldr	r3, [r3, #24]
 8108cda:	881b      	ldrh	r3, [r3, #0]
 8108cdc:	b2db      	uxtb	r3, r3
 8108cde:	837b      	strh	r3, [r7, #26]
        if(Subindex0 != 0x00)
 8108ce0:	8b7b      	ldrh	r3, [r7, #26]
 8108ce2:	2b00      	cmp	r3, #0
 8108ce4:	d002      	beq.n	8108cec <OBJ_Write+0x150>
            bClearSubindex0Required = TRUE;
 8108ce6:	2301      	movs	r3, #1
 8108ce8:	f887 3033 	strb.w	r3, [r7, #51]	@ 0x33
    }

    if ( pObjEntry->Write != NULL )
 8108cec:	687b      	ldr	r3, [r7, #4]
 8108cee:	6a1b      	ldr	r3, [r3, #32]
 8108cf0:	2b00      	cmp	r3, #0
 8108cf2:	d00b      	beq.n	8108d0c <OBJ_Write+0x170>
    {
        /* Write function is defined, we call the object specific write function */
        return pObjEntry->Write(index, subindex, dataSize, pData, bCompleteAccess);
 8108cf4:	687b      	ldr	r3, [r7, #4]
 8108cf6:	6a1c      	ldr	r4, [r3, #32]
 8108cf8:	7b79      	ldrb	r1, [r7, #13]
 8108cfa:	89f8      	ldrh	r0, [r7, #14]
 8108cfc:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
 8108d00:	9300      	str	r3, [sp, #0]
 8108d02:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8108d04:	68ba      	ldr	r2, [r7, #8]
 8108d06:	47a0      	blx	r4
 8108d08:	4603      	mov	r3, r0
 8108d0a:	e2b3      	b.n	8109274 <OBJ_Write+0x6d8>
    }
    else
    {
        UINT8 bWritten = 0;
 8108d0c:	2300      	movs	r3, #0
 8108d0e:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        UINT8 result = ABORTIDX_READ_ONLY_ENTRY;
 8108d12:	2307      	movs	r3, #7
 8108d14:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e

/*ECATCHANGE_START(V5.11) ECAT*/
        if (dataSize == 0)
 8108d18:	68bb      	ldr	r3, [r7, #8]
 8108d1a:	2b00      	cmp	r3, #0
 8108d1c:	d101      	bne.n	8108d22 <OBJ_Write+0x186>
        {
           return 0; //no error
 8108d1e:	2300      	movs	r3, #0
 8108d20:	e2a8      	b.n	8109274 <OBJ_Write+0x6d8>
        }
/*ECATCHANGE_END(V5.11) ECAT*/

        /* we use the standard write function */
        for (i = subindex; i <= lastSubindex; i++)
 8108d22:	7b7b      	ldrb	r3, [r7, #13]
 8108d24:	86fb      	strh	r3, [r7, #54]	@ 0x36
 8108d26:	e298      	b.n	810925a <OBJ_Write+0x6be>
        {
            /* if only a single entry is requested, this loop will only be done once */
            UINT16 MBXMEM *pVarPtr = (UINT16 MBXMEM *) pObjEntry->pVarPtr;
 8108d28:	687b      	ldr	r3, [r7, #4]
 8108d2a:	699b      	ldr	r3, [r3, #24]
 8108d2c:	62bb      	str	r3, [r7, #40]	@ 0x28
            UINT16 bitOffset = 0;
 8108d2e:	2300      	movs	r3, #0
 8108d30:	833b      	strh	r3, [r7, #24]

            /* we get the corresponding entry description */
            pEntry = OBJ_GetEntryDesc(pObjEntry,(UINT8) i);
 8108d32:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 8108d34:	b2db      	uxtb	r3, r3
 8108d36:	4619      	mov	r1, r3
 8108d38:	6878      	ldr	r0, [r7, #4]
 8108d3a:	f7ff f9cf 	bl	81080dc <OBJ_GetEntryDesc>
 8108d3e:	61f8      	str	r0, [r7, #28]

            /*Get the bitOffset before check the access rights to calculate pData offset*/
            bitOffset = OBJ_GetEntryOffset((UINT8)i, pObjEntry);
 8108d40:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 8108d42:	b2db      	uxtb	r3, r3
 8108d44:	6879      	ldr	r1, [r7, #4]
 8108d46:	4618      	mov	r0, r3
 8108d48:	f7ff fa00 	bl	810814c <OBJ_GetEntryOffset>
 8108d4c:	4603      	mov	r3, r0
 8108d4e:	833b      	strh	r3, [r7, #24]

            /* we check if we have write access (bits 3-5 (PREOP, SAFEOP, OP) of ObjAccess)
               by comparing with the actual state (bits 1-3 (PREOP, SAFEOP, OP) of AL Status) */
            if ( ((UINT8)((pEntry->ObjAccess & ACCESS_WRITE) >> 2)) >= (nAlStatus & STATE_MASK) )
 8108d50:	69fb      	ldr	r3, [r7, #28]
 8108d52:	889b      	ldrh	r3, [r3, #4]
 8108d54:	109b      	asrs	r3, r3, #2
 8108d56:	b2db      	uxtb	r3, r3
 8108d58:	f003 020e 	and.w	r2, r3, #14
 8108d5c:	4b63      	ldr	r3, [pc, #396]	@ (8108eec <OBJ_Write+0x350>)
 8108d5e:	781b      	ldrb	r3, [r3, #0]
 8108d60:	f003 030f 	and.w	r3, r3, #15
 8108d64:	429a      	cmp	r2, r3
 8108d66:	f2c0 8251 	blt.w	810920c <OBJ_Write+0x670>
            {
                /* we have write access for this entry */
                if (i != 0)
 8108d6a:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 8108d6c:	2b00      	cmp	r3, #0
 8108d6e:	d006      	beq.n	8108d7e <OBJ_Write+0x1e2>
                {
                    /* we increment the variable pointer to the corresponding word address */
                    pVarPtr += (bitOffset >> 4);
 8108d70:	8b3b      	ldrh	r3, [r7, #24]
 8108d72:	091b      	lsrs	r3, r3, #4
 8108d74:	b29b      	uxth	r3, r3
 8108d76:	005b      	lsls	r3, r3, #1
 8108d78:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8108d7a:	4413      	add	r3, r2
 8108d7c:	62bb      	str	r3, [r7, #40]	@ 0x28
                }


                if ( i == subindex                                     /* requested entry */
 8108d7e:	7b7b      	ldrb	r3, [r7, #13]
 8108d80:	b29b      	uxth	r3, r3
 8108d82:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 8108d84:	429a      	cmp	r2, r3
 8108d86:	d00a      	beq.n	8108d9e <OBJ_Write+0x202>
                  || (bCompleteAccess && i >= subindex) )       /* complete access and entry should be read */
 8108d88:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
 8108d8c:	2b00      	cmp	r3, #0
 8108d8e:	f000 8261 	beq.w	8109254 <OBJ_Write+0x6b8>
 8108d92:	7b7b      	ldrb	r3, [r7, #13]
 8108d94:	b29b      	uxth	r3, r3
 8108d96:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 8108d98:	429a      	cmp	r2, r3
 8108d9a:	f0c0 825b 	bcc.w	8109254 <OBJ_Write+0x6b8>
                {
                    UINT16 bitMask;

                    /* we have to copy the entry */
                    if (i == 0 && objCode != OBJCODE_VAR)
 8108d9e:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 8108da0:	2b00      	cmp	r3, #0
 8108da2:	d115      	bne.n	8108dd0 <OBJ_Write+0x234>
 8108da4:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8108da8:	2b07      	cmp	r3, #7
 8108daa:	d011      	beq.n	8108dd0 <OBJ_Write+0x234>
                    {
                        /*check if the value for subindex0 is valid */
                        UINT8 NewSubindex0 = (UINT8) SWAPWORD(pData[0]);
 8108dac:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8108dae:	881b      	ldrh	r3, [r3, #0]
 8108db0:	75fb      	strb	r3, [r7, #23]
                        if(maxConfiguredSubindex < NewSubindex0)
 8108db2:	7dfb      	ldrb	r3, [r7, #23]
 8108db4:	b29b      	uxth	r3, r3
 8108db6:	8c3a      	ldrh	r2, [r7, #32]
 8108db8:	429a      	cmp	r2, r3
 8108dba:	d201      	bcs.n	8108dc0 <OBJ_Write+0x224>
                        {
                            return ABORTIDX_VALUE_TOO_GREAT;
 8108dbc:	2313      	movs	r3, #19
 8108dbe:	e259      	b.n	8109274 <OBJ_Write+0x6d8>
                        }

                        /* subindex 0 of an array or record shall be written */
/* ECATCHANGE_START(V5.11) SDO5*/
                        pVarPtr[0] = SWAPWORD(pData[0]);
 8108dc0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8108dc2:	881a      	ldrh	r2, [r3, #0]
 8108dc4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8108dc6:	801a      	strh	r2, [r3, #0]
/* ECATCHANGE_END(V5.11) SDO5*/
                        /* we increment the destination pointer by 2 because the subindex 0 will be
                           transmitted as UINT16 for a complete access */
                        pData++;
 8108dc8:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8108dca:	3302      	adds	r3, #2
 8108dcc:	64bb      	str	r3, [r7, #72]	@ 0x48
                    {
 8108dce:	e215      	b.n	81091fc <OBJ_Write+0x660>
                    }
                    else
                    {
                        UINT16 dataType = pEntry->DataType;
 8108dd0:	69fb      	ldr	r3, [r7, #28]
 8108dd2:	881b      	ldrh	r3, [r3, #0]
 8108dd4:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        if (pEntry->DataType >= 0x700)
 8108dd6:	69fb      	ldr	r3, [r7, #28]
 8108dd8:	881b      	ldrh	r3, [r3, #0]
 8108dda:	f5b3 6fe0 	cmp.w	r3, #1792	@ 0x700
 8108dde:	d315      	bcc.n	8108e0c <OBJ_Write+0x270>
                        {
                            /* the ENUM data types are defined from index 0x700 in this example
                               convert in standard data type for the write access */
                            if ( pEntry->BitLength <= 8 )
 8108de0:	69fb      	ldr	r3, [r7, #28]
 8108de2:	885b      	ldrh	r3, [r3, #2]
 8108de4:	2b08      	cmp	r3, #8
 8108de6:	d804      	bhi.n	8108df2 <OBJ_Write+0x256>
                                dataType = DEFTYPE_BIT1-1+pEntry->BitLength;
 8108de8:	69fb      	ldr	r3, [r7, #28]
 8108dea:	885b      	ldrh	r3, [r3, #2]
 8108dec:	332f      	adds	r3, #47	@ 0x2f
 8108dee:	84fb      	strh	r3, [r7, #38]	@ 0x26
 8108df0:	e00c      	b.n	8108e0c <OBJ_Write+0x270>
                            else if ( pEntry->BitLength == 16 )
 8108df2:	69fb      	ldr	r3, [r7, #28]
 8108df4:	885b      	ldrh	r3, [r3, #2]
 8108df6:	2b10      	cmp	r3, #16
 8108df8:	d102      	bne.n	8108e00 <OBJ_Write+0x264>
                                dataType = DEFTYPE_UNSIGNED16;
 8108dfa:	2306      	movs	r3, #6
 8108dfc:	84fb      	strh	r3, [r7, #38]	@ 0x26
 8108dfe:	e005      	b.n	8108e0c <OBJ_Write+0x270>
                            else if ( pEntry->BitLength == 32 )
 8108e00:	69fb      	ldr	r3, [r7, #28]
 8108e02:	885b      	ldrh	r3, [r3, #2]
 8108e04:	2b20      	cmp	r3, #32
 8108e06:	d101      	bne.n	8108e0c <OBJ_Write+0x270>
                                dataType = DEFTYPE_UNSIGNED32;
 8108e08:	2307      	movs	r3, #7
 8108e0a:	84fb      	strh	r3, [r7, #38]	@ 0x26
                        }

                        switch (dataType)
 8108e0c:	8cfb      	ldrh	r3, [r7, #38]	@ 0x26
 8108e0e:	f5b3 7f19 	cmp.w	r3, #612	@ 0x264
 8108e12:	f280 81f0 	bge.w	81091f6 <OBJ_Write+0x65a>
 8108e16:	f5b3 7f18 	cmp.w	r3, #608	@ 0x260
 8108e1a:	f280 81d1 	bge.w	81091c0 <OBJ_Write+0x624>
 8108e1e:	2b37      	cmp	r3, #55	@ 0x37
 8108e20:	f300 81e9 	bgt.w	81091f6 <OBJ_Write+0x65a>
 8108e24:	2b1e      	cmp	r3, #30
 8108e26:	da10      	bge.n	8108e4a <OBJ_Write+0x2ae>
 8108e28:	2b1b      	cmp	r3, #27
 8108e2a:	f300 81e4 	bgt.w	81091f6 <OBJ_Write+0x65a>
 8108e2e:	2b09      	cmp	r3, #9
 8108e30:	da2e      	bge.n	8108e90 <OBJ_Write+0x2f4>
 8108e32:	2b00      	cmp	r3, #0
 8108e34:	f000 8083 	beq.w	8108f3e <OBJ_Write+0x3a2>
 8108e38:	2b00      	cmp	r3, #0
 8108e3a:	f2c0 81dc 	blt.w	81091f6 <OBJ_Write+0x65a>
 8108e3e:	2b08      	cmp	r3, #8
 8108e40:	f300 81d9 	bgt.w	81091f6 <OBJ_Write+0x65a>
 8108e44:	2b00      	cmp	r3, #0
 8108e46:	dc59      	bgt.n	8108efc <OBJ_Write+0x360>
 8108e48:	e1d5      	b.n	81091f6 <OBJ_Write+0x65a>
 8108e4a:	3b1e      	subs	r3, #30
 8108e4c:	2201      	movs	r2, #1
 8108e4e:	fa02 f303 	lsl.w	r3, r2, r3
 8108e52:	4a27      	ldr	r2, [pc, #156]	@ (8108ef0 <OBJ_Write+0x354>)
 8108e54:	401a      	ands	r2, r3
 8108e56:	2a00      	cmp	r2, #0
 8108e58:	bf14      	ite	ne
 8108e5a:	2201      	movne	r2, #1
 8108e5c:	2200      	moveq	r2, #0
 8108e5e:	b2d2      	uxtb	r2, r2
 8108e60:	2a00      	cmp	r2, #0
 8108e62:	f040 808e 	bne.w	8108f82 <OBJ_Write+0x3e6>
 8108e66:	4a23      	ldr	r2, [pc, #140]	@ (8108ef4 <OBJ_Write+0x358>)
 8108e68:	401a      	ands	r2, r3
 8108e6a:	2a00      	cmp	r2, #0
 8108e6c:	bf14      	ite	ne
 8108e6e:	2201      	movne	r2, #1
 8108e70:	2200      	moveq	r2, #0
 8108e72:	b2d2      	uxtb	r2, r2
 8108e74:	2a00      	cmp	r2, #0
 8108e76:	f040 8142 	bne.w	81090fe <OBJ_Write+0x562>
 8108e7a:	4a1f      	ldr	r2, [pc, #124]	@ (8108ef8 <OBJ_Write+0x35c>)
 8108e7c:	401a      	ands	r2, r3
 8108e7e:	2a00      	cmp	r2, #0
 8108e80:	bf14      	ite	ne
 8108e82:	2301      	movne	r3, #1
 8108e84:	2300      	moveq	r3, #0
 8108e86:	b2db      	uxtb	r3, r3
 8108e88:	2b00      	cmp	r3, #0
 8108e8a:	f040 80d8 	bne.w	810903e <OBJ_Write+0x4a2>
 8108e8e:	e1b2      	b.n	81091f6 <OBJ_Write+0x65a>
 8108e90:	3b09      	subs	r3, #9
 8108e92:	2b12      	cmp	r3, #18
 8108e94:	f200 81af 	bhi.w	81091f6 <OBJ_Write+0x65a>
 8108e98:	a201      	add	r2, pc, #4	@ (adr r2, 8108ea0 <OBJ_Write+0x304>)
 8108e9a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8108e9e:	bf00      	nop
 8108ea0:	0810918b 	.word	0x0810918b
 8108ea4:	081091c1 	.word	0x081091c1
 8108ea8:	081091c1 	.word	0x081091c1
 8108eac:	081091f7 	.word	0x081091f7
 8108eb0:	081091f7 	.word	0x081091f7
 8108eb4:	081091f7 	.word	0x081091f7
 8108eb8:	081091f7 	.word	0x081091f7
 8108ebc:	081091f7 	.word	0x081091f7
 8108ec0:	0810914f 	.word	0x0810914f
 8108ec4:	081091f7 	.word	0x081091f7
 8108ec8:	081091f7 	.word	0x081091f7
 8108ecc:	081091f7 	.word	0x081091f7
 8108ed0:	0810914f 	.word	0x0810914f
 8108ed4:	081091f7 	.word	0x081091f7
 8108ed8:	081091f7 	.word	0x081091f7
 8108edc:	081091f7 	.word	0x081091f7
 8108ee0:	081091f7 	.word	0x081091f7
 8108ee4:	081091f7 	.word	0x081091f7
 8108ee8:	0810914f 	.word	0x0810914f
 8108eec:	1000085c 	.word	0x1000085c
 8108ef0:	03fc8001 	.word	0x03fc8001
 8108ef4:	00020004 	.word	0x00020004
 8108ef8:	00010002 	.word	0x00010002
 8108efc:	461a      	mov	r2, r3
 8108efe:	2301      	movs	r3, #1
 8108f00:	4093      	lsls	r3, r2
 8108f02:	f403 72c8 	and.w	r2, r3, #400	@ 0x190
 8108f06:	2a00      	cmp	r2, #0
 8108f08:	bf14      	ite	ne
 8108f0a:	2201      	movne	r2, #1
 8108f0c:	2200      	moveq	r2, #0
 8108f0e:	b2d2      	uxtb	r2, r2
 8108f10:	2a00      	cmp	r2, #0
 8108f12:	f040 80f4 	bne.w	81090fe <OBJ_Write+0x562>
 8108f16:	f003 0226 	and.w	r2, r3, #38	@ 0x26
 8108f1a:	2a00      	cmp	r2, #0
 8108f1c:	bf14      	ite	ne
 8108f1e:	2201      	movne	r2, #1
 8108f20:	2200      	moveq	r2, #0
 8108f22:	b2d2      	uxtb	r2, r2
 8108f24:	2a00      	cmp	r2, #0
 8108f26:	d12c      	bne.n	8108f82 <OBJ_Write+0x3e6>
 8108f28:	f003 0348 	and.w	r3, r3, #72	@ 0x48
 8108f2c:	2b00      	cmp	r3, #0
 8108f2e:	bf14      	ite	ne
 8108f30:	2301      	movne	r3, #1
 8108f32:	2300      	moveq	r3, #0
 8108f34:	b2db      	uxtb	r3, r3
 8108f36:	2b00      	cmp	r3, #0
 8108f38:	f040 8081 	bne.w	810903e <OBJ_Write+0x4a2>
 8108f3c:	e15b      	b.n	81091f6 <OBJ_Write+0x65a>
                        {
                        case DEFTYPE_NULL:
                            if(bCompleteAccess)
 8108f3e:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
 8108f42:	2b00      	cmp	r3, #0
 8108f44:	d01b      	beq.n	8108f7e <OBJ_Write+0x3e2>
                            {
                                /*Handle alignment entry*/
                                if (((pEntry->BitLength & 0xF) > 0)
 8108f46:	69fb      	ldr	r3, [r7, #28]
 8108f48:	885b      	ldrh	r3, [r3, #2]
 8108f4a:	f003 030f 	and.w	r3, r3, #15
 8108f4e:	2b00      	cmp	r3, #0
 8108f50:	dd0b      	ble.n	8108f6a <OBJ_Write+0x3ce>
                                    && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 8108f52:	69fb      	ldr	r3, [r7, #28]
 8108f54:	885a      	ldrh	r2, [r3, #2]
 8108f56:	8b3b      	ldrh	r3, [r7, #24]
 8108f58:	4413      	add	r3, r2
 8108f5a:	b29b      	uxth	r3, r3
 8108f5c:	f003 030f 	and.w	r3, r3, #15
 8108f60:	2b00      	cmp	r3, #0
 8108f62:	d102      	bne.n	8108f6a <OBJ_Write+0x3ce>
                                {
                                    /* we have reached the UINT16 border */
                                    pData++;
 8108f64:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8108f66:	3302      	adds	r3, #2
 8108f68:	64bb      	str	r3, [r7, #72]	@ 0x48
                                }

                                /*increment WORD offset*/
                                pData += ((pEntry->BitLength & 0xF0) >> 4);
 8108f6a:	69fb      	ldr	r3, [r7, #28]
 8108f6c:	885b      	ldrh	r3, [r3, #2]
 8108f6e:	111b      	asrs	r3, r3, #4
 8108f70:	f003 030f 	and.w	r3, r3, #15
 8108f74:	005b      	lsls	r3, r3, #1
 8108f76:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8108f78:	4413      	add	r3, r2
 8108f7a:	64bb      	str	r3, [r7, #72]	@ 0x48
                            }
                            else
                            {
                                return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
                            }
                            break;
 8108f7c:	e13e      	b.n	81091fc <OBJ_Write+0x660>
                                return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 8108f7e:	2318      	movs	r3, #24
 8108f80:	e178      	b.n	8109274 <OBJ_Write+0x6d8>
/*ECATCHANGE_START(V5.11) SDO9*/
                        case    DEFTYPE_BYTE :
/*ECATCHANGE_END(V5.11) SDO9*/
                        {
                            /* depending on the bitOffset we have to copy the Hi or the Lo-Byte */
                            UINT16 TmpValue = 0x0000;
 8108f82:	2300      	movs	r3, #0
 8108f84:	84bb      	strh	r3, [r7, #36]	@ 0x24

                            bitMask = cBitMask[pEntry->BitLength] << (bitOffset & 0x0F);
 8108f86:	69fb      	ldr	r3, [r7, #28]
 8108f88:	885b      	ldrh	r3, [r3, #2]
 8108f8a:	461a      	mov	r2, r3
 8108f8c:	4b9d      	ldr	r3, [pc, #628]	@ (8109204 <OBJ_Write+0x668>)
 8108f8e:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
 8108f92:	461a      	mov	r2, r3
 8108f94:	8b3b      	ldrh	r3, [r7, #24]
 8108f96:	f003 030f 	and.w	r3, r3, #15
 8108f9a:	fa02 f303 	lsl.w	r3, r2, r3
 8108f9e:	827b      	strh	r3, [r7, #18]

                            /*Swap object data (if required); all masks and offsets are defined for little endian format*/
                            TmpValue = SWAPWORD(pVarPtr[0]);
 8108fa0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8108fa2:	881b      	ldrh	r3, [r3, #0]
 8108fa4:	84bb      	strh	r3, [r7, #36]	@ 0x24

                            /*Clear corresponding bits*/
                            TmpValue &= ~bitMask;
 8108fa6:	f9b7 3012 	ldrsh.w	r3, [r7, #18]
 8108faa:	43db      	mvns	r3, r3
 8108fac:	b21a      	sxth	r2, r3
 8108fae:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	@ 0x24
 8108fb2:	4013      	ands	r3, r2
 8108fb4:	b21b      	sxth	r3, r3
 8108fb6:	84bb      	strh	r3, [r7, #36]	@ 0x24

/* ECATCHANGE_START(V5.11) SDO7*/
                            if (bCompleteAccess) 
 8108fb8:	f897 304c 	ldrb.w	r3, [r7, #76]	@ 0x4c
 8108fbc:	2b00      	cmp	r3, #0
 8108fbe:	d008      	beq.n	8108fd2 <OBJ_Write+0x436>
                            {
                                /*shifting is not required for Complete access because the bits are set to the correct offset by the master*/
                                TmpValue |= (SWAPWORD(pData[0]) & bitMask);
 8108fc0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8108fc2:	881a      	ldrh	r2, [r3, #0]
 8108fc4:	8a7b      	ldrh	r3, [r7, #18]
 8108fc6:	4013      	ands	r3, r2
 8108fc8:	b29a      	uxth	r2, r3
 8108fca:	8cbb      	ldrh	r3, [r7, #36]	@ 0x24
 8108fcc:	4313      	orrs	r3, r2
 8108fce:	84bb      	strh	r3, [r7, #36]	@ 0x24
 8108fd0:	e024      	b.n	810901c <OBJ_Write+0x480>
                            }
                            else
                            {
                                if((SWAPWORD(pData[0]) & ~cBitMask[pEntry->BitLength]))
 8108fd2:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8108fd4:	881b      	ldrh	r3, [r3, #0]
 8108fd6:	461a      	mov	r2, r3
 8108fd8:	69fb      	ldr	r3, [r7, #28]
 8108fda:	885b      	ldrh	r3, [r3, #2]
 8108fdc:	4619      	mov	r1, r3
 8108fde:	4b89      	ldr	r3, [pc, #548]	@ (8109204 <OBJ_Write+0x668>)
 8108fe0:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8108fe4:	43db      	mvns	r3, r3
 8108fe6:	4013      	ands	r3, r2
 8108fe8:	2b00      	cmp	r3, #0
 8108fea:	d001      	beq.n	8108ff0 <OBJ_Write+0x454>
                                {
                                    /*written value exceed entry range*/
                                    return ABORTIDX_VALUE_EXCEEDED;
 8108fec:	2312      	movs	r3, #18
 8108fee:	e141      	b.n	8109274 <OBJ_Write+0x6d8>
                                }
                                else
                                {
                                    /*Shift Bits to corresponding offset within the object memory*/
                                    TmpValue |= ((SWAPWORD(pData[0]) & cBitMask[pEntry->BitLength]) << (bitOffset & 0x0F));
 8108ff0:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8108ff2:	881a      	ldrh	r2, [r3, #0]
 8108ff4:	69fb      	ldr	r3, [r7, #28]
 8108ff6:	885b      	ldrh	r3, [r3, #2]
 8108ff8:	4619      	mov	r1, r3
 8108ffa:	4b82      	ldr	r3, [pc, #520]	@ (8109204 <OBJ_Write+0x668>)
 8108ffc:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8109000:	4013      	ands	r3, r2
 8109002:	b29b      	uxth	r3, r3
 8109004:	461a      	mov	r2, r3
 8109006:	8b3b      	ldrh	r3, [r7, #24]
 8109008:	f003 030f 	and.w	r3, r3, #15
 810900c:	fa02 f303 	lsl.w	r3, r2, r3
 8109010:	b21a      	sxth	r2, r3
 8109012:	f9b7 3024 	ldrsh.w	r3, [r7, #36]	@ 0x24
 8109016:	4313      	orrs	r3, r2
 8109018:	b21b      	sxth	r3, r3
 810901a:	84bb      	strh	r3, [r7, #36]	@ 0x24
                                }
                            }
/* ECATCHANGE_END(V5.11) SDO7*/

                            /*Swap written data to big endian format (if required)*/
                            pVarPtr[0] = SWAPWORD(TmpValue);
 810901c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810901e:	8cba      	ldrh	r2, [r7, #36]	@ 0x24
 8109020:	801a      	strh	r2, [r3, #0]

                            if ( ((bitOffset+pEntry->BitLength) & 0x0F) == 0 )
 8109022:	69fb      	ldr	r3, [r7, #28]
 8109024:	885a      	ldrh	r2, [r3, #2]
 8109026:	8b3b      	ldrh	r3, [r7, #24]
 8109028:	4413      	add	r3, r2
 810902a:	b29b      	uxth	r3, r3
 810902c:	f003 030f 	and.w	r3, r3, #15
 8109030:	2b00      	cmp	r3, #0
 8109032:	f040 80e2 	bne.w	81091fa <OBJ_Write+0x65e>
                                /* we have reached the UINT16 border */
                                pData++;
 8109036:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8109038:	3302      	adds	r3, #2
 810903a:	64bb      	str	r3, [r7, #72]	@ 0x48
                        }
                            break;
 810903c:	e0dd      	b.n	81091fa <OBJ_Write+0x65e>
                        case    DEFTYPE_BITARR16:
/*ECATCHANGE_START(V5.11) SDO9*/
                        case    DEFTYPE_WORD:
/*ECATCHANGE_END(V5.11) SDO9*/
/*ECATCHANGE_START(V5.11) SDO1*/
                            if(bitOffset & 0xF)
 810903e:	8b3b      	ldrh	r3, [r7, #24]
 8109040:	f003 030f 	and.w	r3, r3, #15
 8109044:	2b00      	cmp	r3, #0
 8109046:	d001      	beq.n	810904c <OBJ_Write+0x4b0>
                            {
                                /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                return ABORTIDX_UNSUPPORTED_ACCESS;
 8109048:	2305      	movs	r3, #5
 810904a:	e113      	b.n	8109274 <OBJ_Write+0x6d8>
/*ECATCHANGE_END(V5.11) SDO1*/

                            {
                            /* in this example the objects are defined in that way,
                            that the 16 bit type are always starting at an exact WORD offset */
                            UINT16 u16NewData = SWAPWORD(pData[0]);
 810904c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 810904e:	881b      	ldrh	r3, [r3, #0]
 8109050:	82bb      	strh	r3, [r7, #20]
                            if(bClearSubindex0Required && (pVarPtr[0] != u16NewData))
 8109052:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 8109056:	2b00      	cmp	r3, #0
 8109058:	d006      	beq.n	8109068 <OBJ_Write+0x4cc>
 810905a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810905c:	881b      	ldrh	r3, [r3, #0]
 810905e:	8aba      	ldrh	r2, [r7, #20]
 8109060:	429a      	cmp	r2, r3
 8109062:	d001      	beq.n	8109068 <OBJ_Write+0x4cc>
                            {
                                /* try to write new data when subindex0 shall be reset*/
                                return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
 8109064:	231c      	movs	r3, #28
 8109066:	e105      	b.n	8109274 <OBJ_Write+0x6d8>
                            }

                            /*check value if a new PDO assign entry should be written*/
                            if(IS_PDO_ASSIGN(index))  //PDO assign
 8109068:	89fb      	ldrh	r3, [r7, #14]
 810906a:	f641 420f 	movw	r2, #7183	@ 0x1c0f
 810906e:	4293      	cmp	r3, r2
 8109070:	d919      	bls.n	81090a6 <OBJ_Write+0x50a>
 8109072:	89fb      	ldrh	r3, [r7, #14]
 8109074:	f641 422f 	movw	r2, #7215	@ 0x1c2f
 8109078:	4293      	cmp	r3, r2
 810907a:	d814      	bhi.n	81090a6 <OBJ_Write+0x50a>
                            {
                                if (!IS_RX_PDO(u16NewData) && !IS_TX_PDO(u16NewData) && (u16NewData != 0)) //check if the new assign entry value is valid
 810907c:	8abb      	ldrh	r3, [r7, #20]
 810907e:	f5b3 5fb0 	cmp.w	r3, #5632	@ 0x1600
 8109082:	d303      	bcc.n	810908c <OBJ_Write+0x4f0>
 8109084:	8abb      	ldrh	r3, [r7, #20]
 8109086:	f5b3 5fc0 	cmp.w	r3, #6144	@ 0x1800
 810908a:	d30c      	bcc.n	81090a6 <OBJ_Write+0x50a>
 810908c:	8abb      	ldrh	r3, [r7, #20]
 810908e:	f5b3 5fd0 	cmp.w	r3, #6656	@ 0x1a00
 8109092:	d303      	bcc.n	810909c <OBJ_Write+0x500>
 8109094:	8abb      	ldrh	r3, [r7, #20]
 8109096:	f5b3 5fe0 	cmp.w	r3, #7168	@ 0x1c00
 810909a:	d304      	bcc.n	81090a6 <OBJ_Write+0x50a>
 810909c:	8abb      	ldrh	r3, [r7, #20]
 810909e:	2b00      	cmp	r3, #0
 81090a0:	d001      	beq.n	81090a6 <OBJ_Write+0x50a>
                                {
                                    return ABORTIDX_VALUE_EXCEEDED;
 81090a2:	2312      	movs	r3, #18
 81090a4:	e0e6      	b.n	8109274 <OBJ_Write+0x6d8>
                                }
                            }

                            if((index == 0x1C32 || index == 0x1C33) && (i == 1))
 81090a6:	89fb      	ldrh	r3, [r7, #14]
 81090a8:	f641 4232 	movw	r2, #7218	@ 0x1c32
 81090ac:	4293      	cmp	r3, r2
 81090ae:	d004      	beq.n	81090ba <OBJ_Write+0x51e>
 81090b0:	89fb      	ldrh	r3, [r7, #14]
 81090b2:	f641 4233 	movw	r2, #7219	@ 0x1c33
 81090b6:	4293      	cmp	r3, r2
 81090b8:	d11a      	bne.n	81090f0 <OBJ_Write+0x554>
 81090ba:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 81090bc:	2b01      	cmp	r3, #1
 81090be:	d117      	bne.n	81090f0 <OBJ_Write+0x554>
                            {
                                /* The Synchronisation type (0x1C3x.1) was written by the user => the Sync type will not be calculated based on the register settings (if they don't match an error will be returned P_2_S)*/
                                if(pVarPtr[0] != u16NewData)
 81090c0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 81090c2:	881b      	ldrh	r3, [r3, #0]
 81090c4:	8aba      	ldrh	r2, [r7, #20]
 81090c6:	429a      	cmp	r2, r3
 81090c8:	d00f      	beq.n	81090ea <OBJ_Write+0x54e>
                                {
                                    result = CheckSyncTypeValue(index,u16NewData);
 81090ca:	8aba      	ldrh	r2, [r7, #20]
 81090cc:	89fb      	ldrh	r3, [r7, #14]
 81090ce:	4611      	mov	r1, r2
 81090d0:	4618      	mov	r0, r3
 81090d2:	f7ff f921 	bl	8108318 <CheckSyncTypeValue>
 81090d6:	4603      	mov	r3, r0
 81090d8:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e

                                    if(result != 0)
 81090dc:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 81090e0:	2b00      	cmp	r3, #0
 81090e2:	d002      	beq.n	81090ea <OBJ_Write+0x54e>
                                        return result;
 81090e4:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 81090e8:	e0c4      	b.n	8109274 <OBJ_Write+0x6d8>
                                }

                                /* The user may force to current Sync Mode for that reason the flag has also to be set if the same value was written */
                                bSyncSetByUser = TRUE;
 81090ea:	4b47      	ldr	r3, [pc, #284]	@ (8109208 <OBJ_Write+0x66c>)
 81090ec:	2201      	movs	r2, #1
 81090ee:	701a      	strb	r2, [r3, #0]
                            }

                            pVarPtr[0] = u16NewData;
 81090f0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 81090f2:	8aba      	ldrh	r2, [r7, #20]
 81090f4:	801a      	strh	r2, [r3, #0]
                            pData++;
 81090f6:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 81090f8:	3302      	adds	r3, #2
 81090fa:	64bb      	str	r3, [r7, #72]	@ 0x48
                            }
                            break;
 81090fc:	e07e      	b.n	81091fc <OBJ_Write+0x660>
                        case    DEFTYPE_BITARR32:
/*ECATCHANGE_START(V5.11) SDO9*/
                        case    DEFTYPE_DWORD:
/*ECATCHANGE_END(V5.11) SDO9*/
/*ECATCHANGE_START(V5.11) SDO1*/
                            if(bitOffset & 0xF)
 81090fe:	8b3b      	ldrh	r3, [r7, #24]
 8109100:	f003 030f 	and.w	r3, r3, #15
 8109104:	2b00      	cmp	r3, #0
 8109106:	d001      	beq.n	810910c <OBJ_Write+0x570>
                            {
                                /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                return ABORTIDX_UNSUPPORTED_ACCESS;
 8109108:	2305      	movs	r3, #5
 810910a:	e0b3      	b.n	8109274 <OBJ_Write+0x6d8>
/*ECATCHANGE_END(V5.11) SDO1*/
                            {

                            /* in this example the objects are defined in that way,
                               that the 32 bit type are always starting at an exact WORD offset */
                            if(bClearSubindex0Required && 
 810910c:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 8109110:	2b00      	cmp	r3, #0
 8109112:	d00f      	beq.n	8109134 <OBJ_Write+0x598>
                                ((pVarPtr[0] != pData[0])
 8109114:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109116:	881a      	ldrh	r2, [r3, #0]
 8109118:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 810911a:	881b      	ldrh	r3, [r3, #0]
                            if(bClearSubindex0Required && 
 810911c:	429a      	cmp	r2, r3
 810911e:	d107      	bne.n	8109130 <OBJ_Write+0x594>
                                || (pVarPtr[1] != pData[1])))
 8109120:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109122:	3302      	adds	r3, #2
 8109124:	881a      	ldrh	r2, [r3, #0]
 8109126:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8109128:	3302      	adds	r3, #2
 810912a:	881b      	ldrh	r3, [r3, #0]
 810912c:	429a      	cmp	r2, r3
 810912e:	d001      	beq.n	8109134 <OBJ_Write+0x598>
                            {
                                /* try to write new data when subindex0 shall be reset*/
                                return ABORTIDX_ENTRY_CANT_BE_WRITTEN_SI0_NOT_0;
 8109130:	231c      	movs	r3, #28
 8109132:	e09f      	b.n	8109274 <OBJ_Write+0x6d8>
                            }

                            pVarPtr[0] = pData[0];
 8109134:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8109136:	881a      	ldrh	r2, [r3, #0]
 8109138:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810913a:	801a      	strh	r2, [r3, #0]
                            pVarPtr[1] = pData[1];
 810913c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810913e:	3302      	adds	r3, #2
 8109140:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8109142:	8852      	ldrh	r2, [r2, #2]
 8109144:	801a      	strh	r2, [r3, #0]
                            pData += 2;
 8109146:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8109148:	3304      	adds	r3, #4
 810914a:	64bb      	str	r3, [r7, #72]	@ 0x48
                            }
                            break;
 810914c:	e056      	b.n	81091fc <OBJ_Write+0x660>
                        case    DEFTYPE_REAL64:
                        case 	DEFTYPE_INTEGER64:
                        case    DEFTYPE_UNSIGNED64:
/*ECATCHANGE_START(V5.11) SDO1*/
                            if(bitOffset & 0xF)
 810914e:	8b3b      	ldrh	r3, [r7, #24]
 8109150:	f003 030f 	and.w	r3, r3, #15
 8109154:	2b00      	cmp	r3, #0
 8109156:	d001      	beq.n	810915c <OBJ_Write+0x5c0>
                            {
                                /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                return ABORTIDX_UNSUPPORTED_ACCESS;
 8109158:	2305      	movs	r3, #5
 810915a:	e08b      	b.n	8109274 <OBJ_Write+0x6d8>
                            }
/*ECATCHANGE_END(V5.11) SDO1*/
                            /* in this example the objects are defined in that way,
                               that the 64 bit type are always starting at an exact WORD offset */
                            pVarPtr[0] = pData[0];
 810915c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 810915e:	881a      	ldrh	r2, [r3, #0]
 8109160:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109162:	801a      	strh	r2, [r3, #0]
                            pVarPtr[1] = pData[1];
 8109164:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109166:	3302      	adds	r3, #2
 8109168:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 810916a:	8852      	ldrh	r2, [r2, #2]
 810916c:	801a      	strh	r2, [r3, #0]
                            pVarPtr[2] = pData[2];
 810916e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109170:	3304      	adds	r3, #4
 8109172:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 8109174:	8892      	ldrh	r2, [r2, #4]
 8109176:	801a      	strh	r2, [r3, #0]
                            pVarPtr[3] = pData[3];
 8109178:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810917a:	3306      	adds	r3, #6
 810917c:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 810917e:	88d2      	ldrh	r2, [r2, #6]
 8109180:	801a      	strh	r2, [r3, #0]
                            pData += 4;
 8109182:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8109184:	3308      	adds	r3, #8
 8109186:	64bb      	str	r3, [r7, #72]	@ 0x48
                            break;
 8109188:	e038      	b.n	81091fc <OBJ_Write+0x660>
                        case    DEFTYPE_VISIBLESTRING:
/*ECATCHANGE_START(V5.11) SDO1*/
                            if(bitOffset & 0xF)
 810918a:	8b3b      	ldrh	r3, [r7, #24]
 810918c:	f003 030f 	and.w	r3, r3, #15
 8109190:	2b00      	cmp	r3, #0
 8109192:	d001      	beq.n	8109198 <OBJ_Write+0x5fc>
                            {
                                /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                return ABORTIDX_UNSUPPORTED_ACCESS;
 8109194:	2305      	movs	r3, #5
 8109196:	e06d      	b.n	8109274 <OBJ_Write+0x6d8>
                            }
/*ECATCHANGE_END(V5.11) SDO1*/

                            OBJTOMBXSTRCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
 8109198:	69fb      	ldr	r3, [r7, #28]
 810919a:	885b      	ldrh	r3, [r3, #2]
 810919c:	3307      	adds	r3, #7
 810919e:	10db      	asrs	r3, r3, #3
 81091a0:	461a      	mov	r2, r3
 81091a2:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 81091a4:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 81091a6:	f006 fe28 	bl	810fdfa <memcpy>

/*ECATCHANGE_START(V5.11) SDO2*/
                            pData += BIT2WORD((pEntry->BitLength)& ~0xF);
 81091aa:	69fb      	ldr	r3, [r7, #28]
 81091ac:	885b      	ldrh	r3, [r3, #2]
 81091ae:	f023 030f 	bic.w	r3, r3, #15
 81091b2:	330f      	adds	r3, #15
 81091b4:	111b      	asrs	r3, r3, #4
 81091b6:	005b      	lsls	r3, r3, #1
 81091b8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 81091ba:	4413      	add	r3, r2
 81091bc:	64bb      	str	r3, [r7, #72]	@ 0x48
/*ECATCHANGE_END(V5.11) SDO2*/
                            break;
 81091be:	e01d      	b.n	81091fc <OBJ_Write+0x660>
                            case DEFTYPE_ARRAY_OF_SINT :
                            case DEFTYPE_ARRAY_OF_DINT :
                            case DEFTYPE_ARRAY_OF_UDINT:
/*ECATCHANGE_END(V5.11) SDO9*/
/*ECATCHANGE_START(V5.11) SDO1*/
                            if(bitOffset & 0xF)
 81091c0:	8b3b      	ldrh	r3, [r7, #24]
 81091c2:	f003 030f 	and.w	r3, r3, #15
 81091c6:	2b00      	cmp	r3, #0
 81091c8:	d001      	beq.n	81091ce <OBJ_Write+0x632>
                            {
                                /* return an error in case of an odd word offset (to support 16bit data type on odd word addresses an object specific access function need to be implemented and register in the object dictionary, see SSC Application Note)*/
                                return ABORTIDX_UNSUPPORTED_ACCESS;
 81091ca:	2305      	movs	r3, #5
 81091cc:	e052      	b.n	8109274 <OBJ_Write+0x6d8>
                            }
/*ECATCHANGE_END(V5.11) SDO1*/

                            /* in this example the objects are defined in that way,
                               that the other types are always starting at an even byte offset */
                            OBJTOMBXMEMCPY(pVarPtr, pData, BIT2BYTE(pEntry->BitLength));
 81091ce:	69fb      	ldr	r3, [r7, #28]
 81091d0:	885b      	ldrh	r3, [r3, #2]
 81091d2:	3307      	adds	r3, #7
 81091d4:	10db      	asrs	r3, r3, #3
 81091d6:	461a      	mov	r2, r3
 81091d8:	6cb9      	ldr	r1, [r7, #72]	@ 0x48
 81091da:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 81091dc:	f006 fe0d 	bl	810fdfa <memcpy>
/*ECATCHANGE_START(V5.11) SDO2*/
                            pData += BIT2WORD((pEntry->BitLength) & ~0xF);
 81091e0:	69fb      	ldr	r3, [r7, #28]
 81091e2:	885b      	ldrh	r3, [r3, #2]
 81091e4:	f023 030f 	bic.w	r3, r3, #15
 81091e8:	330f      	adds	r3, #15
 81091ea:	111b      	asrs	r3, r3, #4
 81091ec:	005b      	lsls	r3, r3, #1
 81091ee:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 81091f0:	4413      	add	r3, r2
 81091f2:	64bb      	str	r3, [r7, #72]	@ 0x48
/*ECATCHANGE_END(V5.11) SDO2*/

                            break;
 81091f4:	e002      	b.n	81091fc <OBJ_Write+0x660>
                        default:
                            /* other data types are not supported from this example */
                            return ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 81091f6:	2318      	movs	r3, #24
 81091f8:	e03c      	b.n	8109274 <OBJ_Write+0x6d8>
                            break;
 81091fa:	bf00      	nop
                        }
                    }

                    /* set flag */
                    bWritten = 1;
 81091fc:	2301      	movs	r3, #1
 81091fe:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
 8109202:	e027      	b.n	8109254 <OBJ_Write+0x6b8>
 8109204:	08111280 	.word	0x08111280
 8109208:	10000b01 	.word	0x10000b01

                }
            }
            else
            {
                if(i == 0)
 810920c:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 810920e:	2b00      	cmp	r3, #0
 8109210:	d103      	bne.n	810921a <OBJ_Write+0x67e>
                {
                    /* For SubIndex0 16Bit are reserved even if the BitLength is 8 */
                    pData++;
 8109212:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 8109214:	3302      	adds	r3, #2
 8109216:	64bb      	str	r3, [r7, #72]	@ 0x48
 8109218:	e019      	b.n	810924e <OBJ_Write+0x6b2>
                }
                else
                {
                    /*Handle Bit/Byte Offset*/
                    if (((pEntry->BitLength & 0xF) > 0)
 810921a:	69fb      	ldr	r3, [r7, #28]
 810921c:	885b      	ldrh	r3, [r3, #2]
 810921e:	f003 030f 	and.w	r3, r3, #15
 8109222:	2b00      	cmp	r3, #0
 8109224:	dd0b      	ble.n	810923e <OBJ_Write+0x6a2>
                        && (((bitOffset + pEntry->BitLength) & 0x0F) == 0 ))
 8109226:	69fb      	ldr	r3, [r7, #28]
 8109228:	885a      	ldrh	r2, [r3, #2]
 810922a:	8b3b      	ldrh	r3, [r7, #24]
 810922c:	4413      	add	r3, r2
 810922e:	b29b      	uxth	r3, r3
 8109230:	f003 030f 	and.w	r3, r3, #15
 8109234:	2b00      	cmp	r3, #0
 8109236:	d102      	bne.n	810923e <OBJ_Write+0x6a2>
                    {
                        /* we have reached the UINT16 border */
                        pData++;
 8109238:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 810923a:	3302      	adds	r3, #2
 810923c:	64bb      	str	r3, [r7, #72]	@ 0x48
                    }

                    /*increment WORD offset*/
/*ECATCHANGE_START(V5.11) SDO9*/
                    pData += ((pEntry->BitLength & 0xFFF0) >> 4);
 810923e:	69fb      	ldr	r3, [r7, #28]
 8109240:	885b      	ldrh	r3, [r3, #2]
 8109242:	091b      	lsrs	r3, r3, #4
 8109244:	b29b      	uxth	r3, r3
 8109246:	005b      	lsls	r3, r3, #1
 8109248:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 810924a:	4413      	add	r3, r2
 810924c:	64bb      	str	r3, [r7, #72]	@ 0x48
/*ECATCHANGE_END(V5.11) SDO9*/
                }
                /*If no other entry was written this result will be returned*/
                result = ABORTIDX_DATA_CANNOT_BE_READ_OR_STORED;
 810924e:	2318      	movs	r3, #24
 8109250:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
        for (i = subindex; i <= lastSubindex; i++)
 8109254:	8efb      	ldrh	r3, [r7, #54]	@ 0x36
 8109256:	3301      	adds	r3, #1
 8109258:	86fb      	strh	r3, [r7, #54]	@ 0x36
 810925a:	8efa      	ldrh	r2, [r7, #54]	@ 0x36
 810925c:	8e3b      	ldrh	r3, [r7, #48]	@ 0x30
 810925e:	429a      	cmp	r2, r3
 8109260:	f67f ad62 	bls.w	8108d28 <OBJ_Write+0x18c>
            }
        }

        if (bWritten == 0)
 8109264:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8109268:	2b00      	cmp	r3, #0
 810926a:	d102      	bne.n	8109272 <OBJ_Write+0x6d6>
            /* we didn't write anything, so we have to return the stored error code */
            return result;
 810926c:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8109270:	e000      	b.n	8109274 <OBJ_Write+0x6d8>
    }

    return 0;
 8109272:	2300      	movs	r3, #0
}
 8109274:	4618      	mov	r0, r3
 8109276:	373c      	adds	r7, #60	@ 0x3c
 8109278:	46bd      	mov	sp, r7
 810927a:	bd90      	pop	{r4, r7, pc}

0810927c <SdoDownloadSegmentInd>:
            the data will be written to the object dictionary. The
            function sends a response by itself.
*////////////////////////////////////////////////////////////////////////////////////////

static UINT8 SdoDownloadSegmentInd( TDOWNLOADSDOSEGREQMBX MBXMEM * pSdoInd )
{
 810927c:	b5b0      	push	{r4, r5, r7, lr}
 810927e:	b088      	sub	sp, #32
 8109280:	af02      	add	r7, sp, #8
 8109282:	6078      	str	r0, [r7, #4]
    UINT8 abort = 0;
 8109284:	2300      	movs	r3, #0
 8109286:	75fb      	strb	r3, [r7, #23]
    UINT32 bytesToSave = 0;
 8109288:	2300      	movs	r3, #0
 810928a:	613b      	str	r3, [r7, #16]

    if ( (pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle )
 810928c:	687b      	ldr	r3, [r7, #4]
 810928e:	891b      	ldrh	r3, [r3, #8]
 8109290:	f003 0310 	and.w	r3, r3, #16
 8109294:	4a95      	ldr	r2, [pc, #596]	@ (81094ec <SdoDownloadSegmentInd+0x270>)
 8109296:	7812      	ldrb	r2, [r2, #0]
 8109298:	4293      	cmp	r3, r2
 810929a:	d102      	bne.n	81092a2 <SdoDownloadSegmentInd+0x26>
    {
        /* toggle bit has not toggled... */
        abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
 810929c:	2301      	movs	r3, #1
 810929e:	75fb      	strb	r3, [r7, #23]
 81092a0:	e157      	b.n	8109552 <SdoDownloadSegmentInd+0x2d6>
    }
    else
    {
        /* maxData contains the maximum data to be received with a SDO-DownloadSegment */
        UINT16 maxData =    u16ReceiveMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
 81092a2:	4b93      	ldr	r3, [pc, #588]	@ (81094f0 <SdoDownloadSegmentInd+0x274>)
 81092a4:	881b      	ldrh	r3, [r3, #0]
 81092a6:	3b09      	subs	r3, #9
 81092a8:	81bb      	strh	r3, [r7, #12]
        /* the new toggle bit is stored in bSdoSegLastToggle */
        bSdoSegLastToggle = pSdoInd->SdoHeader.SegHeader & SEGHEADER_TOGGLE;
 81092aa:	687b      	ldr	r3, [r7, #4]
 81092ac:	891b      	ldrh	r3, [r3, #8]
 81092ae:	b2db      	uxtb	r3, r3
 81092b0:	f003 0310 	and.w	r3, r3, #16
 81092b4:	b2da      	uxtb	r2, r3
 81092b6:	4b8d      	ldr	r3, [pc, #564]	@ (81094ec <SdoDownloadSegmentInd+0x270>)
 81092b8:	701a      	strb	r2, [r3, #0]

        /* a SDO-Download Segment is only allowed if a SDO-Download Request was received before,
           in that case a buffer for the received data was allocated in SDOS_SdoInd before */
        if ( pSdoSegData )
 81092ba:	4b8e      	ldr	r3, [pc, #568]	@ (81094f4 <SdoDownloadSegmentInd+0x278>)
 81092bc:	681b      	ldr	r3, [r3, #0]
 81092be:	2b00      	cmp	r3, #0
 81092c0:	f000 8145 	beq.w	810954e <SdoDownloadSegmentInd+0x2d2>
        {
            /* bytesToSave contains the remaining data with this and maybe the following
               SDO-Download Segment services */
            bytesToSave = nSdoSegCompleteSize - nSdoSegBytesToHandle;
 81092c4:	4b8c      	ldr	r3, [pc, #560]	@ (81094f8 <SdoDownloadSegmentInd+0x27c>)
 81092c6:	681a      	ldr	r2, [r3, #0]
 81092c8:	4b8c      	ldr	r3, [pc, #560]	@ (81094fc <SdoDownloadSegmentInd+0x280>)
 81092ca:	681b      	ldr	r3, [r3, #0]
 81092cc:	1ad3      	subs	r3, r2, r3
 81092ce:	613b      	str	r3, [r7, #16]

            if ( pSdoInd->SdoHeader.SegHeader & SEGHEADER_NOMOREFOLLOWS )
 81092d0:	687b      	ldr	r3, [r7, #4]
 81092d2:	891b      	ldrh	r3, [r3, #8]
 81092d4:	f003 0301 	and.w	r3, r3, #1
 81092d8:	2b00      	cmp	r3, #0
 81092da:	d02a      	beq.n	8109332 <SdoDownloadSegmentInd+0xb6>
            {
                /* the last segment is received, check if the length of the remaining data is the
                   same as the length of the received data */
                if ( bytesToSave <= maxData )
 81092dc:	89bb      	ldrh	r3, [r7, #12]
 81092de:	693a      	ldr	r2, [r7, #16]
 81092e0:	429a      	cmp	r2, r3
 81092e2:	d823      	bhi.n	810932c <SdoDownloadSegmentInd+0xb0>
                {
/* ECATCHANGE_START(V5.11) ECAT7*/
                    UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
 81092e4:	687b      	ldr	r3, [r7, #4]
 81092e6:	881b      	ldrh	r3, [r3, #0]
 81092e8:	817b      	strh	r3, [r7, #10]

                    /* for the check it is distinguished if the remaining bytes are less than 8 (in that
                       case 7 data bytes were sent and the SDO-Download Segment header contains the information
                        how much bytes are valid (CAN-compatibility)), otherwise the length has to match exactly
                        and the SDO-Download Segment-Headerbyte is ignored */
                    if (((bytesToSave <= (UINT32)(mbxSize - SEGMENT_NORM_HEADER_SIZE))
 81092ea:	897b      	ldrh	r3, [r7, #10]
 81092ec:	3b03      	subs	r3, #3
 81092ee:	461a      	mov	r2, r3
 81092f0:	693b      	ldr	r3, [r7, #16]
 81092f2:	4293      	cmp	r3, r2
 81092f4:	d80a      	bhi.n	810930c <SdoDownloadSegmentInd+0x90>
                         &&( bytesToSave == ((UINT16) (MIN_SEGMENTED_DATA - ((pSdoInd->SdoHeader.SegHeader & SEGHEADER_SEGDATASIZE) >> SEGHEADERSHIFT_SEGDATASIZE))) )
 81092f6:	687b      	ldr	r3, [r7, #4]
 81092f8:	891b      	ldrh	r3, [r3, #8]
 81092fa:	105b      	asrs	r3, r3, #1
 81092fc:	b29b      	uxth	r3, r3
 81092fe:	43db      	mvns	r3, r3
 8109300:	b29b      	uxth	r3, r3
 8109302:	f003 0307 	and.w	r3, r3, #7
 8109306:	693a      	ldr	r2, [r7, #16]
 8109308:	429a      	cmp	r2, r3
 810930a:	d008      	beq.n	810931e <SdoDownloadSegmentInd+0xa2>
                          )
                        ||( ( bytesToSave > MIN_SEGMENTED_DATA )
 810930c:	693b      	ldr	r3, [r7, #16]
 810930e:	2b07      	cmp	r3, #7
 8109310:	d909      	bls.n	8109326 <SdoDownloadSegmentInd+0xaa>
                        && (bytesToSave == (mbxSize - SEGMENT_NORM_HEADER_SIZE))
 8109312:	897b      	ldrh	r3, [r7, #10]
 8109314:	3b03      	subs	r3, #3
 8109316:	461a      	mov	r2, r3
 8109318:	693b      	ldr	r3, [r7, #16]
 810931a:	4293      	cmp	r3, r2
 810931c:	d103      	bne.n	8109326 <SdoDownloadSegmentInd+0xaa>
                        ) )
/* ECATCHANGE_END(V5.11) ECAT7*/
                    {
                        /* length is correct */
                        bSdoSegFollows = FALSE;
 810931e:	4b78      	ldr	r3, [pc, #480]	@ (8109500 <SdoDownloadSegmentInd+0x284>)
 8109320:	2200      	movs	r2, #0
 8109322:	701a      	strb	r2, [r3, #0]
 8109324:	e011      	b.n	810934a <SdoDownloadSegmentInd+0xce>
                    }
                    else
                        abort = ABORTIDX_PARAM_LENGTH_ERROR;
 8109326:	230e      	movs	r3, #14
 8109328:	75fb      	strb	r3, [r7, #23]
 810932a:	e00e      	b.n	810934a <SdoDownloadSegmentInd+0xce>
                }
                else
                    abort = ABORTIDX_PARAM_LENGTH_ERROR;
 810932c:	230e      	movs	r3, #14
 810932e:	75fb      	strb	r3, [r7, #23]
 8109330:	e00b      	b.n	810934a <SdoDownloadSegmentInd+0xce>
            }
            else
            {
                /* its not the last segment */
                bSdoSegFollows = TRUE;
 8109332:	4b73      	ldr	r3, [pc, #460]	@ (8109500 <SdoDownloadSegmentInd+0x284>)
 8109334:	2201      	movs	r2, #1
 8109336:	701a      	strb	r2, [r3, #0]
                /* we have to check if we expect less bytes than the maximum size which can be send with a single
                   SDO Download Segment */
                if ( bytesToSave <= maxData )
 8109338:	89bb      	ldrh	r3, [r7, #12]
 810933a:	693a      	ldr	r2, [r7, #16]
 810933c:	429a      	cmp	r2, r3
 810933e:	d802      	bhi.n	8109346 <SdoDownloadSegmentInd+0xca>
                    abort = ABORTIDX_PARAM_LENGTH_ERROR;
 8109340:	230e      	movs	r3, #14
 8109342:	75fb      	strb	r3, [r7, #23]
 8109344:	e001      	b.n	810934a <SdoDownloadSegmentInd+0xce>
                else
                    /* length is okay, bytesToSave contains the data size to be copied */
                    bytesToSave = maxData;
 8109346:	89bb      	ldrh	r3, [r7, #12]
 8109348:	613b      	str	r3, [r7, #16]
            }

            if ( abort == 0 )
 810934a:	7dfb      	ldrb	r3, [r7, #23]
 810934c:	2b00      	cmp	r3, #0
 810934e:	f040 8100 	bne.w	8109552 <SdoDownloadSegmentInd+0x2d6>
            {
                /* the received data is copied in the buffer */
                UINT16 i = 0;
 8109352:	2300      	movs	r3, #0
 8109354:	81fb      	strh	r3, [r7, #14]

                if ((nSdoSegBytesToHandle & 0x1) == 0x01)
 8109356:	4b69      	ldr	r3, [pc, #420]	@ (81094fc <SdoDownloadSegmentInd+0x280>)
 8109358:	681b      	ldr	r3, [r3, #0]
 810935a:	f003 0301 	and.w	r3, r3, #1
 810935e:	2b00      	cmp	r3, #0
 8109360:	d03c      	beq.n	81093dc <SdoDownloadSegmentInd+0x160>
                {	
                    // Data0 will be copied to an odd address of pSdoSegData, Data1 to an even address (Segment 2, 4, ...)
                    // Read Data0
                    pSdoSegData[(nSdoSegBytesToHandle >> 1)] &= ~SEGHDATA_MASK;
 8109362:	4b64      	ldr	r3, [pc, #400]	@ (81094f4 <SdoDownloadSegmentInd+0x278>)
 8109364:	681a      	ldr	r2, [r3, #0]
 8109366:	4b65      	ldr	r3, [pc, #404]	@ (81094fc <SdoDownloadSegmentInd+0x280>)
 8109368:	681b      	ldr	r3, [r3, #0]
 810936a:	085b      	lsrs	r3, r3, #1
 810936c:	005b      	lsls	r3, r3, #1
 810936e:	4413      	add	r3, r2
 8109370:	8819      	ldrh	r1, [r3, #0]
 8109372:	4b60      	ldr	r3, [pc, #384]	@ (81094f4 <SdoDownloadSegmentInd+0x278>)
 8109374:	681a      	ldr	r2, [r3, #0]
 8109376:	4b61      	ldr	r3, [pc, #388]	@ (81094fc <SdoDownloadSegmentInd+0x280>)
 8109378:	681b      	ldr	r3, [r3, #0]
 810937a:	085b      	lsrs	r3, r3, #1
 810937c:	005b      	lsls	r3, r3, #1
 810937e:	4413      	add	r3, r2
 8109380:	b2ca      	uxtb	r2, r1
 8109382:	b292      	uxth	r2, r2
 8109384:	801a      	strh	r2, [r3, #0]
                    pSdoSegData[(nSdoSegBytesToHandle >> 1)] |= (pSdoInd->SdoHeader.SegHeader & SEGHDATA_MASK);
 8109386:	4b5b      	ldr	r3, [pc, #364]	@ (81094f4 <SdoDownloadSegmentInd+0x278>)
 8109388:	681a      	ldr	r2, [r3, #0]
 810938a:	4b5c      	ldr	r3, [pc, #368]	@ (81094fc <SdoDownloadSegmentInd+0x280>)
 810938c:	681b      	ldr	r3, [r3, #0]
 810938e:	085b      	lsrs	r3, r3, #1
 8109390:	005b      	lsls	r3, r3, #1
 8109392:	4413      	add	r3, r2
 8109394:	881b      	ldrh	r3, [r3, #0]
 8109396:	b21a      	sxth	r2, r3
 8109398:	687b      	ldr	r3, [r7, #4]
 810939a:	891b      	ldrh	r3, [r3, #8]
 810939c:	b21b      	sxth	r3, r3
 810939e:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 81093a2:	b21b      	sxth	r3, r3
 81093a4:	4313      	orrs	r3, r2
 81093a6:	b219      	sxth	r1, r3
 81093a8:	4b52      	ldr	r3, [pc, #328]	@ (81094f4 <SdoDownloadSegmentInd+0x278>)
 81093aa:	681a      	ldr	r2, [r3, #0]
 81093ac:	4b53      	ldr	r3, [pc, #332]	@ (81094fc <SdoDownloadSegmentInd+0x280>)
 81093ae:	681b      	ldr	r3, [r3, #0]
 81093b0:	085b      	lsrs	r3, r3, #1
 81093b2:	005b      	lsls	r3, r3, #1
 81093b4:	4413      	add	r3, r2
 81093b6:	b28a      	uxth	r2, r1
 81093b8:	801a      	strh	r2, [r3, #0]
                    // Copy Data1 - DataN
                    MBXMEMCPY(&pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1],pSdoInd->SdoHeader.Data, bytesToSave - 1 );
 81093ba:	4b4e      	ldr	r3, [pc, #312]	@ (81094f4 <SdoDownloadSegmentInd+0x278>)
 81093bc:	681a      	ldr	r2, [r3, #0]
 81093be:	4b4f      	ldr	r3, [pc, #316]	@ (81094fc <SdoDownloadSegmentInd+0x280>)
 81093c0:	681b      	ldr	r3, [r3, #0]
 81093c2:	085b      	lsrs	r3, r3, #1
 81093c4:	3301      	adds	r3, #1
 81093c6:	005b      	lsls	r3, r3, #1
 81093c8:	18d0      	adds	r0, r2, r3
 81093ca:	687b      	ldr	r3, [r7, #4]
 81093cc:	f103 010a 	add.w	r1, r3, #10
 81093d0:	693b      	ldr	r3, [r7, #16]
 81093d2:	3b01      	subs	r3, #1
 81093d4:	461a      	mov	r2, r3
 81093d6:	f006 fd10 	bl	810fdfa <memcpy>
 81093da:	e03e      	b.n	810945a <SdoDownloadSegmentInd+0x1de>
                }
                else
                {	// Data0 will be copied to an even address of pSdoSegData, Data1 to an odd address (Segment 1, 3,...)
                    // Read Data0 and Data1
                    pSdoSegData[( nSdoSegBytesToHandle >> 1)] = ((pSdoInd->SdoHeader.SegHeader >> SEGDATASHIFT) &~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[0] << 8) & SEGHDATA_MASK);
 81093dc:	687b      	ldr	r3, [r7, #4]
 81093de:	891b      	ldrh	r3, [r3, #8]
 81093e0:	0a1b      	lsrs	r3, r3, #8
 81093e2:	b29b      	uxth	r3, r3
 81093e4:	b21a      	sxth	r2, r3
 81093e6:	687b      	ldr	r3, [r7, #4]
 81093e8:	895b      	ldrh	r3, [r3, #10]
 81093ea:	021b      	lsls	r3, r3, #8
 81093ec:	b21b      	sxth	r3, r3
 81093ee:	4313      	orrs	r3, r2
 81093f0:	b219      	sxth	r1, r3
 81093f2:	4b40      	ldr	r3, [pc, #256]	@ (81094f4 <SdoDownloadSegmentInd+0x278>)
 81093f4:	681a      	ldr	r2, [r3, #0]
 81093f6:	4b41      	ldr	r3, [pc, #260]	@ (81094fc <SdoDownloadSegmentInd+0x280>)
 81093f8:	681b      	ldr	r3, [r3, #0]
 81093fa:	085b      	lsrs	r3, r3, #1
 81093fc:	005b      	lsls	r3, r3, #1
 81093fe:	4413      	add	r3, r2
 8109400:	b28a      	uxth	r2, r1
 8109402:	801a      	strh	r2, [r3, #0]
                    
                    // Copy Data2 - DataN
                    for (i = 1; i <((bytesToSave + 1)  >> 1); i++)
 8109404:	2301      	movs	r3, #1
 8109406:	81fb      	strh	r3, [r7, #14]
 8109408:	e021      	b.n	810944e <SdoDownloadSegmentInd+0x1d2>
                    {
                        pSdoSegData[(nSdoSegBytesToHandle >> 1) + i] = ((pSdoInd->SdoHeader.Data[i - 1] >> SEGDATASHIFT) & ~SEGHDATA_MASK) | ((pSdoInd->SdoHeader.Data[i] << 8) & SEGHDATA_MASK);
 810940a:	89fb      	ldrh	r3, [r7, #14]
 810940c:	3b01      	subs	r3, #1
 810940e:	687a      	ldr	r2, [r7, #4]
 8109410:	3304      	adds	r3, #4
 8109412:	005b      	lsls	r3, r3, #1
 8109414:	4413      	add	r3, r2
 8109416:	885b      	ldrh	r3, [r3, #2]
 8109418:	0a1b      	lsrs	r3, r3, #8
 810941a:	b29b      	uxth	r3, r3
 810941c:	b21a      	sxth	r2, r3
 810941e:	89fb      	ldrh	r3, [r7, #14]
 8109420:	6879      	ldr	r1, [r7, #4]
 8109422:	3304      	adds	r3, #4
 8109424:	005b      	lsls	r3, r3, #1
 8109426:	440b      	add	r3, r1
 8109428:	885b      	ldrh	r3, [r3, #2]
 810942a:	021b      	lsls	r3, r3, #8
 810942c:	b21b      	sxth	r3, r3
 810942e:	4313      	orrs	r3, r2
 8109430:	b218      	sxth	r0, r3
 8109432:	4b30      	ldr	r3, [pc, #192]	@ (81094f4 <SdoDownloadSegmentInd+0x278>)
 8109434:	681a      	ldr	r2, [r3, #0]
 8109436:	4b31      	ldr	r3, [pc, #196]	@ (81094fc <SdoDownloadSegmentInd+0x280>)
 8109438:	681b      	ldr	r3, [r3, #0]
 810943a:	0859      	lsrs	r1, r3, #1
 810943c:	89fb      	ldrh	r3, [r7, #14]
 810943e:	440b      	add	r3, r1
 8109440:	005b      	lsls	r3, r3, #1
 8109442:	4413      	add	r3, r2
 8109444:	b282      	uxth	r2, r0
 8109446:	801a      	strh	r2, [r3, #0]
                    for (i = 1; i <((bytesToSave + 1)  >> 1); i++)
 8109448:	89fb      	ldrh	r3, [r7, #14]
 810944a:	3301      	adds	r3, #1
 810944c:	81fb      	strh	r3, [r7, #14]
 810944e:	89fa      	ldrh	r2, [r7, #14]
 8109450:	693b      	ldr	r3, [r7, #16]
 8109452:	3301      	adds	r3, #1
 8109454:	085b      	lsrs	r3, r3, #1
 8109456:	429a      	cmp	r2, r3
 8109458:	d3d7      	bcc.n	810940a <SdoDownloadSegmentInd+0x18e>
                            // (If bytesToSave is odd, one byte too much is copied. But, that is not a problem.)
                    }
                }

                if ( bSdoSegFollows == FALSE    )
 810945a:	4b29      	ldr	r3, [pc, #164]	@ (8109500 <SdoDownloadSegmentInd+0x284>)
 810945c:	781b      	ldrb	r3, [r3, #0]
 810945e:	2b00      	cmp	r3, #0
 8109460:	d177      	bne.n	8109552 <SdoDownloadSegmentInd+0x2d6>
                {
                    /* it was the last segment, OBJ_Write will called to make the Write-operation */
                    abort = OBJ_Write( nSdoSegIndex, nSdoSegSubindex, nSdoSegCompleteSize, pSdoSegObjEntry, (UINT16 MBXMEM *) pSdoSegData, bSdoSegAccess );
 8109462:	4b28      	ldr	r3, [pc, #160]	@ (8109504 <SdoDownloadSegmentInd+0x288>)
 8109464:	8818      	ldrh	r0, [r3, #0]
 8109466:	4b28      	ldr	r3, [pc, #160]	@ (8109508 <SdoDownloadSegmentInd+0x28c>)
 8109468:	7819      	ldrb	r1, [r3, #0]
 810946a:	4b23      	ldr	r3, [pc, #140]	@ (81094f8 <SdoDownloadSegmentInd+0x27c>)
 810946c:	681c      	ldr	r4, [r3, #0]
 810946e:	4b27      	ldr	r3, [pc, #156]	@ (810950c <SdoDownloadSegmentInd+0x290>)
 8109470:	681d      	ldr	r5, [r3, #0]
 8109472:	4b20      	ldr	r3, [pc, #128]	@ (81094f4 <SdoDownloadSegmentInd+0x278>)
 8109474:	681b      	ldr	r3, [r3, #0]
 8109476:	4a26      	ldr	r2, [pc, #152]	@ (8109510 <SdoDownloadSegmentInd+0x294>)
 8109478:	7812      	ldrb	r2, [r2, #0]
 810947a:	9201      	str	r2, [sp, #4]
 810947c:	9300      	str	r3, [sp, #0]
 810947e:	462b      	mov	r3, r5
 8109480:	4622      	mov	r2, r4
 8109482:	f7ff fb8b 	bl	8108b9c <OBJ_Write>
 8109486:	4603      	mov	r3, r0
 8109488:	75fb      	strb	r3, [r7, #23]
                    if ( abort == ABORTIDX_WORKING )
 810948a:	7dfb      	ldrb	r3, [r7, #23]
 810948c:	2bff      	cmp	r3, #255	@ 0xff
 810948e:	d155      	bne.n	810953c <SdoDownloadSegmentInd+0x2c0>
                    {
                        /* the application generates the SDO-Response later on by calling SDOS_SdoRes (only possible if object access function pointer is defined) */
                        u8PendingSdo = SDO_PENDING_SEG_WRITE;
 8109490:	4b20      	ldr	r3, [pc, #128]	@ (8109514 <SdoDownloadSegmentInd+0x298>)
 8109492:	2202      	movs	r2, #2
 8109494:	701a      	strb	r2, [r3, #0]
                        bStoreCompleteAccess = bSdoSegAccess;
 8109496:	4b1e      	ldr	r3, [pc, #120]	@ (8109510 <SdoDownloadSegmentInd+0x294>)
 8109498:	781a      	ldrb	r2, [r3, #0]
 810949a:	4b1f      	ldr	r3, [pc, #124]	@ (8109518 <SdoDownloadSegmentInd+0x29c>)
 810949c:	701a      	strb	r2, [r3, #0]
                        u8StoreSubindex = nSdoSegSubindex;
 810949e:	4b1a      	ldr	r3, [pc, #104]	@ (8109508 <SdoDownloadSegmentInd+0x28c>)
 81094a0:	781a      	ldrb	r2, [r3, #0]
 81094a2:	4b1e      	ldr	r3, [pc, #120]	@ (810951c <SdoDownloadSegmentInd+0x2a0>)
 81094a4:	701a      	strb	r2, [r3, #0]
                        u16StoreIndex = nSdoSegIndex;
 81094a6:	4b17      	ldr	r3, [pc, #92]	@ (8109504 <SdoDownloadSegmentInd+0x288>)
 81094a8:	881a      	ldrh	r2, [r3, #0]
 81094aa:	4b1d      	ldr	r3, [pc, #116]	@ (8109520 <SdoDownloadSegmentInd+0x2a4>)
 81094ac:	801a      	strh	r2, [r3, #0]
                        u32StoreDataSize = nSdoSegCompleteSize;
 81094ae:	4b12      	ldr	r3, [pc, #72]	@ (81094f8 <SdoDownloadSegmentInd+0x27c>)
 81094b0:	681b      	ldr	r3, [r3, #0]
 81094b2:	4a1c      	ldr	r2, [pc, #112]	@ (8109524 <SdoDownloadSegmentInd+0x2a8>)
 81094b4:	6013      	str	r3, [r2, #0]
                        pStoreData = pSdoSegData;
 81094b6:	4b0f      	ldr	r3, [pc, #60]	@ (81094f4 <SdoDownloadSegmentInd+0x278>)
 81094b8:	681b      	ldr	r3, [r3, #0]
 81094ba:	4a1b      	ldr	r2, [pc, #108]	@ (8109528 <SdoDownloadSegmentInd+0x2ac>)
 81094bc:	6013      	str	r3, [r2, #0]

                        pSdoPendFunc = pSdoSegObjEntry->Write;
 81094be:	4b13      	ldr	r3, [pc, #76]	@ (810950c <SdoDownloadSegmentInd+0x290>)
 81094c0:	681b      	ldr	r3, [r3, #0]
 81094c2:	6a1b      	ldr	r3, [r3, #32]
 81094c4:	4a19      	ldr	r2, [pc, #100]	@ (810952c <SdoDownloadSegmentInd+0x2b0>)
 81094c6:	6013      	str	r3, [r2, #0]

                        bSdoInWork = TRUE;
 81094c8:	4b19      	ldr	r3, [pc, #100]	@ (8109530 <SdoDownloadSegmentInd+0x2b4>)
 81094ca:	2201      	movs	r2, #1
 81094cc:	701a      	strb	r2, [r3, #0]
                        pSdoResStored = (TINITSDOMBX MBXMEM *) pSdoInd;
 81094ce:	4a19      	ldr	r2, [pc, #100]	@ (8109534 <SdoDownloadSegmentInd+0x2b8>)
 81094d0:	687b      	ldr	r3, [r7, #4]
 81094d2:	6013      	str	r3, [r2, #0]

                        bSdoSegFollows = FALSE;
 81094d4:	4b0a      	ldr	r3, [pc, #40]	@ (8109500 <SdoDownloadSegmentInd+0x284>)
 81094d6:	2200      	movs	r2, #0
 81094d8:	701a      	strb	r2, [r3, #0]
                        nSdoSegService    = 0;
 81094da:	4b17      	ldr	r3, [pc, #92]	@ (8109538 <SdoDownloadSegmentInd+0x2bc>)
 81094dc:	2200      	movs	r2, #0
 81094de:	701a      	strb	r2, [r3, #0]
                        nSdoSegBytesToHandle = 0;
 81094e0:	4b06      	ldr	r3, [pc, #24]	@ (81094fc <SdoDownloadSegmentInd+0x280>)
 81094e2:	2200      	movs	r2, #0
 81094e4:	601a      	str	r2, [r3, #0]

                        return ABORTIDX_WORKING;
 81094e6:	23ff      	movs	r3, #255	@ 0xff
 81094e8:	e07a      	b.n	81095e0 <SdoDownloadSegmentInd+0x364>
 81094ea:	bf00      	nop
 81094ec:	10000bd0 	.word	0x10000bd0
 81094f0:	1000087c 	.word	0x1000087c
 81094f4:	10000bb4 	.word	0x10000bb4
 81094f8:	10000bd4 	.word	0x10000bd4
 81094fc:	10000bcc 	.word	0x10000bcc
 8109500:	10000bc6 	.word	0x10000bc6
 8109504:	10000bc8 	.word	0x10000bc8
 8109508:	10000bca 	.word	0x10000bca
 810950c:	10000bd8 	.word	0x10000bd8
 8109510:	10000bc7 	.word	0x10000bc7
 8109514:	10000b90 	.word	0x10000b90
 8109518:	10000b91 	.word	0x10000b91
 810951c:	10000b92 	.word	0x10000b92
 8109520:	10000b94 	.word	0x10000b94
 8109524:	10000b98 	.word	0x10000b98
 8109528:	10000b9c 	.word	0x10000b9c
 810952c:	10000ba0 	.word	0x10000ba0
 8109530:	10000bc4 	.word	0x10000bc4
 8109534:	10000bc0 	.word	0x10000bc0
 8109538:	10000bc5 	.word	0x10000bc5
                    }
                    else
                    {
                        /* the allocated buffer can be released */
                        FREEMEM( (UINT16 VARMEM *) pSdoSegData );
 810953c:	4b2a      	ldr	r3, [pc, #168]	@ (81095e8 <SdoDownloadSegmentInd+0x36c>)
 810953e:	681b      	ldr	r3, [r3, #0]
 8109540:	4618      	mov	r0, r3
 8109542:	f006 f9dd 	bl	810f900 <free>
                        pSdoSegData = NULL;
 8109546:	4b28      	ldr	r3, [pc, #160]	@ (81095e8 <SdoDownloadSegmentInd+0x36c>)
 8109548:	2200      	movs	r2, #0
 810954a:	601a      	str	r2, [r3, #0]
 810954c:	e001      	b.n	8109552 <SdoDownloadSegmentInd+0x2d6>
                }
            }
        }
        else
        {
            abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
 810954e:	2303      	movs	r3, #3
 8109550:	75fb      	strb	r3, [r7, #23]
        }
    }

    if ( abort == 0)
 8109552:	7dfb      	ldrb	r3, [r7, #23]
 8109554:	2b00      	cmp	r3, #0
 8109556:	d12d      	bne.n	81095b4 <SdoDownloadSegmentInd+0x338>
    {
        /* send the SDO Download Segment response */
        pSdoInd->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
 8109558:	687b      	ldr	r3, [r7, #4]
 810955a:	220a      	movs	r2, #10
 810955c:	801a      	strh	r2, [r3, #0]
        pSdoInd->CoeHeader &= ~COEHEADER_COESERVICEMASK;
 810955e:	687b      	ldr	r3, [r7, #4]
 8109560:	88db      	ldrh	r3, [r3, #6]
 8109562:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8109566:	b29a      	uxth	r2, r3
 8109568:	687b      	ldr	r3, [r7, #4]
 810956a:	80da      	strh	r2, [r3, #6]
        pSdoInd->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
 810956c:	687b      	ldr	r3, [r7, #4]
 810956e:	88db      	ldrh	r3, [r3, #6]
 8109570:	f443 5340 	orr.w	r3, r3, #12288	@ 0x3000
 8109574:	b29a      	uxth	r2, r3
 8109576:	687b      	ldr	r3, [r7, #4]
 8109578:	80da      	strh	r2, [r3, #6]
        /* the SDO Download Segment header depends if it was the last segment or not */
        if ( bSdoSegLastToggle )
 810957a:	4b1c      	ldr	r3, [pc, #112]	@ (81095ec <SdoDownloadSegmentInd+0x370>)
 810957c:	781b      	ldrb	r3, [r3, #0]
 810957e:	2b00      	cmp	r3, #0
 8109580:	d003      	beq.n	810958a <SdoDownloadSegmentInd+0x30e>
        {
           pSdoInd->SdoHeader.SegHeader        = SDOSERVICE_DOWNLOADSEGMENTRES|SEGHEADER_TOGGLE;
 8109582:	687b      	ldr	r3, [r7, #4]
 8109584:	2230      	movs	r2, #48	@ 0x30
 8109586:	811a      	strh	r2, [r3, #8]
 8109588:	e002      	b.n	8109590 <SdoDownloadSegmentInd+0x314>
        }
        else
           pSdoInd->SdoHeader.SegHeader        = SDOSERVICE_DOWNLOADSEGMENTRES;
 810958a:	687b      	ldr	r3, [r7, #4]
 810958c:	2220      	movs	r2, #32
 810958e:	811a      	strh	r2, [r3, #8]

        if ( bSdoSegFollows == TRUE )
 8109590:	4b17      	ldr	r3, [pc, #92]	@ (81095f0 <SdoDownloadSegmentInd+0x374>)
 8109592:	781b      	ldrb	r3, [r3, #0]
 8109594:	2b01      	cmp	r3, #1
 8109596:	d106      	bne.n	81095a6 <SdoDownloadSegmentInd+0x32a>
        {
            /* segments are still expected, nSdoSegBytesToHandle contains the number of received data bytes */
            nSdoSegBytesToHandle += bytesToSave;
 8109598:	4b16      	ldr	r3, [pc, #88]	@ (81095f4 <SdoDownloadSegmentInd+0x378>)
 810959a:	681a      	ldr	r2, [r3, #0]
 810959c:	693b      	ldr	r3, [r7, #16]
 810959e:	4413      	add	r3, r2
 81095a0:	4a14      	ldr	r2, [pc, #80]	@ (81095f4 <SdoDownloadSegmentInd+0x378>)
 81095a2:	6013      	str	r3, [r2, #0]
 81095a4:	e01b      	b.n	81095de <SdoDownloadSegmentInd+0x362>
        }
        else
        {
            /* the last segment was received, the variables are reset */
            nSdoSegBytesToHandle = 0;
 81095a6:	4b13      	ldr	r3, [pc, #76]	@ (81095f4 <SdoDownloadSegmentInd+0x378>)
 81095a8:	2200      	movs	r2, #0
 81095aa:	601a      	str	r2, [r3, #0]
            nSdoSegService    = 0;
 81095ac:	4b12      	ldr	r3, [pc, #72]	@ (81095f8 <SdoDownloadSegmentInd+0x37c>)
 81095ae:	2200      	movs	r2, #0
 81095b0:	701a      	strb	r2, [r3, #0]
 81095b2:	e014      	b.n	81095de <SdoDownloadSegmentInd+0x362>
        }
    }
    else 
    {
        /* the Abort-Response will be sent in SDOS_SdoInd*/
        bSdoSegFollows = FALSE;
 81095b4:	4b0e      	ldr	r3, [pc, #56]	@ (81095f0 <SdoDownloadSegmentInd+0x374>)
 81095b6:	2200      	movs	r2, #0
 81095b8:	701a      	strb	r2, [r3, #0]
        nSdoSegService    = 0;
 81095ba:	4b0f      	ldr	r3, [pc, #60]	@ (81095f8 <SdoDownloadSegmentInd+0x37c>)
 81095bc:	2200      	movs	r2, #0
 81095be:	701a      	strb	r2, [r3, #0]
        if (pSdoSegData)
 81095c0:	4b09      	ldr	r3, [pc, #36]	@ (81095e8 <SdoDownloadSegmentInd+0x36c>)
 81095c2:	681b      	ldr	r3, [r3, #0]
 81095c4:	2b00      	cmp	r3, #0
 81095c6:	d007      	beq.n	81095d8 <SdoDownloadSegmentInd+0x35c>
        {
            /* the memory has to be released if it is not released before.
            In case of AbortIdx_Working the buffer will be freed in SDOS_SdoRes*/
            FREEMEM( (UINT16 VARMEM *) pSdoSegData );
 81095c8:	4b07      	ldr	r3, [pc, #28]	@ (81095e8 <SdoDownloadSegmentInd+0x36c>)
 81095ca:	681b      	ldr	r3, [r3, #0]
 81095cc:	4618      	mov	r0, r3
 81095ce:	f006 f997 	bl	810f900 <free>
            pSdoSegData = NULL;
 81095d2:	4b05      	ldr	r3, [pc, #20]	@ (81095e8 <SdoDownloadSegmentInd+0x36c>)
 81095d4:	2200      	movs	r2, #0
 81095d6:	601a      	str	r2, [r3, #0]
        }

        nSdoSegBytesToHandle = 0;
 81095d8:	4b06      	ldr	r3, [pc, #24]	@ (81095f4 <SdoDownloadSegmentInd+0x378>)
 81095da:	2200      	movs	r2, #0
 81095dc:	601a      	str	r2, [r3, #0]
    }

    return abort;
 81095de:	7dfb      	ldrb	r3, [r7, #23]
}
 81095e0:	4618      	mov	r0, r3
 81095e2:	3718      	adds	r7, #24
 81095e4:	46bd      	mov	sp, r7
 81095e6:	bdb0      	pop	{r4, r5, r7, pc}
 81095e8:	10000bb4 	.word	0x10000bb4
 81095ec:	10000bd0 	.word	0x10000bd0
 81095f0:	10000bc6 	.word	0x10000bc6
 81095f4:	10000bcc 	.word	0x10000bcc
 81095f8:	10000bc5 	.word	0x10000bc5

081095fc <SdoUploadSegmentInd>:
            is received from the master. It prepares and operates the
            response and sends it by itself.
*////////////////////////////////////////////////////////////////////////////////////////

static UINT8 SdoUploadSegmentInd( TUPLOADSDOSEGREQMBX MBXMEM * pSdoInd )
{
 81095fc:	b580      	push	{r7, lr}
 81095fe:	b088      	sub	sp, #32
 8109600:	af00      	add	r7, sp, #0
 8109602:	6078      	str	r0, [r7, #4]
    UINT8 abort = 0;
 8109604:	2300      	movs	r3, #0
 8109606:	77fb      	strb	r3, [r7, #31]
    TUPLOADSDOSEGRESMBX MBXMEM * pSdoSegRes = (TUPLOADSDOSEGRESMBX MBXMEM *)pSdoInd;
 8109608:	687b      	ldr	r3, [r7, #4]
 810960a:	613b      	str	r3, [r7, #16]

   if ( (pSdoInd->SegHeader & SEGHEADER_TOGGLE) == bSdoSegLastToggle )
 810960c:	687b      	ldr	r3, [r7, #4]
 810960e:	7a1b      	ldrb	r3, [r3, #8]
 8109610:	f003 0310 	and.w	r3, r3, #16
 8109614:	4a83      	ldr	r2, [pc, #524]	@ (8109824 <SdoUploadSegmentInd+0x228>)
 8109616:	7812      	ldrb	r2, [r2, #0]
 8109618:	4293      	cmp	r3, r2
 810961a:	d102      	bne.n	8109622 <SdoUploadSegmentInd+0x26>
    {
        /* toggle bit has not toggled... */
        abort = ABORTIDX_TOGGLE_BIT_NOT_CHANGED;
 810961c:	2301      	movs	r3, #1
 810961e:	77fb      	strb	r3, [r7, #31]
 8109620:	e0fa      	b.n	8109818 <SdoUploadSegmentInd+0x21c>
    }
    else
    {
        /* maxData contains the maximum data to be sent with a SDO-Upload Segment response */
         
        UINT32 size = 0;
 8109622:	2300      	movs	r3, #0
 8109624:	61bb      	str	r3, [r7, #24]
        UINT16 maxData;
        {
            maxData =    u16SendMbxSize - MBX_HEADER_SIZE - SEGMENT_NORM_HEADER_SIZE;
 8109626:	4b80      	ldr	r3, [pc, #512]	@ (8109828 <SdoUploadSegmentInd+0x22c>)
 8109628:	881b      	ldrh	r3, [r3, #0]
 810962a:	3b09      	subs	r3, #9
 810962c:	81fb      	strh	r3, [r7, #14]
        }

        /* the new toggle bit is stored in bSdoSegLastToggle */
        bSdoSegLastToggle = pSdoInd->SegHeader & SEGHEADER_TOGGLE;
 810962e:	687b      	ldr	r3, [r7, #4]
 8109630:	7a1b      	ldrb	r3, [r3, #8]
 8109632:	f003 0310 	and.w	r3, r3, #16
 8109636:	b2da      	uxtb	r2, r3
 8109638:	4b7a      	ldr	r3, [pc, #488]	@ (8109824 <SdoUploadSegmentInd+0x228>)
 810963a:	701a      	strb	r2, [r3, #0]

        if ( nSdoSegCompleteSize < (nSdoSegBytesToHandle + maxData) )
 810963c:	89fa      	ldrh	r2, [r7, #14]
 810963e:	4b7b      	ldr	r3, [pc, #492]	@ (810982c <SdoUploadSegmentInd+0x230>)
 8109640:	681b      	ldr	r3, [r3, #0]
 8109642:	441a      	add	r2, r3
 8109644:	4b7a      	ldr	r3, [pc, #488]	@ (8109830 <SdoUploadSegmentInd+0x234>)
 8109646:	681b      	ldr	r3, [r3, #0]
 8109648:	429a      	cmp	r2, r3
 810964a:	d909      	bls.n	8109660 <SdoUploadSegmentInd+0x64>
        {
            /* the remaining data can be send with one SDO Upload Segment response,
               size contains the data to be copied */
            size = nSdoSegCompleteSize - nSdoSegBytesToHandle;
 810964c:	4b78      	ldr	r3, [pc, #480]	@ (8109830 <SdoUploadSegmentInd+0x234>)
 810964e:	681a      	ldr	r2, [r3, #0]
 8109650:	4b76      	ldr	r3, [pc, #472]	@ (810982c <SdoUploadSegmentInd+0x230>)
 8109652:	681b      	ldr	r3, [r3, #0]
 8109654:	1ad3      	subs	r3, r2, r3
 8109656:	61bb      	str	r3, [r7, #24]
            bSdoSegFollows = FALSE;
 8109658:	4b76      	ldr	r3, [pc, #472]	@ (8109834 <SdoUploadSegmentInd+0x238>)
 810965a:	2200      	movs	r2, #0
 810965c:	701a      	strb	r2, [r3, #0]
 810965e:	e004      	b.n	810966a <SdoUploadSegmentInd+0x6e>
        }
        else
        {
            /* more data will follow, size contains the data to be copied */
            size = maxData;
 8109660:	89fb      	ldrh	r3, [r7, #14]
 8109662:	61bb      	str	r3, [r7, #24]
            bSdoSegFollows = TRUE;
 8109664:	4b73      	ldr	r3, [pc, #460]	@ (8109834 <SdoUploadSegmentInd+0x238>)
 8109666:	2201      	movs	r2, #1
 8109668:	701a      	strb	r2, [r3, #0]
        }

        /* copy the object data in the SDO Upload segment response */
        // Clear Data0
        pSdoSegRes->SdoHeader.SegHeader &= ~SEGHDATA_MASK;
 810966a:	693b      	ldr	r3, [r7, #16]
 810966c:	891b      	ldrh	r3, [r3, #8]
 810966e:	b2db      	uxtb	r3, r3
 8109670:	b29a      	uxth	r2, r3
 8109672:	693b      	ldr	r3, [r7, #16]
 8109674:	811a      	strh	r2, [r3, #8]
        if ((nSdoSegBytesToHandle & 0x1) == 0x01)
 8109676:	4b6d      	ldr	r3, [pc, #436]	@ (810982c <SdoUploadSegmentInd+0x230>)
 8109678:	681b      	ldr	r3, [r3, #0]
 810967a:	f003 0301 	and.w	r3, r3, #1
 810967e:	2b00      	cmp	r3, #0
 8109680:	d024      	beq.n	81096cc <SdoUploadSegmentInd+0xd0>
        {	// Data starts at odd byte number (Segment 2, 4,...): Data0 is at high byte, Data1 lies at an even address
            // Write Data0
            pSdoSegRes->SdoHeader.SegHeader |= (pSdoSegData[(nSdoSegBytesToHandle >> 1)] & SEGHDATA_MASK);
 8109682:	693b      	ldr	r3, [r7, #16]
 8109684:	891b      	ldrh	r3, [r3, #8]
 8109686:	b21a      	sxth	r2, r3
 8109688:	4b6b      	ldr	r3, [pc, #428]	@ (8109838 <SdoUploadSegmentInd+0x23c>)
 810968a:	6819      	ldr	r1, [r3, #0]
 810968c:	4b67      	ldr	r3, [pc, #412]	@ (810982c <SdoUploadSegmentInd+0x230>)
 810968e:	681b      	ldr	r3, [r3, #0]
 8109690:	085b      	lsrs	r3, r3, #1
 8109692:	005b      	lsls	r3, r3, #1
 8109694:	440b      	add	r3, r1
 8109696:	881b      	ldrh	r3, [r3, #0]
 8109698:	b21b      	sxth	r3, r3
 810969a:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 810969e:	b21b      	sxth	r3, r3
 81096a0:	4313      	orrs	r3, r2
 81096a2:	b21b      	sxth	r3, r3
 81096a4:	b29a      	uxth	r2, r3
 81096a6:	693b      	ldr	r3, [r7, #16]
 81096a8:	811a      	strh	r2, [r3, #8]
            // Copy Data1 - DataN
            MBXMEMCPY( pSdoSegRes->SdoHeader.Data, &pSdoSegData[(nSdoSegBytesToHandle >> 1) + 1], size - 1);
 81096aa:	693b      	ldr	r3, [r7, #16]
 81096ac:	f103 000a 	add.w	r0, r3, #10
 81096b0:	4b61      	ldr	r3, [pc, #388]	@ (8109838 <SdoUploadSegmentInd+0x23c>)
 81096b2:	681a      	ldr	r2, [r3, #0]
 81096b4:	4b5d      	ldr	r3, [pc, #372]	@ (810982c <SdoUploadSegmentInd+0x230>)
 81096b6:	681b      	ldr	r3, [r3, #0]
 81096b8:	085b      	lsrs	r3, r3, #1
 81096ba:	3301      	adds	r3, #1
 81096bc:	005b      	lsls	r3, r3, #1
 81096be:	18d1      	adds	r1, r2, r3
 81096c0:	69bb      	ldr	r3, [r7, #24]
 81096c2:	3b01      	subs	r3, #1
 81096c4:	461a      	mov	r2, r3
 81096c6:	f006 fb98 	bl	810fdfa <memcpy>
 81096ca:	e045      	b.n	8109758 <SdoUploadSegmentInd+0x15c>
        }
        else
        {	
            UINT16 i = 0;
 81096cc:	2300      	movs	r3, #0
 81096ce:	82fb      	strh	r3, [r7, #22]
            UINT32 nIndexOffset = nSdoSegBytesToHandle >> 1;
 81096d0:	4b56      	ldr	r3, [pc, #344]	@ (810982c <SdoUploadSegmentInd+0x230>)
 81096d2:	681b      	ldr	r3, [r3, #0]
 81096d4:	085b      	lsrs	r3, r3, #1
 81096d6:	60bb      	str	r3, [r7, #8]
            // Data starts at even byte number (Segment 1,3, ...): Data0 is at low byte, Data1 lies at an odd address
            // Write Data0
            pSdoSegRes->SdoHeader.SegHeader |= ((pSdoSegData[(nSdoSegBytesToHandle >> 1)] << SEGDATASHIFT) & SEGHDATA_MASK);
 81096d8:	693b      	ldr	r3, [r7, #16]
 81096da:	891b      	ldrh	r3, [r3, #8]
 81096dc:	b21a      	sxth	r2, r3
 81096de:	4b56      	ldr	r3, [pc, #344]	@ (8109838 <SdoUploadSegmentInd+0x23c>)
 81096e0:	6819      	ldr	r1, [r3, #0]
 81096e2:	4b52      	ldr	r3, [pc, #328]	@ (810982c <SdoUploadSegmentInd+0x230>)
 81096e4:	681b      	ldr	r3, [r3, #0]
 81096e6:	085b      	lsrs	r3, r3, #1
 81096e8:	005b      	lsls	r3, r3, #1
 81096ea:	440b      	add	r3, r1
 81096ec:	881b      	ldrh	r3, [r3, #0]
 81096ee:	021b      	lsls	r3, r3, #8
 81096f0:	b21b      	sxth	r3, r3
 81096f2:	4313      	orrs	r3, r2
 81096f4:	b21b      	sxth	r3, r3
 81096f6:	b29a      	uxth	r2, r3
 81096f8:	693b      	ldr	r3, [r7, #16]
 81096fa:	811a      	strh	r2, [r3, #8]
            // Copy Data1 - DataN
            
            for (i = 0; i < (size >> 1);i++)
 81096fc:	2300      	movs	r3, #0
 81096fe:	82fb      	strh	r3, [r7, #22]
 8109700:	e025      	b.n	810974e <SdoUploadSegmentInd+0x152>
            {
                pSdoSegRes->SdoHeader.Data[i] = ((pSdoSegData[i + nIndexOffset] & SEGHDATA_MASK) >> 8) | ((pSdoSegData[i + nIndexOffset + 1] & ~SEGHDATA_MASK) << 8);
 8109702:	4b4d      	ldr	r3, [pc, #308]	@ (8109838 <SdoUploadSegmentInd+0x23c>)
 8109704:	681a      	ldr	r2, [r3, #0]
 8109706:	8af9      	ldrh	r1, [r7, #22]
 8109708:	68bb      	ldr	r3, [r7, #8]
 810970a:	440b      	add	r3, r1
 810970c:	005b      	lsls	r3, r3, #1
 810970e:	4413      	add	r3, r2
 8109710:	881b      	ldrh	r3, [r3, #0]
 8109712:	0a1b      	lsrs	r3, r3, #8
 8109714:	b29b      	uxth	r3, r3
 8109716:	b21a      	sxth	r2, r3
 8109718:	4b47      	ldr	r3, [pc, #284]	@ (8109838 <SdoUploadSegmentInd+0x23c>)
 810971a:	6819      	ldr	r1, [r3, #0]
 810971c:	8af8      	ldrh	r0, [r7, #22]
 810971e:	68bb      	ldr	r3, [r7, #8]
 8109720:	4403      	add	r3, r0
 8109722:	3301      	adds	r3, #1
 8109724:	005b      	lsls	r3, r3, #1
 8109726:	440b      	add	r3, r1
 8109728:	881b      	ldrh	r3, [r3, #0]
 810972a:	021b      	lsls	r3, r3, #8
 810972c:	b21b      	sxth	r3, r3
 810972e:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 8109732:	b21b      	sxth	r3, r3
 8109734:	4313      	orrs	r3, r2
 8109736:	b21a      	sxth	r2, r3
 8109738:	8afb      	ldrh	r3, [r7, #22]
 810973a:	b291      	uxth	r1, r2
 810973c:	693a      	ldr	r2, [r7, #16]
 810973e:	3304      	adds	r3, #4
 8109740:	005b      	lsls	r3, r3, #1
 8109742:	4413      	add	r3, r2
 8109744:	460a      	mov	r2, r1
 8109746:	805a      	strh	r2, [r3, #2]
            for (i = 0; i < (size >> 1);i++)
 8109748:	8afb      	ldrh	r3, [r7, #22]
 810974a:	3301      	adds	r3, #1
 810974c:	82fb      	strh	r3, [r7, #22]
 810974e:	8afa      	ldrh	r2, [r7, #22]
 8109750:	69bb      	ldr	r3, [r7, #24]
 8109752:	085b      	lsrs	r3, r3, #1
 8109754:	429a      	cmp	r2, r3
 8109756:	d3d4      	bcc.n	8109702 <SdoUploadSegmentInd+0x106>
                    // (If size is even, one byte too much is copied. But, that is not a problem.)
            }
        }
        
        /* the SDO Upload Segment header depends if there is still data to be sent */
        pSdoSegRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
 8109758:	693b      	ldr	r3, [r7, #16]
 810975a:	88db      	ldrh	r3, [r3, #6]
 810975c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8109760:	b29a      	uxth	r2, r3
 8109762:	693b      	ldr	r3, [r7, #16]
 8109764:	80da      	strh	r2, [r3, #6]
        pSdoSegRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
 8109766:	693b      	ldr	r3, [r7, #16]
 8109768:	88db      	ldrh	r3, [r3, #6]
 810976a:	f443 5340 	orr.w	r3, r3, #12288	@ 0x3000
 810976e:	b29a      	uxth	r2, r3
 8109770:	693b      	ldr	r3, [r7, #16]
 8109772:	80da      	strh	r2, [r3, #6]

        /*Clear SDO header*/
        pSdoSegRes->SdoHeader.SegHeader &= ~SEGHEADER_MASK;
 8109774:	693b      	ldr	r3, [r7, #16]
 8109776:	891b      	ldrh	r3, [r3, #8]
 8109778:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 810977c:	b29a      	uxth	r2, r3
 810977e:	693b      	ldr	r3, [r7, #16]
 8109780:	811a      	strh	r2, [r3, #8]
        if (bSdoSegFollows)
 8109782:	4b2c      	ldr	r3, [pc, #176]	@ (8109834 <SdoUploadSegmentInd+0x238>)
 8109784:	781b      	ldrb	r3, [r3, #0]
 8109786:	2b00      	cmp	r3, #0
 8109788:	d008      	beq.n	810979c <SdoUploadSegmentInd+0x1a0>
            pSdoSegRes->SdoHeader.SegHeader        |= SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle;
 810978a:	693b      	ldr	r3, [r7, #16]
 810978c:	891b      	ldrh	r3, [r3, #8]
 810978e:	4a25      	ldr	r2, [pc, #148]	@ (8109824 <SdoUploadSegmentInd+0x228>)
 8109790:	7812      	ldrb	r2, [r2, #0]
 8109792:	4313      	orrs	r3, r2
 8109794:	b29a      	uxth	r2, r3
 8109796:	693b      	ldr	r3, [r7, #16]
 8109798:	811a      	strh	r2, [r3, #8]
 810979a:	e00a      	b.n	81097b2 <SdoUploadSegmentInd+0x1b6>
        else
            pSdoSegRes->SdoHeader.SegHeader        |= SDOSERVICE_UPLOADSEGMENTRES | bSdoSegLastToggle | SEGHEADER_NOMOREFOLLOWS;
 810979c:	693b      	ldr	r3, [r7, #16]
 810979e:	891b      	ldrh	r3, [r3, #8]
 81097a0:	4a20      	ldr	r2, [pc, #128]	@ (8109824 <SdoUploadSegmentInd+0x228>)
 81097a2:	7812      	ldrb	r2, [r2, #0]
 81097a4:	f042 0201 	orr.w	r2, r2, #1
 81097a8:	b2d2      	uxtb	r2, r2
 81097aa:	4313      	orrs	r3, r2
 81097ac:	b29a      	uxth	r2, r3
 81097ae:	693b      	ldr	r3, [r7, #16]
 81097b0:	811a      	strh	r2, [r3, #8]

        // operate CAN specific flag segDataSize:
        /* HBu 06.02.06: the sizes were wrong */
        if ( size < MIN_SEGMENTED_DATA )
 81097b2:	69bb      	ldr	r3, [r7, #24]
 81097b4:	2b06      	cmp	r3, #6
 81097b6:	d810      	bhi.n	81097da <SdoUploadSegmentInd+0x1de>
        {
            // at least    MIN_SEGMENTED_DATA bytes have to be send:
            pSdoSegRes->MbxHeader.Length = SEGMENT_NORM_RES_SIZE;
 81097b8:	693b      	ldr	r3, [r7, #16]
 81097ba:	220a      	movs	r2, #10
 81097bc:	801a      	strh	r2, [r3, #0]
            pSdoSegRes->SdoHeader.SegHeader    |= (MIN_SEGMENTED_DATA - size) << SEGHEADERSHIFT_SEGDATASIZE;
 81097be:	693b      	ldr	r3, [r7, #16]
 81097c0:	891a      	ldrh	r2, [r3, #8]
 81097c2:	69bb      	ldr	r3, [r7, #24]
 81097c4:	b29b      	uxth	r3, r3
 81097c6:	f1c3 0307 	rsb	r3, r3, #7
 81097ca:	b29b      	uxth	r3, r3
 81097cc:	005b      	lsls	r3, r3, #1
 81097ce:	b29b      	uxth	r3, r3
 81097d0:	4313      	orrs	r3, r2
 81097d2:	b29a      	uxth	r2, r3
 81097d4:	693b      	ldr	r3, [r7, #16]
 81097d6:	811a      	strh	r2, [r3, #8]
 81097d8:	e005      	b.n	81097e6 <SdoUploadSegmentInd+0x1ea>
        }
        else
        {
            pSdoSegRes->MbxHeader.Length         = ((UINT16) size) + SEGMENT_NORM_HEADER_SIZE;
 81097da:	69bb      	ldr	r3, [r7, #24]
 81097dc:	b29b      	uxth	r3, r3
 81097de:	3303      	adds	r3, #3
 81097e0:	b29a      	uxth	r2, r3
 81097e2:	693b      	ldr	r3, [r7, #16]
 81097e4:	801a      	strh	r2, [r3, #0]
        }

        if ( bSdoSegFollows == TRUE )
 81097e6:	4b13      	ldr	r3, [pc, #76]	@ (8109834 <SdoUploadSegmentInd+0x238>)
 81097e8:	781b      	ldrb	r3, [r3, #0]
 81097ea:	2b01      	cmp	r3, #1
 81097ec:	d106      	bne.n	81097fc <SdoUploadSegmentInd+0x200>
            // updating the value of send bytes:
            nSdoSegBytesToHandle += size;
 81097ee:	4b0f      	ldr	r3, [pc, #60]	@ (810982c <SdoUploadSegmentInd+0x230>)
 81097f0:	681a      	ldr	r2, [r3, #0]
 81097f2:	69bb      	ldr	r3, [r7, #24]
 81097f4:	4413      	add	r3, r2
 81097f6:	4a0d      	ldr	r2, [pc, #52]	@ (810982c <SdoUploadSegmentInd+0x230>)
 81097f8:	6013      	str	r3, [r2, #0]
 81097fa:	e00d      	b.n	8109818 <SdoUploadSegmentInd+0x21c>
        else
        {
            FREEMEM( (UINT16 VARMEM *) pSdoSegData );
 81097fc:	4b0e      	ldr	r3, [pc, #56]	@ (8109838 <SdoUploadSegmentInd+0x23c>)
 81097fe:	681b      	ldr	r3, [r3, #0]
 8109800:	4618      	mov	r0, r3
 8109802:	f006 f87d 	bl	810f900 <free>
            pSdoSegData = NULL;
 8109806:	4b0c      	ldr	r3, [pc, #48]	@ (8109838 <SdoUploadSegmentInd+0x23c>)
 8109808:	2200      	movs	r2, #0
 810980a:	601a      	str	r2, [r3, #0]
            nSdoSegBytesToHandle = 0;
 810980c:	4b07      	ldr	r3, [pc, #28]	@ (810982c <SdoUploadSegmentInd+0x230>)
 810980e:	2200      	movs	r2, #0
 8109810:	601a      	str	r2, [r3, #0]
            nSdoSegService    = 0;
 8109812:	4b0a      	ldr	r3, [pc, #40]	@ (810983c <SdoUploadSegmentInd+0x240>)
 8109814:	2200      	movs	r2, #0
 8109816:	701a      	strb	r2, [r3, #0]
        }
    }

    return abort;
 8109818:	7ffb      	ldrb	r3, [r7, #31]
}
 810981a:	4618      	mov	r0, r3
 810981c:	3720      	adds	r7, #32
 810981e:	46bd      	mov	sp, r7
 8109820:	bd80      	pop	{r7, pc}
 8109822:	bf00      	nop
 8109824:	10000bd0 	.word	0x10000bd0
 8109828:	1000087a 	.word	0x1000087a
 810982c:	10000bcc 	.word	0x10000bcc
 8109830:	10000bd4 	.word	0x10000bd4
 8109834:	10000bc6 	.word	0x10000bc6
 8109838:	10000bb4 	.word	0x10000bb4
 810983c:	10000bc5 	.word	0x10000bc5

08109840 <SdoRes>:

 \brief    This function is called when a SDO response shall be sent
*////////////////////////////////////////////////////////////////////////////////////////

void SdoRes(UINT8 abort, UINT8 command, UINT8 completeAccess, UINT16 dataSize, UINT32 objLength, TINITSDOMBX MBXMEM *pSdoRes)
{
 8109840:	b590      	push	{r4, r7, lr}
 8109842:	b083      	sub	sp, #12
 8109844:	af00      	add	r7, sp, #0
 8109846:	4604      	mov	r4, r0
 8109848:	4608      	mov	r0, r1
 810984a:	4611      	mov	r1, r2
 810984c:	461a      	mov	r2, r3
 810984e:	4623      	mov	r3, r4
 8109850:	71fb      	strb	r3, [r7, #7]
 8109852:	4603      	mov	r3, r0
 8109854:	71bb      	strb	r3, [r7, #6]
 8109856:	460b      	mov	r3, r1
 8109858:	717b      	strb	r3, [r7, #5]
 810985a:	4613      	mov	r3, r2
 810985c:	807b      	strh	r3, [r7, #2]
    /* for an upload segment response the toggle bit was overwritten */
    if ((command != SDOSERVICE_UPLOADSEGMENTREQ) && (command != SDOSERVICE_DOWNLOADSEGMENTREQ))
 810985e:	79bb      	ldrb	r3, [r7, #6]
 8109860:	2b60      	cmp	r3, #96	@ 0x60
 8109862:	d009      	beq.n	8109878 <SdoRes+0x38>
 8109864:	79bb      	ldrb	r3, [r7, #6]
 8109866:	2b00      	cmp	r3, #0
 8109868:	d006      	beq.n	8109878 <SdoRes+0x38>
    {
        pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= 0xFF00;
 810986a:	69fb      	ldr	r3, [r7, #28]
 810986c:	891b      	ldrh	r3, [r3, #8]
 810986e:	f023 03ff 	bic.w	r3, r3, #255	@ 0xff
 8109872:	b29a      	uxth	r2, r3
 8109874:	69fb      	ldr	r3, [r7, #28]
 8109876:	811a      	strh	r2, [r3, #8]
    }
    if ( abort == 0 )
 8109878:	79fb      	ldrb	r3, [r7, #7]
 810987a:	2b00      	cmp	r3, #0
 810987c:	d171      	bne.n	8109962 <SdoRes+0x122>
    {
        /* SDO-Download or SDO-Upload was successful, generate the SDO- and CoE-Header */
        pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
 810987e:	69fb      	ldr	r3, [r7, #28]
 8109880:	88db      	ldrh	r3, [r3, #6]
 8109882:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8109886:	b29a      	uxth	r2, r3
 8109888:	69fb      	ldr	r3, [r7, #28]
 810988a:	80da      	strh	r2, [r3, #6]
        pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDORESPONSE) << COEHEADER_COESERVICESHIFT;
 810988c:	69fb      	ldr	r3, [r7, #28]
 810988e:	88db      	ldrh	r3, [r3, #6]
 8109890:	f443 5340 	orr.w	r3, r3, #12288	@ 0x3000
 8109894:	b29a      	uxth	r2, r3
 8109896:	69fb      	ldr	r3, [r7, #28]
 8109898:	80da      	strh	r2, [r3, #6]
        if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 810989a:	79bb      	ldrb	r3, [r7, #6]
 810989c:	2b40      	cmp	r3, #64	@ 0x40
 810989e:	d144      	bne.n	810992a <SdoRes+0xea>
        {
            // HBu 06.02.06: Complete Access Bit in the SDO-Upload-Response too */
            if ( (objLength <= 4) && (objLength > 0) )
 81098a0:	69bb      	ldr	r3, [r7, #24]
 81098a2:	2b04      	cmp	r3, #4
 81098a4:	d81d      	bhi.n	81098e2 <SdoRes+0xa2>
 81098a6:	69bb      	ldr	r3, [r7, #24]
 81098a8:	2b00      	cmp	r3, #0
 81098aa:	d01a      	beq.n	81098e2 <SdoRes+0xa2>
            {
                /* Expedited Upload Response */
                pSdoRes->MbxHeader.Length             =         EXPEDITED_FRAME_SIZE;
 81098ac:	69fb      	ldr	r3, [r7, #28]
 81098ae:	220a      	movs	r2, #10
 81098b0:	801a      	strh	r2, [r3, #0]
                pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |=     SDOHEADER_SIZEINDICATOR     |
 81098b2:	69fb      	ldr	r3, [r7, #28]
 81098b4:	891a      	ldrh	r2, [r3, #8]
                                                                                        SDOHEADER_TRANSFERTYPE        |
                                                                                        completeAccess |
 81098b6:	797b      	ldrb	r3, [r7, #5]
 81098b8:	f043 0303 	orr.w	r3, r3, #3
 81098bc:	b2db      	uxtb	r3, r3
 81098be:	b219      	sxth	r1, r3
                                                                                        ((MAX_EXPEDITED_DATA - ((UINT8)objLength)) << SDOHEADERSHIFT_DATASETSIZE) |
 81098c0:	69bb      	ldr	r3, [r7, #24]
 81098c2:	b2db      	uxtb	r3, r3
 81098c4:	f1c3 0304 	rsb	r3, r3, #4
 81098c8:	009b      	lsls	r3, r3, #2
                                                                                        completeAccess |
 81098ca:	b21b      	sxth	r3, r3
 81098cc:	430b      	orrs	r3, r1
 81098ce:	b21b      	sxth	r3, r3
                pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |=     SDOHEADER_SIZEINDICATOR     |
 81098d0:	b29b      	uxth	r3, r3
 81098d2:	4313      	orrs	r3, r2
 81098d4:	b29b      	uxth	r3, r3
 81098d6:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 81098da:	b29a      	uxth	r2, r3
 81098dc:	69fb      	ldr	r3, [r7, #28]
 81098de:	811a      	strh	r2, [r3, #8]
 81098e0:	e059      	b.n	8109996 <SdoRes+0x156>
                                                                                        SDOSERVICE_INITIATEUPLOADRES;
            }
            else
            {
                /* Normal or Segmented Upload Response */
                if (dataSize <  objLength)
 81098e2:	887b      	ldrh	r3, [r7, #2]
 81098e4:	69ba      	ldr	r2, [r7, #24]
 81098e6:	429a      	cmp	r2, r3
 81098e8:	d905      	bls.n	81098f6 <SdoRes+0xb6>
                {
                    pSdoRes->MbxHeader.Length         =         UPLOAD_NORM_RES_SIZE+dataSize;
 81098ea:	887b      	ldrh	r3, [r7, #2]
 81098ec:	330a      	adds	r3, #10
 81098ee:	b29a      	uxth	r2, r3
 81098f0:	69fb      	ldr	r3, [r7, #28]
 81098f2:	801a      	strh	r2, [r3, #0]
 81098f4:	e005      	b.n	8109902 <SdoRes+0xc2>
                }
                else
                {
                    pSdoRes->MbxHeader.Length         =         UPLOAD_NORM_RES_SIZE+((UINT16)objLength);
 81098f6:	69bb      	ldr	r3, [r7, #24]
 81098f8:	b29b      	uxth	r3, r3
 81098fa:	330a      	adds	r3, #10
 81098fc:	b29a      	uxth	r2, r3
 81098fe:	69fb      	ldr	r3, [r7, #28]
 8109900:	801a      	strh	r2, [r3, #0]
                }
                   ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[0] = SWAPWORD((UINT16)objLength);
 8109902:	69bb      	ldr	r3, [r7, #24]
 8109904:	b29a      	uxth	r2, r3
 8109906:	69fb      	ldr	r3, [r7, #28]
 8109908:	819a      	strh	r2, [r3, #12]
                   ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoRes)->CompleteSize[1] = SWAPWORD((UINT16)(objLength>>16));
 810990a:	69bb      	ldr	r3, [r7, #24]
 810990c:	0c1b      	lsrs	r3, r3, #16
 810990e:	b29a      	uxth	r2, r3
 8109910:	69fb      	ldr	r3, [r7, #28]
 8109912:	81da      	strh	r2, [r3, #14]
                pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |=     SDOHEADER_SIZEINDICATOR     |
 8109914:	69fb      	ldr	r3, [r7, #28]
 8109916:	891b      	ldrh	r3, [r3, #8]
 8109918:	797a      	ldrb	r2, [r7, #5]
 810991a:	f042 0241 	orr.w	r2, r2, #65	@ 0x41
 810991e:	b2d2      	uxtb	r2, r2
 8109920:	4313      	orrs	r3, r2
 8109922:	b29a      	uxth	r2, r3
 8109924:	69fb      	ldr	r3, [r7, #28]
 8109926:	811a      	strh	r2, [r3, #8]
 8109928:	e035      	b.n	8109996 <SdoRes+0x156>
                                                                                        completeAccess |
                                                                                        SDOSERVICE_INITIATEUPLOADRES;
            }
        }
        /* for a segmented response the command was wrong in the response */
        else if ( command == SDOSERVICE_DOWNLOADSEGMENTREQ )
 810992a:	79bb      	ldrb	r3, [r7, #6]
 810992c:	2b00      	cmp	r3, #0
 810992e:	d10a      	bne.n	8109946 <SdoRes+0x106>
        {
            /* Download segmented response */
            pSdoRes->MbxHeader.Length         = DOWNLOAD_NORM_RES_SIZE;
 8109930:	69fb      	ldr	r3, [r7, #28]
 8109932:	220a      	movs	r2, #10
 8109934:	801a      	strh	r2, [r3, #0]
            pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |= SDOSERVICE_DOWNLOADSEGMENTRES;
 8109936:	69fb      	ldr	r3, [r7, #28]
 8109938:	891b      	ldrh	r3, [r3, #8]
 810993a:	f043 0320 	orr.w	r3, r3, #32
 810993e:	b29a      	uxth	r2, r3
 8109940:	69fb      	ldr	r3, [r7, #28]
 8109942:	811a      	strh	r2, [r3, #8]
 8109944:	e027      	b.n	8109996 <SdoRes+0x156>
      }
        else if ( command != SDOSERVICE_UPLOADSEGMENTREQ )
 8109946:	79bb      	ldrb	r3, [r7, #6]
 8109948:	2b60      	cmp	r3, #96	@ 0x60
 810994a:	d024      	beq.n	8109996 <SdoRes+0x156>
        {
            /* Download response */
            pSdoRes->MbxHeader.Length         = DOWNLOAD_NORM_RES_SIZE;
 810994c:	69fb      	ldr	r3, [r7, #28]
 810994e:	220a      	movs	r2, #10
 8109950:	801a      	strh	r2, [r3, #0]
            pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |= SDOSERVICE_INITIATEDOWNLOADRES;
 8109952:	69fb      	ldr	r3, [r7, #28]
 8109954:	891b      	ldrh	r3, [r3, #8]
 8109956:	f043 0360 	orr.w	r3, r3, #96	@ 0x60
 810995a:	b29a      	uxth	r2, r3
 810995c:	69fb      	ldr	r3, [r7, #28]
 810995e:	811a      	strh	r2, [r3, #8]
 8109960:	e019      	b.n	8109996 <SdoRes+0x156>
        }
    }
    else
    {
        /* generate a SDO-Abort-Request */
        pSdoRes->MbxHeader.Length         = ABORT_NORM_RES_SIZE;
 8109962:	69fb      	ldr	r3, [r7, #28]
 8109964:	220a      	movs	r2, #10
 8109966:	801a      	strh	r2, [r3, #0]
        pSdoRes->CoeHeader &= ~COEHEADER_COESERVICEMASK;
 8109968:	69fb      	ldr	r3, [r7, #28]
 810996a:	88db      	ldrh	r3, [r3, #6]
 810996c:	f3c3 030b 	ubfx	r3, r3, #0, #12
 8109970:	b29a      	uxth	r2, r3
 8109972:	69fb      	ldr	r3, [r7, #28]
 8109974:	80da      	strh	r2, [r3, #6]
        pSdoRes->CoeHeader |= ((UINT16)COESERVICE_SDOREQUEST) << COEHEADER_COESERVICESHIFT;
 8109976:	69fb      	ldr	r3, [r7, #28]
 8109978:	88db      	ldrh	r3, [r3, #6]
 810997a:	f443 5300 	orr.w	r3, r3, #8192	@ 0x2000
 810997e:	b29a      	uxth	r2, r3
 8109980:	69fb      	ldr	r3, [r7, #28]
 8109982:	80da      	strh	r2, [r3, #6]
        pSdoRes->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    = SDOSERVICE_ABORTTRANSFER;
 8109984:	69fb      	ldr	r3, [r7, #28]
 8109986:	2280      	movs	r2, #128	@ 0x80
 8109988:	811a      	strh	r2, [r3, #8]
        ((TABORTSDOTRANSFERREQMBX MBXMEM *) pSdoRes)->AbortCode = SWAPDWORD(cAbortCode[abort]);
 810998a:	79fb      	ldrb	r3, [r7, #7]
 810998c:	4a09      	ldr	r2, [pc, #36]	@ (81099b4 <SdoRes+0x174>)
 810998e:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 8109992:	69fb      	ldr	r3, [r7, #28]
 8109994:	60da      	str	r2, [r3, #12]
    }

    // HBu 02.05.06: if the CoE-response could not be sent because the
    //               send mailbox is full it should be stored
    if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoRes, COE_SERVICE) != 0)
 8109996:	2102      	movs	r1, #2
 8109998:	69f8      	ldr	r0, [r7, #28]
 810999a:	f7fd ff81 	bl	81078a0 <MBX_MailboxSendReq>
 810999e:	4603      	mov	r3, r0
 81099a0:	2b00      	cmp	r3, #0
 81099a2:	d002      	beq.n	81099aa <SdoRes+0x16a>
    {
        /* we store the CoE mailbox service to send it later (in COE_ContinueInd) when the mailbox is read */
        pCoeSendStored = (TMBX MBXMEM *) pSdoRes;
 81099a4:	4a04      	ldr	r2, [pc, #16]	@ (81099b8 <SdoRes+0x178>)
 81099a6:	69fb      	ldr	r3, [r7, #28]
 81099a8:	6013      	str	r3, [r2, #0]
    }
}
 81099aa:	bf00      	nop
 81099ac:	370c      	adds	r7, #12
 81099ae:	46bd      	mov	sp, r7
 81099b0:	bd90      	pop	{r4, r7, pc}
 81099b2:	bf00      	nop
 81099b4:	081112a0 	.word	0x081112a0
 81099b8:	10000824 	.word	0x10000824

081099bc <SDOS_SdoInd>:
            is received from the master and calls depending from
            the command the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInd(TINITSDOMBX MBXMEM *pSdoInd)
{
 81099bc:	b590      	push	{r4, r7, lr}
 81099be:	b08f      	sub	sp, #60	@ 0x3c
 81099c0:	af02      	add	r7, sp, #8
 81099c2:	6078      	str	r0, [r7, #4]
    UINT8 abort = 0;
 81099c4:	2300      	movs	r3, #0
 81099c6:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
    UINT8 sdoHeader = pSdoInd->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMANDMASK;
 81099ca:	687b      	ldr	r3, [r7, #4]
 81099cc:	891b      	ldrh	r3, [r3, #8]
 81099ce:	76bb      	strb	r3, [r7, #26]
    /* the SDO-command is in bit 5-7 of the first SDO-Byte */
    UINT8 command = (sdoHeader & SDOHEADER_COMMAND);
 81099d0:	7ebb      	ldrb	r3, [r7, #26]
 81099d2:	f023 031f 	bic.w	r3, r3, #31
 81099d6:	767b      	strb	r3, [r7, #25]
    /* mbxSize contains the size of the mailbox (CoE-Header (2 Bytes) + SDO-Header (8 Bytes) + SDO-Data (if the data length is greater than 4)) */
    UINT16 mbxSize = SWAPWORD(pSdoInd->MbxHeader.Length);
 81099d8:	687b      	ldr	r3, [r7, #4]
 81099da:	881b      	ldrh	r3, [r3, #0]
 81099dc:	82fb      	strh	r3, [r7, #22]
    UINT16 index;
    UINT8 subindex;
    OBJCONST TOBJECT OBJMEM * pObjEntry;
    /* this variable contains the information, if all entries of an object will be read (bCompleteAccess > 0) or a single entry */
    UINT8 bCompleteAccess = 0;
 81099de:	2300      	movs	r3, #0
 81099e0:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
    UINT32 objLength = 0;
 81099e4:	2300      	movs	r3, #0
 81099e6:	62bb      	str	r3, [r7, #40]	@ 0x28
    UINT32 dataSize = 0;
 81099e8:	2300      	movs	r3, #0
 81099ea:	627b      	str	r3, [r7, #36]	@ 0x24

    if ( bSdoInWork )
 81099ec:	4b99      	ldr	r3, [pc, #612]	@ (8109c54 <SDOS_SdoInd+0x298>)
 81099ee:	781b      	ldrb	r3, [r3, #0]
 81099f0:	2b00      	cmp	r3, #0
 81099f2:	d001      	beq.n	81099f8 <SDOS_SdoInd+0x3c>
    {
        /* the last SDO is still in work */
        return MBXERR_SERVICEINWORK;
 81099f4:	2309      	movs	r3, #9
 81099f6:	e272      	b.n	8109ede <SDOS_SdoInd+0x522>
    }


    switch (command)
 81099f8:	7e7b      	ldrb	r3, [r7, #25]
 81099fa:	2b60      	cmp	r3, #96	@ 0x60
 81099fc:	f000 823b 	beq.w	8109e76 <SDOS_SdoInd+0x4ba>
 8109a00:	2b60      	cmp	r3, #96	@ 0x60
 8109a02:	f300 8252 	bgt.w	8109eaa <SDOS_SdoInd+0x4ee>
 8109a06:	2b40      	cmp	r3, #64	@ 0x40
 8109a08:	d008      	beq.n	8109a1c <SDOS_SdoInd+0x60>
 8109a0a:	2b40      	cmp	r3, #64	@ 0x40
 8109a0c:	f300 824d 	bgt.w	8109eaa <SDOS_SdoInd+0x4ee>
 8109a10:	2b00      	cmp	r3, #0
 8109a12:	f000 8230 	beq.w	8109e76 <SDOS_SdoInd+0x4ba>
 8109a16:	2b20      	cmp	r3, #32
 8109a18:	f040 8247 	bne.w	8109eaa <SDOS_SdoInd+0x4ee>
    {
    case SDOSERVICE_INITIATEDOWNLOADREQ:
    case SDOSERVICE_INITIATEUPLOADREQ:
        /* the variable index contains the requested index of the SDO service */
        index = pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXHIOFFSET] & SDOHEADER_INDEXHIMASK;
 8109a1c:	687b      	ldr	r3, [r7, #4]
 8109a1e:	895b      	ldrh	r3, [r3, #10]
 8109a20:	b2db      	uxtb	r3, r3
 8109a22:	82bb      	strh	r3, [r7, #20]
        index <<= 8;
 8109a24:	8abb      	ldrh	r3, [r7, #20]
 8109a26:	021b      	lsls	r3, r3, #8
 8109a28:	82bb      	strh	r3, [r7, #20]
        index += pSdoInd->SdoHeader.Sdo[SDOHEADER_INDEXLOOFFSET] >> SDOHEADER_INDEXLOSHIFT;
 8109a2a:	687b      	ldr	r3, [r7, #4]
 8109a2c:	891b      	ldrh	r3, [r3, #8]
 8109a2e:	0a1b      	lsrs	r3, r3, #8
 8109a30:	b29a      	uxth	r2, r3
 8109a32:	8abb      	ldrh	r3, [r7, #20]
 8109a34:	4413      	add	r3, r2
 8109a36:	82bb      	strh	r3, [r7, #20]
        /* the variable subindex contains the requested subindex of the SDO service */
        subindex    = pSdoInd->SdoHeader.Sdo[SDOHEADER_SUBINDEXOFFSET] >> SDOHEADER_SUBINDEXSHIFT;
 8109a38:	687b      	ldr	r3, [r7, #4]
 8109a3a:	895b      	ldrh	r3, [r3, #10]
 8109a3c:	0a1b      	lsrs	r3, r3, #8
 8109a3e:	b29b      	uxth	r3, r3
 8109a40:	74fb      	strb	r3, [r7, #19]

        /* OBJ_GetObjectHandle checks if the requested index is defined in the object dictionary */
        pObjEntry = OBJ_GetObjectHandle( index );
 8109a42:	8abb      	ldrh	r3, [r7, #20]
 8109a44:	4618      	mov	r0, r3
 8109a46:	f7fe f8ff 	bl	8107c48 <OBJ_GetObjectHandle>
 8109a4a:	60f8      	str	r0, [r7, #12]

        if ( pObjEntry )
 8109a4c:	68fb      	ldr	r3, [r7, #12]
 8109a4e:	2b00      	cmp	r3, #0
 8109a50:	f000 820d 	beq.w	8109e6e <SDOS_SdoInd+0x4b2>
        {
            /* transferType contains the information if the SDO Download Request or the SDO Upload Response
               can be an expedited service (SDO data length <= 4, that means the data is stored in the
                SDO-Header completely */
            UINT8 bTransferType = 0;
 8109a54:	2300      	movs	r3, #0
 8109a56:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
            /* pData is the pointer to the received (SDO-Download) or sent (SDO-Upload) SDO data in the mailbox */
            UINT16 MBXMEM * pData = NULL;
 8109a5a:	2300      	movs	r3, #0
 8109a5c:	61fb      	str	r3, [r7, #28]
            UINT8 segTransfer = 0;
 8109a5e:	2300      	movs	r3, #0
 8109a60:	76fb      	strb	r3, [r7, #27]

            {
                dataSize = objLength = OBJ_GetObjectLength( index, subindex, pObjEntry, (UINT8) (sdoHeader & SDOHEADER_COMPLETEACCESS) );
 8109a62:	7ebb      	ldrb	r3, [r7, #26]
 8109a64:	f003 0310 	and.w	r3, r3, #16
 8109a68:	b2db      	uxtb	r3, r3
 8109a6a:	7cf9      	ldrb	r1, [r7, #19]
 8109a6c:	8ab8      	ldrh	r0, [r7, #20]
 8109a6e:	68fa      	ldr	r2, [r7, #12]
 8109a70:	f7fe f905 	bl	8107c7e <OBJ_GetObjectLength>
 8109a74:	62b8      	str	r0, [r7, #40]	@ 0x28
 8109a76:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109a78:	627b      	str	r3, [r7, #36]	@ 0x24

                if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 8109a7a:	7e7b      	ldrb	r3, [r7, #25]
 8109a7c:	2b40      	cmp	r3, #64	@ 0x40
 8109a7e:	d127      	bne.n	8109ad0 <SDOS_SdoInd+0x114>
                {
                    /* SDO Upload */
                    if ( mbxSize != EXPEDITED_FRAME_SIZE )
 8109a80:	8afb      	ldrh	r3, [r7, #22]
 8109a82:	2b0a      	cmp	r3, #10
 8109a84:	d001      	beq.n	8109a8a <SDOS_SdoInd+0xce>
                        /* a SDO Upload request has always a fixed size (2 Byte CoE-Header plus 8 Byte SDO-Header) */
                        return MBXERR_INVALIDSIZE;
 8109a86:	2308      	movs	r3, #8
 8109a88:	e229      	b.n	8109ede <SDOS_SdoInd+0x522>
                    /* distinguish between expedited and normal upload response within the length of the response data */
                    if ( (objLength <= MAX_EXPEDITED_DATA) && objLength != 0 )
 8109a8a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109a8c:	2b04      	cmp	r3, #4
 8109a8e:	d810      	bhi.n	8109ab2 <SDOS_SdoInd+0xf6>
 8109a90:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109a92:	2b00      	cmp	r3, #0
 8109a94:	d00d      	beq.n	8109ab2 <SDOS_SdoInd+0xf6>
                    {
                        /* Expedited Upload */
                        bTransferType = 1;
 8109a96:	2301      	movs	r3, #1
 8109a98:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
                        /* pData is the pointer where the object data has to be copied for the response */
                        pData = ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoInd)->Data;
 8109a9c:	687b      	ldr	r3, [r7, #4]
 8109a9e:	330c      	adds	r3, #12
 8109aa0:	61fb      	str	r3, [r7, #28]
                        /* initialize the 4 data bytes of the SDO upload response because the requested object data
                           could be less than 4 */
                        pData[0] = 0;
 8109aa2:	69fb      	ldr	r3, [r7, #28]
 8109aa4:	2200      	movs	r2, #0
 8109aa6:	801a      	strh	r2, [r3, #0]
                        pData[1] = 0;
 8109aa8:	69fb      	ldr	r3, [r7, #28]
 8109aaa:	3302      	adds	r3, #2
 8109aac:	2200      	movs	r2, #0
 8109aae:	801a      	strh	r2, [r3, #0]
 8109ab0:	e013      	b.n	8109ada <SDOS_SdoInd+0x11e>
                    }
                    else
                    {
                        /* HBu 06.02.06: the variable dataSize has to be set to the available size in one mailbox */
                    dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
 8109ab2:	4b69      	ldr	r3, [pc, #420]	@ (8109c58 <SDOS_SdoInd+0x29c>)
 8109ab4:	881b      	ldrh	r3, [r3, #0]
 8109ab6:	3b10      	subs	r3, #16
 8109ab8:	627b      	str	r3, [r7, #36]	@ 0x24
                        if ( dataSize < objLength )
 8109aba:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8109abc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109abe:	429a      	cmp	r2, r3
 8109ac0:	d202      	bcs.n	8109ac8 <SDOS_SdoInd+0x10c>
                            /* Segmented Upload */
                            segTransfer = 1;
 8109ac2:	2301      	movs	r3, #1
 8109ac4:	76fb      	strb	r3, [r7, #27]
 8109ac6:	e008      	b.n	8109ada <SDOS_SdoInd+0x11e>
                        else
                            /* Normal Upload */
                            pData = ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data;
 8109ac8:	687b      	ldr	r3, [r7, #4]
 8109aca:	3310      	adds	r3, #16
 8109acc:	61fb      	str	r3, [r7, #28]
 8109ace:	e004      	b.n	8109ada <SDOS_SdoInd+0x11e>
                    }
                }
                else
                {
                    /* SDO-Download: store if the request is a expedited or normal request  */
                    bTransferType = sdoHeader & SDOHEADER_TRANSFERTYPE;
 8109ad0:	7ebb      	ldrb	r3, [r7, #26]
 8109ad2:	f003 0302 	and.w	r3, r3, #2
 8109ad6:	f887 3023 	strb.w	r3, [r7, #35]	@ 0x23
                }
            }

            if ( command == SDOSERVICE_INITIATEDOWNLOADREQ )
 8109ada:	7e7b      	ldrb	r3, [r7, #25]
 8109adc:	2b20      	cmp	r3, #32
 8109ade:	d13b      	bne.n	8109b58 <SDOS_SdoInd+0x19c>
            {
                /* SDO Download */
                if ( bTransferType )
 8109ae0:	f897 3023 	ldrb.w	r3, [r7, #35]	@ 0x23
 8109ae4:	2b00      	cmp	r3, #0
 8109ae6:	d00f      	beq.n	8109b08 <SDOS_SdoInd+0x14c>
                {
                    /* Expedited Download */
                    if ( mbxSize != EXPEDITED_FRAME_SIZE )
 8109ae8:	8afb      	ldrh	r3, [r7, #22]
 8109aea:	2b0a      	cmp	r3, #10
 8109aec:	d001      	beq.n	8109af2 <SDOS_SdoInd+0x136>
                        /* an Expedited SDO Download request has always a fixed size (2 Byte CoE-Header plus 8 Byte SDO-Header) */
                        return MBXERR_INVALIDSIZE;
 8109aee:	2308      	movs	r3, #8
 8109af0:	e1f5      	b.n	8109ede <SDOS_SdoInd+0x522>
                    /* dataSize gets the real size of the downloaded object data (1,2,3 or 4) */
                    dataSize = MAX_EXPEDITED_DATA - ((sdoHeader & SDOHEADER_DATASETSIZE) >> SDOHEADERSHIFT_DATASETSIZE);
 8109af2:	7ebb      	ldrb	r3, [r7, #26]
 8109af4:	109b      	asrs	r3, r3, #2
 8109af6:	f003 0303 	and.w	r3, r3, #3
 8109afa:	f1c3 0304 	rsb	r3, r3, #4
 8109afe:	627b      	str	r3, [r7, #36]	@ 0x24
                    /* pData is the pointer to the downloaded object data */
                    pData = (UINT16 MBXMEM *) &pSdoInd[1];
 8109b00:	687b      	ldr	r3, [r7, #4]
 8109b02:	330c      	adds	r3, #12
 8109b04:	61fb      	str	r3, [r7, #28]
 8109b06:	e027      	b.n	8109b58 <SDOS_SdoInd+0x19c>
                {
                    /* Normal Download */
                    /* downloadSize gets the real size of the downloaded data */
                    /* '&' operator was too much */

                    UINT32 downloadSize = ((UINT32)(SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[1]))<<16) + (SWAPWORD(((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->CompleteSize[0]));
 8109b08:	687b      	ldr	r3, [r7, #4]
 8109b0a:	89db      	ldrh	r3, [r3, #14]
 8109b0c:	041b      	lsls	r3, r3, #16
 8109b0e:	687a      	ldr	r2, [r7, #4]
 8109b10:	8992      	ldrh	r2, [r2, #12]
 8109b12:	4413      	add	r3, r2
 8109b14:	60bb      	str	r3, [r7, #8]

                    /* HBu 29.03.06: if it is a segmented download the mbxSize has to be the complete mailbox size */
                    if ( (MBX_HEADER_SIZE+EXPEDITED_FRAME_SIZE+downloadSize) > u16ReceiveMbxSize )
 8109b16:	68bb      	ldr	r3, [r7, #8]
 8109b18:	3310      	adds	r3, #16
 8109b1a:	4a50      	ldr	r2, [pc, #320]	@ (8109c5c <SDOS_SdoInd+0x2a0>)
 8109b1c:	8812      	ldrh	r2, [r2, #0]
 8109b1e:	4293      	cmp	r3, r2
 8109b20:	d907      	bls.n	8109b32 <SDOS_SdoInd+0x176>
                    {
                        if ( mbxSize != (u16ReceiveMbxSize-MBX_HEADER_SIZE) )
 8109b22:	8afa      	ldrh	r2, [r7, #22]
 8109b24:	4b4d      	ldr	r3, [pc, #308]	@ (8109c5c <SDOS_SdoInd+0x2a0>)
 8109b26:	881b      	ldrh	r3, [r3, #0]
 8109b28:	3b06      	subs	r3, #6
 8109b2a:	429a      	cmp	r2, r3
 8109b2c:	d008      	beq.n	8109b40 <SDOS_SdoInd+0x184>
                            return MBXERR_INVALIDSIZE;
 8109b2e:	2308      	movs	r3, #8
 8109b30:	e1d5      	b.n	8109ede <SDOS_SdoInd+0x522>
                    }
                    else
                    {
                        if ( mbxSize != (EXPEDITED_FRAME_SIZE+downloadSize) )
 8109b32:	8afa      	ldrh	r2, [r7, #22]
 8109b34:	68bb      	ldr	r3, [r7, #8]
 8109b36:	330a      	adds	r3, #10
 8109b38:	429a      	cmp	r2, r3
 8109b3a:	d001      	beq.n	8109b40 <SDOS_SdoInd+0x184>
                            /* the mbxSize and the downloadSize are not consistent (mbxSize = downloadSize + 2 byte CoE-Header + 8 byte SDO Header */
                            return MBXERR_INVALIDSIZE;
 8109b3c:	2308      	movs	r3, #8
 8109b3e:	e1ce      	b.n	8109ede <SDOS_SdoInd+0x522>
                    }

                    /* pData is the pointer to the downloaded object data */
                    pData = (UINT16 MBXMEM *) ((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data;
 8109b40:	687b      	ldr	r3, [r7, #4]
 8109b42:	3310      	adds	r3, #16
 8109b44:	61fb      	str	r3, [r7, #28]
                    /* the received dataSize will be checked in the object specific functions called from
                       OBJ_Write (in objdef.c) */
                    dataSize = downloadSize;
 8109b46:	68bb      	ldr	r3, [r7, #8]
 8109b48:	627b      	str	r3, [r7, #36]	@ 0x24
                    if ( dataSize > (UINT32)(mbxSize - DOWNLOAD_NORM_REQ_SIZE) )
 8109b4a:	8afb      	ldrh	r3, [r7, #22]
 8109b4c:	3b0a      	subs	r3, #10
 8109b4e:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8109b50:	429a      	cmp	r2, r3
 8109b52:	d901      	bls.n	8109b58 <SDOS_SdoInd+0x19c>
                        /* Segmented Download */
                        segTransfer = 1;
 8109b54:	2301      	movs	r3, #1
 8109b56:	76fb      	strb	r3, [r7, #27]
                }
            }

            if ( sdoHeader & SDOHEADER_COMPLETEACCESS )
 8109b58:	7ebb      	ldrb	r3, [r7, #26]
 8109b5a:	f003 0310 	and.w	r3, r3, #16
 8109b5e:	2b00      	cmp	r3, #0
 8109b60:	d008      	beq.n	8109b74 <SDOS_SdoInd+0x1b8>
            {
                bCompleteAccess = 1;
 8109b62:	2301      	movs	r3, #1
 8109b64:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
                // HBu 02.05.06: Complete Access is only supported with subindex 0 and 1
                if (subindex > 1)
 8109b68:	7cfb      	ldrb	r3, [r7, #19]
 8109b6a:	2b01      	cmp	r3, #1
 8109b6c:	d902      	bls.n	8109b74 <SDOS_SdoInd+0x1b8>
                    abort = ABORTIDX_UNSUPPORTED_ACCESS;
 8109b6e:	2305      	movs	r3, #5
 8109b70:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
            }

            if ( abort == 0 )
 8109b74:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8109b78:	2b00      	cmp	r3, #0
 8109b7a:	f040 819a 	bne.w	8109eb2 <SDOS_SdoInd+0x4f6>
            {
                if ( segTransfer )
 8109b7e:	7efb      	ldrb	r3, [r7, #27]
 8109b80:	2b00      	cmp	r3, #0
 8109b82:	f000 80d2 	beq.w	8109d2a <SDOS_SdoInd+0x36e>
                {
                    bSdoSegFollows         = TRUE;
 8109b86:	4b36      	ldr	r3, [pc, #216]	@ (8109c60 <SDOS_SdoInd+0x2a4>)
 8109b88:	2201      	movs	r2, #1
 8109b8a:	701a      	strb	r2, [r3, #0]
                    bSdoSegLastToggle     = 1;
 8109b8c:	4b35      	ldr	r3, [pc, #212]	@ (8109c64 <SDOS_SdoInd+0x2a8>)
 8109b8e:	2201      	movs	r2, #1
 8109b90:	701a      	strb	r2, [r3, #0]
                    bSdoSegAccess             = bCompleteAccess;
 8109b92:	4a35      	ldr	r2, [pc, #212]	@ (8109c68 <SDOS_SdoInd+0x2ac>)
 8109b94:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8109b98:	7013      	strb	r3, [r2, #0]
                    nSdoSegIndex             = index;
 8109b9a:	4a34      	ldr	r2, [pc, #208]	@ (8109c6c <SDOS_SdoInd+0x2b0>)
 8109b9c:	8abb      	ldrh	r3, [r7, #20]
 8109b9e:	8013      	strh	r3, [r2, #0]
                    nSdoSegSubindex         = subindex;
 8109ba0:	4a33      	ldr	r2, [pc, #204]	@ (8109c70 <SDOS_SdoInd+0x2b4>)
 8109ba2:	7cfb      	ldrb	r3, [r7, #19]
 8109ba4:	7013      	strb	r3, [r2, #0]
                    pSdoSegObjEntry        = pObjEntry;
 8109ba6:	4a33      	ldr	r2, [pc, #204]	@ (8109c74 <SDOS_SdoInd+0x2b8>)
 8109ba8:	68fb      	ldr	r3, [r7, #12]
 8109baa:	6013      	str	r3, [r2, #0]
                    if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 8109bac:	7e7b      	ldrb	r3, [r7, #25]
 8109bae:	2b40      	cmp	r3, #64	@ 0x40
 8109bb0:	d103      	bne.n	8109bba <SDOS_SdoInd+0x1fe>
                        nSdoSegCompleteSize    = objLength;
 8109bb2:	4a31      	ldr	r2, [pc, #196]	@ (8109c78 <SDOS_SdoInd+0x2bc>)
 8109bb4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109bb6:	6013      	str	r3, [r2, #0]
 8109bb8:	e002      	b.n	8109bc0 <SDOS_SdoInd+0x204>
                    else
                        nSdoSegCompleteSize    = dataSize;
 8109bba:	4a2f      	ldr	r2, [pc, #188]	@ (8109c78 <SDOS_SdoInd+0x2bc>)
 8109bbc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8109bbe:	6013      	str	r3, [r2, #0]

                    if (pSdoSegData != NULL)
 8109bc0:	4b2e      	ldr	r3, [pc, #184]	@ (8109c7c <SDOS_SdoInd+0x2c0>)
 8109bc2:	681b      	ldr	r3, [r3, #0]
 8109bc4:	2b00      	cmp	r3, #0
 8109bc6:	d007      	beq.n	8109bd8 <SDOS_SdoInd+0x21c>
                    {
                        FREEMEM( (UINT16 VARMEM *) pSdoSegData);
 8109bc8:	4b2c      	ldr	r3, [pc, #176]	@ (8109c7c <SDOS_SdoInd+0x2c0>)
 8109bca:	681b      	ldr	r3, [r3, #0]
 8109bcc:	4618      	mov	r0, r3
 8109bce:	f005 fe97 	bl	810f900 <free>
                        pSdoSegData = NULL;
 8109bd2:	4b2a      	ldr	r3, [pc, #168]	@ (8109c7c <SDOS_SdoInd+0x2c0>)
 8109bd4:	2200      	movs	r2, #0
 8109bd6:	601a      	str	r2, [r3, #0]
                    }
                    pSdoSegData = (UINT16 VARMEM *) ALLOCMEM( ROUNDUPBYTE2WORD(nSdoSegCompleteSize) );
 8109bd8:	4b27      	ldr	r3, [pc, #156]	@ (8109c78 <SDOS_SdoInd+0x2bc>)
 8109bda:	681b      	ldr	r3, [r3, #0]
 8109bdc:	3301      	adds	r3, #1
 8109bde:	f023 0301 	bic.w	r3, r3, #1
 8109be2:	4618      	mov	r0, r3
 8109be4:	f005 fe84 	bl	810f8f0 <malloc>
 8109be8:	4603      	mov	r3, r0
 8109bea:	461a      	mov	r2, r3
 8109bec:	4b23      	ldr	r3, [pc, #140]	@ (8109c7c <SDOS_SdoInd+0x2c0>)
 8109bee:	601a      	str	r2, [r3, #0]

                    if ( pSdoSegData == NULL )
 8109bf0:	4b22      	ldr	r3, [pc, #136]	@ (8109c7c <SDOS_SdoInd+0x2c0>)
 8109bf2:	681b      	ldr	r3, [r3, #0]
 8109bf4:	2b00      	cmp	r3, #0
 8109bf6:	d10b      	bne.n	8109c10 <SDOS_SdoInd+0x254>
                    {
/*ECATCHANGE_START(V5.11) SDO4*/
                        if(bCompleteAccess)
 8109bf8:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8109bfc:	2b00      	cmp	r3, #0
 8109bfe:	d003      	beq.n	8109c08 <SDOS_SdoInd+0x24c>
                            abort = ABORTIDX_UNSUPPORTED_ACCESS;
 8109c00:	2305      	movs	r3, #5
 8109c02:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        } //if(pEntry) (Object handle found)
        else
        {
            abort = ABORTIDX_OBJECT_NOT_EXISTING;
        }
        break;
 8109c06:	e154      	b.n	8109eb2 <SDOS_SdoInd+0x4f6>
                            abort = ABORTIDX_OUT_OF_MEMORY;
 8109c08:	2304      	movs	r3, #4
 8109c0a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        break;
 8109c0e:	e150      	b.n	8109eb2 <SDOS_SdoInd+0x4f6>
                        if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 8109c10:	7e7b      	ldrb	r3, [r7, #25]
 8109c12:	2b40      	cmp	r3, #64	@ 0x40
 8109c14:	d175      	bne.n	8109d02 <SDOS_SdoInd+0x346>
                            abort = OBJ_Read( index, subindex, objLength, pObjEntry, (UINT16 MBXMEM *) pSdoSegData, bCompleteAccess );
 8109c16:	4b19      	ldr	r3, [pc, #100]	@ (8109c7c <SDOS_SdoInd+0x2c0>)
 8109c18:	681b      	ldr	r3, [r3, #0]
 8109c1a:	7cf9      	ldrb	r1, [r7, #19]
 8109c1c:	8ab8      	ldrh	r0, [r7, #20]
 8109c1e:	f897 202e 	ldrb.w	r2, [r7, #46]	@ 0x2e
 8109c22:	9201      	str	r2, [sp, #4]
 8109c24:	9300      	str	r3, [sp, #0]
 8109c26:	68fb      	ldr	r3, [r7, #12]
 8109c28:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8109c2a:	f7fe fc4f 	bl	81084cc <OBJ_Read>
 8109c2e:	4603      	mov	r3, r0
 8109c30:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
                            if ( abort == 0 )
 8109c34:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8109c38:	2b00      	cmp	r3, #0
 8109c3a:	d123      	bne.n	8109c84 <SDOS_SdoInd+0x2c8>
                                MBXMEMCPY( ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoInd)->Data, pSdoSegData, dataSize );
 8109c3c:	687b      	ldr	r3, [r7, #4]
 8109c3e:	3310      	adds	r3, #16
 8109c40:	4a0e      	ldr	r2, [pc, #56]	@ (8109c7c <SDOS_SdoInd+0x2c0>)
 8109c42:	6811      	ldr	r1, [r2, #0]
 8109c44:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8109c46:	4618      	mov	r0, r3
 8109c48:	f006 f8d7 	bl	810fdfa <memcpy>
                                nSdoSegService    = SDOSERVICE_UPLOADSEGMENTREQ;
 8109c4c:	4b0c      	ldr	r3, [pc, #48]	@ (8109c80 <SDOS_SdoInd+0x2c4>)
 8109c4e:	2260      	movs	r2, #96	@ 0x60
 8109c50:	701a      	strb	r2, [r3, #0]
 8109c52:	e066      	b.n	8109d22 <SDOS_SdoInd+0x366>
 8109c54:	10000bc4 	.word	0x10000bc4
 8109c58:	1000087a 	.word	0x1000087a
 8109c5c:	1000087c 	.word	0x1000087c
 8109c60:	10000bc6 	.word	0x10000bc6
 8109c64:	10000bd0 	.word	0x10000bd0
 8109c68:	10000bc7 	.word	0x10000bc7
 8109c6c:	10000bc8 	.word	0x10000bc8
 8109c70:	10000bca 	.word	0x10000bca
 8109c74:	10000bd8 	.word	0x10000bd8
 8109c78:	10000bd4 	.word	0x10000bd4
 8109c7c:	10000bb4 	.word	0x10000bb4
 8109c80:	10000bc5 	.word	0x10000bc5
                            else if ( abort == ABORTIDX_WORKING )
 8109c84:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8109c88:	2bff      	cmp	r3, #255	@ 0xff
 8109c8a:	d14a      	bne.n	8109d22 <SDOS_SdoInd+0x366>
                                u8PendingSdo = SDO_PENDING_SEG_READ;
 8109c8c:	4b96      	ldr	r3, [pc, #600]	@ (8109ee8 <SDOS_SdoInd+0x52c>)
 8109c8e:	2204      	movs	r2, #4
 8109c90:	701a      	strb	r2, [r3, #0]
                                bStoreCompleteAccess = bCompleteAccess;
 8109c92:	4a96      	ldr	r2, [pc, #600]	@ (8109eec <SDOS_SdoInd+0x530>)
 8109c94:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8109c98:	7013      	strb	r3, [r2, #0]
                                u8StoreSubindex = subindex;
 8109c9a:	4a95      	ldr	r2, [pc, #596]	@ (8109ef0 <SDOS_SdoInd+0x534>)
 8109c9c:	7cfb      	ldrb	r3, [r7, #19]
 8109c9e:	7013      	strb	r3, [r2, #0]
                                u16StoreIndex = index;
 8109ca0:	4a94      	ldr	r2, [pc, #592]	@ (8109ef4 <SDOS_SdoInd+0x538>)
 8109ca2:	8abb      	ldrh	r3, [r7, #20]
 8109ca4:	8013      	strh	r3, [r2, #0]
                                u32StoreDataSize = objLength;
 8109ca6:	4a94      	ldr	r2, [pc, #592]	@ (8109ef8 <SDOS_SdoInd+0x53c>)
 8109ca8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109caa:	6013      	str	r3, [r2, #0]
                                pStoreData = pSdoSegData;
 8109cac:	4b93      	ldr	r3, [pc, #588]	@ (8109efc <SDOS_SdoInd+0x540>)
 8109cae:	681b      	ldr	r3, [r3, #0]
 8109cb0:	4a93      	ldr	r2, [pc, #588]	@ (8109f00 <SDOS_SdoInd+0x544>)
 8109cb2:	6013      	str	r3, [r2, #0]
                                pSdoPendFunc = pObjEntry->Read;
 8109cb4:	68fb      	ldr	r3, [r7, #12]
 8109cb6:	69db      	ldr	r3, [r3, #28]
 8109cb8:	4a92      	ldr	r2, [pc, #584]	@ (8109f04 <SDOS_SdoInd+0x548>)
 8109cba:	6013      	str	r3, [r2, #0]
                                bSdoInWork = TRUE;
 8109cbc:	4b92      	ldr	r3, [pc, #584]	@ (8109f08 <SDOS_SdoInd+0x54c>)
 8109cbe:	2201      	movs	r2, #1
 8109cc0:	701a      	strb	r2, [r3, #0]
                                pSdoResStored = pSdoInd;
 8109cc2:	4a92      	ldr	r2, [pc, #584]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109cc4:	687b      	ldr	r3, [r7, #4]
 8109cc6:	6013      	str	r3, [r2, #0]
                                pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]   &= ~SDOHEADER_COMMANDMASK;
 8109cc8:	4b90      	ldr	r3, [pc, #576]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109cca:	681b      	ldr	r3, [r3, #0]
 8109ccc:	891a      	ldrh	r2, [r3, #8]
 8109cce:	4b8f      	ldr	r3, [pc, #572]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109cd0:	681b      	ldr	r3, [r3, #0]
 8109cd2:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8109cd6:	b292      	uxth	r2, r2
 8109cd8:	811a      	strh	r2, [r3, #8]
                                pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]   |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
 8109cda:	4b8c      	ldr	r3, [pc, #560]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109cdc:	681b      	ldr	r3, [r3, #0]
 8109cde:	891b      	ldrh	r3, [r3, #8]
 8109ce0:	b21a      	sxth	r2, r3
 8109ce2:	7ebb      	ldrb	r3, [r7, #26]
 8109ce4:	b21b      	sxth	r3, r3
 8109ce6:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8109cea:	b21b      	sxth	r3, r3
 8109cec:	4313      	orrs	r3, r2
 8109cee:	b21a      	sxth	r2, r3
 8109cf0:	4b86      	ldr	r3, [pc, #536]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109cf2:	681b      	ldr	r3, [r3, #0]
 8109cf4:	b292      	uxth	r2, r2
 8109cf6:	811a      	strh	r2, [r3, #8]
                                nSdoSegService    = SDOSERVICE_UPLOADSEGMENTREQ;
 8109cf8:	4b85      	ldr	r3, [pc, #532]	@ (8109f10 <SDOS_SdoInd+0x554>)
 8109cfa:	2260      	movs	r2, #96	@ 0x60
 8109cfc:	701a      	strb	r2, [r3, #0]
                                return 0;
 8109cfe:	2300      	movs	r3, #0
 8109d00:	e0ed      	b.n	8109ede <SDOS_SdoInd+0x522>
                            MBXMEMCPY( pSdoSegData, ((TINITSDODOWNLOADNORMREQMBX MBXMEM *) pSdoInd)->Data, mbxSize-DOWNLOAD_NORM_REQ_SIZE );
 8109d02:	4b7e      	ldr	r3, [pc, #504]	@ (8109efc <SDOS_SdoInd+0x540>)
 8109d04:	6818      	ldr	r0, [r3, #0]
 8109d06:	687b      	ldr	r3, [r7, #4]
 8109d08:	f103 0110 	add.w	r1, r3, #16
 8109d0c:	8afb      	ldrh	r3, [r7, #22]
 8109d0e:	3b0a      	subs	r3, #10
 8109d10:	461a      	mov	r2, r3
 8109d12:	f006 f872 	bl	810fdfa <memcpy>
                            nSdoSegService    = SDOSERVICE_DOWNLOADSEGMENTREQ;
 8109d16:	4b7e      	ldr	r3, [pc, #504]	@ (8109f10 <SDOS_SdoInd+0x554>)
 8109d18:	2200      	movs	r2, #0
 8109d1a:	701a      	strb	r2, [r3, #0]
                            dataSize = (mbxSize-DOWNLOAD_NORM_REQ_SIZE);
 8109d1c:	8afb      	ldrh	r3, [r7, #22]
 8109d1e:	3b0a      	subs	r3, #10
 8109d20:	627b      	str	r3, [r7, #36]	@ 0x24
                        nSdoSegBytesToHandle = dataSize;
 8109d22:	4a7c      	ldr	r2, [pc, #496]	@ (8109f14 <SDOS_SdoInd+0x558>)
 8109d24:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8109d26:	6013      	str	r3, [r2, #0]
        break;
 8109d28:	e0c3      	b.n	8109eb2 <SDOS_SdoInd+0x4f6>
                    if ( objLength == 0 )
 8109d2a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109d2c:	2b00      	cmp	r3, #0
 8109d2e:	d108      	bne.n	8109d42 <SDOS_SdoInd+0x386>
                        nSdoSegIndex             = index;
 8109d30:	4a79      	ldr	r2, [pc, #484]	@ (8109f18 <SDOS_SdoInd+0x55c>)
 8109d32:	8abb      	ldrh	r3, [r7, #20]
 8109d34:	8013      	strh	r3, [r2, #0]
                        nSdoSegSubindex         = subindex;
 8109d36:	4a79      	ldr	r2, [pc, #484]	@ (8109f1c <SDOS_SdoInd+0x560>)
 8109d38:	7cfb      	ldrb	r3, [r7, #19]
 8109d3a:	7013      	strb	r3, [r2, #0]
                        pSdoSegObjEntry        = pObjEntry;
 8109d3c:	4a78      	ldr	r2, [pc, #480]	@ (8109f20 <SDOS_SdoInd+0x564>)
 8109d3e:	68fb      	ldr	r3, [r7, #12]
 8109d40:	6013      	str	r3, [r2, #0]
                    if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 8109d42:	7e7b      	ldrb	r3, [r7, #25]
 8109d44:	2b40      	cmp	r3, #64	@ 0x40
 8109d46:	d149      	bne.n	8109ddc <SDOS_SdoInd+0x420>
                        abort = OBJ_Read( index, subindex, objLength, pObjEntry, pData, bCompleteAccess );
 8109d48:	7cf9      	ldrb	r1, [r7, #19]
 8109d4a:	8ab8      	ldrh	r0, [r7, #20]
 8109d4c:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8109d50:	9301      	str	r3, [sp, #4]
 8109d52:	69fb      	ldr	r3, [r7, #28]
 8109d54:	9300      	str	r3, [sp, #0]
 8109d56:	68fb      	ldr	r3, [r7, #12]
 8109d58:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 8109d5a:	f7fe fbb7 	bl	81084cc <OBJ_Read>
 8109d5e:	4603      	mov	r3, r0
 8109d60:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
                        if ( abort == ABORTIDX_WORKING )
 8109d64:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8109d68:	2bff      	cmp	r3, #255	@ 0xff
 8109d6a:	f040 80a2 	bne.w	8109eb2 <SDOS_SdoInd+0x4f6>
                            u8PendingSdo = SDO_PENDING_READ;
 8109d6e:	4b5e      	ldr	r3, [pc, #376]	@ (8109ee8 <SDOS_SdoInd+0x52c>)
 8109d70:	2203      	movs	r2, #3
 8109d72:	701a      	strb	r2, [r3, #0]
                            bStoreCompleteAccess = bCompleteAccess;
 8109d74:	4a5d      	ldr	r2, [pc, #372]	@ (8109eec <SDOS_SdoInd+0x530>)
 8109d76:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8109d7a:	7013      	strb	r3, [r2, #0]
                            u8StoreSubindex = subindex;
 8109d7c:	4a5c      	ldr	r2, [pc, #368]	@ (8109ef0 <SDOS_SdoInd+0x534>)
 8109d7e:	7cfb      	ldrb	r3, [r7, #19]
 8109d80:	7013      	strb	r3, [r2, #0]
                            u16StoreIndex = index;
 8109d82:	4a5c      	ldr	r2, [pc, #368]	@ (8109ef4 <SDOS_SdoInd+0x538>)
 8109d84:	8abb      	ldrh	r3, [r7, #20]
 8109d86:	8013      	strh	r3, [r2, #0]
                            u32StoreDataSize = objLength;
 8109d88:	4a5b      	ldr	r2, [pc, #364]	@ (8109ef8 <SDOS_SdoInd+0x53c>)
 8109d8a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109d8c:	6013      	str	r3, [r2, #0]
                            pStoreData = pData;
 8109d8e:	4a5c      	ldr	r2, [pc, #368]	@ (8109f00 <SDOS_SdoInd+0x544>)
 8109d90:	69fb      	ldr	r3, [r7, #28]
 8109d92:	6013      	str	r3, [r2, #0]
                            pSdoPendFunc = pObjEntry->Read;
 8109d94:	68fb      	ldr	r3, [r7, #12]
 8109d96:	69db      	ldr	r3, [r3, #28]
 8109d98:	4a5a      	ldr	r2, [pc, #360]	@ (8109f04 <SDOS_SdoInd+0x548>)
 8109d9a:	6013      	str	r3, [r2, #0]
                            bSdoInWork = TRUE;
 8109d9c:	4b5a      	ldr	r3, [pc, #360]	@ (8109f08 <SDOS_SdoInd+0x54c>)
 8109d9e:	2201      	movs	r2, #1
 8109da0:	701a      	strb	r2, [r3, #0]
                            pSdoResStored = pSdoInd;
 8109da2:	4a5a      	ldr	r2, [pc, #360]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109da4:	687b      	ldr	r3, [r7, #4]
 8109da6:	6013      	str	r3, [r2, #0]
                            pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COMMANDMASK;
 8109da8:	4b58      	ldr	r3, [pc, #352]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109daa:	681b      	ldr	r3, [r3, #0]
 8109dac:	891a      	ldrh	r2, [r3, #8]
 8109dae:	4b57      	ldr	r3, [pc, #348]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109db0:	681b      	ldr	r3, [r3, #0]
 8109db2:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8109db6:	b292      	uxth	r2, r2
 8109db8:	811a      	strh	r2, [r3, #8]
                            pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
 8109dba:	4b54      	ldr	r3, [pc, #336]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109dbc:	681b      	ldr	r3, [r3, #0]
 8109dbe:	891b      	ldrh	r3, [r3, #8]
 8109dc0:	b21a      	sxth	r2, r3
 8109dc2:	7ebb      	ldrb	r3, [r7, #26]
 8109dc4:	b21b      	sxth	r3, r3
 8109dc6:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8109dca:	b21b      	sxth	r3, r3
 8109dcc:	4313      	orrs	r3, r2
 8109dce:	b21a      	sxth	r2, r3
 8109dd0:	4b4e      	ldr	r3, [pc, #312]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109dd2:	681b      	ldr	r3, [r3, #0]
 8109dd4:	b292      	uxth	r2, r2
 8109dd6:	811a      	strh	r2, [r3, #8]
                            return 0;
 8109dd8:	2300      	movs	r3, #0
 8109dda:	e080      	b.n	8109ede <SDOS_SdoInd+0x522>
                        abort = OBJ_Write( index, subindex, dataSize, pObjEntry, pData, bCompleteAccess );
 8109ddc:	7cf9      	ldrb	r1, [r7, #19]
 8109dde:	8ab8      	ldrh	r0, [r7, #20]
 8109de0:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8109de4:	9301      	str	r3, [sp, #4]
 8109de6:	69fb      	ldr	r3, [r7, #28]
 8109de8:	9300      	str	r3, [sp, #0]
 8109dea:	68fb      	ldr	r3, [r7, #12]
 8109dec:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 8109dee:	f7fe fed5 	bl	8108b9c <OBJ_Write>
 8109df2:	4603      	mov	r3, r0
 8109df4:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
                        if ( abort == ABORTIDX_WORKING )
 8109df8:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8109dfc:	2bff      	cmp	r3, #255	@ 0xff
 8109dfe:	d158      	bne.n	8109eb2 <SDOS_SdoInd+0x4f6>
                            u8PendingSdo = SDO_PENDING_WRITE;
 8109e00:	4b39      	ldr	r3, [pc, #228]	@ (8109ee8 <SDOS_SdoInd+0x52c>)
 8109e02:	2201      	movs	r2, #1
 8109e04:	701a      	strb	r2, [r3, #0]
                            bStoreCompleteAccess = bCompleteAccess;
 8109e06:	4a39      	ldr	r2, [pc, #228]	@ (8109eec <SDOS_SdoInd+0x530>)
 8109e08:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
 8109e0c:	7013      	strb	r3, [r2, #0]
                            u8StoreSubindex = subindex;
 8109e0e:	4a38      	ldr	r2, [pc, #224]	@ (8109ef0 <SDOS_SdoInd+0x534>)
 8109e10:	7cfb      	ldrb	r3, [r7, #19]
 8109e12:	7013      	strb	r3, [r2, #0]
                            u16StoreIndex = index;
 8109e14:	4a37      	ldr	r2, [pc, #220]	@ (8109ef4 <SDOS_SdoInd+0x538>)
 8109e16:	8abb      	ldrh	r3, [r7, #20]
 8109e18:	8013      	strh	r3, [r2, #0]
                            u32StoreDataSize = dataSize;
 8109e1a:	4a37      	ldr	r2, [pc, #220]	@ (8109ef8 <SDOS_SdoInd+0x53c>)
 8109e1c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8109e1e:	6013      	str	r3, [r2, #0]
                            pStoreData = pData;
 8109e20:	4a37      	ldr	r2, [pc, #220]	@ (8109f00 <SDOS_SdoInd+0x544>)
 8109e22:	69fb      	ldr	r3, [r7, #28]
 8109e24:	6013      	str	r3, [r2, #0]
                            pSdoPendFunc = pObjEntry->Write;
 8109e26:	68fb      	ldr	r3, [r7, #12]
 8109e28:	6a1b      	ldr	r3, [r3, #32]
 8109e2a:	4a36      	ldr	r2, [pc, #216]	@ (8109f04 <SDOS_SdoInd+0x548>)
 8109e2c:	6013      	str	r3, [r2, #0]
                            bSdoInWork = TRUE;
 8109e2e:	4b36      	ldr	r3, [pc, #216]	@ (8109f08 <SDOS_SdoInd+0x54c>)
 8109e30:	2201      	movs	r2, #1
 8109e32:	701a      	strb	r2, [r3, #0]
                            pSdoResStored = pSdoInd;
 8109e34:	4a35      	ldr	r2, [pc, #212]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109e36:	687b      	ldr	r3, [r7, #4]
 8109e38:	6013      	str	r3, [r2, #0]
                            pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] &= ~SDOHEADER_COMMANDMASK;
 8109e3a:	4b34      	ldr	r3, [pc, #208]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109e3c:	681b      	ldr	r3, [r3, #0]
 8109e3e:	891a      	ldrh	r2, [r3, #8]
 8109e40:	4b32      	ldr	r3, [pc, #200]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109e42:	681b      	ldr	r3, [r3, #0]
 8109e44:	f022 02ff 	bic.w	r2, r2, #255	@ 0xff
 8109e48:	b292      	uxth	r2, r2
 8109e4a:	811a      	strh	r2, [r3, #8]
                            pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET]    |= (sdoHeader & (SDOHEADER_COMPLETEACCESS | SDOHEADER_COMMAND));
 8109e4c:	4b2f      	ldr	r3, [pc, #188]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109e4e:	681b      	ldr	r3, [r3, #0]
 8109e50:	891b      	ldrh	r3, [r3, #8]
 8109e52:	b21a      	sxth	r2, r3
 8109e54:	7ebb      	ldrb	r3, [r7, #26]
 8109e56:	b21b      	sxth	r3, r3
 8109e58:	f003 03f0 	and.w	r3, r3, #240	@ 0xf0
 8109e5c:	b21b      	sxth	r3, r3
 8109e5e:	4313      	orrs	r3, r2
 8109e60:	b21a      	sxth	r2, r3
 8109e62:	4b2a      	ldr	r3, [pc, #168]	@ (8109f0c <SDOS_SdoInd+0x550>)
 8109e64:	681b      	ldr	r3, [r3, #0]
 8109e66:	b292      	uxth	r2, r2
 8109e68:	811a      	strh	r2, [r3, #8]
                            return 0;
 8109e6a:	2300      	movs	r3, #0
 8109e6c:	e037      	b.n	8109ede <SDOS_SdoInd+0x522>
            abort = ABORTIDX_OBJECT_NOT_EXISTING;
 8109e6e:	2308      	movs	r3, #8
 8109e70:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        break;
 8109e74:	e01d      	b.n	8109eb2 <SDOS_SdoInd+0x4f6>

    case SDOSERVICE_DOWNLOADSEGMENTREQ:
    case SDOSERVICE_UPLOADSEGMENTREQ:
        if ( command == nSdoSegService )
 8109e76:	4b26      	ldr	r3, [pc, #152]	@ (8109f10 <SDOS_SdoInd+0x554>)
 8109e78:	781b      	ldrb	r3, [r3, #0]
 8109e7a:	7e7a      	ldrb	r2, [r7, #25]
 8109e7c:	429a      	cmp	r2, r3
 8109e7e:	d110      	bne.n	8109ea2 <SDOS_SdoInd+0x4e6>
        {
            if ( command == SDOSERVICE_DOWNLOADSEGMENTREQ )
 8109e80:	7e7b      	ldrb	r3, [r7, #25]
 8109e82:	2b00      	cmp	r3, #0
 8109e84:	d106      	bne.n	8109e94 <SDOS_SdoInd+0x4d8>
                abort = SdoDownloadSegmentInd( (TDOWNLOADSDOSEGREQMBX MBXMEM *) pSdoInd );
 8109e86:	6878      	ldr	r0, [r7, #4]
 8109e88:	f7ff f9f8 	bl	810927c <SdoDownloadSegmentInd>
 8109e8c:	4603      	mov	r3, r0
 8109e8e:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
            else
                abort = SdoUploadSegmentInd( (TUPLOADSDOSEGREQMBX MBXMEM *) pSdoInd );
        }
        else
            abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
        break;
 8109e92:	e00f      	b.n	8109eb4 <SDOS_SdoInd+0x4f8>
                abort = SdoUploadSegmentInd( (TUPLOADSDOSEGREQMBX MBXMEM *) pSdoInd );
 8109e94:	6878      	ldr	r0, [r7, #4]
 8109e96:	f7ff fbb1 	bl	81095fc <SdoUploadSegmentInd>
 8109e9a:	4603      	mov	r3, r0
 8109e9c:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        break;
 8109ea0:	e008      	b.n	8109eb4 <SDOS_SdoInd+0x4f8>
            abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
 8109ea2:	2303      	movs	r3, #3
 8109ea4:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        break;
 8109ea8:	e004      	b.n	8109eb4 <SDOS_SdoInd+0x4f8>

    default:
        abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
 8109eaa:	2303      	movs	r3, #3
 8109eac:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
        break;
 8109eb0:	e000      	b.n	8109eb4 <SDOS_SdoInd+0x4f8>
        break;
 8109eb2:	bf00      	nop
    }

    if(abort != ABORTIDX_WORKING)
 8109eb4:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 8109eb8:	2bff      	cmp	r3, #255	@ 0xff
 8109eba:	d00f      	beq.n	8109edc <SDOS_SdoInd+0x520>
    {
        /*  type cast was added because of warning */
        SdoRes(abort, command, (UINT8) (sdoHeader & SDOHEADER_COMPLETEACCESS), (UINT16) dataSize, objLength, pSdoInd);
 8109ebc:	7ebb      	ldrb	r3, [r7, #26]
 8109ebe:	f003 0310 	and.w	r3, r3, #16
 8109ec2:	b2da      	uxtb	r2, r3
 8109ec4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 8109ec6:	b29c      	uxth	r4, r3
 8109ec8:	7e79      	ldrb	r1, [r7, #25]
 8109eca:	f897 002f 	ldrb.w	r0, [r7, #47]	@ 0x2f
 8109ece:	687b      	ldr	r3, [r7, #4]
 8109ed0:	9301      	str	r3, [sp, #4]
 8109ed2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 8109ed4:	9300      	str	r3, [sp, #0]
 8109ed6:	4623      	mov	r3, r4
 8109ed8:	f7ff fcb2 	bl	8109840 <SdoRes>
    }

    return 0;
 8109edc:	2300      	movs	r3, #0
}
 8109ede:	4618      	mov	r0, r3
 8109ee0:	3734      	adds	r7, #52	@ 0x34
 8109ee2:	46bd      	mov	sp, r7
 8109ee4:	bd90      	pop	{r4, r7, pc}
 8109ee6:	bf00      	nop
 8109ee8:	10000b90 	.word	0x10000b90
 8109eec:	10000b91 	.word	0x10000b91
 8109ef0:	10000b92 	.word	0x10000b92
 8109ef4:	10000b94 	.word	0x10000b94
 8109ef8:	10000b98 	.word	0x10000b98
 8109efc:	10000bb4 	.word	0x10000bb4
 8109f00:	10000b9c 	.word	0x10000b9c
 8109f04:	10000ba0 	.word	0x10000ba0
 8109f08:	10000bc4 	.word	0x10000bc4
 8109f0c:	10000bc0 	.word	0x10000bc0
 8109f10:	10000bc5 	.word	0x10000bc5
 8109f14:	10000bcc 	.word	0x10000bcc
 8109f18:	10000bc8 	.word	0x10000bc8
 8109f1c:	10000bca 	.word	0x10000bca
 8109f20:	10000bd8 	.word	0x10000bd8

08109f24 <SDOS_SdoRes>:

 \brief    This function is called when a SDO response shall be sent
*////////////////////////////////////////////////////////////////////////////////////////

void SDOS_SdoRes(UINT8 abort, UINT32 objLength, UINT16 MBXMEM *pData)
{
 8109f24:	b590      	push	{r4, r7, lr}
 8109f26:	b089      	sub	sp, #36	@ 0x24
 8109f28:	af02      	add	r7, sp, #8
 8109f2a:	4603      	mov	r3, r0
 8109f2c:	60b9      	str	r1, [r7, #8]
 8109f2e:	607a      	str	r2, [r7, #4]
 8109f30:	73fb      	strb	r3, [r7, #15]
    UINT16 dataSize = 0;
 8109f32:	2300      	movs	r3, #0
 8109f34:	82fb      	strh	r3, [r7, #22]

    if (bSdoInWork)
 8109f36:	4b38      	ldr	r3, [pc, #224]	@ (810a018 <SDOS_SdoRes+0xf4>)
 8109f38:	781b      	ldrb	r3, [r3, #0]
 8109f3a:	2b00      	cmp	r3, #0
 8109f3c:	d068      	beq.n	810a010 <SDOS_SdoRes+0xec>
    {
        /* SDO-Response is expected */
        UINT8 command = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMMAND;
 8109f3e:	4b37      	ldr	r3, [pc, #220]	@ (810a01c <SDOS_SdoRes+0xf8>)
 8109f40:	681b      	ldr	r3, [r3, #0]
 8109f42:	891b      	ldrh	r3, [r3, #8]
 8109f44:	b2db      	uxtb	r3, r3
 8109f46:	f023 031f 	bic.w	r3, r3, #31
 8109f4a:	757b      	strb	r3, [r7, #21]
        UINT8 completeAccess = pSdoResStored->SdoHeader.Sdo[SDOHEADER_COMMANDOFFSET] & SDOHEADER_COMPLETEACCESS;
 8109f4c:	4b33      	ldr	r3, [pc, #204]	@ (810a01c <SDOS_SdoRes+0xf8>)
 8109f4e:	681b      	ldr	r3, [r3, #0]
 8109f50:	891b      	ldrh	r3, [r3, #8]
 8109f52:	b2db      	uxtb	r3, r3
 8109f54:	f003 0310 	and.w	r3, r3, #16
 8109f58:	753b      	strb	r3, [r7, #20]

        if ( command == SDOSERVICE_INITIATEUPLOADREQ )
 8109f5a:	7d7b      	ldrb	r3, [r7, #21]
 8109f5c:	2b40      	cmp	r3, #64	@ 0x40
 8109f5e:	d148      	bne.n	8109ff2 <SDOS_SdoRes+0xce>
        {
            /* dataSize contains the available size in one mailbox */
            dataSize = u16SendMbxSize - MBX_HEADER_SIZE - UPLOAD_NORM_RES_SIZE;
 8109f60:	4b2f      	ldr	r3, [pc, #188]	@ (810a020 <SDOS_SdoRes+0xfc>)
 8109f62:	881b      	ldrh	r3, [r3, #0]
 8109f64:	3b10      	subs	r3, #16
 8109f66:	82fb      	strh	r3, [r7, #22]
            if ( dataSize < objLength )
 8109f68:	8afb      	ldrh	r3, [r7, #22]
 8109f6a:	68ba      	ldr	r2, [r7, #8]
 8109f6c:	429a      	cmp	r2, r3
 8109f6e:	d91d      	bls.n	8109fac <SDOS_SdoRes+0x88>
            {
                /* Segmented Upload, the variables for the segmented transfer should be initialized */
                bSdoSegFollows         = TRUE;
 8109f70:	4b2c      	ldr	r3, [pc, #176]	@ (810a024 <SDOS_SdoRes+0x100>)
 8109f72:	2201      	movs	r2, #1
 8109f74:	701a      	strb	r2, [r3, #0]
                bSdoSegLastToggle     = 1;
 8109f76:	4b2c      	ldr	r3, [pc, #176]	@ (810a028 <SDOS_SdoRes+0x104>)
 8109f78:	2201      	movs	r2, #1
 8109f7a:	701a      	strb	r2, [r3, #0]
                bSdoSegAccess             = completeAccess;
 8109f7c:	4a2b      	ldr	r2, [pc, #172]	@ (810a02c <SDOS_SdoRes+0x108>)
 8109f7e:	7d3b      	ldrb	r3, [r7, #20]
 8109f80:	7013      	strb	r3, [r2, #0]
                nSdoSegCompleteSize    = objLength;
 8109f82:	4a2b      	ldr	r2, [pc, #172]	@ (810a030 <SDOS_SdoRes+0x10c>)
 8109f84:	68bb      	ldr	r3, [r7, #8]
 8109f86:	6013      	str	r3, [r2, #0]
                nSdoSegService            = SDOSERVICE_UPLOADSEGMENTREQ;
 8109f88:	4b2a      	ldr	r3, [pc, #168]	@ (810a034 <SDOS_SdoRes+0x110>)
 8109f8a:	2260      	movs	r2, #96	@ 0x60
 8109f8c:	701a      	strb	r2, [r3, #0]
                pSdoSegData                = (UINT16 VARMEM *) pData;
 8109f8e:	4a2a      	ldr	r2, [pc, #168]	@ (810a038 <SDOS_SdoRes+0x114>)
 8109f90:	687b      	ldr	r3, [r7, #4]
 8109f92:	6013      	str	r3, [r2, #0]
                /* the first segment shall be copied */
                MBXMEMCPY(((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, dataSize);
 8109f94:	4b21      	ldr	r3, [pc, #132]	@ (810a01c <SDOS_SdoRes+0xf8>)
 8109f96:	681b      	ldr	r3, [r3, #0]
 8109f98:	3310      	adds	r3, #16
 8109f9a:	8afa      	ldrh	r2, [r7, #22]
 8109f9c:	6879      	ldr	r1, [r7, #4]
 8109f9e:	4618      	mov	r0, r3
 8109fa0:	f005 ff2b 	bl	810fdfa <memcpy>
                nSdoSegBytesToHandle = dataSize;
 8109fa4:	8afb      	ldrh	r3, [r7, #22]
 8109fa6:	4a25      	ldr	r2, [pc, #148]	@ (810a03c <SDOS_SdoRes+0x118>)
 8109fa8:	6013      	str	r3, [r2, #0]
 8109faa:	e022      	b.n	8109ff2 <SDOS_SdoRes+0xce>
            }
            else
            if ( (objLength <= 4) && (objLength > 0) )
 8109fac:	68bb      	ldr	r3, [r7, #8]
 8109fae:	2b04      	cmp	r3, #4
 8109fb0:	d811      	bhi.n	8109fd6 <SDOS_SdoRes+0xb2>
 8109fb2:	68bb      	ldr	r3, [r7, #8]
 8109fb4:	2b00      	cmp	r3, #0
 8109fb6:	d00e      	beq.n	8109fd6 <SDOS_SdoRes+0xb2>
            {
                /* Expedited response */
                if ( pData != ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data )
 8109fb8:	4b18      	ldr	r3, [pc, #96]	@ (810a01c <SDOS_SdoRes+0xf8>)
 8109fba:	681b      	ldr	r3, [r3, #0]
 8109fbc:	330c      	adds	r3, #12
 8109fbe:	687a      	ldr	r2, [r7, #4]
 8109fc0:	429a      	cmp	r2, r3
 8109fc2:	d016      	beq.n	8109ff2 <SDOS_SdoRes+0xce>
                {
                    /* the data is not in the response buffer yet, it shall be copied */
                    MBXMEMCPY(((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data, pData, objLength);
 8109fc4:	4b15      	ldr	r3, [pc, #84]	@ (810a01c <SDOS_SdoRes+0xf8>)
 8109fc6:	681b      	ldr	r3, [r3, #0]
 8109fc8:	330c      	adds	r3, #12
 8109fca:	68ba      	ldr	r2, [r7, #8]
 8109fcc:	6879      	ldr	r1, [r7, #4]
 8109fce:	4618      	mov	r0, r3
 8109fd0:	f005 ff13 	bl	810fdfa <memcpy>
                if ( pData != ((TINITSDOUPLOADEXPRESMBX MBXMEM *) pSdoResStored)->Data )
 8109fd4:	e00d      	b.n	8109ff2 <SDOS_SdoRes+0xce>
                }
            }
            else
            {
                /* Normal response */
                if ( pData != ((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data )
 8109fd6:	4b11      	ldr	r3, [pc, #68]	@ (810a01c <SDOS_SdoRes+0xf8>)
 8109fd8:	681b      	ldr	r3, [r3, #0]
 8109fda:	3310      	adds	r3, #16
 8109fdc:	687a      	ldr	r2, [r7, #4]
 8109fde:	429a      	cmp	r2, r3
 8109fe0:	d007      	beq.n	8109ff2 <SDOS_SdoRes+0xce>
                {
                    /* the data is not in the response buffer yet, it shall be copied */
                    MBXMEMCPY(((TINITSDOUPLOADNORMRESMBX MBXMEM *) pSdoResStored)->Data, pData, objLength);
 8109fe2:	4b0e      	ldr	r3, [pc, #56]	@ (810a01c <SDOS_SdoRes+0xf8>)
 8109fe4:	681b      	ldr	r3, [r3, #0]
 8109fe6:	3310      	adds	r3, #16
 8109fe8:	68ba      	ldr	r2, [r7, #8]
 8109fea:	6879      	ldr	r1, [r7, #4]
 8109fec:	4618      	mov	r0, r3
 8109fee:	f005 ff04 	bl	810fdfa <memcpy>
                }
            }
        }

        /* SDO access is finished, send the response */
        bSdoInWork = FALSE;
 8109ff2:	4b09      	ldr	r3, [pc, #36]	@ (810a018 <SDOS_SdoRes+0xf4>)
 8109ff4:	2200      	movs	r2, #0
 8109ff6:	701a      	strb	r2, [r3, #0]
        SdoRes(abort, command, completeAccess, dataSize, objLength, pSdoResStored);
 8109ff8:	4b08      	ldr	r3, [pc, #32]	@ (810a01c <SDOS_SdoRes+0xf8>)
 8109ffa:	681b      	ldr	r3, [r3, #0]
 8109ffc:	8afc      	ldrh	r4, [r7, #22]
 8109ffe:	7d3a      	ldrb	r2, [r7, #20]
 810a000:	7d79      	ldrb	r1, [r7, #21]
 810a002:	7bf8      	ldrb	r0, [r7, #15]
 810a004:	9301      	str	r3, [sp, #4]
 810a006:	68bb      	ldr	r3, [r7, #8]
 810a008:	9300      	str	r3, [sp, #0]
 810a00a:	4623      	mov	r3, r4
 810a00c:	f7ff fc18 	bl	8109840 <SdoRes>
    }
}
 810a010:	bf00      	nop
 810a012:	371c      	adds	r7, #28
 810a014:	46bd      	mov	sp, r7
 810a016:	bd90      	pop	{r4, r7, pc}
 810a018:	10000bc4 	.word	0x10000bc4
 810a01c:	10000bc0 	.word	0x10000bc0
 810a020:	1000087a 	.word	0x1000087a
 810a024:	10000bc6 	.word	0x10000bc6
 810a028:	10000bd0 	.word	0x10000bd0
 810a02c:	10000bc7 	.word	0x10000bc7
 810a030:	10000bd4 	.word	0x10000bd4
 810a034:	10000bc5 	.word	0x10000bc5
 810a038:	10000bb4 	.word	0x10000bb4
 810a03c:	10000bcc 	.word	0x10000bcc

0810a040 <SDOS_SdoInfoInd>:
            is received from the master and calls depending from
            the opcode the concerning function.
*////////////////////////////////////////////////////////////////////////////////////////

UINT8 SDOS_SdoInfoInd( TSDOINFORMATION MBXMEM *pSdoInfoInd )
{
 810a040:	b590      	push	{r4, r7, lr}
 810a042:	b08f      	sub	sp, #60	@ 0x3c
 810a044:	af02      	add	r7, sp, #8
 810a046:	6078      	str	r0, [r7, #4]
    UINT8 abort = 0;
 810a048:	2300      	movs	r3, #0
 810a04a:	73fb      	strb	r3, [r7, #15]
    /* the variable opCode contains the requested SDO Information type */
    UINT8 opCode = (UINT8) ((pSdoInfoInd->SdoHeader.InfoHead & INFOHEAD_OPCODE_MASK) >> INFOHEAD_OPCODE_SHIFT);
 810a04c:	687b      	ldr	r3, [r7, #4]
 810a04e:	891b      	ldrh	r3, [r3, #8]
 810a050:	b2db      	uxtb	r3, r3
 810a052:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 810a056:	f887 3021 	strb.w	r3, [r7, #33]	@ 0x21
    OBJCONST TOBJECT OBJMEM * pObjEntry;
    UINT16 index;
    UINT8 flags = COE_SERVICE;
 810a05a:	2302      	movs	r3, #2
 810a05c:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f

    /* it has to be checked if the mailbox protocol is correct, the sent mailbox data length has to
       great enough for the service header of the requested SDO Information type */
    if ( opCode == SDOINFOSERVICE_ENTRYDESCRIPTION_Q )
 810a060:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 810a064:	2b05      	cmp	r3, #5
 810a066:	d105      	bne.n	810a074 <SDOS_SdoInfoInd+0x34>
    {
        if ( pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOENTRYREQSTRUCT )
 810a068:	687b      	ldr	r3, [r7, #4]
 810a06a:	881b      	ldrh	r3, [r3, #0]
 810a06c:	2b09      	cmp	r3, #9
 810a06e:	d807      	bhi.n	810a080 <SDOS_SdoInfoInd+0x40>
            return MBXERR_SIZETOOSHORT;
 810a070:	2306      	movs	r3, #6
 810a072:	e1d6      	b.n	810a422 <SDOS_SdoInfoInd+0x3e2>
    }
    else
    {
        if ( pSdoInfoInd->MbxHeader.Length < SIZEOF_SDOINFOLISTSTRUCT )
 810a074:	687b      	ldr	r3, [r7, #4]
 810a076:	881b      	ldrh	r3, [r3, #0]
 810a078:	2b07      	cmp	r3, #7
 810a07a:	d801      	bhi.n	810a080 <SDOS_SdoInfoInd+0x40>
            return MBXERR_SIZETOOSHORT;
 810a07c:	2306      	movs	r3, #6
 810a07e:	e1d0      	b.n	810a422 <SDOS_SdoInfoInd+0x3e2>
    }

    switch ( opCode )
 810a080:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 810a084:	2b05      	cmp	r3, #5
 810a086:	f000 80c9 	beq.w	810a21c <SDOS_SdoInfoInd+0x1dc>
 810a08a:	2b05      	cmp	r3, #5
 810a08c:	f300 8195 	bgt.w	810a3ba <SDOS_SdoInfoInd+0x37a>
 810a090:	2b01      	cmp	r3, #1
 810a092:	d003      	beq.n	810a09c <SDOS_SdoInfoInd+0x5c>
 810a094:	2b03      	cmp	r3, #3
 810a096:	f000 80c1 	beq.w	810a21c <SDOS_SdoInfoInd+0x1dc>
 810a09a:	e18e      	b.n	810a3ba <SDOS_SdoInfoInd+0x37a>
    {
    case SDOINFOSERVICE_OBJDICTIONARYLIST_Q:
        /* an object list is requested, check if the list type is supported */
        if ( SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType) <= INFO_LIST_TYPE_MAX )
 810a09c:	687b      	ldr	r3, [r7, #4]
 810a09e:	899b      	ldrh	r3, [r3, #12]
 810a0a0:	2b05      	cmp	r3, #5
 810a0a2:	f200 818d 	bhi.w	810a3c0 <SDOS_SdoInfoInd+0x380>
        {
            UINT16 size = 0;
 810a0a6:	2300      	movs	r3, #0
 810a0a8:	85bb      	strh	r3, [r7, #44]	@ 0x2c
            /* the variable listType contains the requested listType */
            UINT8 listType = (UINT8) SWAPWORD(pSdoInfoInd->SdoHeader.Data.List.ListType);
 810a0aa:	687b      	ldr	r3, [r7, #4]
 810a0ac:	899b      	ldrh	r3, [r3, #12]
 810a0ae:	75fb      	strb	r3, [r7, #23]

            /* the SDO Information Header has to be stored because this function will be
               called again if the response could not be sent with one mailbox service, the
               variable nSdoInfoFragmentsLeft is 0 zero for the first call and unequal 0
               for the following calls */
            MBXMEMCPY(aSdoInfoHeader, pSdoInfoInd, SDO_INFO_HEADER_BYTE_SIZE);
 810a0b0:	220e      	movs	r2, #14
 810a0b2:	6879      	ldr	r1, [r7, #4]
 810a0b4:	489c      	ldr	r0, [pc, #624]	@ (810a328 <SDOS_SdoInfoInd+0x2e8>)
 810a0b6:	f005 fea0 	bl	810fdfa <memcpy>
            if ( listType-- == 0 )
 810a0ba:	7dfb      	ldrb	r3, [r7, #23]
 810a0bc:	1e5a      	subs	r2, r3, #1
 810a0be:	75fa      	strb	r2, [r7, #23]
 810a0c0:	2b00      	cmp	r3, #0
 810a0c2:	d122      	bne.n	810a10a <SDOS_SdoInfoInd+0xca>
                /* List-Type 0: length of the lists */
                UINT8 i;

                /* the needed mailbox size for List-Type 0 response is just 24 bytes, the mailbox has always
                   to be at least 24 bytes to support the SDO Information service */
                nSdoInfoFragmentsLeft = 0;
 810a0c4:	4b99      	ldr	r3, [pc, #612]	@ (810a32c <SDOS_SdoInfoInd+0x2ec>)
 810a0c6:	2200      	movs	r2, #0
 810a0c8:	801a      	strh	r2, [r3, #0]
                for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
 810a0ca:	2300      	movs	r3, #0
 810a0cc:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
 810a0d0:	e014      	b.n	810a0fc <SDOS_SdoInfoInd+0xbc>
                {
                    UINT16 n = OBJ_GetNoOfObjects(i);
 810a0d2:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 810a0d6:	4618      	mov	r0, r3
 810a0d8:	f7fd fea4 	bl	8107e24 <OBJ_GetNoOfObjects>
 810a0dc:	4603      	mov	r3, r0
 810a0de:	823b      	strh	r3, [r7, #16]

                    /* copy the number of objects of the list type in the SDO Information response */
                    ((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[(SIZEOF_SDOINFOLISTSTRUCT>>1)+i] = SWAPWORD(n);
 810a0e0:	687b      	ldr	r3, [r7, #4]
 810a0e2:	1d9a      	adds	r2, r3, #6
 810a0e4:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 810a0e8:	3304      	adds	r3, #4
 810a0ea:	005b      	lsls	r3, r3, #1
 810a0ec:	4413      	add	r3, r2
 810a0ee:	8a3a      	ldrh	r2, [r7, #16]
 810a0f0:	801a      	strh	r2, [r3, #0]
                for (i = 0; i < INFO_LIST_TYPE_MAX; i++)
 810a0f2:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 810a0f6:	3301      	adds	r3, #1
 810a0f8:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
 810a0fc:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
 810a100:	2b04      	cmp	r3, #4
 810a102:	d9e6      	bls.n	810a0d2 <SDOS_SdoInfoInd+0x92>
                }

                /* size of the mailbox service response */
                size = (INFO_LIST_TYPE_MAX << 1) + SIZEOF_SDOINFOLISTSTRUCT;
 810a104:	2312      	movs	r3, #18
 810a106:	85bb      	strh	r3, [r7, #44]	@ 0x2c
 810a108:	e058      	b.n	810a1bc <SDOS_SdoInfoInd+0x17c>
            }
            else
            {
                /* object list with indexes is requested */
                UINT16 MBXMEM * pData;
                UINT16 n = 0;
 810a10a:	2300      	movs	r3, #0
 810a10c:	82bb      	strh	r3, [r7, #20]

                if ( nSdoInfoFragmentsLeft )
 810a10e:	4b87      	ldr	r3, [pc, #540]	@ (810a32c <SDOS_SdoInfoInd+0x2ec>)
 810a110:	881b      	ldrh	r3, [r3, #0]
 810a112:	2b00      	cmp	r3, #0
 810a114:	d011      	beq.n	810a13a <SDOS_SdoInfoInd+0xfa>
                {
                    /* the next fragment of the SDO Information response shall be sent */
                    /* initialize size with the maximum size fits into one mailbox service */
                    {
                        size = u16SendMbxSize - SIZEOF_SDOINFO - MBX_HEADER_SIZE;
 810a116:	4b86      	ldr	r3, [pc, #536]	@ (810a330 <SDOS_SdoInfoInd+0x2f0>)
 810a118:	881b      	ldrh	r3, [r3, #0]
 810a11a:	3b0c      	subs	r3, #12
 810a11c:	85bb      	strh	r3, [r7, #44]	@ 0x2c
                    }
                    /* initialize pData with the pointer where the fragment has to be copied */
                    pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFO>>1];
 810a11e:	687b      	ldr	r3, [r7, #4]
 810a120:	3306      	adds	r3, #6
 810a122:	3306      	adds	r3, #6
 810a124:	627b      	str	r3, [r7, #36]	@ 0x24
                    /* initialize index with the next index to be sent */
                    index = nSdoInfoIndex;
 810a126:	4b83      	ldr	r3, [pc, #524]	@ (810a334 <SDOS_SdoInfoInd+0x2f4>)
 810a128:	881b      	ldrh	r3, [r3, #0]
 810a12a:	81bb      	strh	r3, [r7, #12]
                    /* decrement the number of fragments to be sent */
                    nSdoInfoFragmentsLeft--;
 810a12c:	4b7f      	ldr	r3, [pc, #508]	@ (810a32c <SDOS_SdoInfoInd+0x2ec>)
 810a12e:	881b      	ldrh	r3, [r3, #0]
 810a130:	3b01      	subs	r3, #1
 810a132:	b29a      	uxth	r2, r3
 810a134:	4b7d      	ldr	r3, [pc, #500]	@ (810a32c <SDOS_SdoInfoInd+0x2ec>)
 810a136:	801a      	strh	r2, [r3, #0]
 810a138:	e029      	b.n	810a18e <SDOS_SdoInfoInd+0x14e>
                }
                else
                {
                    /* the first fragment of the SDO Information response has to be sent */
                    /* get the number of objects of the requested object list */
                    n = OBJ_GetNoOfObjects(listType);
 810a13a:	7dfb      	ldrb	r3, [r7, #23]
 810a13c:	4618      	mov	r0, r3
 810a13e:	f7fd fe71 	bl	8107e24 <OBJ_GetNoOfObjects>
 810a142:	4603      	mov	r3, r0
 810a144:	82bb      	strh	r3, [r7, #20]
                    /* we start with index 0x1000 */
                    index = 0x1000;
 810a146:	f44f 5380 	mov.w	r3, #4096	@ 0x1000
 810a14a:	81bb      	strh	r3, [r7, #12]
                    /* initialize size with the maximum size fits into one mailbox service */
                    {
                        size = u16SendMbxSize - SIZEOF_SDOINFOLISTSTRUCT - MBX_HEADER_SIZE;
 810a14c:	4b78      	ldr	r3, [pc, #480]	@ (810a330 <SDOS_SdoInfoInd+0x2f0>)
 810a14e:	881b      	ldrh	r3, [r3, #0]
 810a150:	3b0e      	subs	r3, #14
 810a152:	85bb      	strh	r3, [r7, #44]	@ 0x2c
                    }
                    /* initialize pData with the pointer where the fragment has to be copied */
                    pData = &((UINT16 MBXMEM *) &pSdoInfoInd->CoeHeader)[SIZEOF_SDOINFOLISTSTRUCT>>1];
 810a154:	687b      	ldr	r3, [r7, #4]
 810a156:	3306      	adds	r3, #6
 810a158:	3308      	adds	r3, #8
 810a15a:	627b      	str	r3, [r7, #36]	@ 0x24
                    /*Check if List need to be send in fragments*/
                    if( (n<<1) > size)
 810a15c:	8abb      	ldrh	r3, [r7, #20]
 810a15e:	005a      	lsls	r2, r3, #1
 810a160:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 810a162:	429a      	cmp	r2, r3
 810a164:	dd10      	ble.n	810a188 <SDOS_SdoInfoInd+0x148>
                        /*number of Bytes to transmit don't fit into one mailbox datagram*/

                        /*calculate number of fragments which need to be send
                        total number of bytes - bytes which will be transmitted with the current response plus the fragment size - 1 (to round up) divided by the size of the following fragments 
                        */
                        UINT16 Fragsize = size + 2;
 810a166:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 810a168:	3302      	adds	r3, #2
 810a16a:	827b      	strh	r3, [r7, #18]
                        nSdoInfoFragmentsLeft = (((n<<1)-size + (Fragsize-1)) /Fragsize);
 810a16c:	8abb      	ldrh	r3, [r7, #20]
 810a16e:	005a      	lsls	r2, r3, #1
 810a170:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 810a172:	1ad2      	subs	r2, r2, r3
 810a174:	8a7b      	ldrh	r3, [r7, #18]
 810a176:	3b01      	subs	r3, #1
 810a178:	441a      	add	r2, r3
 810a17a:	8a7b      	ldrh	r3, [r7, #18]
 810a17c:	fb92 f3f3 	sdiv	r3, r2, r3
 810a180:	b29a      	uxth	r2, r3
 810a182:	4b6a      	ldr	r3, [pc, #424]	@ (810a32c <SDOS_SdoInfoInd+0x2ec>)
 810a184:	801a      	strh	r2, [r3, #0]
 810a186:	e002      	b.n	810a18e <SDOS_SdoInfoInd+0x14e>
                    }
                    else
                    {
                        nSdoInfoFragmentsLeft = 0;
 810a188:	4b68      	ldr	r3, [pc, #416]	@ (810a32c <SDOS_SdoInfoInd+0x2ec>)
 810a18a:	2200      	movs	r2, #0
 810a18c:	801a      	strh	r2, [r3, #0]
                    }
                }

                /* get the next part of the requested object list */
                size = OBJ_GetObjectList(listType, &index, size, pData,&abort);
 810a18e:	7dfb      	ldrb	r3, [r7, #23]
 810a190:	b298      	uxth	r0, r3
 810a192:	8dba      	ldrh	r2, [r7, #44]	@ 0x2c
 810a194:	f107 010c 	add.w	r1, r7, #12
 810a198:	f107 030f 	add.w	r3, r7, #15
 810a19c:	9300      	str	r3, [sp, #0]
 810a19e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a1a0:	f7fd fe8c 	bl	8107ebc <OBJ_GetObjectList>
 810a1a4:	4603      	mov	r3, r0
 810a1a6:	85bb      	strh	r3, [r7, #44]	@ 0x2c

                /* store index for next fragment */
                nSdoInfoIndex = index;
 810a1a8:	89ba      	ldrh	r2, [r7, #12]
 810a1aa:	4b62      	ldr	r3, [pc, #392]	@ (810a334 <SDOS_SdoInfoInd+0x2f4>)
 810a1ac:	801a      	strh	r2, [r3, #0]
                /* size contains before the instruction the size still available in the mailbox buffer
                    and shall contain the size of the mailbox response data after the next instruction */
                {
                    size = u16SendMbxSize - size - MBX_HEADER_SIZE;
 810a1ae:	4b60      	ldr	r3, [pc, #384]	@ (810a330 <SDOS_SdoInfoInd+0x2f0>)
 810a1b0:	881a      	ldrh	r2, [r3, #0]
 810a1b2:	8dbb      	ldrh	r3, [r7, #44]	@ 0x2c
 810a1b4:	1ad3      	subs	r3, r2, r3
 810a1b6:	b29b      	uxth	r3, r3
 810a1b8:	3b06      	subs	r3, #6
 810a1ba:	85bb      	strh	r3, [r7, #44]	@ 0x2c
                }
            }

            /* size of the mailbox response data */
            pSdoInfoInd->MbxHeader.Length    = size;
 810a1bc:	687b      	ldr	r3, [r7, #4]
 810a1be:	8dba      	ldrh	r2, [r7, #44]	@ 0x2c
 810a1c0:	801a      	strh	r2, [r3, #0]

            if(abort == 0)
 810a1c2:	7bfb      	ldrb	r3, [r7, #15]
 810a1c4:	2b00      	cmp	r3, #0
 810a1c6:	f040 80fb 	bne.w	810a3c0 <SDOS_SdoInfoInd+0x380>
            {
             pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
 810a1ca:	687b      	ldr	r3, [r7, #4]
 810a1cc:	891b      	ldrh	r3, [r3, #8]
 810a1ce:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 810a1d2:	b29a      	uxth	r2, r3
 810a1d4:	687b      	ldr	r3, [r7, #4]
 810a1d6:	811a      	strh	r2, [r3, #8]
             pSdoInfoInd->SdoHeader.InfoHead |= (UINT16) (SDOINFOSERVICE_OBJDICTIONARYLIST_S << INFOHEAD_OPCODE_SHIFT);
 810a1d8:	687b      	ldr	r3, [r7, #4]
 810a1da:	891b      	ldrh	r3, [r3, #8]
 810a1dc:	f043 0302 	orr.w	r3, r3, #2
 810a1e0:	b29a      	uxth	r2, r3
 810a1e2:	687b      	ldr	r3, [r7, #4]
 810a1e4:	811a      	strh	r2, [r3, #8]
                /* number of fragments still has to be sent */
                pSdoInfoInd->SdoHeader.FragmentsLeft             = SWAPWORD(nSdoInfoFragmentsLeft);
 810a1e6:	4b51      	ldr	r3, [pc, #324]	@ (810a32c <SDOS_SdoInfoInd+0x2ec>)
 810a1e8:	881a      	ldrh	r2, [r3, #0]
 810a1ea:	687b      	ldr	r3, [r7, #4]
 810a1ec:	815a      	strh	r2, [r3, #10]

                if (nSdoInfoFragmentsLeft)
 810a1ee:	4b4f      	ldr	r3, [pc, #316]	@ (810a32c <SDOS_SdoInfoInd+0x2ec>)
 810a1f0:	881b      	ldrh	r3, [r3, #0]
 810a1f2:	2b00      	cmp	r3, #0
 810a1f4:	f000 80e4 	beq.w	810a3c0 <SDOS_SdoInfoInd+0x380>
                {
                    /* there still are fragments to be sent,
                       the InComplete flag in the SDO Information response has to be sent */
                    pSdoInfoInd->SdoHeader.InfoHead &= ~ INFOHEADER_INCOMPLETE_MASK;
 810a1f8:	687b      	ldr	r3, [r7, #4]
 810a1fa:	891b      	ldrh	r3, [r3, #8]
 810a1fc:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 810a200:	b29a      	uxth	r2, r3
 810a202:	687b      	ldr	r3, [r7, #4]
 810a204:	811a      	strh	r2, [r3, #8]
                    pSdoInfoInd->SdoHeader.InfoHead |= (UINT16) (SDOINFOSERVICE_INCOMPLETE << INFOHEAD_OPCODE_SHIFT);
 810a206:	687b      	ldr	r3, [r7, #4]
 810a208:	891b      	ldrh	r3, [r3, #8]
 810a20a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 810a20e:	b29a      	uxth	r2, r3
 810a210:	687b      	ldr	r3, [r7, #4]
 810a212:	811a      	strh	r2, [r3, #8]
                    /* the FRAGMENTS_FOLLOW flag has to be set for the function MBX_MailboxSendReq to
                       indicate the mailbox handler that still fragments has to be sent so that this
                        function shall be called again from COE_ContinueInd when the actual mailbox buffer
                        was sent */
                    flags = FRAGMENTS_FOLLOW | COE_SERVICE;
 810a214:	2382      	movs	r3, #130	@ 0x82
 810a216:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
                }
            }
        }
        break;
 810a21a:	e0d1      	b.n	810a3c0 <SDOS_SdoInfoInd+0x380>

    case SDOINFOSERVICE_OBJDESCRIPTION_Q:
    case SDOINFOSERVICE_ENTRYDESCRIPTION_Q:
        /* get the requested index */
        index = SWAPWORD(pSdoInfoInd->SdoHeader.Data.Obj.Index);
 810a21c:	687b      	ldr	r3, [r7, #4]
 810a21e:	899b      	ldrh	r3, [r3, #12]
 810a220:	81bb      	strh	r3, [r7, #12]
        if(index < 0x1000)
 810a222:	89bb      	ldrh	r3, [r7, #12]
 810a224:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
 810a228:	d202      	bcs.n	810a230 <SDOS_SdoInfoInd+0x1f0>
        {
            /*SDO Info access is only allowed for objects >= 0x1000*/
            abort = ABORTIDX_UNSUPPORTED_ACCESS;
 810a22a:	2305      	movs	r3, #5
 810a22c:	73fb      	strb	r3, [r7, #15]
                }
            }
            else
                abort = ABORTIDX_OBJECT_NOT_EXISTING;
        }
        break;
 810a22e:	e0c9      	b.n	810a3c4 <SDOS_SdoInfoInd+0x384>
            pObjEntry = OBJ_GetObjectHandle( index );
 810a230:	89bb      	ldrh	r3, [r7, #12]
 810a232:	4618      	mov	r0, r3
 810a234:	f7fd fd08 	bl	8107c48 <OBJ_GetObjectHandle>
 810a238:	61f8      	str	r0, [r7, #28]
            if ( pObjEntry )
 810a23a:	69fb      	ldr	r3, [r7, #28]
 810a23c:	2b00      	cmp	r3, #0
 810a23e:	f000 80b9 	beq.w	810a3b4 <SDOS_SdoInfoInd+0x374>
                UINT16 size = 0;
 810a242:	2300      	movs	r3, #0
 810a244:	847b      	strh	r3, [r7, #34]	@ 0x22
                if ( opCode == SDOINFOSERVICE_OBJDESCRIPTION_Q )
 810a246:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 810a24a:	2b03      	cmp	r3, #3
 810a24c:	d126      	bne.n	810a29c <SDOS_SdoInfoInd+0x25c>
                    OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Obj.Res, OBJ_GetObjDesc(pObjEntry), SDO_INFO_OBJ_DESC_SIZE);
 810a24e:	687b      	ldr	r3, [r7, #4]
 810a250:	f103 040e 	add.w	r4, r3, #14
 810a254:	69f8      	ldr	r0, [r7, #28]
 810a256:	f7fd ff6d 	bl	8108134 <OBJ_GetObjDesc>
 810a25a:	4603      	mov	r3, r0
 810a25c:	681b      	ldr	r3, [r3, #0]
 810a25e:	6023      	str	r3, [r4, #0]
                    size = OBJ_GetDesc(index, 0, pObjEntry, NULL) + SIZEOF_SDOINFOOBJSTRUCT;
 810a260:	89b8      	ldrh	r0, [r7, #12]
 810a262:	2300      	movs	r3, #0
 810a264:	69fa      	ldr	r2, [r7, #28]
 810a266:	2100      	movs	r1, #0
 810a268:	f7fd fea4 	bl	8107fb4 <OBJ_GetDesc>
 810a26c:	4603      	mov	r3, r0
 810a26e:	330c      	adds	r3, #12
 810a270:	847b      	strh	r3, [r7, #34]	@ 0x22
                    if ( size > (u16SendMbxSize - MBX_HEADER_SIZE) )
 810a272:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
 810a274:	4b2e      	ldr	r3, [pc, #184]	@ (810a330 <SDOS_SdoInfoInd+0x2f0>)
 810a276:	881b      	ldrh	r3, [r3, #0]
 810a278:	3b06      	subs	r3, #6
 810a27a:	429a      	cmp	r2, r3
 810a27c:	d902      	bls.n	810a284 <SDOS_SdoInfoInd+0x244>
                        size = SIZEOF_SDOINFOOBJSTRUCT;
 810a27e:	230c      	movs	r3, #12
 810a280:	847b      	strh	r3, [r7, #34]	@ 0x22
 810a282:	e07b      	b.n	810a37c <SDOS_SdoInfoInd+0x33c>
                        size = OBJ_GetDesc(index, 0, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Obj.Res)[1])) + SIZEOF_SDOINFOOBJSTRUCT;
 810a284:	89b8      	ldrh	r0, [r7, #12]
 810a286:	687b      	ldr	r3, [r7, #4]
 810a288:	330e      	adds	r3, #14
 810a28a:	3304      	adds	r3, #4
 810a28c:	69fa      	ldr	r2, [r7, #28]
 810a28e:	2100      	movs	r1, #0
 810a290:	f7fd fe90 	bl	8107fb4 <OBJ_GetDesc>
 810a294:	4603      	mov	r3, r0
 810a296:	330c      	adds	r3, #12
 810a298:	847b      	strh	r3, [r7, #34]	@ 0x22
 810a29a:	e06f      	b.n	810a37c <SDOS_SdoInfoInd+0x33c>
                    UINT8 subindex = (UINT8) ((pSdoInfoInd->SdoHeader.Data.Entry.Info & ENTRY_MASK_SUBINDEX) >> ENTRY_SUBINDEX_SHIFT);
 810a29c:	687b      	ldr	r3, [r7, #4]
 810a29e:	89db      	ldrh	r3, [r3, #14]
 810a2a0:	76fb      	strb	r3, [r7, #27]
                    UINT8 maxSubindex = (OBJ_GetObjDesc(pObjEntry)->ObjFlags & OBJFLAGS_MAXSUBINDEXMASK) >> OBJFLAGS_MAXSUBINDEXSHIFT;
 810a2a2:	69f8      	ldr	r0, [r7, #28]
 810a2a4:	f7fd ff46 	bl	8108134 <OBJ_GetObjDesc>
 810a2a8:	4603      	mov	r3, r0
 810a2aa:	885b      	ldrh	r3, [r3, #2]
 810a2ac:	76bb      	strb	r3, [r7, #26]
                    if ( subindex <= maxSubindex )
 810a2ae:	7efa      	ldrb	r2, [r7, #27]
 810a2b0:	7ebb      	ldrb	r3, [r7, #26]
 810a2b2:	429a      	cmp	r2, r3
 810a2b4:	d860      	bhi.n	810a378 <SDOS_SdoInfoInd+0x338>
                        OBJTOMBXMEMCPY(&pSdoInfoInd->SdoHeader.Data.Entry.Res, OBJ_GetEntryDesc(pObjEntry, subindex), SIZEOF(TSDOINFOENTRYDESC));
 810a2b6:	687b      	ldr	r3, [r7, #4]
 810a2b8:	f103 0410 	add.w	r4, r3, #16
 810a2bc:	7efb      	ldrb	r3, [r7, #27]
 810a2be:	4619      	mov	r1, r3
 810a2c0:	69f8      	ldr	r0, [r7, #28]
 810a2c2:	f7fd ff0b 	bl	81080dc <OBJ_GetEntryDesc>
 810a2c6:	4603      	mov	r3, r0
 810a2c8:	2206      	movs	r2, #6
 810a2ca:	4619      	mov	r1, r3
 810a2cc:	4620      	mov	r0, r4
 810a2ce:	f005 fd94 	bl	810fdfa <memcpy>
                        pSdoInfoInd->SdoHeader.Data.Entry.Info &= ~ENTRY_MASK_VALUEINFO;
 810a2d2:	687b      	ldr	r3, [r7, #4]
 810a2d4:	89db      	ldrh	r3, [r3, #14]
 810a2d6:	b2db      	uxtb	r3, r3
 810a2d8:	b29a      	uxth	r2, r3
 810a2da:	687b      	ldr	r3, [r7, #4]
 810a2dc:	81da      	strh	r2, [r3, #14]
                        ObjectFlags = OBJ_GetObjDesc(pObjEntry)->ObjFlags;
 810a2de:	69f8      	ldr	r0, [r7, #28]
 810a2e0:	f7fd ff28 	bl	8108134 <OBJ_GetObjDesc>
 810a2e4:	4603      	mov	r3, r0
 810a2e6:	885b      	ldrh	r3, [r3, #2]
 810a2e8:	833b      	strh	r3, [r7, #24]
                        ObjectFlags = (ObjectFlags & OBJFLAGS_OBJCODEMASK) >> OBJFLAGS_OBJCODESHIFT;
 810a2ea:	8b3b      	ldrh	r3, [r7, #24]
 810a2ec:	121b      	asrs	r3, r3, #8
 810a2ee:	b29b      	uxth	r3, r3
 810a2f0:	f003 030f 	and.w	r3, r3, #15
 810a2f4:	833b      	strh	r3, [r7, #24]
                        if(((ObjectFlags == OBJCODE_ARR) || (ObjectFlags == OBJCODE_REC)) && (subindex == 0) )
 810a2f6:	8b3b      	ldrh	r3, [r7, #24]
 810a2f8:	2b08      	cmp	r3, #8
 810a2fa:	d002      	beq.n	810a302 <SDOS_SdoInfoInd+0x2c2>
 810a2fc:	8b3b      	ldrh	r3, [r7, #24]
 810a2fe:	2b09      	cmp	r3, #9
 810a300:	d11c      	bne.n	810a33c <SDOS_SdoInfoInd+0x2fc>
 810a302:	7efb      	ldrb	r3, [r7, #27]
 810a304:	2b00      	cmp	r3, #0
 810a306:	d119      	bne.n	810a33c <SDOS_SdoInfoInd+0x2fc>
                            OBJTOMBXSTRCPY( ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1]), aSubindexDesc, SIZEOF(aSubindexDesc) );
 810a308:	687b      	ldr	r3, [r7, #4]
 810a30a:	3310      	adds	r3, #16
 810a30c:	3306      	adds	r3, #6
 810a30e:	4a0a      	ldr	r2, [pc, #40]	@ (810a338 <SDOS_SdoInfoInd+0x2f8>)
 810a310:	6814      	ldr	r4, [r2, #0]
 810a312:	6850      	ldr	r0, [r2, #4]
 810a314:	6891      	ldr	r1, [r2, #8]
 810a316:	601c      	str	r4, [r3, #0]
 810a318:	6058      	str	r0, [r3, #4]
 810a31a:	6099      	str	r1, [r3, #8]
 810a31c:	7b12      	ldrb	r2, [r2, #12]
 810a31e:	731a      	strb	r2, [r3, #12]
                            size = 12 + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY); // 12: Length of "SubIndex 000"
 810a320:	231c      	movs	r3, #28
 810a322:	847b      	strh	r3, [r7, #34]	@ 0x22
 810a324:	e02a      	b.n	810a37c <SDOS_SdoInfoInd+0x33c>
 810a326:	bf00      	nop
 810a328:	10000ba4 	.word	0x10000ba4
 810a32c:	10000bb8 	.word	0x10000bb8
 810a330:	1000087a 	.word	0x1000087a
 810a334:	10000bba 	.word	0x10000bba
 810a338:	10000480 	.word	0x10000480
                            size = OBJ_GetDesc(index, subindex, pObjEntry, NULL) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
 810a33c:	89b8      	ldrh	r0, [r7, #12]
 810a33e:	7ef9      	ldrb	r1, [r7, #27]
 810a340:	2300      	movs	r3, #0
 810a342:	69fa      	ldr	r2, [r7, #28]
 810a344:	f7fd fe36 	bl	8107fb4 <OBJ_GetDesc>
 810a348:	4603      	mov	r3, r0
 810a34a:	3310      	adds	r3, #16
 810a34c:	847b      	strh	r3, [r7, #34]	@ 0x22
                            if ( size > (u16SendMbxSize - MBX_HEADER_SIZE) )
 810a34e:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
 810a350:	4b36      	ldr	r3, [pc, #216]	@ (810a42c <SDOS_SdoInfoInd+0x3ec>)
 810a352:	881b      	ldrh	r3, [r3, #0]
 810a354:	3b06      	subs	r3, #6
 810a356:	429a      	cmp	r2, r3
 810a358:	d902      	bls.n	810a360 <SDOS_SdoInfoInd+0x320>
                                size =  SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
 810a35a:	2310      	movs	r3, #16
 810a35c:	847b      	strh	r3, [r7, #34]	@ 0x22
 810a35e:	e00d      	b.n	810a37c <SDOS_SdoInfoInd+0x33c>
                                size = OBJ_GetDesc(index, subindex, pObjEntry, ((UINT16 MBXMEM *) &(&pSdoInfoInd->SdoHeader.Data.Entry.Res)[1])) + SIZEOF_SDOINFO + SIZEOF(TSDOINFOENTRY);
 810a360:	89b8      	ldrh	r0, [r7, #12]
 810a362:	687b      	ldr	r3, [r7, #4]
 810a364:	3310      	adds	r3, #16
 810a366:	3306      	adds	r3, #6
 810a368:	7ef9      	ldrb	r1, [r7, #27]
 810a36a:	69fa      	ldr	r2, [r7, #28]
 810a36c:	f7fd fe22 	bl	8107fb4 <OBJ_GetDesc>
 810a370:	4603      	mov	r3, r0
 810a372:	3310      	adds	r3, #16
 810a374:	847b      	strh	r3, [r7, #34]	@ 0x22
 810a376:	e001      	b.n	810a37c <SDOS_SdoInfoInd+0x33c>
                        abort = ABORTIDX_SUBINDEX_NOT_EXISTING;
 810a378:	2311      	movs	r3, #17
 810a37a:	73fb      	strb	r3, [r7, #15]
                if ( abort == 0 )
 810a37c:	7bfb      	ldrb	r3, [r7, #15]
 810a37e:	2b00      	cmp	r3, #0
 810a380:	d120      	bne.n	810a3c4 <SDOS_SdoInfoInd+0x384>
                        pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
 810a382:	687b      	ldr	r3, [r7, #4]
 810a384:	2200      	movs	r2, #0
 810a386:	815a      	strh	r2, [r3, #10]
                        pSdoInfoInd->MbxHeader.Length = size;
 810a388:	687b      	ldr	r3, [r7, #4]
 810a38a:	8c7a      	ldrh	r2, [r7, #34]	@ 0x22
 810a38c:	801a      	strh	r2, [r3, #0]
                        pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
 810a38e:	687b      	ldr	r3, [r7, #4]
 810a390:	891b      	ldrh	r3, [r3, #8]
 810a392:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 810a396:	b29a      	uxth	r2, r3
 810a398:	687b      	ldr	r3, [r7, #4]
 810a39a:	811a      	strh	r2, [r3, #8]
                        pSdoInfoInd->SdoHeader.InfoHead |= (UINT16)((opCode + 1) << INFOHEAD_OPCODE_SHIFT);
 810a39c:	687b      	ldr	r3, [r7, #4]
 810a39e:	891a      	ldrh	r2, [r3, #8]
 810a3a0:	f897 3021 	ldrb.w	r3, [r7, #33]	@ 0x21
 810a3a4:	b29b      	uxth	r3, r3
 810a3a6:	3301      	adds	r3, #1
 810a3a8:	b29b      	uxth	r3, r3
 810a3aa:	4313      	orrs	r3, r2
 810a3ac:	b29a      	uxth	r2, r3
 810a3ae:	687b      	ldr	r3, [r7, #4]
 810a3b0:	811a      	strh	r2, [r3, #8]
        break;
 810a3b2:	e007      	b.n	810a3c4 <SDOS_SdoInfoInd+0x384>
                abort = ABORTIDX_OBJECT_NOT_EXISTING;
 810a3b4:	2308      	movs	r3, #8
 810a3b6:	73fb      	strb	r3, [r7, #15]
        break;
 810a3b8:	e004      	b.n	810a3c4 <SDOS_SdoInfoInd+0x384>
    default:
        abort = ABORTIDX_COMMAND_SPECIFIER_UNKNOWN;
 810a3ba:	2303      	movs	r3, #3
 810a3bc:	73fb      	strb	r3, [r7, #15]
 810a3be:	e002      	b.n	810a3c6 <SDOS_SdoInfoInd+0x386>
        break;
 810a3c0:	bf00      	nop
 810a3c2:	e000      	b.n	810a3c6 <SDOS_SdoInfoInd+0x386>
        break;
 810a3c4:	bf00      	nop
    }

    if ( abort )
 810a3c6:	7bfb      	ldrb	r3, [r7, #15]
 810a3c8:	2b00      	cmp	r3, #0
 810a3ca:	d01d      	beq.n	810a408 <SDOS_SdoInfoInd+0x3c8>
    {
        /* send a SDO Information Error response */
        pSdoInfoInd->MbxHeader.Length = SIZEOF_SDOINFOERRORSTRUCT;
 810a3cc:	687b      	ldr	r3, [r7, #4]
 810a3ce:	220a      	movs	r2, #10
 810a3d0:	801a      	strh	r2, [r3, #0]

        pSdoInfoInd->SdoHeader.InfoHead &= ~INFOHEAD_OPCODE_MASK;
 810a3d2:	687b      	ldr	r3, [r7, #4]
 810a3d4:	891b      	ldrh	r3, [r3, #8]
 810a3d6:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
 810a3da:	b29a      	uxth	r2, r3
 810a3dc:	687b      	ldr	r3, [r7, #4]
 810a3de:	811a      	strh	r2, [r3, #8]
        pSdoInfoInd->SdoHeader.InfoHead |= (UINT16) ((SDOINFOSERVICE_ERROR_Q) << INFOHEAD_OPCODE_SHIFT);
 810a3e0:	687b      	ldr	r3, [r7, #4]
 810a3e2:	891b      	ldrh	r3, [r3, #8]
 810a3e4:	f043 0307 	orr.w	r3, r3, #7
 810a3e8:	b29a      	uxth	r2, r3
 810a3ea:	687b      	ldr	r3, [r7, #4]
 810a3ec:	811a      	strh	r2, [r3, #8]

        pSdoInfoInd->SdoHeader.FragmentsLeft = 0;
 810a3ee:	687b      	ldr	r3, [r7, #4]
 810a3f0:	2200      	movs	r2, #0
 810a3f2:	815a      	strh	r2, [r3, #10]
        pSdoInfoInd->SdoHeader.Data.Error.ErrorCode = SWAPDWORD(cAbortCode[abort]);
 810a3f4:	7bfb      	ldrb	r3, [r7, #15]
 810a3f6:	461a      	mov	r2, r3
 810a3f8:	4b0d      	ldr	r3, [pc, #52]	@ (810a430 <SDOS_SdoInfoInd+0x3f0>)
 810a3fa:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 810a3fe:	687b      	ldr	r3, [r7, #4]
 810a400:	60da      	str	r2, [r3, #12]

        nSdoInfoFragmentsLeft = 0;
 810a402:	4b0c      	ldr	r3, [pc, #48]	@ (810a434 <SDOS_SdoInfoInd+0x3f4>)
 810a404:	2200      	movs	r2, #0
 810a406:	801a      	strh	r2, [r3, #0]
    }

    if (MBX_MailboxSendReq((TMBX MBXMEM *) pSdoInfoInd, flags) != 0)
 810a408:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
 810a40c:	4619      	mov	r1, r3
 810a40e:	6878      	ldr	r0, [r7, #4]
 810a410:	f7fd fa46 	bl	81078a0 <MBX_MailboxSendReq>
 810a414:	4603      	mov	r3, r0
 810a416:	2b00      	cmp	r3, #0
 810a418:	d002      	beq.n	810a420 <SDOS_SdoInfoInd+0x3e0>
    {
        /* if the mailbox response could not be sent (or stored), the response will be
           stored in the variable pCoeSendStored and will be sent automatically
            from the mailbox handler (COE_ContinueInd) when the send mailbox will be read
            the next time from the master */
        pCoeSendStored = (TMBX MBXMEM *) pSdoInfoInd;
 810a41a:	4a07      	ldr	r2, [pc, #28]	@ (810a438 <SDOS_SdoInfoInd+0x3f8>)
 810a41c:	687b      	ldr	r3, [r7, #4]
 810a41e:	6013      	str	r3, [r2, #0]
    }

    return 0;
 810a420:	2300      	movs	r3, #0
}
 810a422:	4618      	mov	r0, r3
 810a424:	3734      	adds	r7, #52	@ 0x34
 810a426:	46bd      	mov	sp, r7
 810a428:	bd90      	pop	{r4, r7, pc}
 810a42a:	bf00      	nop
 810a42c:	1000087a 	.word	0x1000087a
 810a430:	081112a0 	.word	0x081112a0
 810a434:	10000bb8 	.word	0x10000bb8
 810a438:	10000824 	.word	0x10000824

0810a43c <__NVIC_SetPriority>:
{
 810a43c:	b480      	push	{r7}
 810a43e:	b083      	sub	sp, #12
 810a440:	af00      	add	r7, sp, #0
 810a442:	4603      	mov	r3, r0
 810a444:	6039      	str	r1, [r7, #0]
 810a446:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
 810a448:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 810a44c:	2b00      	cmp	r3, #0
 810a44e:	db0a      	blt.n	810a466 <__NVIC_SetPriority+0x2a>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 810a450:	683b      	ldr	r3, [r7, #0]
 810a452:	b2da      	uxtb	r2, r3
 810a454:	490c      	ldr	r1, [pc, #48]	@ (810a488 <__NVIC_SetPriority+0x4c>)
 810a456:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
 810a45a:	0112      	lsls	r2, r2, #4
 810a45c:	b2d2      	uxtb	r2, r2
 810a45e:	440b      	add	r3, r1
 810a460:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
}
 810a464:	e00a      	b.n	810a47c <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 810a466:	683b      	ldr	r3, [r7, #0]
 810a468:	b2da      	uxtb	r2, r3
 810a46a:	4908      	ldr	r1, [pc, #32]	@ (810a48c <__NVIC_SetPriority+0x50>)
 810a46c:	88fb      	ldrh	r3, [r7, #6]
 810a46e:	f003 030f 	and.w	r3, r3, #15
 810a472:	3b04      	subs	r3, #4
 810a474:	0112      	lsls	r2, r2, #4
 810a476:	b2d2      	uxtb	r2, r2
 810a478:	440b      	add	r3, r1
 810a47a:	761a      	strb	r2, [r3, #24]
}
 810a47c:	bf00      	nop
 810a47e:	370c      	adds	r7, #12
 810a480:	46bd      	mov	sp, r7
 810a482:	f85d 7b04 	ldr.w	r7, [sp], #4
 810a486:	4770      	bx	lr
 810a488:	e000e100 	.word	0xe000e100
 810a48c:	e000ed00 	.word	0xe000ed00

0810a490 <SysTick_Handler>:

/*
  SysTick handler implementation that also clears overflow flag.
*/
#if (USE_CUSTOM_SYSTICK_HANDLER_IMPLEMENTATION == 0)
void SysTick_Handler (void) {
 810a490:	b580      	push	{r7, lr}
 810a492:	af00      	add	r7, sp, #0
  /* Clear overflow flag */
  SysTick->CTRL;
 810a494:	4b05      	ldr	r3, [pc, #20]	@ (810a4ac <SysTick_Handler+0x1c>)
 810a496:	681b      	ldr	r3, [r3, #0]

  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) {
 810a498:	f002 fadc 	bl	810ca54 <xTaskGetSchedulerState>
 810a49c:	4603      	mov	r3, r0
 810a49e:	2b01      	cmp	r3, #1
 810a4a0:	d001      	beq.n	810a4a6 <SysTick_Handler+0x16>
    /* Call tick handler */
    xPortSysTickHandler();
 810a4a2:	f000 fe29 	bl	810b0f8 <xPortSysTickHandler>
  }
}
 810a4a6:	bf00      	nop
 810a4a8:	bd80      	pop	{r7, pc}
 810a4aa:	bf00      	nop
 810a4ac:	e000e010 	.word	0xe000e010

0810a4b0 <SVC_Setup>:
#endif /* SysTick */

/*
  Setup SVC to reset value.
*/
__STATIC_INLINE void SVC_Setup (void) {
 810a4b0:	b580      	push	{r7, lr}
 810a4b2:	af00      	add	r7, sp, #0
#if (__ARM_ARCH_7A__ == 0U)
  /* Service Call interrupt might be configured before kernel start     */
  /* and when its priority is lower or equal to BASEPRI, svc intruction */
  /* causes a Hard Fault.                                               */
  NVIC_SetPriority (SVCall_IRQ_NBR, 0U);
 810a4b4:	2100      	movs	r1, #0
 810a4b6:	f06f 0004 	mvn.w	r0, #4
 810a4ba:	f7ff ffbf 	bl	810a43c <__NVIC_SetPriority>
#endif
}
 810a4be:	bf00      	nop
 810a4c0:	bd80      	pop	{r7, pc}
	...

0810a4c4 <osKernelInitialize>:
static uint32_t OS_Tick_GetOverflow (void);
/* Get OS Tick interval */
static uint32_t OS_Tick_GetInterval (void);
/*---------------------------------------------------------------------------*/

osStatus_t osKernelInitialize (void) {
 810a4c4:	b480      	push	{r7}
 810a4c6:	b083      	sub	sp, #12
 810a4c8:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 810a4ca:	f3ef 8305 	mrs	r3, IPSR
 810a4ce:	603b      	str	r3, [r7, #0]
  return(result);
 810a4d0:	683b      	ldr	r3, [r7, #0]
  osStatus_t stat;

  if (IS_IRQ()) {
 810a4d2:	2b00      	cmp	r3, #0
 810a4d4:	d003      	beq.n	810a4de <osKernelInitialize+0x1a>
    stat = osErrorISR;
 810a4d6:	f06f 0305 	mvn.w	r3, #5
 810a4da:	607b      	str	r3, [r7, #4]
 810a4dc:	e00c      	b.n	810a4f8 <osKernelInitialize+0x34>
  }
  else {
    if (KernelState == osKernelInactive) {
 810a4de:	4b0a      	ldr	r3, [pc, #40]	@ (810a508 <osKernelInitialize+0x44>)
 810a4e0:	681b      	ldr	r3, [r3, #0]
 810a4e2:	2b00      	cmp	r3, #0
 810a4e4:	d105      	bne.n	810a4f2 <osKernelInitialize+0x2e>
        EvrFreeRTOSSetup(0U);
      #endif
      #if defined(USE_FreeRTOS_HEAP_5) && (HEAP_5_REGION_SETUP == 1)
        vPortDefineHeapRegions (configHEAP_5_REGIONS);
      #endif
      KernelState = osKernelReady;
 810a4e6:	4b08      	ldr	r3, [pc, #32]	@ (810a508 <osKernelInitialize+0x44>)
 810a4e8:	2201      	movs	r2, #1
 810a4ea:	601a      	str	r2, [r3, #0]
      stat = osOK;
 810a4ec:	2300      	movs	r3, #0
 810a4ee:	607b      	str	r3, [r7, #4]
 810a4f0:	e002      	b.n	810a4f8 <osKernelInitialize+0x34>
    } else {
      stat = osError;
 810a4f2:	f04f 33ff 	mov.w	r3, #4294967295
 810a4f6:	607b      	str	r3, [r7, #4]
    }
  }

  return (stat);
 810a4f8:	687b      	ldr	r3, [r7, #4]
}
 810a4fa:	4618      	mov	r0, r3
 810a4fc:	370c      	adds	r7, #12
 810a4fe:	46bd      	mov	sp, r7
 810a500:	f85d 7b04 	ldr.w	r7, [sp], #4
 810a504:	4770      	bx	lr
 810a506:	bf00      	nop
 810a508:	10000bdc 	.word	0x10000bdc

0810a50c <osKernelStart>:
  }

  return (state);
}

osStatus_t osKernelStart (void) {
 810a50c:	b580      	push	{r7, lr}
 810a50e:	b082      	sub	sp, #8
 810a510:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 810a512:	f3ef 8305 	mrs	r3, IPSR
 810a516:	603b      	str	r3, [r7, #0]
  return(result);
 810a518:	683b      	ldr	r3, [r7, #0]
  osStatus_t stat;

  if (IS_IRQ()) {
 810a51a:	2b00      	cmp	r3, #0
 810a51c:	d003      	beq.n	810a526 <osKernelStart+0x1a>
    stat = osErrorISR;
 810a51e:	f06f 0305 	mvn.w	r3, #5
 810a522:	607b      	str	r3, [r7, #4]
 810a524:	e010      	b.n	810a548 <osKernelStart+0x3c>
  }
  else {
    if (KernelState == osKernelReady) {
 810a526:	4b0b      	ldr	r3, [pc, #44]	@ (810a554 <osKernelStart+0x48>)
 810a528:	681b      	ldr	r3, [r3, #0]
 810a52a:	2b01      	cmp	r3, #1
 810a52c:	d109      	bne.n	810a542 <osKernelStart+0x36>
      /* Ensure SVC priority is at the reset value */
      SVC_Setup();
 810a52e:	f7ff ffbf 	bl	810a4b0 <SVC_Setup>
      /* Change state to enable IRQ masking check */
      KernelState = osKernelRunning;
 810a532:	4b08      	ldr	r3, [pc, #32]	@ (810a554 <osKernelStart+0x48>)
 810a534:	2202      	movs	r2, #2
 810a536:	601a      	str	r2, [r3, #0]
      /* Start the kernel scheduler */
      vTaskStartScheduler();
 810a538:	f001 fe3e 	bl	810c1b8 <vTaskStartScheduler>
      stat = osOK;
 810a53c:	2300      	movs	r3, #0
 810a53e:	607b      	str	r3, [r7, #4]
 810a540:	e002      	b.n	810a548 <osKernelStart+0x3c>
    } else {
      stat = osError;
 810a542:	f04f 33ff 	mov.w	r3, #4294967295
 810a546:	607b      	str	r3, [r7, #4]
    }
  }

  return (stat);
 810a548:	687b      	ldr	r3, [r7, #4]
}
 810a54a:	4618      	mov	r0, r3
 810a54c:	3708      	adds	r7, #8
 810a54e:	46bd      	mov	sp, r7
 810a550:	bd80      	pop	{r7, pc}
 810a552:	bf00      	nop
 810a554:	10000bdc 	.word	0x10000bdc

0810a558 <osThreadNew>:
  return (configCPU_CLOCK_HZ);
}

/*---------------------------------------------------------------------------*/

osThreadId_t osThreadNew (osThreadFunc_t func, void *argument, const osThreadAttr_t *attr) {
 810a558:	b580      	push	{r7, lr}
 810a55a:	b08e      	sub	sp, #56	@ 0x38
 810a55c:	af04      	add	r7, sp, #16
 810a55e:	60f8      	str	r0, [r7, #12]
 810a560:	60b9      	str	r1, [r7, #8]
 810a562:	607a      	str	r2, [r7, #4]
  uint32_t stack;
  TaskHandle_t hTask;
  UBaseType_t prio;
  int32_t mem;

  hTask = NULL;
 810a564:	2300      	movs	r3, #0
 810a566:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 810a568:	f3ef 8305 	mrs	r3, IPSR
 810a56c:	617b      	str	r3, [r7, #20]
  return(result);
 810a56e:	697b      	ldr	r3, [r7, #20]

  if (!IS_IRQ() && (func != NULL)) {
 810a570:	2b00      	cmp	r3, #0
 810a572:	d17e      	bne.n	810a672 <osThreadNew+0x11a>
 810a574:	68fb      	ldr	r3, [r7, #12]
 810a576:	2b00      	cmp	r3, #0
 810a578:	d07b      	beq.n	810a672 <osThreadNew+0x11a>
    stack = configMINIMAL_STACK_SIZE;
 810a57a:	2380      	movs	r3, #128	@ 0x80
 810a57c:	623b      	str	r3, [r7, #32]
    prio  = (UBaseType_t)osPriorityNormal;
 810a57e:	2318      	movs	r3, #24
 810a580:	61fb      	str	r3, [r7, #28]

    name = NULL;
 810a582:	2300      	movs	r3, #0
 810a584:	627b      	str	r3, [r7, #36]	@ 0x24
    mem  = -1;
 810a586:	f04f 33ff 	mov.w	r3, #4294967295
 810a58a:	61bb      	str	r3, [r7, #24]

    if (attr != NULL) {
 810a58c:	687b      	ldr	r3, [r7, #4]
 810a58e:	2b00      	cmp	r3, #0
 810a590:	d045      	beq.n	810a61e <osThreadNew+0xc6>
      if (attr->name != NULL) {
 810a592:	687b      	ldr	r3, [r7, #4]
 810a594:	681b      	ldr	r3, [r3, #0]
 810a596:	2b00      	cmp	r3, #0
 810a598:	d002      	beq.n	810a5a0 <osThreadNew+0x48>
        name = attr->name;
 810a59a:	687b      	ldr	r3, [r7, #4]
 810a59c:	681b      	ldr	r3, [r3, #0]
 810a59e:	627b      	str	r3, [r7, #36]	@ 0x24
      }
      if (attr->priority != osPriorityNone) {
 810a5a0:	687b      	ldr	r3, [r7, #4]
 810a5a2:	699b      	ldr	r3, [r3, #24]
 810a5a4:	2b00      	cmp	r3, #0
 810a5a6:	d002      	beq.n	810a5ae <osThreadNew+0x56>
        prio = (UBaseType_t)attr->priority;
 810a5a8:	687b      	ldr	r3, [r7, #4]
 810a5aa:	699b      	ldr	r3, [r3, #24]
 810a5ac:	61fb      	str	r3, [r7, #28]
      }

      if ((prio < osPriorityIdle) || (prio > osPriorityISR) || ((attr->attr_bits & osThreadJoinable) == osThreadJoinable)) {
 810a5ae:	69fb      	ldr	r3, [r7, #28]
 810a5b0:	2b00      	cmp	r3, #0
 810a5b2:	d008      	beq.n	810a5c6 <osThreadNew+0x6e>
 810a5b4:	69fb      	ldr	r3, [r7, #28]
 810a5b6:	2b38      	cmp	r3, #56	@ 0x38
 810a5b8:	d805      	bhi.n	810a5c6 <osThreadNew+0x6e>
 810a5ba:	687b      	ldr	r3, [r7, #4]
 810a5bc:	685b      	ldr	r3, [r3, #4]
 810a5be:	f003 0301 	and.w	r3, r3, #1
 810a5c2:	2b00      	cmp	r3, #0
 810a5c4:	d001      	beq.n	810a5ca <osThreadNew+0x72>
        return (NULL);
 810a5c6:	2300      	movs	r3, #0
 810a5c8:	e054      	b.n	810a674 <osThreadNew+0x11c>
      }

      if (attr->stack_size > 0U) {
 810a5ca:	687b      	ldr	r3, [r7, #4]
 810a5cc:	695b      	ldr	r3, [r3, #20]
 810a5ce:	2b00      	cmp	r3, #0
 810a5d0:	d003      	beq.n	810a5da <osThreadNew+0x82>
        /* In FreeRTOS stack is not in bytes, but in sizeof(StackType_t) which is 4 on ARM ports.       */
        /* Stack size should be therefore 4 byte aligned in order to avoid division caused side effects */
        stack = attr->stack_size / sizeof(StackType_t);
 810a5d2:	687b      	ldr	r3, [r7, #4]
 810a5d4:	695b      	ldr	r3, [r3, #20]
 810a5d6:	089b      	lsrs	r3, r3, #2
 810a5d8:	623b      	str	r3, [r7, #32]
      }

      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 810a5da:	687b      	ldr	r3, [r7, #4]
 810a5dc:	689b      	ldr	r3, [r3, #8]
 810a5de:	2b00      	cmp	r3, #0
 810a5e0:	d00e      	beq.n	810a600 <osThreadNew+0xa8>
 810a5e2:	687b      	ldr	r3, [r7, #4]
 810a5e4:	68db      	ldr	r3, [r3, #12]
 810a5e6:	2b5b      	cmp	r3, #91	@ 0x5b
 810a5e8:	d90a      	bls.n	810a600 <osThreadNew+0xa8>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 810a5ea:	687b      	ldr	r3, [r7, #4]
 810a5ec:	691b      	ldr	r3, [r3, #16]
      if ((attr->cb_mem    != NULL) && (attr->cb_size    >= sizeof(StaticTask_t)) &&
 810a5ee:	2b00      	cmp	r3, #0
 810a5f0:	d006      	beq.n	810a600 <osThreadNew+0xa8>
          (attr->stack_mem != NULL) && (attr->stack_size >  0U)) {
 810a5f2:	687b      	ldr	r3, [r7, #4]
 810a5f4:	695b      	ldr	r3, [r3, #20]
 810a5f6:	2b00      	cmp	r3, #0
 810a5f8:	d002      	beq.n	810a600 <osThreadNew+0xa8>
        mem = 1;
 810a5fa:	2301      	movs	r3, #1
 810a5fc:	61bb      	str	r3, [r7, #24]
 810a5fe:	e010      	b.n	810a622 <osThreadNew+0xca>
      }
      else {
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U) && (attr->stack_mem == NULL)) {
 810a600:	687b      	ldr	r3, [r7, #4]
 810a602:	689b      	ldr	r3, [r3, #8]
 810a604:	2b00      	cmp	r3, #0
 810a606:	d10c      	bne.n	810a622 <osThreadNew+0xca>
 810a608:	687b      	ldr	r3, [r7, #4]
 810a60a:	68db      	ldr	r3, [r3, #12]
 810a60c:	2b00      	cmp	r3, #0
 810a60e:	d108      	bne.n	810a622 <osThreadNew+0xca>
 810a610:	687b      	ldr	r3, [r7, #4]
 810a612:	691b      	ldr	r3, [r3, #16]
 810a614:	2b00      	cmp	r3, #0
 810a616:	d104      	bne.n	810a622 <osThreadNew+0xca>
          mem = 0;
 810a618:	2300      	movs	r3, #0
 810a61a:	61bb      	str	r3, [r7, #24]
 810a61c:	e001      	b.n	810a622 <osThreadNew+0xca>
        }
      }
    }
    else {
      mem = 0;
 810a61e:	2300      	movs	r3, #0
 810a620:	61bb      	str	r3, [r7, #24]
    }

    if (mem == 1) {
 810a622:	69bb      	ldr	r3, [r7, #24]
 810a624:	2b01      	cmp	r3, #1
 810a626:	d110      	bne.n	810a64a <osThreadNew+0xf2>
      #if (configSUPPORT_STATIC_ALLOCATION == 1)
        hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 810a628:	687b      	ldr	r3, [r7, #4]
 810a62a:	691b      	ldr	r3, [r3, #16]
                                                                                      (StaticTask_t *)attr->cb_mem);
 810a62c:	687a      	ldr	r2, [r7, #4]
 810a62e:	6892      	ldr	r2, [r2, #8]
        hTask = xTaskCreateStatic ((TaskFunction_t)func, name, stack, argument, prio, (StackType_t  *)attr->stack_mem,
 810a630:	9202      	str	r2, [sp, #8]
 810a632:	9301      	str	r3, [sp, #4]
 810a634:	69fb      	ldr	r3, [r7, #28]
 810a636:	9300      	str	r3, [sp, #0]
 810a638:	68bb      	ldr	r3, [r7, #8]
 810a63a:	6a3a      	ldr	r2, [r7, #32]
 810a63c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 810a63e:	68f8      	ldr	r0, [r7, #12]
 810a640:	f001 fbde 	bl	810be00 <xTaskCreateStatic>
 810a644:	4603      	mov	r3, r0
 810a646:	613b      	str	r3, [r7, #16]
 810a648:	e013      	b.n	810a672 <osThreadNew+0x11a>
      #endif
    }
    else {
      if (mem == 0) {
 810a64a:	69bb      	ldr	r3, [r7, #24]
 810a64c:	2b00      	cmp	r3, #0
 810a64e:	d110      	bne.n	810a672 <osThreadNew+0x11a>
        #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
          if (xTaskCreate ((TaskFunction_t)func, name, (uint16_t)stack, argument, prio, &hTask) != pdPASS) {
 810a650:	6a3b      	ldr	r3, [r7, #32]
 810a652:	b29a      	uxth	r2, r3
 810a654:	f107 0310 	add.w	r3, r7, #16
 810a658:	9301      	str	r3, [sp, #4]
 810a65a:	69fb      	ldr	r3, [r7, #28]
 810a65c:	9300      	str	r3, [sp, #0]
 810a65e:	68bb      	ldr	r3, [r7, #8]
 810a660:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 810a662:	68f8      	ldr	r0, [r7, #12]
 810a664:	f001 fc2c 	bl	810bec0 <xTaskCreate>
 810a668:	4603      	mov	r3, r0
 810a66a:	2b01      	cmp	r3, #1
 810a66c:	d001      	beq.n	810a672 <osThreadNew+0x11a>
            hTask = NULL;
 810a66e:	2300      	movs	r3, #0
 810a670:	613b      	str	r3, [r7, #16]
        #endif
      }
    }
  }

  return ((osThreadId_t)hTask);
 810a672:	693b      	ldr	r3, [r7, #16]
}
 810a674:	4618      	mov	r0, r3
 810a676:	3728      	adds	r7, #40	@ 0x28
 810a678:	46bd      	mov	sp, r7
 810a67a:	bd80      	pop	{r7, pc}

0810a67c <osDelay>:
  /* Return flags before clearing */
  return (rflags);
}
#endif /* (configUSE_OS2_THREAD_FLAGS == 1) */

osStatus_t osDelay (uint32_t ticks) {
 810a67c:	b580      	push	{r7, lr}
 810a67e:	b084      	sub	sp, #16
 810a680:	af00      	add	r7, sp, #0
 810a682:	6078      	str	r0, [r7, #4]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 810a684:	f3ef 8305 	mrs	r3, IPSR
 810a688:	60bb      	str	r3, [r7, #8]
  return(result);
 810a68a:	68bb      	ldr	r3, [r7, #8]
  osStatus_t stat;

  if (IS_IRQ()) {
 810a68c:	2b00      	cmp	r3, #0
 810a68e:	d003      	beq.n	810a698 <osDelay+0x1c>
    stat = osErrorISR;
 810a690:	f06f 0305 	mvn.w	r3, #5
 810a694:	60fb      	str	r3, [r7, #12]
 810a696:	e007      	b.n	810a6a8 <osDelay+0x2c>
  }
  else {
    stat = osOK;
 810a698:	2300      	movs	r3, #0
 810a69a:	60fb      	str	r3, [r7, #12]

    if (ticks != 0U) {
 810a69c:	687b      	ldr	r3, [r7, #4]
 810a69e:	2b00      	cmp	r3, #0
 810a6a0:	d002      	beq.n	810a6a8 <osDelay+0x2c>
      vTaskDelay(ticks);
 810a6a2:	6878      	ldr	r0, [r7, #4]
 810a6a4:	f001 fd52 	bl	810c14c <vTaskDelay>
    }
  }

  return (stat);
 810a6a8:	68fb      	ldr	r3, [r7, #12]
}
 810a6aa:	4618      	mov	r0, r3
 810a6ac:	3710      	adds	r7, #16
 810a6ae:	46bd      	mov	sp, r7
 810a6b0:	bd80      	pop	{r7, pc}

0810a6b2 <osSemaphoreNew>:
}
#endif /* (configUSE_OS2_MUTEX == 1) */

/*---------------------------------------------------------------------------*/

osSemaphoreId_t osSemaphoreNew (uint32_t max_count, uint32_t initial_count, const osSemaphoreAttr_t *attr) {
 810a6b2:	b580      	push	{r7, lr}
 810a6b4:	b08a      	sub	sp, #40	@ 0x28
 810a6b6:	af02      	add	r7, sp, #8
 810a6b8:	60f8      	str	r0, [r7, #12]
 810a6ba:	60b9      	str	r1, [r7, #8]
 810a6bc:	607a      	str	r2, [r7, #4]
  int32_t mem;
  #if (configQUEUE_REGISTRY_SIZE > 0)
  const char *name;
  #endif

  hSemaphore = NULL;
 810a6be:	2300      	movs	r3, #0
 810a6c0:	61fb      	str	r3, [r7, #28]
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 810a6c2:	f3ef 8305 	mrs	r3, IPSR
 810a6c6:	613b      	str	r3, [r7, #16]
  return(result);
 810a6c8:	693b      	ldr	r3, [r7, #16]

  if (!IS_IRQ() && (max_count > 0U) && (initial_count <= max_count)) {
 810a6ca:	2b00      	cmp	r3, #0
 810a6cc:	d175      	bne.n	810a7ba <osSemaphoreNew+0x108>
 810a6ce:	68fb      	ldr	r3, [r7, #12]
 810a6d0:	2b00      	cmp	r3, #0
 810a6d2:	d072      	beq.n	810a7ba <osSemaphoreNew+0x108>
 810a6d4:	68ba      	ldr	r2, [r7, #8]
 810a6d6:	68fb      	ldr	r3, [r7, #12]
 810a6d8:	429a      	cmp	r2, r3
 810a6da:	d86e      	bhi.n	810a7ba <osSemaphoreNew+0x108>
    mem = -1;
 810a6dc:	f04f 33ff 	mov.w	r3, #4294967295
 810a6e0:	61bb      	str	r3, [r7, #24]

    if (attr != NULL) {
 810a6e2:	687b      	ldr	r3, [r7, #4]
 810a6e4:	2b00      	cmp	r3, #0
 810a6e6:	d015      	beq.n	810a714 <osSemaphoreNew+0x62>
      if ((attr->cb_mem != NULL) && (attr->cb_size >= sizeof(StaticSemaphore_t))) {
 810a6e8:	687b      	ldr	r3, [r7, #4]
 810a6ea:	689b      	ldr	r3, [r3, #8]
 810a6ec:	2b00      	cmp	r3, #0
 810a6ee:	d006      	beq.n	810a6fe <osSemaphoreNew+0x4c>
 810a6f0:	687b      	ldr	r3, [r7, #4]
 810a6f2:	68db      	ldr	r3, [r3, #12]
 810a6f4:	2b4f      	cmp	r3, #79	@ 0x4f
 810a6f6:	d902      	bls.n	810a6fe <osSemaphoreNew+0x4c>
        mem = 1;
 810a6f8:	2301      	movs	r3, #1
 810a6fa:	61bb      	str	r3, [r7, #24]
 810a6fc:	e00c      	b.n	810a718 <osSemaphoreNew+0x66>
      }
      else {
        if ((attr->cb_mem == NULL) && (attr->cb_size == 0U)) {
 810a6fe:	687b      	ldr	r3, [r7, #4]
 810a700:	689b      	ldr	r3, [r3, #8]
 810a702:	2b00      	cmp	r3, #0
 810a704:	d108      	bne.n	810a718 <osSemaphoreNew+0x66>
 810a706:	687b      	ldr	r3, [r7, #4]
 810a708:	68db      	ldr	r3, [r3, #12]
 810a70a:	2b00      	cmp	r3, #0
 810a70c:	d104      	bne.n	810a718 <osSemaphoreNew+0x66>
          mem = 0;
 810a70e:	2300      	movs	r3, #0
 810a710:	61bb      	str	r3, [r7, #24]
 810a712:	e001      	b.n	810a718 <osSemaphoreNew+0x66>
        }
      }
    }
    else {
      mem = 0;
 810a714:	2300      	movs	r3, #0
 810a716:	61bb      	str	r3, [r7, #24]
    }

    if (mem != -1) {
 810a718:	69bb      	ldr	r3, [r7, #24]
 810a71a:	f1b3 3fff 	cmp.w	r3, #4294967295
 810a71e:	d04c      	beq.n	810a7ba <osSemaphoreNew+0x108>
      if (max_count == 1U) {
 810a720:	68fb      	ldr	r3, [r7, #12]
 810a722:	2b01      	cmp	r3, #1
 810a724:	d128      	bne.n	810a778 <osSemaphoreNew+0xc6>
        if (mem == 1) {
 810a726:	69bb      	ldr	r3, [r7, #24]
 810a728:	2b01      	cmp	r3, #1
 810a72a:	d10a      	bne.n	810a742 <osSemaphoreNew+0x90>
          #if (configSUPPORT_STATIC_ALLOCATION == 1)
            hSemaphore = xSemaphoreCreateBinaryStatic ((StaticSemaphore_t *)attr->cb_mem);
 810a72c:	687b      	ldr	r3, [r7, #4]
 810a72e:	689b      	ldr	r3, [r3, #8]
 810a730:	2203      	movs	r2, #3
 810a732:	9200      	str	r2, [sp, #0]
 810a734:	2200      	movs	r2, #0
 810a736:	2100      	movs	r1, #0
 810a738:	2001      	movs	r0, #1
 810a73a:	f000 fdd9 	bl	810b2f0 <xQueueGenericCreateStatic>
 810a73e:	61f8      	str	r0, [r7, #28]
 810a740:	e005      	b.n	810a74e <osSemaphoreNew+0x9c>
          #endif
        }
        else {
          #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
            hSemaphore = xSemaphoreCreateBinary();
 810a742:	2203      	movs	r2, #3
 810a744:	2100      	movs	r1, #0
 810a746:	2001      	movs	r0, #1
 810a748:	f000 fe4f 	bl	810b3ea <xQueueGenericCreate>
 810a74c:	61f8      	str	r0, [r7, #28]
          #endif
        }

        if ((hSemaphore != NULL) && (initial_count != 0U)) {
 810a74e:	69fb      	ldr	r3, [r7, #28]
 810a750:	2b00      	cmp	r3, #0
 810a752:	d022      	beq.n	810a79a <osSemaphoreNew+0xe8>
 810a754:	68bb      	ldr	r3, [r7, #8]
 810a756:	2b00      	cmp	r3, #0
 810a758:	d01f      	beq.n	810a79a <osSemaphoreNew+0xe8>
          if (xSemaphoreGive (hSemaphore) != pdPASS) {
 810a75a:	2300      	movs	r3, #0
 810a75c:	2200      	movs	r2, #0
 810a75e:	2100      	movs	r1, #0
 810a760:	69f8      	ldr	r0, [r7, #28]
 810a762:	f000 ff0f 	bl	810b584 <xQueueGenericSend>
 810a766:	4603      	mov	r3, r0
 810a768:	2b01      	cmp	r3, #1
 810a76a:	d016      	beq.n	810a79a <osSemaphoreNew+0xe8>
            vSemaphoreDelete (hSemaphore);
 810a76c:	69f8      	ldr	r0, [r7, #28]
 810a76e:	f001 f98b 	bl	810ba88 <vQueueDelete>
            hSemaphore = NULL;
 810a772:	2300      	movs	r3, #0
 810a774:	61fb      	str	r3, [r7, #28]
 810a776:	e010      	b.n	810a79a <osSemaphoreNew+0xe8>
          }
        }
      }
      else {
        if (mem == 1) {
 810a778:	69bb      	ldr	r3, [r7, #24]
 810a77a:	2b01      	cmp	r3, #1
 810a77c:	d108      	bne.n	810a790 <osSemaphoreNew+0xde>
          #if (configSUPPORT_STATIC_ALLOCATION == 1)
            hSemaphore = xSemaphoreCreateCountingStatic (max_count, initial_count, (StaticSemaphore_t *)attr->cb_mem);
 810a77e:	687b      	ldr	r3, [r7, #4]
 810a780:	689b      	ldr	r3, [r3, #8]
 810a782:	461a      	mov	r2, r3
 810a784:	68b9      	ldr	r1, [r7, #8]
 810a786:	68f8      	ldr	r0, [r7, #12]
 810a788:	f000 fe8d 	bl	810b4a6 <xQueueCreateCountingSemaphoreStatic>
 810a78c:	61f8      	str	r0, [r7, #28]
 810a78e:	e004      	b.n	810a79a <osSemaphoreNew+0xe8>
          #endif
        }
        else {
          #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
            hSemaphore = xSemaphoreCreateCounting (max_count, initial_count);
 810a790:	68b9      	ldr	r1, [r7, #8]
 810a792:	68f8      	ldr	r0, [r7, #12]
 810a794:	f000 fec0 	bl	810b518 <xQueueCreateCountingSemaphore>
 810a798:	61f8      	str	r0, [r7, #28]
          #endif
        }
      }
      
      #if (configQUEUE_REGISTRY_SIZE > 0)
      if (hSemaphore != NULL) {
 810a79a:	69fb      	ldr	r3, [r7, #28]
 810a79c:	2b00      	cmp	r3, #0
 810a79e:	d00c      	beq.n	810a7ba <osSemaphoreNew+0x108>
        if (attr != NULL) {
 810a7a0:	687b      	ldr	r3, [r7, #4]
 810a7a2:	2b00      	cmp	r3, #0
 810a7a4:	d003      	beq.n	810a7ae <osSemaphoreNew+0xfc>
          name = attr->name;
 810a7a6:	687b      	ldr	r3, [r7, #4]
 810a7a8:	681b      	ldr	r3, [r3, #0]
 810a7aa:	617b      	str	r3, [r7, #20]
 810a7ac:	e001      	b.n	810a7b2 <osSemaphoreNew+0x100>
        } else {
          name = NULL;
 810a7ae:	2300      	movs	r3, #0
 810a7b0:	617b      	str	r3, [r7, #20]
        }
        vQueueAddToRegistry (hSemaphore, name);
 810a7b2:	6979      	ldr	r1, [r7, #20]
 810a7b4:	69f8      	ldr	r0, [r7, #28]
 810a7b6:	f001 fa9b 	bl	810bcf0 <vQueueAddToRegistry>
      }
      #endif
    }
  }

  return ((osSemaphoreId_t)hSemaphore);
 810a7ba:	69fb      	ldr	r3, [r7, #28]
}
 810a7bc:	4618      	mov	r0, r3
 810a7be:	3720      	adds	r7, #32
 810a7c0:	46bd      	mov	sp, r7
 810a7c2:	bd80      	pop	{r7, pc}

0810a7c4 <vApplicationGetIdleTaskMemory>:

/*
  vApplicationGetIdleTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
__WEAK void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
 810a7c4:	b480      	push	{r7}
 810a7c6:	b085      	sub	sp, #20
 810a7c8:	af00      	add	r7, sp, #0
 810a7ca:	60f8      	str	r0, [r7, #12]
 810a7cc:	60b9      	str	r1, [r7, #8]
 810a7ce:	607a      	str	r2, [r7, #4]
  /* Idle task control block and stack */
  static StaticTask_t Idle_TCB;
  static StackType_t  Idle_Stack[configMINIMAL_STACK_SIZE];

  *ppxIdleTaskTCBBuffer   = &Idle_TCB;
 810a7d0:	68fb      	ldr	r3, [r7, #12]
 810a7d2:	4a07      	ldr	r2, [pc, #28]	@ (810a7f0 <vApplicationGetIdleTaskMemory+0x2c>)
 810a7d4:	601a      	str	r2, [r3, #0]
  *ppxIdleTaskStackBuffer = &Idle_Stack[0];
 810a7d6:	68bb      	ldr	r3, [r7, #8]
 810a7d8:	4a06      	ldr	r2, [pc, #24]	@ (810a7f4 <vApplicationGetIdleTaskMemory+0x30>)
 810a7da:	601a      	str	r2, [r3, #0]
  *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
 810a7dc:	687b      	ldr	r3, [r7, #4]
 810a7de:	2280      	movs	r2, #128	@ 0x80
 810a7e0:	601a      	str	r2, [r3, #0]
}
 810a7e2:	bf00      	nop
 810a7e4:	3714      	adds	r7, #20
 810a7e6:	46bd      	mov	sp, r7
 810a7e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 810a7ec:	4770      	bx	lr
 810a7ee:	bf00      	nop
 810a7f0:	10000be0 	.word	0x10000be0
 810a7f4:	10000c3c 	.word	0x10000c3c

0810a7f8 <vApplicationGetTimerTaskMemory>:

/*
  vApplicationGetTimerTaskMemory gets called when configSUPPORT_STATIC_ALLOCATION
  equals to 1 and is required for static memory allocation support.
*/
__WEAK void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
 810a7f8:	b480      	push	{r7}
 810a7fa:	b085      	sub	sp, #20
 810a7fc:	af00      	add	r7, sp, #0
 810a7fe:	60f8      	str	r0, [r7, #12]
 810a800:	60b9      	str	r1, [r7, #8]
 810a802:	607a      	str	r2, [r7, #4]
  /* Timer task control block and stack */
  static StaticTask_t Timer_TCB;
  static StackType_t  Timer_Stack[configTIMER_TASK_STACK_DEPTH];

  *ppxTimerTaskTCBBuffer   = &Timer_TCB;
 810a804:	68fb      	ldr	r3, [r7, #12]
 810a806:	4a07      	ldr	r2, [pc, #28]	@ (810a824 <vApplicationGetTimerTaskMemory+0x2c>)
 810a808:	601a      	str	r2, [r3, #0]
  *ppxTimerTaskStackBuffer = &Timer_Stack[0];
 810a80a:	68bb      	ldr	r3, [r7, #8]
 810a80c:	4a06      	ldr	r2, [pc, #24]	@ (810a828 <vApplicationGetTimerTaskMemory+0x30>)
 810a80e:	601a      	str	r2, [r3, #0]
  *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
 810a810:	687b      	ldr	r3, [r7, #4]
 810a812:	f44f 7280 	mov.w	r2, #256	@ 0x100
 810a816:	601a      	str	r2, [r3, #0]
}
 810a818:	bf00      	nop
 810a81a:	3714      	adds	r7, #20
 810a81c:	46bd      	mov	sp, r7
 810a81e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810a822:	4770      	bx	lr
 810a824:	10000e3c 	.word	0x10000e3c
 810a828:	10000e98 	.word	0x10000e98

0810a82c <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 810a82c:	b580      	push	{r7, lr}
 810a82e:	b08a      	sub	sp, #40	@ 0x28
 810a830:	af00      	add	r7, sp, #0
 810a832:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
 810a834:	2300      	movs	r3, #0
 810a836:	61fb      	str	r3, [r7, #28]

	vTaskSuspendAll();
 810a838:	f001 fd26 	bl	810c288 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
 810a83c:	4b5c      	ldr	r3, [pc, #368]	@ (810a9b0 <pvPortMalloc+0x184>)
 810a83e:	681b      	ldr	r3, [r3, #0]
 810a840:	2b00      	cmp	r3, #0
 810a842:	d101      	bne.n	810a848 <pvPortMalloc+0x1c>
		{
			prvHeapInit();
 810a844:	f000 f924 	bl	810aa90 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 810a848:	4b5a      	ldr	r3, [pc, #360]	@ (810a9b4 <pvPortMalloc+0x188>)
 810a84a:	681a      	ldr	r2, [r3, #0]
 810a84c:	687b      	ldr	r3, [r7, #4]
 810a84e:	4013      	ands	r3, r2
 810a850:	2b00      	cmp	r3, #0
 810a852:	f040 8095 	bne.w	810a980 <pvPortMalloc+0x154>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
 810a856:	687b      	ldr	r3, [r7, #4]
 810a858:	2b00      	cmp	r3, #0
 810a85a:	d01e      	beq.n	810a89a <pvPortMalloc+0x6e>
			{
				xWantedSize += xHeapStructSize;
 810a85c:	2208      	movs	r2, #8
 810a85e:	687b      	ldr	r3, [r7, #4]
 810a860:	4413      	add	r3, r2
 810a862:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 810a864:	687b      	ldr	r3, [r7, #4]
 810a866:	f003 0307 	and.w	r3, r3, #7
 810a86a:	2b00      	cmp	r3, #0
 810a86c:	d015      	beq.n	810a89a <pvPortMalloc+0x6e>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 810a86e:	687b      	ldr	r3, [r7, #4]
 810a870:	f023 0307 	bic.w	r3, r3, #7
 810a874:	3308      	adds	r3, #8
 810a876:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
 810a878:	687b      	ldr	r3, [r7, #4]
 810a87a:	f003 0307 	and.w	r3, r3, #7
 810a87e:	2b00      	cmp	r3, #0
 810a880:	d00b      	beq.n	810a89a <pvPortMalloc+0x6e>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 810a882:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810a886:	f383 8811 	msr	BASEPRI, r3
 810a88a:	f3bf 8f6f 	isb	sy
 810a88e:	f3bf 8f4f 	dsb	sy
 810a892:	617b      	str	r3, [r7, #20]
		"	msr basepri, %0											\n" \
		"	isb														\n" \
		"	dsb														\n" \
		:"=r" (ulNewBASEPRI) : "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "memory"
	);
}
 810a894:	bf00      	nop
 810a896:	bf00      	nop
 810a898:	e7fd      	b.n	810a896 <pvPortMalloc+0x6a>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 810a89a:	687b      	ldr	r3, [r7, #4]
 810a89c:	2b00      	cmp	r3, #0
 810a89e:	d06f      	beq.n	810a980 <pvPortMalloc+0x154>
 810a8a0:	4b45      	ldr	r3, [pc, #276]	@ (810a9b8 <pvPortMalloc+0x18c>)
 810a8a2:	681b      	ldr	r3, [r3, #0]
 810a8a4:	687a      	ldr	r2, [r7, #4]
 810a8a6:	429a      	cmp	r2, r3
 810a8a8:	d86a      	bhi.n	810a980 <pvPortMalloc+0x154>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
 810a8aa:	4b44      	ldr	r3, [pc, #272]	@ (810a9bc <pvPortMalloc+0x190>)
 810a8ac:	623b      	str	r3, [r7, #32]
				pxBlock = xStart.pxNextFreeBlock;
 810a8ae:	4b43      	ldr	r3, [pc, #268]	@ (810a9bc <pvPortMalloc+0x190>)
 810a8b0:	681b      	ldr	r3, [r3, #0]
 810a8b2:	627b      	str	r3, [r7, #36]	@ 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 810a8b4:	e004      	b.n	810a8c0 <pvPortMalloc+0x94>
				{
					pxPreviousBlock = pxBlock;
 810a8b6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a8b8:	623b      	str	r3, [r7, #32]
					pxBlock = pxBlock->pxNextFreeBlock;
 810a8ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a8bc:	681b      	ldr	r3, [r3, #0]
 810a8be:	627b      	str	r3, [r7, #36]	@ 0x24
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 810a8c0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a8c2:	685b      	ldr	r3, [r3, #4]
 810a8c4:	687a      	ldr	r2, [r7, #4]
 810a8c6:	429a      	cmp	r2, r3
 810a8c8:	d903      	bls.n	810a8d2 <pvPortMalloc+0xa6>
 810a8ca:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a8cc:	681b      	ldr	r3, [r3, #0]
 810a8ce:	2b00      	cmp	r3, #0
 810a8d0:	d1f1      	bne.n	810a8b6 <pvPortMalloc+0x8a>
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
 810a8d2:	4b37      	ldr	r3, [pc, #220]	@ (810a9b0 <pvPortMalloc+0x184>)
 810a8d4:	681b      	ldr	r3, [r3, #0]
 810a8d6:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 810a8d8:	429a      	cmp	r2, r3
 810a8da:	d051      	beq.n	810a980 <pvPortMalloc+0x154>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 810a8dc:	6a3b      	ldr	r3, [r7, #32]
 810a8de:	681b      	ldr	r3, [r3, #0]
 810a8e0:	2208      	movs	r2, #8
 810a8e2:	4413      	add	r3, r2
 810a8e4:	61fb      	str	r3, [r7, #28]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 810a8e6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a8e8:	681a      	ldr	r2, [r3, #0]
 810a8ea:	6a3b      	ldr	r3, [r7, #32]
 810a8ec:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 810a8ee:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a8f0:	685a      	ldr	r2, [r3, #4]
 810a8f2:	687b      	ldr	r3, [r7, #4]
 810a8f4:	1ad2      	subs	r2, r2, r3
 810a8f6:	2308      	movs	r3, #8
 810a8f8:	005b      	lsls	r3, r3, #1
 810a8fa:	429a      	cmp	r2, r3
 810a8fc:	d920      	bls.n	810a940 <pvPortMalloc+0x114>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 810a8fe:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 810a900:	687b      	ldr	r3, [r7, #4]
 810a902:	4413      	add	r3, r2
 810a904:	61bb      	str	r3, [r7, #24]
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 810a906:	69bb      	ldr	r3, [r7, #24]
 810a908:	f003 0307 	and.w	r3, r3, #7
 810a90c:	2b00      	cmp	r3, #0
 810a90e:	d00b      	beq.n	810a928 <pvPortMalloc+0xfc>
	__asm volatile
 810a910:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810a914:	f383 8811 	msr	BASEPRI, r3
 810a918:	f3bf 8f6f 	isb	sy
 810a91c:	f3bf 8f4f 	dsb	sy
 810a920:	613b      	str	r3, [r7, #16]
}
 810a922:	bf00      	nop
 810a924:	bf00      	nop
 810a926:	e7fd      	b.n	810a924 <pvPortMalloc+0xf8>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 810a928:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a92a:	685a      	ldr	r2, [r3, #4]
 810a92c:	687b      	ldr	r3, [r7, #4]
 810a92e:	1ad2      	subs	r2, r2, r3
 810a930:	69bb      	ldr	r3, [r7, #24]
 810a932:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
 810a934:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a936:	687a      	ldr	r2, [r7, #4]
 810a938:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 810a93a:	69b8      	ldr	r0, [r7, #24]
 810a93c:	f000 f90a 	bl	810ab54 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
 810a940:	4b1d      	ldr	r3, [pc, #116]	@ (810a9b8 <pvPortMalloc+0x18c>)
 810a942:	681a      	ldr	r2, [r3, #0]
 810a944:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a946:	685b      	ldr	r3, [r3, #4]
 810a948:	1ad3      	subs	r3, r2, r3
 810a94a:	4a1b      	ldr	r2, [pc, #108]	@ (810a9b8 <pvPortMalloc+0x18c>)
 810a94c:	6013      	str	r3, [r2, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 810a94e:	4b1a      	ldr	r3, [pc, #104]	@ (810a9b8 <pvPortMalloc+0x18c>)
 810a950:	681a      	ldr	r2, [r3, #0]
 810a952:	4b1b      	ldr	r3, [pc, #108]	@ (810a9c0 <pvPortMalloc+0x194>)
 810a954:	681b      	ldr	r3, [r3, #0]
 810a956:	429a      	cmp	r2, r3
 810a958:	d203      	bcs.n	810a962 <pvPortMalloc+0x136>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 810a95a:	4b17      	ldr	r3, [pc, #92]	@ (810a9b8 <pvPortMalloc+0x18c>)
 810a95c:	681b      	ldr	r3, [r3, #0]
 810a95e:	4a18      	ldr	r2, [pc, #96]	@ (810a9c0 <pvPortMalloc+0x194>)
 810a960:	6013      	str	r3, [r2, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 810a962:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a964:	685a      	ldr	r2, [r3, #4]
 810a966:	4b13      	ldr	r3, [pc, #76]	@ (810a9b4 <pvPortMalloc+0x188>)
 810a968:	681b      	ldr	r3, [r3, #0]
 810a96a:	431a      	orrs	r2, r3
 810a96c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a96e:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
 810a970:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810a972:	2200      	movs	r2, #0
 810a974:	601a      	str	r2, [r3, #0]
					xNumberOfSuccessfulAllocations++;
 810a976:	4b13      	ldr	r3, [pc, #76]	@ (810a9c4 <pvPortMalloc+0x198>)
 810a978:	681b      	ldr	r3, [r3, #0]
 810a97a:	3301      	adds	r3, #1
 810a97c:	4a11      	ldr	r2, [pc, #68]	@ (810a9c4 <pvPortMalloc+0x198>)
 810a97e:	6013      	str	r3, [r2, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 810a980:	f001 fc90 	bl	810c2a4 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 810a984:	69fb      	ldr	r3, [r7, #28]
 810a986:	f003 0307 	and.w	r3, r3, #7
 810a98a:	2b00      	cmp	r3, #0
 810a98c:	d00b      	beq.n	810a9a6 <pvPortMalloc+0x17a>
	__asm volatile
 810a98e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810a992:	f383 8811 	msr	BASEPRI, r3
 810a996:	f3bf 8f6f 	isb	sy
 810a99a:	f3bf 8f4f 	dsb	sy
 810a99e:	60fb      	str	r3, [r7, #12]
}
 810a9a0:	bf00      	nop
 810a9a2:	bf00      	nop
 810a9a4:	e7fd      	b.n	810a9a2 <pvPortMalloc+0x176>
	return pvReturn;
 810a9a6:	69fb      	ldr	r3, [r7, #28]
}
 810a9a8:	4618      	mov	r0, r3
 810a9aa:	3728      	adds	r7, #40	@ 0x28
 810a9ac:	46bd      	mov	sp, r7
 810a9ae:	bd80      	pop	{r7, pc}
 810a9b0:	10004ea0 	.word	0x10004ea0
 810a9b4:	10004eb4 	.word	0x10004eb4
 810a9b8:	10004ea4 	.word	0x10004ea4
 810a9bc:	10004e98 	.word	0x10004e98
 810a9c0:	10004ea8 	.word	0x10004ea8
 810a9c4:	10004eac 	.word	0x10004eac

0810a9c8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 810a9c8:	b580      	push	{r7, lr}
 810a9ca:	b086      	sub	sp, #24
 810a9cc:	af00      	add	r7, sp, #0
 810a9ce:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
 810a9d0:	687b      	ldr	r3, [r7, #4]
 810a9d2:	617b      	str	r3, [r7, #20]
BlockLink_t *pxLink;

	if( pv != NULL )
 810a9d4:	687b      	ldr	r3, [r7, #4]
 810a9d6:	2b00      	cmp	r3, #0
 810a9d8:	d04f      	beq.n	810aa7a <vPortFree+0xb2>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
 810a9da:	2308      	movs	r3, #8
 810a9dc:	425b      	negs	r3, r3
 810a9de:	697a      	ldr	r2, [r7, #20]
 810a9e0:	4413      	add	r3, r2
 810a9e2:	617b      	str	r3, [r7, #20]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
 810a9e4:	697b      	ldr	r3, [r7, #20]
 810a9e6:	613b      	str	r3, [r7, #16]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 810a9e8:	693b      	ldr	r3, [r7, #16]
 810a9ea:	685a      	ldr	r2, [r3, #4]
 810a9ec:	4b25      	ldr	r3, [pc, #148]	@ (810aa84 <vPortFree+0xbc>)
 810a9ee:	681b      	ldr	r3, [r3, #0]
 810a9f0:	4013      	ands	r3, r2
 810a9f2:	2b00      	cmp	r3, #0
 810a9f4:	d10b      	bne.n	810aa0e <vPortFree+0x46>
	__asm volatile
 810a9f6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810a9fa:	f383 8811 	msr	BASEPRI, r3
 810a9fe:	f3bf 8f6f 	isb	sy
 810aa02:	f3bf 8f4f 	dsb	sy
 810aa06:	60fb      	str	r3, [r7, #12]
}
 810aa08:	bf00      	nop
 810aa0a:	bf00      	nop
 810aa0c:	e7fd      	b.n	810aa0a <vPortFree+0x42>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 810aa0e:	693b      	ldr	r3, [r7, #16]
 810aa10:	681b      	ldr	r3, [r3, #0]
 810aa12:	2b00      	cmp	r3, #0
 810aa14:	d00b      	beq.n	810aa2e <vPortFree+0x66>
	__asm volatile
 810aa16:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810aa1a:	f383 8811 	msr	BASEPRI, r3
 810aa1e:	f3bf 8f6f 	isb	sy
 810aa22:	f3bf 8f4f 	dsb	sy
 810aa26:	60bb      	str	r3, [r7, #8]
}
 810aa28:	bf00      	nop
 810aa2a:	bf00      	nop
 810aa2c:	e7fd      	b.n	810aa2a <vPortFree+0x62>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
 810aa2e:	693b      	ldr	r3, [r7, #16]
 810aa30:	685a      	ldr	r2, [r3, #4]
 810aa32:	4b14      	ldr	r3, [pc, #80]	@ (810aa84 <vPortFree+0xbc>)
 810aa34:	681b      	ldr	r3, [r3, #0]
 810aa36:	4013      	ands	r3, r2
 810aa38:	2b00      	cmp	r3, #0
 810aa3a:	d01e      	beq.n	810aa7a <vPortFree+0xb2>
		{
			if( pxLink->pxNextFreeBlock == NULL )
 810aa3c:	693b      	ldr	r3, [r7, #16]
 810aa3e:	681b      	ldr	r3, [r3, #0]
 810aa40:	2b00      	cmp	r3, #0
 810aa42:	d11a      	bne.n	810aa7a <vPortFree+0xb2>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 810aa44:	693b      	ldr	r3, [r7, #16]
 810aa46:	685a      	ldr	r2, [r3, #4]
 810aa48:	4b0e      	ldr	r3, [pc, #56]	@ (810aa84 <vPortFree+0xbc>)
 810aa4a:	681b      	ldr	r3, [r3, #0]
 810aa4c:	43db      	mvns	r3, r3
 810aa4e:	401a      	ands	r2, r3
 810aa50:	693b      	ldr	r3, [r7, #16]
 810aa52:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
 810aa54:	f001 fc18 	bl	810c288 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
 810aa58:	693b      	ldr	r3, [r7, #16]
 810aa5a:	685a      	ldr	r2, [r3, #4]
 810aa5c:	4b0a      	ldr	r3, [pc, #40]	@ (810aa88 <vPortFree+0xc0>)
 810aa5e:	681b      	ldr	r3, [r3, #0]
 810aa60:	4413      	add	r3, r2
 810aa62:	4a09      	ldr	r2, [pc, #36]	@ (810aa88 <vPortFree+0xc0>)
 810aa64:	6013      	str	r3, [r2, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 810aa66:	6938      	ldr	r0, [r7, #16]
 810aa68:	f000 f874 	bl	810ab54 <prvInsertBlockIntoFreeList>
					xNumberOfSuccessfulFrees++;
 810aa6c:	4b07      	ldr	r3, [pc, #28]	@ (810aa8c <vPortFree+0xc4>)
 810aa6e:	681b      	ldr	r3, [r3, #0]
 810aa70:	3301      	adds	r3, #1
 810aa72:	4a06      	ldr	r2, [pc, #24]	@ (810aa8c <vPortFree+0xc4>)
 810aa74:	6013      	str	r3, [r2, #0]
				}
				( void ) xTaskResumeAll();
 810aa76:	f001 fc15 	bl	810c2a4 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 810aa7a:	bf00      	nop
 810aa7c:	3718      	adds	r7, #24
 810aa7e:	46bd      	mov	sp, r7
 810aa80:	bd80      	pop	{r7, pc}
 810aa82:	bf00      	nop
 810aa84:	10004eb4 	.word	0x10004eb4
 810aa88:	10004ea4 	.word	0x10004ea4
 810aa8c:	10004eb0 	.word	0x10004eb0

0810aa90 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
 810aa90:	b480      	push	{r7}
 810aa92:	b085      	sub	sp, #20
 810aa94:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
size_t uxAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 810aa96:	f44f 5370 	mov.w	r3, #15360	@ 0x3c00
 810aa9a:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	uxAddress = ( size_t ) ucHeap;
 810aa9c:	4b27      	ldr	r3, [pc, #156]	@ (810ab3c <prvHeapInit+0xac>)
 810aa9e:	60fb      	str	r3, [r7, #12]

	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 810aaa0:	68fb      	ldr	r3, [r7, #12]
 810aaa2:	f003 0307 	and.w	r3, r3, #7
 810aaa6:	2b00      	cmp	r3, #0
 810aaa8:	d00c      	beq.n	810aac4 <prvHeapInit+0x34>
	{
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 810aaaa:	68fb      	ldr	r3, [r7, #12]
 810aaac:	3307      	adds	r3, #7
 810aaae:	60fb      	str	r3, [r7, #12]
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 810aab0:	68fb      	ldr	r3, [r7, #12]
 810aab2:	f023 0307 	bic.w	r3, r3, #7
 810aab6:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 810aab8:	68ba      	ldr	r2, [r7, #8]
 810aaba:	68fb      	ldr	r3, [r7, #12]
 810aabc:	1ad3      	subs	r3, r2, r3
 810aabe:	4a1f      	ldr	r2, [pc, #124]	@ (810ab3c <prvHeapInit+0xac>)
 810aac0:	4413      	add	r3, r2
 810aac2:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) uxAddress;
 810aac4:	68fb      	ldr	r3, [r7, #12]
 810aac6:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 810aac8:	4a1d      	ldr	r2, [pc, #116]	@ (810ab40 <prvHeapInit+0xb0>)
 810aaca:	687b      	ldr	r3, [r7, #4]
 810aacc:	6013      	str	r3, [r2, #0]
	xStart.xBlockSize = ( size_t ) 0;
 810aace:	4b1c      	ldr	r3, [pc, #112]	@ (810ab40 <prvHeapInit+0xb0>)
 810aad0:	2200      	movs	r2, #0
 810aad2:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 810aad4:	687b      	ldr	r3, [r7, #4]
 810aad6:	68ba      	ldr	r2, [r7, #8]
 810aad8:	4413      	add	r3, r2
 810aada:	60fb      	str	r3, [r7, #12]
	uxAddress -= xHeapStructSize;
 810aadc:	2208      	movs	r2, #8
 810aade:	68fb      	ldr	r3, [r7, #12]
 810aae0:	1a9b      	subs	r3, r3, r2
 810aae2:	60fb      	str	r3, [r7, #12]
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 810aae4:	68fb      	ldr	r3, [r7, #12]
 810aae6:	f023 0307 	bic.w	r3, r3, #7
 810aaea:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) uxAddress;
 810aaec:	68fb      	ldr	r3, [r7, #12]
 810aaee:	4a15      	ldr	r2, [pc, #84]	@ (810ab44 <prvHeapInit+0xb4>)
 810aaf0:	6013      	str	r3, [r2, #0]
	pxEnd->xBlockSize = 0;
 810aaf2:	4b14      	ldr	r3, [pc, #80]	@ (810ab44 <prvHeapInit+0xb4>)
 810aaf4:	681b      	ldr	r3, [r3, #0]
 810aaf6:	2200      	movs	r2, #0
 810aaf8:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 810aafa:	4b12      	ldr	r3, [pc, #72]	@ (810ab44 <prvHeapInit+0xb4>)
 810aafc:	681b      	ldr	r3, [r3, #0]
 810aafe:	2200      	movs	r2, #0
 810ab00:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
 810ab02:	687b      	ldr	r3, [r7, #4]
 810ab04:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 810ab06:	683b      	ldr	r3, [r7, #0]
 810ab08:	68fa      	ldr	r2, [r7, #12]
 810ab0a:	1ad2      	subs	r2, r2, r3
 810ab0c:	683b      	ldr	r3, [r7, #0]
 810ab0e:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 810ab10:	4b0c      	ldr	r3, [pc, #48]	@ (810ab44 <prvHeapInit+0xb4>)
 810ab12:	681a      	ldr	r2, [r3, #0]
 810ab14:	683b      	ldr	r3, [r7, #0]
 810ab16:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 810ab18:	683b      	ldr	r3, [r7, #0]
 810ab1a:	685b      	ldr	r3, [r3, #4]
 810ab1c:	4a0a      	ldr	r2, [pc, #40]	@ (810ab48 <prvHeapInit+0xb8>)
 810ab1e:	6013      	str	r3, [r2, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 810ab20:	683b      	ldr	r3, [r7, #0]
 810ab22:	685b      	ldr	r3, [r3, #4]
 810ab24:	4a09      	ldr	r2, [pc, #36]	@ (810ab4c <prvHeapInit+0xbc>)
 810ab26:	6013      	str	r3, [r2, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 810ab28:	4b09      	ldr	r3, [pc, #36]	@ (810ab50 <prvHeapInit+0xc0>)
 810ab2a:	f04f 4200 	mov.w	r2, #2147483648	@ 0x80000000
 810ab2e:	601a      	str	r2, [r3, #0]
}
 810ab30:	bf00      	nop
 810ab32:	3714      	adds	r7, #20
 810ab34:	46bd      	mov	sp, r7
 810ab36:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ab3a:	4770      	bx	lr
 810ab3c:	10001298 	.word	0x10001298
 810ab40:	10004e98 	.word	0x10004e98
 810ab44:	10004ea0 	.word	0x10004ea0
 810ab48:	10004ea8 	.word	0x10004ea8
 810ab4c:	10004ea4 	.word	0x10004ea4
 810ab50:	10004eb4 	.word	0x10004eb4

0810ab54 <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 810ab54:	b480      	push	{r7}
 810ab56:	b085      	sub	sp, #20
 810ab58:	af00      	add	r7, sp, #0
 810ab5a:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 810ab5c:	4b28      	ldr	r3, [pc, #160]	@ (810ac00 <prvInsertBlockIntoFreeList+0xac>)
 810ab5e:	60fb      	str	r3, [r7, #12]
 810ab60:	e002      	b.n	810ab68 <prvInsertBlockIntoFreeList+0x14>
 810ab62:	68fb      	ldr	r3, [r7, #12]
 810ab64:	681b      	ldr	r3, [r3, #0]
 810ab66:	60fb      	str	r3, [r7, #12]
 810ab68:	68fb      	ldr	r3, [r7, #12]
 810ab6a:	681b      	ldr	r3, [r3, #0]
 810ab6c:	687a      	ldr	r2, [r7, #4]
 810ab6e:	429a      	cmp	r2, r3
 810ab70:	d8f7      	bhi.n	810ab62 <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
 810ab72:	68fb      	ldr	r3, [r7, #12]
 810ab74:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 810ab76:	68fb      	ldr	r3, [r7, #12]
 810ab78:	685b      	ldr	r3, [r3, #4]
 810ab7a:	68ba      	ldr	r2, [r7, #8]
 810ab7c:	4413      	add	r3, r2
 810ab7e:	687a      	ldr	r2, [r7, #4]
 810ab80:	429a      	cmp	r2, r3
 810ab82:	d108      	bne.n	810ab96 <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 810ab84:	68fb      	ldr	r3, [r7, #12]
 810ab86:	685a      	ldr	r2, [r3, #4]
 810ab88:	687b      	ldr	r3, [r7, #4]
 810ab8a:	685b      	ldr	r3, [r3, #4]
 810ab8c:	441a      	add	r2, r3
 810ab8e:	68fb      	ldr	r3, [r7, #12]
 810ab90:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
 810ab92:	68fb      	ldr	r3, [r7, #12]
 810ab94:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
 810ab96:	687b      	ldr	r3, [r7, #4]
 810ab98:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 810ab9a:	687b      	ldr	r3, [r7, #4]
 810ab9c:	685b      	ldr	r3, [r3, #4]
 810ab9e:	68ba      	ldr	r2, [r7, #8]
 810aba0:	441a      	add	r2, r3
 810aba2:	68fb      	ldr	r3, [r7, #12]
 810aba4:	681b      	ldr	r3, [r3, #0]
 810aba6:	429a      	cmp	r2, r3
 810aba8:	d118      	bne.n	810abdc <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 810abaa:	68fb      	ldr	r3, [r7, #12]
 810abac:	681a      	ldr	r2, [r3, #0]
 810abae:	4b15      	ldr	r3, [pc, #84]	@ (810ac04 <prvInsertBlockIntoFreeList+0xb0>)
 810abb0:	681b      	ldr	r3, [r3, #0]
 810abb2:	429a      	cmp	r2, r3
 810abb4:	d00d      	beq.n	810abd2 <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 810abb6:	687b      	ldr	r3, [r7, #4]
 810abb8:	685a      	ldr	r2, [r3, #4]
 810abba:	68fb      	ldr	r3, [r7, #12]
 810abbc:	681b      	ldr	r3, [r3, #0]
 810abbe:	685b      	ldr	r3, [r3, #4]
 810abc0:	441a      	add	r2, r3
 810abc2:	687b      	ldr	r3, [r7, #4]
 810abc4:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 810abc6:	68fb      	ldr	r3, [r7, #12]
 810abc8:	681b      	ldr	r3, [r3, #0]
 810abca:	681a      	ldr	r2, [r3, #0]
 810abcc:	687b      	ldr	r3, [r7, #4]
 810abce:	601a      	str	r2, [r3, #0]
 810abd0:	e008      	b.n	810abe4 <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
 810abd2:	4b0c      	ldr	r3, [pc, #48]	@ (810ac04 <prvInsertBlockIntoFreeList+0xb0>)
 810abd4:	681a      	ldr	r2, [r3, #0]
 810abd6:	687b      	ldr	r3, [r7, #4]
 810abd8:	601a      	str	r2, [r3, #0]
 810abda:	e003      	b.n	810abe4 <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 810abdc:	68fb      	ldr	r3, [r7, #12]
 810abde:	681a      	ldr	r2, [r3, #0]
 810abe0:	687b      	ldr	r3, [r7, #4]
 810abe2:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 810abe4:	68fa      	ldr	r2, [r7, #12]
 810abe6:	687b      	ldr	r3, [r7, #4]
 810abe8:	429a      	cmp	r2, r3
 810abea:	d002      	beq.n	810abf2 <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 810abec:	68fb      	ldr	r3, [r7, #12]
 810abee:	687a      	ldr	r2, [r7, #4]
 810abf0:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 810abf2:	bf00      	nop
 810abf4:	3714      	adds	r7, #20
 810abf6:	46bd      	mov	sp, r7
 810abf8:	f85d 7b04 	ldr.w	r7, [sp], #4
 810abfc:	4770      	bx	lr
 810abfe:	bf00      	nop
 810ac00:	10004e98 	.word	0x10004e98
 810ac04:	10004ea0 	.word	0x10004ea0

0810ac08 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 810ac08:	b480      	push	{r7}
 810ac0a:	b083      	sub	sp, #12
 810ac0c:	af00      	add	r7, sp, #0
 810ac0e:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 810ac10:	687b      	ldr	r3, [r7, #4]
 810ac12:	f103 0208 	add.w	r2, r3, #8
 810ac16:	687b      	ldr	r3, [r7, #4]
 810ac18:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 810ac1a:	687b      	ldr	r3, [r7, #4]
 810ac1c:	f04f 32ff 	mov.w	r2, #4294967295
 810ac20:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 810ac22:	687b      	ldr	r3, [r7, #4]
 810ac24:	f103 0208 	add.w	r2, r3, #8
 810ac28:	687b      	ldr	r3, [r7, #4]
 810ac2a:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 810ac2c:	687b      	ldr	r3, [r7, #4]
 810ac2e:	f103 0208 	add.w	r2, r3, #8
 810ac32:	687b      	ldr	r3, [r7, #4]
 810ac34:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 810ac36:	687b      	ldr	r3, [r7, #4]
 810ac38:	2200      	movs	r2, #0
 810ac3a:	601a      	str	r2, [r3, #0]

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
 810ac3c:	bf00      	nop
 810ac3e:	370c      	adds	r7, #12
 810ac40:	46bd      	mov	sp, r7
 810ac42:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ac46:	4770      	bx	lr

0810ac48 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
 810ac48:	b480      	push	{r7}
 810ac4a:	b083      	sub	sp, #12
 810ac4c:	af00      	add	r7, sp, #0
 810ac4e:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
 810ac50:	687b      	ldr	r3, [r7, #4]
 810ac52:	2200      	movs	r2, #0
 810ac54:	611a      	str	r2, [r3, #16]

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
 810ac56:	bf00      	nop
 810ac58:	370c      	adds	r7, #12
 810ac5a:	46bd      	mov	sp, r7
 810ac5c:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ac60:	4770      	bx	lr

0810ac62 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 810ac62:	b480      	push	{r7}
 810ac64:	b085      	sub	sp, #20
 810ac66:	af00      	add	r7, sp, #0
 810ac68:	6078      	str	r0, [r7, #4]
 810ac6a:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
 810ac6c:	687b      	ldr	r3, [r7, #4]
 810ac6e:	685b      	ldr	r3, [r3, #4]
 810ac70:	60fb      	str	r3, [r7, #12]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 810ac72:	683b      	ldr	r3, [r7, #0]
 810ac74:	68fa      	ldr	r2, [r7, #12]
 810ac76:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 810ac78:	68fb      	ldr	r3, [r7, #12]
 810ac7a:	689a      	ldr	r2, [r3, #8]
 810ac7c:	683b      	ldr	r3, [r7, #0]
 810ac7e:	609a      	str	r2, [r3, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 810ac80:	68fb      	ldr	r3, [r7, #12]
 810ac82:	689b      	ldr	r3, [r3, #8]
 810ac84:	683a      	ldr	r2, [r7, #0]
 810ac86:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
 810ac88:	68fb      	ldr	r3, [r7, #12]
 810ac8a:	683a      	ldr	r2, [r7, #0]
 810ac8c:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
 810ac8e:	683b      	ldr	r3, [r7, #0]
 810ac90:	687a      	ldr	r2, [r7, #4]
 810ac92:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 810ac94:	687b      	ldr	r3, [r7, #4]
 810ac96:	681b      	ldr	r3, [r3, #0]
 810ac98:	1c5a      	adds	r2, r3, #1
 810ac9a:	687b      	ldr	r3, [r7, #4]
 810ac9c:	601a      	str	r2, [r3, #0]
}
 810ac9e:	bf00      	nop
 810aca0:	3714      	adds	r7, #20
 810aca2:	46bd      	mov	sp, r7
 810aca4:	f85d 7b04 	ldr.w	r7, [sp], #4
 810aca8:	4770      	bx	lr

0810acaa <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 810acaa:	b480      	push	{r7}
 810acac:	b085      	sub	sp, #20
 810acae:	af00      	add	r7, sp, #0
 810acb0:	6078      	str	r0, [r7, #4]
 810acb2:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 810acb4:	683b      	ldr	r3, [r7, #0]
 810acb6:	681b      	ldr	r3, [r3, #0]
 810acb8:	60bb      	str	r3, [r7, #8]
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 810acba:	68bb      	ldr	r3, [r7, #8]
 810acbc:	f1b3 3fff 	cmp.w	r3, #4294967295
 810acc0:	d103      	bne.n	810acca <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 810acc2:	687b      	ldr	r3, [r7, #4]
 810acc4:	691b      	ldr	r3, [r3, #16]
 810acc6:	60fb      	str	r3, [r7, #12]
 810acc8:	e00c      	b.n	810ace4 <vListInsert+0x3a>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
 810acca:	687b      	ldr	r3, [r7, #4]
 810accc:	3308      	adds	r3, #8
 810acce:	60fb      	str	r3, [r7, #12]
 810acd0:	e002      	b.n	810acd8 <vListInsert+0x2e>
 810acd2:	68fb      	ldr	r3, [r7, #12]
 810acd4:	685b      	ldr	r3, [r3, #4]
 810acd6:	60fb      	str	r3, [r7, #12]
 810acd8:	68fb      	ldr	r3, [r7, #12]
 810acda:	685b      	ldr	r3, [r3, #4]
 810acdc:	681b      	ldr	r3, [r3, #0]
 810acde:	68ba      	ldr	r2, [r7, #8]
 810ace0:	429a      	cmp	r2, r3
 810ace2:	d2f6      	bcs.n	810acd2 <vListInsert+0x28>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 810ace4:	68fb      	ldr	r3, [r7, #12]
 810ace6:	685a      	ldr	r2, [r3, #4]
 810ace8:	683b      	ldr	r3, [r7, #0]
 810acea:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 810acec:	683b      	ldr	r3, [r7, #0]
 810acee:	685b      	ldr	r3, [r3, #4]
 810acf0:	683a      	ldr	r2, [r7, #0]
 810acf2:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
 810acf4:	683b      	ldr	r3, [r7, #0]
 810acf6:	68fa      	ldr	r2, [r7, #12]
 810acf8:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
 810acfa:	68fb      	ldr	r3, [r7, #12]
 810acfc:	683a      	ldr	r2, [r7, #0]
 810acfe:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
 810ad00:	683b      	ldr	r3, [r7, #0]
 810ad02:	687a      	ldr	r2, [r7, #4]
 810ad04:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
 810ad06:	687b      	ldr	r3, [r7, #4]
 810ad08:	681b      	ldr	r3, [r3, #0]
 810ad0a:	1c5a      	adds	r2, r3, #1
 810ad0c:	687b      	ldr	r3, [r7, #4]
 810ad0e:	601a      	str	r2, [r3, #0]
}
 810ad10:	bf00      	nop
 810ad12:	3714      	adds	r7, #20
 810ad14:	46bd      	mov	sp, r7
 810ad16:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ad1a:	4770      	bx	lr

0810ad1c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 810ad1c:	b480      	push	{r7}
 810ad1e:	b085      	sub	sp, #20
 810ad20:	af00      	add	r7, sp, #0
 810ad22:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 810ad24:	687b      	ldr	r3, [r7, #4]
 810ad26:	691b      	ldr	r3, [r3, #16]
 810ad28:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 810ad2a:	687b      	ldr	r3, [r7, #4]
 810ad2c:	685b      	ldr	r3, [r3, #4]
 810ad2e:	687a      	ldr	r2, [r7, #4]
 810ad30:	6892      	ldr	r2, [r2, #8]
 810ad32:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 810ad34:	687b      	ldr	r3, [r7, #4]
 810ad36:	689b      	ldr	r3, [r3, #8]
 810ad38:	687a      	ldr	r2, [r7, #4]
 810ad3a:	6852      	ldr	r2, [r2, #4]
 810ad3c:	605a      	str	r2, [r3, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 810ad3e:	68fb      	ldr	r3, [r7, #12]
 810ad40:	685b      	ldr	r3, [r3, #4]
 810ad42:	687a      	ldr	r2, [r7, #4]
 810ad44:	429a      	cmp	r2, r3
 810ad46:	d103      	bne.n	810ad50 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 810ad48:	687b      	ldr	r3, [r7, #4]
 810ad4a:	689a      	ldr	r2, [r3, #8]
 810ad4c:	68fb      	ldr	r3, [r7, #12]
 810ad4e:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
 810ad50:	687b      	ldr	r3, [r7, #4]
 810ad52:	2200      	movs	r2, #0
 810ad54:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
 810ad56:	68fb      	ldr	r3, [r7, #12]
 810ad58:	681b      	ldr	r3, [r3, #0]
 810ad5a:	1e5a      	subs	r2, r3, #1
 810ad5c:	68fb      	ldr	r3, [r7, #12]
 810ad5e:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
 810ad60:	68fb      	ldr	r3, [r7, #12]
 810ad62:	681b      	ldr	r3, [r3, #0]
}
 810ad64:	4618      	mov	r0, r3
 810ad66:	3714      	adds	r7, #20
 810ad68:	46bd      	mov	sp, r7
 810ad6a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ad6e:	4770      	bx	lr

0810ad70 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
 810ad70:	b480      	push	{r7}
 810ad72:	b085      	sub	sp, #20
 810ad74:	af00      	add	r7, sp, #0
 810ad76:	60f8      	str	r0, [r7, #12]
 810ad78:	60b9      	str	r1, [r7, #8]
 810ad7a:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */

	/* Offset added to account for the way the MCU uses the stack on entry/exit
	of interrupts, and to ensure alignment. */
	pxTopOfStack--;
 810ad7c:	68fb      	ldr	r3, [r7, #12]
 810ad7e:	3b04      	subs	r3, #4
 810ad80:	60fb      	str	r3, [r7, #12]

	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 810ad82:	68fb      	ldr	r3, [r7, #12]
 810ad84:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
 810ad88:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 810ad8a:	68fb      	ldr	r3, [r7, #12]
 810ad8c:	3b04      	subs	r3, #4
 810ad8e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 810ad90:	68bb      	ldr	r3, [r7, #8]
 810ad92:	f023 0201 	bic.w	r2, r3, #1
 810ad96:	68fb      	ldr	r3, [r7, #12]
 810ad98:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
 810ad9a:	68fb      	ldr	r3, [r7, #12]
 810ad9c:	3b04      	subs	r3, #4
 810ad9e:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 810ada0:	4a0c      	ldr	r2, [pc, #48]	@ (810add4 <pxPortInitialiseStack+0x64>)
 810ada2:	68fb      	ldr	r3, [r7, #12]
 810ada4:	601a      	str	r2, [r3, #0]

	/* Save code space by skipping register initialisation. */
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
 810ada6:	68fb      	ldr	r3, [r7, #12]
 810ada8:	3b14      	subs	r3, #20
 810adaa:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 810adac:	687a      	ldr	r2, [r7, #4]
 810adae:	68fb      	ldr	r3, [r7, #12]
 810adb0:	601a      	str	r2, [r3, #0]

	/* A save method is being used that requires each task to maintain its
	own exec return value. */
	pxTopOfStack--;
 810adb2:	68fb      	ldr	r3, [r7, #12]
 810adb4:	3b04      	subs	r3, #4
 810adb6:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_EXC_RETURN;
 810adb8:	68fb      	ldr	r3, [r7, #12]
 810adba:	f06f 0202 	mvn.w	r2, #2
 810adbe:	601a      	str	r2, [r3, #0]

	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
 810adc0:	68fb      	ldr	r3, [r7, #12]
 810adc2:	3b20      	subs	r3, #32
 810adc4:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
 810adc6:	68fb      	ldr	r3, [r7, #12]
}
 810adc8:	4618      	mov	r0, r3
 810adca:	3714      	adds	r7, #20
 810adcc:	46bd      	mov	sp, r7
 810adce:	f85d 7b04 	ldr.w	r7, [sp], #4
 810add2:	4770      	bx	lr
 810add4:	0810add9 	.word	0x0810add9

0810add8 <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
 810add8:	b480      	push	{r7}
 810adda:	b085      	sub	sp, #20
 810addc:	af00      	add	r7, sp, #0
volatile uint32_t ulDummy = 0;
 810adde:	2300      	movs	r3, #0
 810ade0:	607b      	str	r3, [r7, #4]
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 810ade2:	4b13      	ldr	r3, [pc, #76]	@ (810ae30 <prvTaskExitError+0x58>)
 810ade4:	681b      	ldr	r3, [r3, #0]
 810ade6:	f1b3 3fff 	cmp.w	r3, #4294967295
 810adea:	d00b      	beq.n	810ae04 <prvTaskExitError+0x2c>
	__asm volatile
 810adec:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810adf0:	f383 8811 	msr	BASEPRI, r3
 810adf4:	f3bf 8f6f 	isb	sy
 810adf8:	f3bf 8f4f 	dsb	sy
 810adfc:	60fb      	str	r3, [r7, #12]
}
 810adfe:	bf00      	nop
 810ae00:	bf00      	nop
 810ae02:	e7fd      	b.n	810ae00 <prvTaskExitError+0x28>
	__asm volatile
 810ae04:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810ae08:	f383 8811 	msr	BASEPRI, r3
 810ae0c:	f3bf 8f6f 	isb	sy
 810ae10:	f3bf 8f4f 	dsb	sy
 810ae14:	60bb      	str	r3, [r7, #8]
}
 810ae16:	bf00      	nop
	portDISABLE_INTERRUPTS();
	while( ulDummy == 0 )
 810ae18:	bf00      	nop
 810ae1a:	687b      	ldr	r3, [r7, #4]
 810ae1c:	2b00      	cmp	r3, #0
 810ae1e:	d0fc      	beq.n	810ae1a <prvTaskExitError+0x42>
		about code appearing after this function is called - making ulDummy
		volatile makes the compiler think the function could return and
		therefore not output an 'unreachable code' warning for code that appears
		after it. */
	}
}
 810ae20:	bf00      	nop
 810ae22:	bf00      	nop
 810ae24:	3714      	adds	r7, #20
 810ae26:	46bd      	mov	sp, r7
 810ae28:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ae2c:	4770      	bx	lr
 810ae2e:	bf00      	nop
 810ae30:	10000490 	.word	0x10000490
	...

0810ae40 <SVC_Handler>:
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 810ae40:	4b07      	ldr	r3, [pc, #28]	@ (810ae60 <pxCurrentTCBConst2>)
 810ae42:	6819      	ldr	r1, [r3, #0]
 810ae44:	6808      	ldr	r0, [r1, #0]
 810ae46:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 810ae4a:	f380 8809 	msr	PSP, r0
 810ae4e:	f3bf 8f6f 	isb	sy
 810ae52:	f04f 0000 	mov.w	r0, #0
 810ae56:	f380 8811 	msr	BASEPRI, r0
 810ae5a:	4770      	bx	lr
 810ae5c:	f3af 8000 	nop.w

0810ae60 <pxCurrentTCBConst2>:
 810ae60:	10004f00 	.word	0x10004f00
					"	bx r14							\n"
					"									\n"
					"	.align 4						\n"
					"pxCurrentTCBConst2: .word pxCurrentTCB				\n"
				);
}
 810ae64:	bf00      	nop
 810ae66:	bf00      	nop

0810ae68 <prvPortStartFirstTask>:
{
	/* Start the first task.  This also clears the bit that indicates the FPU is
	in use in case the FPU was used before the scheduler was started - which
	would otherwise result in the unnecessary leaving of space in the SVC stack
	for lazy saving of FPU registers. */
	__asm volatile(
 810ae68:	4808      	ldr	r0, [pc, #32]	@ (810ae8c <prvPortStartFirstTask+0x24>)
 810ae6a:	6800      	ldr	r0, [r0, #0]
 810ae6c:	6800      	ldr	r0, [r0, #0]
 810ae6e:	f380 8808 	msr	MSP, r0
 810ae72:	f04f 0000 	mov.w	r0, #0
 810ae76:	f380 8814 	msr	CONTROL, r0
 810ae7a:	b662      	cpsie	i
 810ae7c:	b661      	cpsie	f
 810ae7e:	f3bf 8f4f 	dsb	sy
 810ae82:	f3bf 8f6f 	isb	sy
 810ae86:	df00      	svc	0
 810ae88:	bf00      	nop
					" dsb					\n"
					" isb					\n"
					" svc 0					\n" /* System call to start first task. */
					" nop					\n"
				);
}
 810ae8a:	bf00      	nop
 810ae8c:	e000ed08 	.word	0xe000ed08

0810ae90 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
 810ae90:	b580      	push	{r7, lr}
 810ae92:	b086      	sub	sp, #24
 810ae94:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	/* This port can be used on all revisions of the Cortex-M7 core other than
	the r0p1 parts.  r0p1 parts should use the port from the
	/source/portable/GCC/ARM_CM7/r0p1 directory. */
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 810ae96:	4b47      	ldr	r3, [pc, #284]	@ (810afb4 <xPortStartScheduler+0x124>)
 810ae98:	681b      	ldr	r3, [r3, #0]
 810ae9a:	4a47      	ldr	r2, [pc, #284]	@ (810afb8 <xPortStartScheduler+0x128>)
 810ae9c:	4293      	cmp	r3, r2
 810ae9e:	d10b      	bne.n	810aeb8 <xPortStartScheduler+0x28>
	__asm volatile
 810aea0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810aea4:	f383 8811 	msr	BASEPRI, r3
 810aea8:	f3bf 8f6f 	isb	sy
 810aeac:	f3bf 8f4f 	dsb	sy
 810aeb0:	613b      	str	r3, [r7, #16]
}
 810aeb2:	bf00      	nop
 810aeb4:	bf00      	nop
 810aeb6:	e7fd      	b.n	810aeb4 <xPortStartScheduler+0x24>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 810aeb8:	4b3e      	ldr	r3, [pc, #248]	@ (810afb4 <xPortStartScheduler+0x124>)
 810aeba:	681b      	ldr	r3, [r3, #0]
 810aebc:	4a3f      	ldr	r2, [pc, #252]	@ (810afbc <xPortStartScheduler+0x12c>)
 810aebe:	4293      	cmp	r3, r2
 810aec0:	d10b      	bne.n	810aeda <xPortStartScheduler+0x4a>
	__asm volatile
 810aec2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810aec6:	f383 8811 	msr	BASEPRI, r3
 810aeca:	f3bf 8f6f 	isb	sy
 810aece:	f3bf 8f4f 	dsb	sy
 810aed2:	60fb      	str	r3, [r7, #12]
}
 810aed4:	bf00      	nop
 810aed6:	bf00      	nop
 810aed8:	e7fd      	b.n	810aed6 <xPortStartScheduler+0x46>

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
 810aeda:	4b39      	ldr	r3, [pc, #228]	@ (810afc0 <xPortStartScheduler+0x130>)
 810aedc:	617b      	str	r3, [r7, #20]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 810aede:	697b      	ldr	r3, [r7, #20]
 810aee0:	781b      	ldrb	r3, [r3, #0]
 810aee2:	b2db      	uxtb	r3, r3
 810aee4:	607b      	str	r3, [r7, #4]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 810aee6:	697b      	ldr	r3, [r7, #20]
 810aee8:	22ff      	movs	r2, #255	@ 0xff
 810aeea:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 810aeec:	697b      	ldr	r3, [r7, #20]
 810aeee:	781b      	ldrb	r3, [r3, #0]
 810aef0:	b2db      	uxtb	r3, r3
 810aef2:	70fb      	strb	r3, [r7, #3]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 810aef4:	78fb      	ldrb	r3, [r7, #3]
 810aef6:	b2db      	uxtb	r3, r3
 810aef8:	f003 0350 	and.w	r3, r3, #80	@ 0x50
 810aefc:	b2da      	uxtb	r2, r3
 810aefe:	4b31      	ldr	r3, [pc, #196]	@ (810afc4 <xPortStartScheduler+0x134>)
 810af00:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 810af02:	4b31      	ldr	r3, [pc, #196]	@ (810afc8 <xPortStartScheduler+0x138>)
 810af04:	2207      	movs	r2, #7
 810af06:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 810af08:	e009      	b.n	810af1e <xPortStartScheduler+0x8e>
		{
			ulMaxPRIGROUPValue--;
 810af0a:	4b2f      	ldr	r3, [pc, #188]	@ (810afc8 <xPortStartScheduler+0x138>)
 810af0c:	681b      	ldr	r3, [r3, #0]
 810af0e:	3b01      	subs	r3, #1
 810af10:	4a2d      	ldr	r2, [pc, #180]	@ (810afc8 <xPortStartScheduler+0x138>)
 810af12:	6013      	str	r3, [r2, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 810af14:	78fb      	ldrb	r3, [r7, #3]
 810af16:	b2db      	uxtb	r3, r3
 810af18:	005b      	lsls	r3, r3, #1
 810af1a:	b2db      	uxtb	r3, r3
 810af1c:	70fb      	strb	r3, [r7, #3]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 810af1e:	78fb      	ldrb	r3, [r7, #3]
 810af20:	b2db      	uxtb	r3, r3
 810af22:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 810af26:	2b80      	cmp	r3, #128	@ 0x80
 810af28:	d0ef      	beq.n	810af0a <xPortStartScheduler+0x7a>
		#ifdef configPRIO_BITS
		{
			/* Check the FreeRTOS configuration that defines the number of
			priority bits matches the number of priority bits actually queried
			from the hardware. */
			configASSERT( ( portMAX_PRIGROUP_BITS - ulMaxPRIGROUPValue ) == configPRIO_BITS );
 810af2a:	4b27      	ldr	r3, [pc, #156]	@ (810afc8 <xPortStartScheduler+0x138>)
 810af2c:	681b      	ldr	r3, [r3, #0]
 810af2e:	f1c3 0307 	rsb	r3, r3, #7
 810af32:	2b04      	cmp	r3, #4
 810af34:	d00b      	beq.n	810af4e <xPortStartScheduler+0xbe>
	__asm volatile
 810af36:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810af3a:	f383 8811 	msr	BASEPRI, r3
 810af3e:	f3bf 8f6f 	isb	sy
 810af42:	f3bf 8f4f 	dsb	sy
 810af46:	60bb      	str	r3, [r7, #8]
}
 810af48:	bf00      	nop
 810af4a:	bf00      	nop
 810af4c:	e7fd      	b.n	810af4a <xPortStartScheduler+0xba>
		}
		#endif

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 810af4e:	4b1e      	ldr	r3, [pc, #120]	@ (810afc8 <xPortStartScheduler+0x138>)
 810af50:	681b      	ldr	r3, [r3, #0]
 810af52:	021b      	lsls	r3, r3, #8
 810af54:	4a1c      	ldr	r2, [pc, #112]	@ (810afc8 <xPortStartScheduler+0x138>)
 810af56:	6013      	str	r3, [r2, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 810af58:	4b1b      	ldr	r3, [pc, #108]	@ (810afc8 <xPortStartScheduler+0x138>)
 810af5a:	681b      	ldr	r3, [r3, #0]
 810af5c:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
 810af60:	4a19      	ldr	r2, [pc, #100]	@ (810afc8 <xPortStartScheduler+0x138>)
 810af62:	6013      	str	r3, [r2, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 810af64:	687b      	ldr	r3, [r7, #4]
 810af66:	b2da      	uxtb	r2, r3
 810af68:	697b      	ldr	r3, [r7, #20]
 810af6a:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 810af6c:	4b17      	ldr	r3, [pc, #92]	@ (810afcc <xPortStartScheduler+0x13c>)
 810af6e:	681b      	ldr	r3, [r3, #0]
 810af70:	4a16      	ldr	r2, [pc, #88]	@ (810afcc <xPortStartScheduler+0x13c>)
 810af72:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
 810af76:	6013      	str	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 810af78:	4b14      	ldr	r3, [pc, #80]	@ (810afcc <xPortStartScheduler+0x13c>)
 810af7a:	681b      	ldr	r3, [r3, #0]
 810af7c:	4a13      	ldr	r2, [pc, #76]	@ (810afcc <xPortStartScheduler+0x13c>)
 810af7e:	f043 4370 	orr.w	r3, r3, #4026531840	@ 0xf0000000
 810af82:	6013      	str	r3, [r2, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
 810af84:	f000 f8da 	bl	810b13c <vPortSetupTimerInterrupt>

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
 810af88:	4b11      	ldr	r3, [pc, #68]	@ (810afd0 <xPortStartScheduler+0x140>)
 810af8a:	2200      	movs	r2, #0
 810af8c:	601a      	str	r2, [r3, #0]

	/* Ensure the VFP is enabled - it should be anyway. */
	vPortEnableVFP();
 810af8e:	f000 f8f9 	bl	810b184 <vPortEnableVFP>

	/* Lazy save always. */
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 810af92:	4b10      	ldr	r3, [pc, #64]	@ (810afd4 <xPortStartScheduler+0x144>)
 810af94:	681b      	ldr	r3, [r3, #0]
 810af96:	4a0f      	ldr	r2, [pc, #60]	@ (810afd4 <xPortStartScheduler+0x144>)
 810af98:	f043 4340 	orr.w	r3, r3, #3221225472	@ 0xc0000000
 810af9c:	6013      	str	r3, [r2, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
 810af9e:	f7ff ff63 	bl	810ae68 <prvPortStartFirstTask>
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS.  Call
	vTaskSwitchContext() so link time optimisation does not remove the
	symbol. */
	vTaskSwitchContext();
 810afa2:	f001 fae7 	bl	810c574 <vTaskSwitchContext>
	prvTaskExitError();
 810afa6:	f7ff ff17 	bl	810add8 <prvTaskExitError>

	/* Should not get here! */
	return 0;
 810afaa:	2300      	movs	r3, #0
}
 810afac:	4618      	mov	r0, r3
 810afae:	3718      	adds	r7, #24
 810afb0:	46bd      	mov	sp, r7
 810afb2:	bd80      	pop	{r7, pc}
 810afb4:	e000ed00 	.word	0xe000ed00
 810afb8:	410fc271 	.word	0x410fc271
 810afbc:	410fc270 	.word	0x410fc270
 810afc0:	e000e400 	.word	0xe000e400
 810afc4:	10004eb8 	.word	0x10004eb8
 810afc8:	10004ebc 	.word	0x10004ebc
 810afcc:	e000ed20 	.word	0xe000ed20
 810afd0:	10000490 	.word	0x10000490
 810afd4:	e000ef34 	.word	0xe000ef34

0810afd8 <vPortEnterCritical>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
 810afd8:	b480      	push	{r7}
 810afda:	b083      	sub	sp, #12
 810afdc:	af00      	add	r7, sp, #0
	__asm volatile
 810afde:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810afe2:	f383 8811 	msr	BASEPRI, r3
 810afe6:	f3bf 8f6f 	isb	sy
 810afea:	f3bf 8f4f 	dsb	sy
 810afee:	607b      	str	r3, [r7, #4]
}
 810aff0:	bf00      	nop
	portDISABLE_INTERRUPTS();
	uxCriticalNesting++;
 810aff2:	4b10      	ldr	r3, [pc, #64]	@ (810b034 <vPortEnterCritical+0x5c>)
 810aff4:	681b      	ldr	r3, [r3, #0]
 810aff6:	3301      	adds	r3, #1
 810aff8:	4a0e      	ldr	r2, [pc, #56]	@ (810b034 <vPortEnterCritical+0x5c>)
 810affa:	6013      	str	r3, [r2, #0]
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
 810affc:	4b0d      	ldr	r3, [pc, #52]	@ (810b034 <vPortEnterCritical+0x5c>)
 810affe:	681b      	ldr	r3, [r3, #0]
 810b000:	2b01      	cmp	r3, #1
 810b002:	d110      	bne.n	810b026 <vPortEnterCritical+0x4e>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 810b004:	4b0c      	ldr	r3, [pc, #48]	@ (810b038 <vPortEnterCritical+0x60>)
 810b006:	681b      	ldr	r3, [r3, #0]
 810b008:	b2db      	uxtb	r3, r3
 810b00a:	2b00      	cmp	r3, #0
 810b00c:	d00b      	beq.n	810b026 <vPortEnterCritical+0x4e>
	__asm volatile
 810b00e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b012:	f383 8811 	msr	BASEPRI, r3
 810b016:	f3bf 8f6f 	isb	sy
 810b01a:	f3bf 8f4f 	dsb	sy
 810b01e:	603b      	str	r3, [r7, #0]
}
 810b020:	bf00      	nop
 810b022:	bf00      	nop
 810b024:	e7fd      	b.n	810b022 <vPortEnterCritical+0x4a>
	}
}
 810b026:	bf00      	nop
 810b028:	370c      	adds	r7, #12
 810b02a:	46bd      	mov	sp, r7
 810b02c:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b030:	4770      	bx	lr
 810b032:	bf00      	nop
 810b034:	10000490 	.word	0x10000490
 810b038:	e000ed04 	.word	0xe000ed04

0810b03c <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
 810b03c:	b480      	push	{r7}
 810b03e:	b083      	sub	sp, #12
 810b040:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
 810b042:	4b12      	ldr	r3, [pc, #72]	@ (810b08c <vPortExitCritical+0x50>)
 810b044:	681b      	ldr	r3, [r3, #0]
 810b046:	2b00      	cmp	r3, #0
 810b048:	d10b      	bne.n	810b062 <vPortExitCritical+0x26>
	__asm volatile
 810b04a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b04e:	f383 8811 	msr	BASEPRI, r3
 810b052:	f3bf 8f6f 	isb	sy
 810b056:	f3bf 8f4f 	dsb	sy
 810b05a:	607b      	str	r3, [r7, #4]
}
 810b05c:	bf00      	nop
 810b05e:	bf00      	nop
 810b060:	e7fd      	b.n	810b05e <vPortExitCritical+0x22>
	uxCriticalNesting--;
 810b062:	4b0a      	ldr	r3, [pc, #40]	@ (810b08c <vPortExitCritical+0x50>)
 810b064:	681b      	ldr	r3, [r3, #0]
 810b066:	3b01      	subs	r3, #1
 810b068:	4a08      	ldr	r2, [pc, #32]	@ (810b08c <vPortExitCritical+0x50>)
 810b06a:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 810b06c:	4b07      	ldr	r3, [pc, #28]	@ (810b08c <vPortExitCritical+0x50>)
 810b06e:	681b      	ldr	r3, [r3, #0]
 810b070:	2b00      	cmp	r3, #0
 810b072:	d105      	bne.n	810b080 <vPortExitCritical+0x44>
 810b074:	2300      	movs	r3, #0
 810b076:	603b      	str	r3, [r7, #0]
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 810b078:	683b      	ldr	r3, [r7, #0]
 810b07a:	f383 8811 	msr	BASEPRI, r3
	(
		"	msr basepri, %0	" :: "r" ( ulNewMaskValue ) : "memory"
	);
}
 810b07e:	bf00      	nop
	{
		portENABLE_INTERRUPTS();
	}
}
 810b080:	bf00      	nop
 810b082:	370c      	adds	r7, #12
 810b084:	46bd      	mov	sp, r7
 810b086:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b08a:	4770      	bx	lr
 810b08c:	10000490 	.word	0x10000490

0810b090 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 810b090:	f3ef 8009 	mrs	r0, PSP
 810b094:	f3bf 8f6f 	isb	sy
 810b098:	4b15      	ldr	r3, [pc, #84]	@ (810b0f0 <pxCurrentTCBConst>)
 810b09a:	681a      	ldr	r2, [r3, #0]
 810b09c:	f01e 0f10 	tst.w	lr, #16
 810b0a0:	bf08      	it	eq
 810b0a2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 810b0a6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 810b0aa:	6010      	str	r0, [r2, #0]
 810b0ac:	e92d 0009 	stmdb	sp!, {r0, r3}
 810b0b0:	f04f 0050 	mov.w	r0, #80	@ 0x50
 810b0b4:	f380 8811 	msr	BASEPRI, r0
 810b0b8:	f3bf 8f4f 	dsb	sy
 810b0bc:	f3bf 8f6f 	isb	sy
 810b0c0:	f001 fa58 	bl	810c574 <vTaskSwitchContext>
 810b0c4:	f04f 0000 	mov.w	r0, #0
 810b0c8:	f380 8811 	msr	BASEPRI, r0
 810b0cc:	bc09      	pop	{r0, r3}
 810b0ce:	6819      	ldr	r1, [r3, #0]
 810b0d0:	6808      	ldr	r0, [r1, #0]
 810b0d2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 810b0d6:	f01e 0f10 	tst.w	lr, #16
 810b0da:	bf08      	it	eq
 810b0dc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 810b0e0:	f380 8809 	msr	PSP, r0
 810b0e4:	f3bf 8f6f 	isb	sy
 810b0e8:	4770      	bx	lr
 810b0ea:	bf00      	nop
 810b0ec:	f3af 8000 	nop.w

0810b0f0 <pxCurrentTCBConst>:
 810b0f0:	10004f00 	.word	0x10004f00
	"										\n"
	"	.align 4							\n"
	"pxCurrentTCBConst: .word pxCurrentTCB	\n"
	::"i"(configMAX_SYSCALL_INTERRUPT_PRIORITY)
	);
}
 810b0f4:	bf00      	nop
 810b0f6:	bf00      	nop

0810b0f8 <xPortSysTickHandler>:
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 810b0f8:	b580      	push	{r7, lr}
 810b0fa:	b082      	sub	sp, #8
 810b0fc:	af00      	add	r7, sp, #0
	__asm volatile
 810b0fe:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b102:	f383 8811 	msr	BASEPRI, r3
 810b106:	f3bf 8f6f 	isb	sy
 810b10a:	f3bf 8f4f 	dsb	sy
 810b10e:	607b      	str	r3, [r7, #4]
}
 810b110:	bf00      	nop
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 810b112:	f001 f975 	bl	810c400 <xTaskIncrementTick>
 810b116:	4603      	mov	r3, r0
 810b118:	2b00      	cmp	r3, #0
 810b11a:	d003      	beq.n	810b124 <xPortSysTickHandler+0x2c>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 810b11c:	4b06      	ldr	r3, [pc, #24]	@ (810b138 <xPortSysTickHandler+0x40>)
 810b11e:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 810b122:	601a      	str	r2, [r3, #0]
 810b124:	2300      	movs	r3, #0
 810b126:	603b      	str	r3, [r7, #0]
	__asm volatile
 810b128:	683b      	ldr	r3, [r7, #0]
 810b12a:	f383 8811 	msr	BASEPRI, r3
}
 810b12e:	bf00      	nop
		}
	}
	portENABLE_INTERRUPTS();
}
 810b130:	bf00      	nop
 810b132:	3708      	adds	r7, #8
 810b134:	46bd      	mov	sp, r7
 810b136:	bd80      	pop	{r7, pc}
 810b138:	e000ed04 	.word	0xe000ed04

0810b13c <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
 810b13c:	b480      	push	{r7}
 810b13e:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Stop and clear the SysTick. */
	portNVIC_SYSTICK_CTRL_REG = 0UL;
 810b140:	4b0b      	ldr	r3, [pc, #44]	@ (810b170 <vPortSetupTimerInterrupt+0x34>)
 810b142:	2200      	movs	r2, #0
 810b144:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CURRENT_VALUE_REG = 0UL;
 810b146:	4b0b      	ldr	r3, [pc, #44]	@ (810b174 <vPortSetupTimerInterrupt+0x38>)
 810b148:	2200      	movs	r2, #0
 810b14a:	601a      	str	r2, [r3, #0]

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 810b14c:	4b0a      	ldr	r3, [pc, #40]	@ (810b178 <vPortSetupTimerInterrupt+0x3c>)
 810b14e:	681b      	ldr	r3, [r3, #0]
 810b150:	4a0a      	ldr	r2, [pc, #40]	@ (810b17c <vPortSetupTimerInterrupt+0x40>)
 810b152:	fba2 2303 	umull	r2, r3, r2, r3
 810b156:	099b      	lsrs	r3, r3, #6
 810b158:	4a09      	ldr	r2, [pc, #36]	@ (810b180 <vPortSetupTimerInterrupt+0x44>)
 810b15a:	3b01      	subs	r3, #1
 810b15c:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 810b15e:	4b04      	ldr	r3, [pc, #16]	@ (810b170 <vPortSetupTimerInterrupt+0x34>)
 810b160:	2207      	movs	r2, #7
 810b162:	601a      	str	r2, [r3, #0]
}
 810b164:	bf00      	nop
 810b166:	46bd      	mov	sp, r7
 810b168:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b16c:	4770      	bx	lr
 810b16e:	bf00      	nop
 810b170:	e000e010 	.word	0xe000e010
 810b174:	e000e018 	.word	0xe000e018
 810b178:	10000004 	.word	0x10000004
 810b17c:	10624dd3 	.word	0x10624dd3
 810b180:	e000e014 	.word	0xe000e014

0810b184 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 810b184:	f8df 000c 	ldr.w	r0, [pc, #12]	@ 810b194 <vPortEnableVFP+0x10>
 810b188:	6801      	ldr	r1, [r0, #0]
 810b18a:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 810b18e:	6001      	str	r1, [r0, #0]
 810b190:	4770      	bx	lr
		"								\n"
		"	orr r1, r1, #( 0xf << 20 )	\n" /* Enable CP10 and CP11 coprocessors, then save back. */
		"	str r1, [r0]				\n"
		"	bx r14						"
	);
}
 810b192:	bf00      	nop
 810b194:	e000ed88 	.word	0xe000ed88

0810b198 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
 810b198:	b480      	push	{r7}
 810b19a:	b085      	sub	sp, #20
 810b19c:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) :: "memory" );
 810b19e:	f3ef 8305 	mrs	r3, IPSR
 810b1a2:	60fb      	str	r3, [r7, #12]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
 810b1a4:	68fb      	ldr	r3, [r7, #12]
 810b1a6:	2b0f      	cmp	r3, #15
 810b1a8:	d915      	bls.n	810b1d6 <vPortValidateInterruptPriority+0x3e>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
 810b1aa:	4a18      	ldr	r2, [pc, #96]	@ (810b20c <vPortValidateInterruptPriority+0x74>)
 810b1ac:	68fb      	ldr	r3, [r7, #12]
 810b1ae:	4413      	add	r3, r2
 810b1b0:	781b      	ldrb	r3, [r3, #0]
 810b1b2:	72fb      	strb	r3, [r7, #11]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
 810b1b4:	4b16      	ldr	r3, [pc, #88]	@ (810b210 <vPortValidateInterruptPriority+0x78>)
 810b1b6:	781b      	ldrb	r3, [r3, #0]
 810b1b8:	7afa      	ldrb	r2, [r7, #11]
 810b1ba:	429a      	cmp	r2, r3
 810b1bc:	d20b      	bcs.n	810b1d6 <vPortValidateInterruptPriority+0x3e>
	__asm volatile
 810b1be:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b1c2:	f383 8811 	msr	BASEPRI, r3
 810b1c6:	f3bf 8f6f 	isb	sy
 810b1ca:	f3bf 8f4f 	dsb	sy
 810b1ce:	607b      	str	r3, [r7, #4]
}
 810b1d0:	bf00      	nop
 810b1d2:	bf00      	nop
 810b1d4:	e7fd      	b.n	810b1d2 <vPortValidateInterruptPriority+0x3a>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredictable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
 810b1d6:	4b0f      	ldr	r3, [pc, #60]	@ (810b214 <vPortValidateInterruptPriority+0x7c>)
 810b1d8:	681b      	ldr	r3, [r3, #0]
 810b1da:	f403 62e0 	and.w	r2, r3, #1792	@ 0x700
 810b1de:	4b0e      	ldr	r3, [pc, #56]	@ (810b218 <vPortValidateInterruptPriority+0x80>)
 810b1e0:	681b      	ldr	r3, [r3, #0]
 810b1e2:	429a      	cmp	r2, r3
 810b1e4:	d90b      	bls.n	810b1fe <vPortValidateInterruptPriority+0x66>
	__asm volatile
 810b1e6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b1ea:	f383 8811 	msr	BASEPRI, r3
 810b1ee:	f3bf 8f6f 	isb	sy
 810b1f2:	f3bf 8f4f 	dsb	sy
 810b1f6:	603b      	str	r3, [r7, #0]
}
 810b1f8:	bf00      	nop
 810b1fa:	bf00      	nop
 810b1fc:	e7fd      	b.n	810b1fa <vPortValidateInterruptPriority+0x62>
	}
 810b1fe:	bf00      	nop
 810b200:	3714      	adds	r7, #20
 810b202:	46bd      	mov	sp, r7
 810b204:	f85d 7b04 	ldr.w	r7, [sp], #4
 810b208:	4770      	bx	lr
 810b20a:	bf00      	nop
 810b20c:	e000e3f0 	.word	0xe000e3f0
 810b210:	10004eb8 	.word	0x10004eb8
 810b214:	e000ed0c 	.word	0xe000ed0c
 810b218:	10004ebc 	.word	0x10004ebc

0810b21c <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
 810b21c:	b580      	push	{r7, lr}
 810b21e:	b084      	sub	sp, #16
 810b220:	af00      	add	r7, sp, #0
 810b222:	6078      	str	r0, [r7, #4]
 810b224:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = xQueue;
 810b226:	687b      	ldr	r3, [r7, #4]
 810b228:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
 810b22a:	68fb      	ldr	r3, [r7, #12]
 810b22c:	2b00      	cmp	r3, #0
 810b22e:	d10b      	bne.n	810b248 <xQueueGenericReset+0x2c>
	__asm volatile
 810b230:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b234:	f383 8811 	msr	BASEPRI, r3
 810b238:	f3bf 8f6f 	isb	sy
 810b23c:	f3bf 8f4f 	dsb	sy
 810b240:	60bb      	str	r3, [r7, #8]
}
 810b242:	bf00      	nop
 810b244:	bf00      	nop
 810b246:	e7fd      	b.n	810b244 <xQueueGenericReset+0x28>

	taskENTER_CRITICAL();
 810b248:	f7ff fec6 	bl	810afd8 <vPortEnterCritical>
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 810b24c:	68fb      	ldr	r3, [r7, #12]
 810b24e:	681a      	ldr	r2, [r3, #0]
 810b250:	68fb      	ldr	r3, [r7, #12]
 810b252:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 810b254:	68f9      	ldr	r1, [r7, #12]
 810b256:	6c09      	ldr	r1, [r1, #64]	@ 0x40
 810b258:	fb01 f303 	mul.w	r3, r1, r3
 810b25c:	441a      	add	r2, r3
 810b25e:	68fb      	ldr	r3, [r7, #12]
 810b260:	609a      	str	r2, [r3, #8]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
 810b262:	68fb      	ldr	r3, [r7, #12]
 810b264:	2200      	movs	r2, #0
 810b266:	639a      	str	r2, [r3, #56]	@ 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
 810b268:	68fb      	ldr	r3, [r7, #12]
 810b26a:	681a      	ldr	r2, [r3, #0]
 810b26c:	68fb      	ldr	r3, [r7, #12]
 810b26e:	605a      	str	r2, [r3, #4]
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 810b270:	68fb      	ldr	r3, [r7, #12]
 810b272:	681a      	ldr	r2, [r3, #0]
 810b274:	68fb      	ldr	r3, [r7, #12]
 810b276:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 810b278:	3b01      	subs	r3, #1
 810b27a:	68f9      	ldr	r1, [r7, #12]
 810b27c:	6c09      	ldr	r1, [r1, #64]	@ 0x40
 810b27e:	fb01 f303 	mul.w	r3, r1, r3
 810b282:	441a      	add	r2, r3
 810b284:	68fb      	ldr	r3, [r7, #12]
 810b286:	60da      	str	r2, [r3, #12]
		pxQueue->cRxLock = queueUNLOCKED;
 810b288:	68fb      	ldr	r3, [r7, #12]
 810b28a:	22ff      	movs	r2, #255	@ 0xff
 810b28c:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
		pxQueue->cTxLock = queueUNLOCKED;
 810b290:	68fb      	ldr	r3, [r7, #12]
 810b292:	22ff      	movs	r2, #255	@ 0xff
 810b294:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45

		if( xNewQueue == pdFALSE )
 810b298:	683b      	ldr	r3, [r7, #0]
 810b29a:	2b00      	cmp	r3, #0
 810b29c:	d114      	bne.n	810b2c8 <xQueueGenericReset+0xac>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 810b29e:	68fb      	ldr	r3, [r7, #12]
 810b2a0:	691b      	ldr	r3, [r3, #16]
 810b2a2:	2b00      	cmp	r3, #0
 810b2a4:	d01a      	beq.n	810b2dc <xQueueGenericReset+0xc0>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 810b2a6:	68fb      	ldr	r3, [r7, #12]
 810b2a8:	3310      	adds	r3, #16
 810b2aa:	4618      	mov	r0, r3
 810b2ac:	f001 fa12 	bl	810c6d4 <xTaskRemoveFromEventList>
 810b2b0:	4603      	mov	r3, r0
 810b2b2:	2b00      	cmp	r3, #0
 810b2b4:	d012      	beq.n	810b2dc <xQueueGenericReset+0xc0>
				{
					queueYIELD_IF_USING_PREEMPTION();
 810b2b6:	4b0d      	ldr	r3, [pc, #52]	@ (810b2ec <xQueueGenericReset+0xd0>)
 810b2b8:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 810b2bc:	601a      	str	r2, [r3, #0]
 810b2be:	f3bf 8f4f 	dsb	sy
 810b2c2:	f3bf 8f6f 	isb	sy
 810b2c6:	e009      	b.n	810b2dc <xQueueGenericReset+0xc0>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
 810b2c8:	68fb      	ldr	r3, [r7, #12]
 810b2ca:	3310      	adds	r3, #16
 810b2cc:	4618      	mov	r0, r3
 810b2ce:	f7ff fc9b 	bl	810ac08 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
 810b2d2:	68fb      	ldr	r3, [r7, #12]
 810b2d4:	3324      	adds	r3, #36	@ 0x24
 810b2d6:	4618      	mov	r0, r3
 810b2d8:	f7ff fc96 	bl	810ac08 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
 810b2dc:	f7ff feae 	bl	810b03c <vPortExitCritical>

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
 810b2e0:	2301      	movs	r3, #1
}
 810b2e2:	4618      	mov	r0, r3
 810b2e4:	3710      	adds	r7, #16
 810b2e6:	46bd      	mov	sp, r7
 810b2e8:	bd80      	pop	{r7, pc}
 810b2ea:	bf00      	nop
 810b2ec:	e000ed04 	.word	0xe000ed04

0810b2f0 <xQueueGenericCreateStatic>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_STATIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
	{
 810b2f0:	b580      	push	{r7, lr}
 810b2f2:	b08e      	sub	sp, #56	@ 0x38
 810b2f4:	af02      	add	r7, sp, #8
 810b2f6:	60f8      	str	r0, [r7, #12]
 810b2f8:	60b9      	str	r1, [r7, #8]
 810b2fa:	607a      	str	r2, [r7, #4]
 810b2fc:	603b      	str	r3, [r7, #0]
	Queue_t *pxNewQueue;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 810b2fe:	68fb      	ldr	r3, [r7, #12]
 810b300:	2b00      	cmp	r3, #0
 810b302:	d10b      	bne.n	810b31c <xQueueGenericCreateStatic+0x2c>
	__asm volatile
 810b304:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b308:	f383 8811 	msr	BASEPRI, r3
 810b30c:	f3bf 8f6f 	isb	sy
 810b310:	f3bf 8f4f 	dsb	sy
 810b314:	62bb      	str	r3, [r7, #40]	@ 0x28
}
 810b316:	bf00      	nop
 810b318:	bf00      	nop
 810b31a:	e7fd      	b.n	810b318 <xQueueGenericCreateStatic+0x28>

		/* The StaticQueue_t structure and the queue storage area must be
		supplied. */
		configASSERT( pxStaticQueue != NULL );
 810b31c:	683b      	ldr	r3, [r7, #0]
 810b31e:	2b00      	cmp	r3, #0
 810b320:	d10b      	bne.n	810b33a <xQueueGenericCreateStatic+0x4a>
	__asm volatile
 810b322:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b326:	f383 8811 	msr	BASEPRI, r3
 810b32a:	f3bf 8f6f 	isb	sy
 810b32e:	f3bf 8f4f 	dsb	sy
 810b332:	627b      	str	r3, [r7, #36]	@ 0x24
}
 810b334:	bf00      	nop
 810b336:	bf00      	nop
 810b338:	e7fd      	b.n	810b336 <xQueueGenericCreateStatic+0x46>

		/* A queue storage area should be provided if the item size is not 0, and
		should not be provided if the item size is 0. */
		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
 810b33a:	687b      	ldr	r3, [r7, #4]
 810b33c:	2b00      	cmp	r3, #0
 810b33e:	d002      	beq.n	810b346 <xQueueGenericCreateStatic+0x56>
 810b340:	68bb      	ldr	r3, [r7, #8]
 810b342:	2b00      	cmp	r3, #0
 810b344:	d001      	beq.n	810b34a <xQueueGenericCreateStatic+0x5a>
 810b346:	2301      	movs	r3, #1
 810b348:	e000      	b.n	810b34c <xQueueGenericCreateStatic+0x5c>
 810b34a:	2300      	movs	r3, #0
 810b34c:	2b00      	cmp	r3, #0
 810b34e:	d10b      	bne.n	810b368 <xQueueGenericCreateStatic+0x78>
	__asm volatile
 810b350:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b354:	f383 8811 	msr	BASEPRI, r3
 810b358:	f3bf 8f6f 	isb	sy
 810b35c:	f3bf 8f4f 	dsb	sy
 810b360:	623b      	str	r3, [r7, #32]
}
 810b362:	bf00      	nop
 810b364:	bf00      	nop
 810b366:	e7fd      	b.n	810b364 <xQueueGenericCreateStatic+0x74>
		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
 810b368:	687b      	ldr	r3, [r7, #4]
 810b36a:	2b00      	cmp	r3, #0
 810b36c:	d102      	bne.n	810b374 <xQueueGenericCreateStatic+0x84>
 810b36e:	68bb      	ldr	r3, [r7, #8]
 810b370:	2b00      	cmp	r3, #0
 810b372:	d101      	bne.n	810b378 <xQueueGenericCreateStatic+0x88>
 810b374:	2301      	movs	r3, #1
 810b376:	e000      	b.n	810b37a <xQueueGenericCreateStatic+0x8a>
 810b378:	2300      	movs	r3, #0
 810b37a:	2b00      	cmp	r3, #0
 810b37c:	d10b      	bne.n	810b396 <xQueueGenericCreateStatic+0xa6>
	__asm volatile
 810b37e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b382:	f383 8811 	msr	BASEPRI, r3
 810b386:	f3bf 8f6f 	isb	sy
 810b38a:	f3bf 8f4f 	dsb	sy
 810b38e:	61fb      	str	r3, [r7, #28]
}
 810b390:	bf00      	nop
 810b392:	bf00      	nop
 810b394:	e7fd      	b.n	810b392 <xQueueGenericCreateStatic+0xa2>
		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
			the real queue and semaphore structures. */
			volatile size_t xSize = sizeof( StaticQueue_t );
 810b396:	2350      	movs	r3, #80	@ 0x50
 810b398:	617b      	str	r3, [r7, #20]
			configASSERT( xSize == sizeof( Queue_t ) );
 810b39a:	697b      	ldr	r3, [r7, #20]
 810b39c:	2b50      	cmp	r3, #80	@ 0x50
 810b39e:	d00b      	beq.n	810b3b8 <xQueueGenericCreateStatic+0xc8>
	__asm volatile
 810b3a0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b3a4:	f383 8811 	msr	BASEPRI, r3
 810b3a8:	f3bf 8f6f 	isb	sy
 810b3ac:	f3bf 8f4f 	dsb	sy
 810b3b0:	61bb      	str	r3, [r7, #24]
}
 810b3b2:	bf00      	nop
 810b3b4:	bf00      	nop
 810b3b6:	e7fd      	b.n	810b3b4 <xQueueGenericCreateStatic+0xc4>
			( void ) xSize; /* Keeps lint quiet when configASSERT() is not defined. */
 810b3b8:	697b      	ldr	r3, [r7, #20]
		#endif /* configASSERT_DEFINED */

		/* The address of a statically allocated queue was passed in, use it.
		The address of a statically allocated storage area was also passed in
		but is already set. */
		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
 810b3ba:	683b      	ldr	r3, [r7, #0]
 810b3bc:	62fb      	str	r3, [r7, #44]	@ 0x2c

		if( pxNewQueue != NULL )
 810b3be:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810b3c0:	2b00      	cmp	r3, #0
 810b3c2:	d00d      	beq.n	810b3e0 <xQueueGenericCreateStatic+0xf0>
			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
			{
				/* Queues can be allocated wither statically or dynamically, so
				note this queue was allocated statically in case the queue is
				later deleted. */
				pxNewQueue->ucStaticallyAllocated = pdTRUE;
 810b3c4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810b3c6:	2201      	movs	r2, #1
 810b3c8:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46
			}
			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 810b3cc:	f897 2038 	ldrb.w	r2, [r7, #56]	@ 0x38
 810b3d0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810b3d2:	9300      	str	r3, [sp, #0]
 810b3d4:	4613      	mov	r3, r2
 810b3d6:	687a      	ldr	r2, [r7, #4]
 810b3d8:	68b9      	ldr	r1, [r7, #8]
 810b3da:	68f8      	ldr	r0, [r7, #12]
 810b3dc:	f000 f840 	bl	810b460 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
 810b3e0:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
	}
 810b3e2:	4618      	mov	r0, r3
 810b3e4:	3730      	adds	r7, #48	@ 0x30
 810b3e6:	46bd      	mov	sp, r7
 810b3e8:	bd80      	pop	{r7, pc}

0810b3ea <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
 810b3ea:	b580      	push	{r7, lr}
 810b3ec:	b08a      	sub	sp, #40	@ 0x28
 810b3ee:	af02      	add	r7, sp, #8
 810b3f0:	60f8      	str	r0, [r7, #12]
 810b3f2:	60b9      	str	r1, [r7, #8]
 810b3f4:	4613      	mov	r3, r2
 810b3f6:	71fb      	strb	r3, [r7, #7]
	Queue_t *pxNewQueue;
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
 810b3f8:	68fb      	ldr	r3, [r7, #12]
 810b3fa:	2b00      	cmp	r3, #0
 810b3fc:	d10b      	bne.n	810b416 <xQueueGenericCreate+0x2c>
	__asm volatile
 810b3fe:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b402:	f383 8811 	msr	BASEPRI, r3
 810b406:	f3bf 8f6f 	isb	sy
 810b40a:	f3bf 8f4f 	dsb	sy
 810b40e:	613b      	str	r3, [r7, #16]
}
 810b410:	bf00      	nop
 810b412:	bf00      	nop
 810b414:	e7fd      	b.n	810b412 <xQueueGenericCreate+0x28>

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 810b416:	68fb      	ldr	r3, [r7, #12]
 810b418:	68ba      	ldr	r2, [r7, #8]
 810b41a:	fb02 f303 	mul.w	r3, r2, r3
 810b41e:	61fb      	str	r3, [r7, #28]
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
 810b420:	69fb      	ldr	r3, [r7, #28]
 810b422:	3350      	adds	r3, #80	@ 0x50
 810b424:	4618      	mov	r0, r3
 810b426:	f7ff fa01 	bl	810a82c <pvPortMalloc>
 810b42a:	61b8      	str	r0, [r7, #24]

		if( pxNewQueue != NULL )
 810b42c:	69bb      	ldr	r3, [r7, #24]
 810b42e:	2b00      	cmp	r3, #0
 810b430:	d011      	beq.n	810b456 <xQueueGenericCreate+0x6c>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
 810b432:	69bb      	ldr	r3, [r7, #24]
 810b434:	617b      	str	r3, [r7, #20]
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
 810b436:	697b      	ldr	r3, [r7, #20]
 810b438:	3350      	adds	r3, #80	@ 0x50
 810b43a:	617b      	str	r3, [r7, #20]
			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
			{
				/* Queues can be created either statically or dynamically, so
				note this task was created dynamically in case it is later
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
 810b43c:	69bb      	ldr	r3, [r7, #24]
 810b43e:	2200      	movs	r2, #0
 810b440:	f883 2046 	strb.w	r2, [r3, #70]	@ 0x46
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
 810b444:	79fa      	ldrb	r2, [r7, #7]
 810b446:	69bb      	ldr	r3, [r7, #24]
 810b448:	9300      	str	r3, [sp, #0]
 810b44a:	4613      	mov	r3, r2
 810b44c:	697a      	ldr	r2, [r7, #20]
 810b44e:	68b9      	ldr	r1, [r7, #8]
 810b450:	68f8      	ldr	r0, [r7, #12]
 810b452:	f000 f805 	bl	810b460 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
 810b456:	69bb      	ldr	r3, [r7, #24]
	}
 810b458:	4618      	mov	r0, r3
 810b45a:	3720      	adds	r7, #32
 810b45c:	46bd      	mov	sp, r7
 810b45e:	bd80      	pop	{r7, pc}

0810b460 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
 810b460:	b580      	push	{r7, lr}
 810b462:	b084      	sub	sp, #16
 810b464:	af00      	add	r7, sp, #0
 810b466:	60f8      	str	r0, [r7, #12]
 810b468:	60b9      	str	r1, [r7, #8]
 810b46a:	607a      	str	r2, [r7, #4]
 810b46c:	70fb      	strb	r3, [r7, #3]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
 810b46e:	68bb      	ldr	r3, [r7, #8]
 810b470:	2b00      	cmp	r3, #0
 810b472:	d103      	bne.n	810b47c <prvInitialiseNewQueue+0x1c>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
 810b474:	69bb      	ldr	r3, [r7, #24]
 810b476:	69ba      	ldr	r2, [r7, #24]
 810b478:	601a      	str	r2, [r3, #0]
 810b47a:	e002      	b.n	810b482 <prvInitialiseNewQueue+0x22>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
 810b47c:	69bb      	ldr	r3, [r7, #24]
 810b47e:	687a      	ldr	r2, [r7, #4]
 810b480:	601a      	str	r2, [r3, #0]
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
 810b482:	69bb      	ldr	r3, [r7, #24]
 810b484:	68fa      	ldr	r2, [r7, #12]
 810b486:	63da      	str	r2, [r3, #60]	@ 0x3c
	pxNewQueue->uxItemSize = uxItemSize;
 810b488:	69bb      	ldr	r3, [r7, #24]
 810b48a:	68ba      	ldr	r2, [r7, #8]
 810b48c:	641a      	str	r2, [r3, #64]	@ 0x40
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
 810b48e:	2101      	movs	r1, #1
 810b490:	69b8      	ldr	r0, [r7, #24]
 810b492:	f7ff fec3 	bl	810b21c <xQueueGenericReset>

	#if ( configUSE_TRACE_FACILITY == 1 )
	{
		pxNewQueue->ucQueueType = ucQueueType;
 810b496:	69bb      	ldr	r3, [r7, #24]
 810b498:	78fa      	ldrb	r2, [r7, #3]
 810b49a:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
 810b49e:	bf00      	nop
 810b4a0:	3710      	adds	r7, #16
 810b4a2:	46bd      	mov	sp, r7
 810b4a4:	bd80      	pop	{r7, pc}

0810b4a6 <xQueueCreateCountingSemaphoreStatic>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
	{
 810b4a6:	b580      	push	{r7, lr}
 810b4a8:	b08a      	sub	sp, #40	@ 0x28
 810b4aa:	af02      	add	r7, sp, #8
 810b4ac:	60f8      	str	r0, [r7, #12]
 810b4ae:	60b9      	str	r1, [r7, #8]
 810b4b0:	607a      	str	r2, [r7, #4]
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
 810b4b2:	68fb      	ldr	r3, [r7, #12]
 810b4b4:	2b00      	cmp	r3, #0
 810b4b6:	d10b      	bne.n	810b4d0 <xQueueCreateCountingSemaphoreStatic+0x2a>
	__asm volatile
 810b4b8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b4bc:	f383 8811 	msr	BASEPRI, r3
 810b4c0:	f3bf 8f6f 	isb	sy
 810b4c4:	f3bf 8f4f 	dsb	sy
 810b4c8:	61bb      	str	r3, [r7, #24]
}
 810b4ca:	bf00      	nop
 810b4cc:	bf00      	nop
 810b4ce:	e7fd      	b.n	810b4cc <xQueueCreateCountingSemaphoreStatic+0x26>
		configASSERT( uxInitialCount <= uxMaxCount );
 810b4d0:	68ba      	ldr	r2, [r7, #8]
 810b4d2:	68fb      	ldr	r3, [r7, #12]
 810b4d4:	429a      	cmp	r2, r3
 810b4d6:	d90b      	bls.n	810b4f0 <xQueueCreateCountingSemaphoreStatic+0x4a>
	__asm volatile
 810b4d8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b4dc:	f383 8811 	msr	BASEPRI, r3
 810b4e0:	f3bf 8f6f 	isb	sy
 810b4e4:	f3bf 8f4f 	dsb	sy
 810b4e8:	617b      	str	r3, [r7, #20]
}
 810b4ea:	bf00      	nop
 810b4ec:	bf00      	nop
 810b4ee:	e7fd      	b.n	810b4ec <xQueueCreateCountingSemaphoreStatic+0x46>

		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 810b4f0:	2302      	movs	r3, #2
 810b4f2:	9300      	str	r3, [sp, #0]
 810b4f4:	687b      	ldr	r3, [r7, #4]
 810b4f6:	2200      	movs	r2, #0
 810b4f8:	2100      	movs	r1, #0
 810b4fa:	68f8      	ldr	r0, [r7, #12]
 810b4fc:	f7ff fef8 	bl	810b2f0 <xQueueGenericCreateStatic>
 810b500:	61f8      	str	r0, [r7, #28]

		if( xHandle != NULL )
 810b502:	69fb      	ldr	r3, [r7, #28]
 810b504:	2b00      	cmp	r3, #0
 810b506:	d002      	beq.n	810b50e <xQueueCreateCountingSemaphoreStatic+0x68>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 810b508:	69fb      	ldr	r3, [r7, #28]
 810b50a:	68ba      	ldr	r2, [r7, #8]
 810b50c:	639a      	str	r2, [r3, #56]	@ 0x38
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
 810b50e:	69fb      	ldr	r3, [r7, #28]
	}
 810b510:	4618      	mov	r0, r3
 810b512:	3720      	adds	r7, #32
 810b514:	46bd      	mov	sp, r7
 810b516:	bd80      	pop	{r7, pc}

0810b518 <xQueueCreateCountingSemaphore>:
/*-----------------------------------------------------------*/

#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
	{
 810b518:	b580      	push	{r7, lr}
 810b51a:	b086      	sub	sp, #24
 810b51c:	af00      	add	r7, sp, #0
 810b51e:	6078      	str	r0, [r7, #4]
 810b520:	6039      	str	r1, [r7, #0]
	QueueHandle_t xHandle;

		configASSERT( uxMaxCount != 0 );
 810b522:	687b      	ldr	r3, [r7, #4]
 810b524:	2b00      	cmp	r3, #0
 810b526:	d10b      	bne.n	810b540 <xQueueCreateCountingSemaphore+0x28>
	__asm volatile
 810b528:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b52c:	f383 8811 	msr	BASEPRI, r3
 810b530:	f3bf 8f6f 	isb	sy
 810b534:	f3bf 8f4f 	dsb	sy
 810b538:	613b      	str	r3, [r7, #16]
}
 810b53a:	bf00      	nop
 810b53c:	bf00      	nop
 810b53e:	e7fd      	b.n	810b53c <xQueueCreateCountingSemaphore+0x24>
		configASSERT( uxInitialCount <= uxMaxCount );
 810b540:	683a      	ldr	r2, [r7, #0]
 810b542:	687b      	ldr	r3, [r7, #4]
 810b544:	429a      	cmp	r2, r3
 810b546:	d90b      	bls.n	810b560 <xQueueCreateCountingSemaphore+0x48>
	__asm volatile
 810b548:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b54c:	f383 8811 	msr	BASEPRI, r3
 810b550:	f3bf 8f6f 	isb	sy
 810b554:	f3bf 8f4f 	dsb	sy
 810b558:	60fb      	str	r3, [r7, #12]
}
 810b55a:	bf00      	nop
 810b55c:	bf00      	nop
 810b55e:	e7fd      	b.n	810b55c <xQueueCreateCountingSemaphore+0x44>

		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
 810b560:	2202      	movs	r2, #2
 810b562:	2100      	movs	r1, #0
 810b564:	6878      	ldr	r0, [r7, #4]
 810b566:	f7ff ff40 	bl	810b3ea <xQueueGenericCreate>
 810b56a:	6178      	str	r0, [r7, #20]

		if( xHandle != NULL )
 810b56c:	697b      	ldr	r3, [r7, #20]
 810b56e:	2b00      	cmp	r3, #0
 810b570:	d002      	beq.n	810b578 <xQueueCreateCountingSemaphore+0x60>
		{
			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
 810b572:	697b      	ldr	r3, [r7, #20]
 810b574:	683a      	ldr	r2, [r7, #0]
 810b576:	639a      	str	r2, [r3, #56]	@ 0x38
		else
		{
			traceCREATE_COUNTING_SEMAPHORE_FAILED();
		}

		return xHandle;
 810b578:	697b      	ldr	r3, [r7, #20]
	}
 810b57a:	4618      	mov	r0, r3
 810b57c:	3718      	adds	r7, #24
 810b57e:	46bd      	mov	sp, r7
 810b580:	bd80      	pop	{r7, pc}
	...

0810b584 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
 810b584:	b580      	push	{r7, lr}
 810b586:	b08e      	sub	sp, #56	@ 0x38
 810b588:	af00      	add	r7, sp, #0
 810b58a:	60f8      	str	r0, [r7, #12]
 810b58c:	60b9      	str	r1, [r7, #8]
 810b58e:	607a      	str	r2, [r7, #4]
 810b590:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
 810b592:	2300      	movs	r3, #0
 810b594:	637b      	str	r3, [r7, #52]	@ 0x34
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 810b596:	68fb      	ldr	r3, [r7, #12]
 810b598:	633b      	str	r3, [r7, #48]	@ 0x30

	configASSERT( pxQueue );
 810b59a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810b59c:	2b00      	cmp	r3, #0
 810b59e:	d10b      	bne.n	810b5b8 <xQueueGenericSend+0x34>
	__asm volatile
 810b5a0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b5a4:	f383 8811 	msr	BASEPRI, r3
 810b5a8:	f3bf 8f6f 	isb	sy
 810b5ac:	f3bf 8f4f 	dsb	sy
 810b5b0:	62bb      	str	r3, [r7, #40]	@ 0x28
}
 810b5b2:	bf00      	nop
 810b5b4:	bf00      	nop
 810b5b6:	e7fd      	b.n	810b5b4 <xQueueGenericSend+0x30>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 810b5b8:	68bb      	ldr	r3, [r7, #8]
 810b5ba:	2b00      	cmp	r3, #0
 810b5bc:	d103      	bne.n	810b5c6 <xQueueGenericSend+0x42>
 810b5be:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810b5c0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810b5c2:	2b00      	cmp	r3, #0
 810b5c4:	d101      	bne.n	810b5ca <xQueueGenericSend+0x46>
 810b5c6:	2301      	movs	r3, #1
 810b5c8:	e000      	b.n	810b5cc <xQueueGenericSend+0x48>
 810b5ca:	2300      	movs	r3, #0
 810b5cc:	2b00      	cmp	r3, #0
 810b5ce:	d10b      	bne.n	810b5e8 <xQueueGenericSend+0x64>
	__asm volatile
 810b5d0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b5d4:	f383 8811 	msr	BASEPRI, r3
 810b5d8:	f3bf 8f6f 	isb	sy
 810b5dc:	f3bf 8f4f 	dsb	sy
 810b5e0:	627b      	str	r3, [r7, #36]	@ 0x24
}
 810b5e2:	bf00      	nop
 810b5e4:	bf00      	nop
 810b5e6:	e7fd      	b.n	810b5e4 <xQueueGenericSend+0x60>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 810b5e8:	683b      	ldr	r3, [r7, #0]
 810b5ea:	2b02      	cmp	r3, #2
 810b5ec:	d103      	bne.n	810b5f6 <xQueueGenericSend+0x72>
 810b5ee:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810b5f0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 810b5f2:	2b01      	cmp	r3, #1
 810b5f4:	d101      	bne.n	810b5fa <xQueueGenericSend+0x76>
 810b5f6:	2301      	movs	r3, #1
 810b5f8:	e000      	b.n	810b5fc <xQueueGenericSend+0x78>
 810b5fa:	2300      	movs	r3, #0
 810b5fc:	2b00      	cmp	r3, #0
 810b5fe:	d10b      	bne.n	810b618 <xQueueGenericSend+0x94>
	__asm volatile
 810b600:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b604:	f383 8811 	msr	BASEPRI, r3
 810b608:	f3bf 8f6f 	isb	sy
 810b60c:	f3bf 8f4f 	dsb	sy
 810b610:	623b      	str	r3, [r7, #32]
}
 810b612:	bf00      	nop
 810b614:	bf00      	nop
 810b616:	e7fd      	b.n	810b614 <xQueueGenericSend+0x90>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 810b618:	f001 fa1c 	bl	810ca54 <xTaskGetSchedulerState>
 810b61c:	4603      	mov	r3, r0
 810b61e:	2b00      	cmp	r3, #0
 810b620:	d102      	bne.n	810b628 <xQueueGenericSend+0xa4>
 810b622:	687b      	ldr	r3, [r7, #4]
 810b624:	2b00      	cmp	r3, #0
 810b626:	d101      	bne.n	810b62c <xQueueGenericSend+0xa8>
 810b628:	2301      	movs	r3, #1
 810b62a:	e000      	b.n	810b62e <xQueueGenericSend+0xaa>
 810b62c:	2300      	movs	r3, #0
 810b62e:	2b00      	cmp	r3, #0
 810b630:	d10b      	bne.n	810b64a <xQueueGenericSend+0xc6>
	__asm volatile
 810b632:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b636:	f383 8811 	msr	BASEPRI, r3
 810b63a:	f3bf 8f6f 	isb	sy
 810b63e:	f3bf 8f4f 	dsb	sy
 810b642:	61fb      	str	r3, [r7, #28]
}
 810b644:	bf00      	nop
 810b646:	bf00      	nop
 810b648:	e7fd      	b.n	810b646 <xQueueGenericSend+0xc2>
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 810b64a:	f7ff fcc5 	bl	810afd8 <vPortEnterCritical>
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 810b64e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810b650:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 810b652:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810b654:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 810b656:	429a      	cmp	r2, r3
 810b658:	d302      	bcc.n	810b660 <xQueueGenericSend+0xdc>
 810b65a:	683b      	ldr	r3, [r7, #0]
 810b65c:	2b02      	cmp	r3, #2
 810b65e:	d129      	bne.n	810b6b4 <xQueueGenericSend+0x130>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 810b660:	683a      	ldr	r2, [r7, #0]
 810b662:	68b9      	ldr	r1, [r7, #8]
 810b664:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 810b666:	f000 fa33 	bl	810bad0 <prvCopyDataToQueue>
 810b66a:	62f8      	str	r0, [r7, #44]	@ 0x2c

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 810b66c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810b66e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810b670:	2b00      	cmp	r3, #0
 810b672:	d010      	beq.n	810b696 <xQueueGenericSend+0x112>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 810b674:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810b676:	3324      	adds	r3, #36	@ 0x24
 810b678:	4618      	mov	r0, r3
 810b67a:	f001 f82b 	bl	810c6d4 <xTaskRemoveFromEventList>
 810b67e:	4603      	mov	r3, r0
 810b680:	2b00      	cmp	r3, #0
 810b682:	d013      	beq.n	810b6ac <xQueueGenericSend+0x128>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
 810b684:	4b3f      	ldr	r3, [pc, #252]	@ (810b784 <xQueueGenericSend+0x200>)
 810b686:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 810b68a:	601a      	str	r2, [r3, #0]
 810b68c:	f3bf 8f4f 	dsb	sy
 810b690:	f3bf 8f6f 	isb	sy
 810b694:	e00a      	b.n	810b6ac <xQueueGenericSend+0x128>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
 810b696:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810b698:	2b00      	cmp	r3, #0
 810b69a:	d007      	beq.n	810b6ac <xQueueGenericSend+0x128>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
 810b69c:	4b39      	ldr	r3, [pc, #228]	@ (810b784 <xQueueGenericSend+0x200>)
 810b69e:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 810b6a2:	601a      	str	r2, [r3, #0]
 810b6a4:	f3bf 8f4f 	dsb	sy
 810b6a8:	f3bf 8f6f 	isb	sy
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
 810b6ac:	f7ff fcc6 	bl	810b03c <vPortExitCritical>
				return pdPASS;
 810b6b0:	2301      	movs	r3, #1
 810b6b2:	e063      	b.n	810b77c <xQueueGenericSend+0x1f8>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 810b6b4:	687b      	ldr	r3, [r7, #4]
 810b6b6:	2b00      	cmp	r3, #0
 810b6b8:	d103      	bne.n	810b6c2 <xQueueGenericSend+0x13e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 810b6ba:	f7ff fcbf 	bl	810b03c <vPortExitCritical>

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
 810b6be:	2300      	movs	r3, #0
 810b6c0:	e05c      	b.n	810b77c <xQueueGenericSend+0x1f8>
				}
				else if( xEntryTimeSet == pdFALSE )
 810b6c2:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810b6c4:	2b00      	cmp	r3, #0
 810b6c6:	d106      	bne.n	810b6d6 <xQueueGenericSend+0x152>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 810b6c8:	f107 0314 	add.w	r3, r7, #20
 810b6cc:	4618      	mov	r0, r3
 810b6ce:	f001 f865 	bl	810c79c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 810b6d2:	2301      	movs	r3, #1
 810b6d4:	637b      	str	r3, [r7, #52]	@ 0x34
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 810b6d6:	f7ff fcb1 	bl	810b03c <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 810b6da:	f000 fdd5 	bl	810c288 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 810b6de:	f7ff fc7b 	bl	810afd8 <vPortEnterCritical>
 810b6e2:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810b6e4:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
 810b6e8:	b25b      	sxtb	r3, r3
 810b6ea:	f1b3 3fff 	cmp.w	r3, #4294967295
 810b6ee:	d103      	bne.n	810b6f8 <xQueueGenericSend+0x174>
 810b6f0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810b6f2:	2200      	movs	r2, #0
 810b6f4:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 810b6f8:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810b6fa:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
 810b6fe:	b25b      	sxtb	r3, r3
 810b700:	f1b3 3fff 	cmp.w	r3, #4294967295
 810b704:	d103      	bne.n	810b70e <xQueueGenericSend+0x18a>
 810b706:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810b708:	2200      	movs	r2, #0
 810b70a:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 810b70e:	f7ff fc95 	bl	810b03c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 810b712:	1d3a      	adds	r2, r7, #4
 810b714:	f107 0314 	add.w	r3, r7, #20
 810b718:	4611      	mov	r1, r2
 810b71a:	4618      	mov	r0, r3
 810b71c:	f001 f854 	bl	810c7c8 <xTaskCheckForTimeOut>
 810b720:	4603      	mov	r3, r0
 810b722:	2b00      	cmp	r3, #0
 810b724:	d124      	bne.n	810b770 <xQueueGenericSend+0x1ec>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
 810b726:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 810b728:	f000 faca 	bl	810bcc0 <prvIsQueueFull>
 810b72c:	4603      	mov	r3, r0
 810b72e:	2b00      	cmp	r3, #0
 810b730:	d018      	beq.n	810b764 <xQueueGenericSend+0x1e0>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
 810b732:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810b734:	3310      	adds	r3, #16
 810b736:	687a      	ldr	r2, [r7, #4]
 810b738:	4611      	mov	r1, r2
 810b73a:	4618      	mov	r0, r3
 810b73c:	f000 ff78 	bl	810c630 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
 810b740:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 810b742:	f000 fa55 	bl	810bbf0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
 810b746:	f000 fdad 	bl	810c2a4 <xTaskResumeAll>
 810b74a:	4603      	mov	r3, r0
 810b74c:	2b00      	cmp	r3, #0
 810b74e:	f47f af7c 	bne.w	810b64a <xQueueGenericSend+0xc6>
				{
					portYIELD_WITHIN_API();
 810b752:	4b0c      	ldr	r3, [pc, #48]	@ (810b784 <xQueueGenericSend+0x200>)
 810b754:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 810b758:	601a      	str	r2, [r3, #0]
 810b75a:	f3bf 8f4f 	dsb	sy
 810b75e:	f3bf 8f6f 	isb	sy
 810b762:	e772      	b.n	810b64a <xQueueGenericSend+0xc6>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
 810b764:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 810b766:	f000 fa43 	bl	810bbf0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 810b76a:	f000 fd9b 	bl	810c2a4 <xTaskResumeAll>
 810b76e:	e76c      	b.n	810b64a <xQueueGenericSend+0xc6>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
 810b770:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 810b772:	f000 fa3d 	bl	810bbf0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 810b776:	f000 fd95 	bl	810c2a4 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
 810b77a:	2300      	movs	r3, #0
		}
	} /*lint -restore */
}
 810b77c:	4618      	mov	r0, r3
 810b77e:	3738      	adds	r7, #56	@ 0x38
 810b780:	46bd      	mov	sp, r7
 810b782:	bd80      	pop	{r7, pc}
 810b784:	e000ed04 	.word	0xe000ed04

0810b788 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
 810b788:	b580      	push	{r7, lr}
 810b78a:	b090      	sub	sp, #64	@ 0x40
 810b78c:	af00      	add	r7, sp, #0
 810b78e:	60f8      	str	r0, [r7, #12]
 810b790:	60b9      	str	r1, [r7, #8]
 810b792:	607a      	str	r2, [r7, #4]
 810b794:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
 810b796:	68fb      	ldr	r3, [r7, #12]
 810b798:	63bb      	str	r3, [r7, #56]	@ 0x38

	configASSERT( pxQueue );
 810b79a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810b79c:	2b00      	cmp	r3, #0
 810b79e:	d10b      	bne.n	810b7b8 <xQueueGenericSendFromISR+0x30>
	__asm volatile
 810b7a0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b7a4:	f383 8811 	msr	BASEPRI, r3
 810b7a8:	f3bf 8f6f 	isb	sy
 810b7ac:	f3bf 8f4f 	dsb	sy
 810b7b0:	62bb      	str	r3, [r7, #40]	@ 0x28
}
 810b7b2:	bf00      	nop
 810b7b4:	bf00      	nop
 810b7b6:	e7fd      	b.n	810b7b4 <xQueueGenericSendFromISR+0x2c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
 810b7b8:	68bb      	ldr	r3, [r7, #8]
 810b7ba:	2b00      	cmp	r3, #0
 810b7bc:	d103      	bne.n	810b7c6 <xQueueGenericSendFromISR+0x3e>
 810b7be:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810b7c0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810b7c2:	2b00      	cmp	r3, #0
 810b7c4:	d101      	bne.n	810b7ca <xQueueGenericSendFromISR+0x42>
 810b7c6:	2301      	movs	r3, #1
 810b7c8:	e000      	b.n	810b7cc <xQueueGenericSendFromISR+0x44>
 810b7ca:	2300      	movs	r3, #0
 810b7cc:	2b00      	cmp	r3, #0
 810b7ce:	d10b      	bne.n	810b7e8 <xQueueGenericSendFromISR+0x60>
	__asm volatile
 810b7d0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b7d4:	f383 8811 	msr	BASEPRI, r3
 810b7d8:	f3bf 8f6f 	isb	sy
 810b7dc:	f3bf 8f4f 	dsb	sy
 810b7e0:	627b      	str	r3, [r7, #36]	@ 0x24
}
 810b7e2:	bf00      	nop
 810b7e4:	bf00      	nop
 810b7e6:	e7fd      	b.n	810b7e4 <xQueueGenericSendFromISR+0x5c>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
 810b7e8:	683b      	ldr	r3, [r7, #0]
 810b7ea:	2b02      	cmp	r3, #2
 810b7ec:	d103      	bne.n	810b7f6 <xQueueGenericSendFromISR+0x6e>
 810b7ee:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810b7f0:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 810b7f2:	2b01      	cmp	r3, #1
 810b7f4:	d101      	bne.n	810b7fa <xQueueGenericSendFromISR+0x72>
 810b7f6:	2301      	movs	r3, #1
 810b7f8:	e000      	b.n	810b7fc <xQueueGenericSendFromISR+0x74>
 810b7fa:	2300      	movs	r3, #0
 810b7fc:	2b00      	cmp	r3, #0
 810b7fe:	d10b      	bne.n	810b818 <xQueueGenericSendFromISR+0x90>
	__asm volatile
 810b800:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b804:	f383 8811 	msr	BASEPRI, r3
 810b808:	f3bf 8f6f 	isb	sy
 810b80c:	f3bf 8f4f 	dsb	sy
 810b810:	623b      	str	r3, [r7, #32]
}
 810b812:	bf00      	nop
 810b814:	bf00      	nop
 810b816:	e7fd      	b.n	810b814 <xQueueGenericSendFromISR+0x8c>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
 810b818:	f7ff fcbe 	bl	810b198 <vPortValidateInterruptPriority>
	__asm volatile
 810b81c:	f3ef 8211 	mrs	r2, BASEPRI
 810b820:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b824:	f383 8811 	msr	BASEPRI, r3
 810b828:	f3bf 8f6f 	isb	sy
 810b82c:	f3bf 8f4f 	dsb	sy
 810b830:	61fa      	str	r2, [r7, #28]
 810b832:	61bb      	str	r3, [r7, #24]
	return ulOriginalBASEPRI;
 810b834:	69fb      	ldr	r3, [r7, #28]
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
 810b836:	637b      	str	r3, [r7, #52]	@ 0x34
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
 810b838:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810b83a:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 810b83c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810b83e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 810b840:	429a      	cmp	r2, r3
 810b842:	d302      	bcc.n	810b84a <xQueueGenericSendFromISR+0xc2>
 810b844:	683b      	ldr	r3, [r7, #0]
 810b846:	2b02      	cmp	r3, #2
 810b848:	d12f      	bne.n	810b8aa <xQueueGenericSendFromISR+0x122>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
 810b84a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810b84c:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
 810b850:	f887 3033 	strb.w	r3, [r7, #51]	@ 0x33
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
 810b854:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810b856:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 810b858:	62fb      	str	r3, [r7, #44]	@ 0x2c
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
 810b85a:	683a      	ldr	r2, [r7, #0]
 810b85c:	68b9      	ldr	r1, [r7, #8]
 810b85e:	6bb8      	ldr	r0, [r7, #56]	@ 0x38
 810b860:	f000 f936 	bl	810bad0 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
 810b864:	f997 3033 	ldrsb.w	r3, [r7, #51]	@ 0x33
 810b868:	f1b3 3fff 	cmp.w	r3, #4294967295
 810b86c:	d112      	bne.n	810b894 <xQueueGenericSendFromISR+0x10c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 810b86e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810b870:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810b872:	2b00      	cmp	r3, #0
 810b874:	d016      	beq.n	810b8a4 <xQueueGenericSendFromISR+0x11c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 810b876:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810b878:	3324      	adds	r3, #36	@ 0x24
 810b87a:	4618      	mov	r0, r3
 810b87c:	f000 ff2a 	bl	810c6d4 <xTaskRemoveFromEventList>
 810b880:	4603      	mov	r3, r0
 810b882:	2b00      	cmp	r3, #0
 810b884:	d00e      	beq.n	810b8a4 <xQueueGenericSendFromISR+0x11c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
 810b886:	687b      	ldr	r3, [r7, #4]
 810b888:	2b00      	cmp	r3, #0
 810b88a:	d00b      	beq.n	810b8a4 <xQueueGenericSendFromISR+0x11c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
 810b88c:	687b      	ldr	r3, [r7, #4]
 810b88e:	2201      	movs	r2, #1
 810b890:	601a      	str	r2, [r3, #0]
 810b892:	e007      	b.n	810b8a4 <xQueueGenericSendFromISR+0x11c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
 810b894:	f897 3033 	ldrb.w	r3, [r7, #51]	@ 0x33
 810b898:	3301      	adds	r3, #1
 810b89a:	b2db      	uxtb	r3, r3
 810b89c:	b25a      	sxtb	r2, r3
 810b89e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810b8a0:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
			}

			xReturn = pdPASS;
 810b8a4:	2301      	movs	r3, #1
 810b8a6:	63fb      	str	r3, [r7, #60]	@ 0x3c
		{
 810b8a8:	e001      	b.n	810b8ae <xQueueGenericSendFromISR+0x126>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
 810b8aa:	2300      	movs	r3, #0
 810b8ac:	63fb      	str	r3, [r7, #60]	@ 0x3c
 810b8ae:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810b8b0:	617b      	str	r3, [r7, #20]
	__asm volatile
 810b8b2:	697b      	ldr	r3, [r7, #20]
 810b8b4:	f383 8811 	msr	BASEPRI, r3
}
 810b8b8:	bf00      	nop
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
 810b8ba:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
}
 810b8bc:	4618      	mov	r0, r3
 810b8be:	3740      	adds	r7, #64	@ 0x40
 810b8c0:	46bd      	mov	sp, r7
 810b8c2:	bd80      	pop	{r7, pc}

0810b8c4 <xQueueReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
 810b8c4:	b580      	push	{r7, lr}
 810b8c6:	b08c      	sub	sp, #48	@ 0x30
 810b8c8:	af00      	add	r7, sp, #0
 810b8ca:	60f8      	str	r0, [r7, #12]
 810b8cc:	60b9      	str	r1, [r7, #8]
 810b8ce:	607a      	str	r2, [r7, #4]
BaseType_t xEntryTimeSet = pdFALSE;
 810b8d0:	2300      	movs	r3, #0
 810b8d2:	62fb      	str	r3, [r7, #44]	@ 0x2c
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
 810b8d4:	68fb      	ldr	r3, [r7, #12]
 810b8d6:	62bb      	str	r3, [r7, #40]	@ 0x28

	/* Check the pointer is not NULL. */
	configASSERT( ( pxQueue ) );
 810b8d8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810b8da:	2b00      	cmp	r3, #0
 810b8dc:	d10b      	bne.n	810b8f6 <xQueueReceive+0x32>
	__asm volatile
 810b8de:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b8e2:	f383 8811 	msr	BASEPRI, r3
 810b8e6:	f3bf 8f6f 	isb	sy
 810b8ea:	f3bf 8f4f 	dsb	sy
 810b8ee:	623b      	str	r3, [r7, #32]
}
 810b8f0:	bf00      	nop
 810b8f2:	bf00      	nop
 810b8f4:	e7fd      	b.n	810b8f2 <xQueueReceive+0x2e>

	/* The buffer into which data is received can only be NULL if the data size
	is zero (so no data is copied into the buffer. */
	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
 810b8f6:	68bb      	ldr	r3, [r7, #8]
 810b8f8:	2b00      	cmp	r3, #0
 810b8fa:	d103      	bne.n	810b904 <xQueueReceive+0x40>
 810b8fc:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810b8fe:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810b900:	2b00      	cmp	r3, #0
 810b902:	d101      	bne.n	810b908 <xQueueReceive+0x44>
 810b904:	2301      	movs	r3, #1
 810b906:	e000      	b.n	810b90a <xQueueReceive+0x46>
 810b908:	2300      	movs	r3, #0
 810b90a:	2b00      	cmp	r3, #0
 810b90c:	d10b      	bne.n	810b926 <xQueueReceive+0x62>
	__asm volatile
 810b90e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b912:	f383 8811 	msr	BASEPRI, r3
 810b916:	f3bf 8f6f 	isb	sy
 810b91a:	f3bf 8f4f 	dsb	sy
 810b91e:	61fb      	str	r3, [r7, #28]
}
 810b920:	bf00      	nop
 810b922:	bf00      	nop
 810b924:	e7fd      	b.n	810b922 <xQueueReceive+0x5e>

	/* Cannot block if the scheduler is suspended. */
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
 810b926:	f001 f895 	bl	810ca54 <xTaskGetSchedulerState>
 810b92a:	4603      	mov	r3, r0
 810b92c:	2b00      	cmp	r3, #0
 810b92e:	d102      	bne.n	810b936 <xQueueReceive+0x72>
 810b930:	687b      	ldr	r3, [r7, #4]
 810b932:	2b00      	cmp	r3, #0
 810b934:	d101      	bne.n	810b93a <xQueueReceive+0x76>
 810b936:	2301      	movs	r3, #1
 810b938:	e000      	b.n	810b93c <xQueueReceive+0x78>
 810b93a:	2300      	movs	r3, #0
 810b93c:	2b00      	cmp	r3, #0
 810b93e:	d10b      	bne.n	810b958 <xQueueReceive+0x94>
	__asm volatile
 810b940:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810b944:	f383 8811 	msr	BASEPRI, r3
 810b948:	f3bf 8f6f 	isb	sy
 810b94c:	f3bf 8f4f 	dsb	sy
 810b950:	61bb      	str	r3, [r7, #24]
}
 810b952:	bf00      	nop
 810b954:	bf00      	nop
 810b956:	e7fd      	b.n	810b954 <xQueueReceive+0x90>
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
 810b958:	f7ff fb3e 	bl	810afd8 <vPortEnterCritical>
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 810b95c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810b95e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 810b960:	627b      	str	r3, [r7, #36]	@ 0x24

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 810b962:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810b964:	2b00      	cmp	r3, #0
 810b966:	d01f      	beq.n	810b9a8 <xQueueReceive+0xe4>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
 810b968:	68b9      	ldr	r1, [r7, #8]
 810b96a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810b96c:	f000 f91a 	bl	810bba4 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
 810b970:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810b972:	1e5a      	subs	r2, r3, #1
 810b974:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810b976:	639a      	str	r2, [r3, #56]	@ 0x38

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 810b978:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810b97a:	691b      	ldr	r3, [r3, #16]
 810b97c:	2b00      	cmp	r3, #0
 810b97e:	d00f      	beq.n	810b9a0 <xQueueReceive+0xdc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 810b980:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810b982:	3310      	adds	r3, #16
 810b984:	4618      	mov	r0, r3
 810b986:	f000 fea5 	bl	810c6d4 <xTaskRemoveFromEventList>
 810b98a:	4603      	mov	r3, r0
 810b98c:	2b00      	cmp	r3, #0
 810b98e:	d007      	beq.n	810b9a0 <xQueueReceive+0xdc>
					{
						queueYIELD_IF_USING_PREEMPTION();
 810b990:	4b3c      	ldr	r3, [pc, #240]	@ (810ba84 <xQueueReceive+0x1c0>)
 810b992:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 810b996:	601a      	str	r2, [r3, #0]
 810b998:	f3bf 8f4f 	dsb	sy
 810b99c:	f3bf 8f6f 	isb	sy
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
 810b9a0:	f7ff fb4c 	bl	810b03c <vPortExitCritical>
				return pdPASS;
 810b9a4:	2301      	movs	r3, #1
 810b9a6:	e069      	b.n	810ba7c <xQueueReceive+0x1b8>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
 810b9a8:	687b      	ldr	r3, [r7, #4]
 810b9aa:	2b00      	cmp	r3, #0
 810b9ac:	d103      	bne.n	810b9b6 <xQueueReceive+0xf2>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
 810b9ae:	f7ff fb45 	bl	810b03c <vPortExitCritical>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
 810b9b2:	2300      	movs	r3, #0
 810b9b4:	e062      	b.n	810ba7c <xQueueReceive+0x1b8>
				}
				else if( xEntryTimeSet == pdFALSE )
 810b9b6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810b9b8:	2b00      	cmp	r3, #0
 810b9ba:	d106      	bne.n	810b9ca <xQueueReceive+0x106>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
 810b9bc:	f107 0310 	add.w	r3, r7, #16
 810b9c0:	4618      	mov	r0, r3
 810b9c2:	f000 feeb 	bl	810c79c <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
 810b9c6:	2301      	movs	r3, #1
 810b9c8:	62fb      	str	r3, [r7, #44]	@ 0x2c
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
 810b9ca:	f7ff fb37 	bl	810b03c <vPortExitCritical>

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
 810b9ce:	f000 fc5b 	bl	810c288 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
 810b9d2:	f7ff fb01 	bl	810afd8 <vPortEnterCritical>
 810b9d6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810b9d8:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
 810b9dc:	b25b      	sxtb	r3, r3
 810b9de:	f1b3 3fff 	cmp.w	r3, #4294967295
 810b9e2:	d103      	bne.n	810b9ec <xQueueReceive+0x128>
 810b9e4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810b9e6:	2200      	movs	r2, #0
 810b9e8:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 810b9ec:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810b9ee:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
 810b9f2:	b25b      	sxtb	r3, r3
 810b9f4:	f1b3 3fff 	cmp.w	r3, #4294967295
 810b9f8:	d103      	bne.n	810ba02 <xQueueReceive+0x13e>
 810b9fa:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810b9fc:	2200      	movs	r2, #0
 810b9fe:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 810ba02:	f7ff fb1b 	bl	810b03c <vPortExitCritical>

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
 810ba06:	1d3a      	adds	r2, r7, #4
 810ba08:	f107 0310 	add.w	r3, r7, #16
 810ba0c:	4611      	mov	r1, r2
 810ba0e:	4618      	mov	r0, r3
 810ba10:	f000 feda 	bl	810c7c8 <xTaskCheckForTimeOut>
 810ba14:	4603      	mov	r3, r0
 810ba16:	2b00      	cmp	r3, #0
 810ba18:	d123      	bne.n	810ba62 <xQueueReceive+0x19e>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 810ba1a:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810ba1c:	f000 f93a 	bl	810bc94 <prvIsQueueEmpty>
 810ba20:	4603      	mov	r3, r0
 810ba22:	2b00      	cmp	r3, #0
 810ba24:	d017      	beq.n	810ba56 <xQueueReceive+0x192>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
 810ba26:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810ba28:	3324      	adds	r3, #36	@ 0x24
 810ba2a:	687a      	ldr	r2, [r7, #4]
 810ba2c:	4611      	mov	r1, r2
 810ba2e:	4618      	mov	r0, r3
 810ba30:	f000 fdfe 	bl	810c630 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
 810ba34:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810ba36:	f000 f8db 	bl	810bbf0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
 810ba3a:	f000 fc33 	bl	810c2a4 <xTaskResumeAll>
 810ba3e:	4603      	mov	r3, r0
 810ba40:	2b00      	cmp	r3, #0
 810ba42:	d189      	bne.n	810b958 <xQueueReceive+0x94>
				{
					portYIELD_WITHIN_API();
 810ba44:	4b0f      	ldr	r3, [pc, #60]	@ (810ba84 <xQueueReceive+0x1c0>)
 810ba46:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 810ba4a:	601a      	str	r2, [r3, #0]
 810ba4c:	f3bf 8f4f 	dsb	sy
 810ba50:	f3bf 8f6f 	isb	sy
 810ba54:	e780      	b.n	810b958 <xQueueReceive+0x94>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
 810ba56:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810ba58:	f000 f8ca 	bl	810bbf0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
 810ba5c:	f000 fc22 	bl	810c2a4 <xTaskResumeAll>
 810ba60:	e77a      	b.n	810b958 <xQueueReceive+0x94>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
 810ba62:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810ba64:	f000 f8c4 	bl	810bbf0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
 810ba68:	f000 fc1c 	bl	810c2a4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
 810ba6c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810ba6e:	f000 f911 	bl	810bc94 <prvIsQueueEmpty>
 810ba72:	4603      	mov	r3, r0
 810ba74:	2b00      	cmp	r3, #0
 810ba76:	f43f af6f 	beq.w	810b958 <xQueueReceive+0x94>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
 810ba7a:	2300      	movs	r3, #0
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
}
 810ba7c:	4618      	mov	r0, r3
 810ba7e:	3730      	adds	r7, #48	@ 0x30
 810ba80:	46bd      	mov	sp, r7
 810ba82:	bd80      	pop	{r7, pc}
 810ba84:	e000ed04 	.word	0xe000ed04

0810ba88 <vQueueDelete>:
	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
 810ba88:	b580      	push	{r7, lr}
 810ba8a:	b084      	sub	sp, #16
 810ba8c:	af00      	add	r7, sp, #0
 810ba8e:	6078      	str	r0, [r7, #4]
Queue_t * const pxQueue = xQueue;
 810ba90:	687b      	ldr	r3, [r7, #4]
 810ba92:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
 810ba94:	68fb      	ldr	r3, [r7, #12]
 810ba96:	2b00      	cmp	r3, #0
 810ba98:	d10b      	bne.n	810bab2 <vQueueDelete+0x2a>
	__asm volatile
 810ba9a:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810ba9e:	f383 8811 	msr	BASEPRI, r3
 810baa2:	f3bf 8f6f 	isb	sy
 810baa6:	f3bf 8f4f 	dsb	sy
 810baaa:	60bb      	str	r3, [r7, #8]
}
 810baac:	bf00      	nop
 810baae:	bf00      	nop
 810bab0:	e7fd      	b.n	810baae <vQueueDelete+0x26>
	traceQUEUE_DELETE( pxQueue );

	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		vQueueUnregisterQueue( pxQueue );
 810bab2:	68f8      	ldr	r0, [r7, #12]
 810bab4:	f000 f946 	bl	810bd44 <vQueueUnregisterQueue>
	}
	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
	{
		/* The queue could have been allocated statically or dynamically, so
		check before attempting to free the memory. */
		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
 810bab8:	68fb      	ldr	r3, [r7, #12]
 810baba:	f893 3046 	ldrb.w	r3, [r3, #70]	@ 0x46
 810babe:	2b00      	cmp	r3, #0
 810bac0:	d102      	bne.n	810bac8 <vQueueDelete+0x40>
		{
			vPortFree( pxQueue );
 810bac2:	68f8      	ldr	r0, [r7, #12]
 810bac4:	f7fe ff80 	bl	810a9c8 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
 810bac8:	bf00      	nop
 810baca:	3710      	adds	r7, #16
 810bacc:	46bd      	mov	sp, r7
 810bace:	bd80      	pop	{r7, pc}

0810bad0 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
 810bad0:	b580      	push	{r7, lr}
 810bad2:	b086      	sub	sp, #24
 810bad4:	af00      	add	r7, sp, #0
 810bad6:	60f8      	str	r0, [r7, #12]
 810bad8:	60b9      	str	r1, [r7, #8]
 810bada:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
 810badc:	2300      	movs	r3, #0
 810bade:	617b      	str	r3, [r7, #20]
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
 810bae0:	68fb      	ldr	r3, [r7, #12]
 810bae2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 810bae4:	613b      	str	r3, [r7, #16]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
 810bae6:	68fb      	ldr	r3, [r7, #12]
 810bae8:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810baea:	2b00      	cmp	r3, #0
 810baec:	d10d      	bne.n	810bb0a <prvCopyDataToQueue+0x3a>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
 810baee:	68fb      	ldr	r3, [r7, #12]
 810baf0:	681b      	ldr	r3, [r3, #0]
 810baf2:	2b00      	cmp	r3, #0
 810baf4:	d14d      	bne.n	810bb92 <prvCopyDataToQueue+0xc2>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
 810baf6:	68fb      	ldr	r3, [r7, #12]
 810baf8:	689b      	ldr	r3, [r3, #8]
 810bafa:	4618      	mov	r0, r3
 810bafc:	f000 ffc8 	bl	810ca90 <xTaskPriorityDisinherit>
 810bb00:	6178      	str	r0, [r7, #20]
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
 810bb02:	68fb      	ldr	r3, [r7, #12]
 810bb04:	2200      	movs	r2, #0
 810bb06:	609a      	str	r2, [r3, #8]
 810bb08:	e043      	b.n	810bb92 <prvCopyDataToQueue+0xc2>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
 810bb0a:	687b      	ldr	r3, [r7, #4]
 810bb0c:	2b00      	cmp	r3, #0
 810bb0e:	d119      	bne.n	810bb44 <prvCopyDataToQueue+0x74>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 810bb10:	68fb      	ldr	r3, [r7, #12]
 810bb12:	6858      	ldr	r0, [r3, #4]
 810bb14:	68fb      	ldr	r3, [r7, #12]
 810bb16:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810bb18:	461a      	mov	r2, r3
 810bb1a:	68b9      	ldr	r1, [r7, #8]
 810bb1c:	f004 f96d 	bl	810fdfa <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 810bb20:	68fb      	ldr	r3, [r7, #12]
 810bb22:	685a      	ldr	r2, [r3, #4]
 810bb24:	68fb      	ldr	r3, [r7, #12]
 810bb26:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810bb28:	441a      	add	r2, r3
 810bb2a:	68fb      	ldr	r3, [r7, #12]
 810bb2c:	605a      	str	r2, [r3, #4]
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 810bb2e:	68fb      	ldr	r3, [r7, #12]
 810bb30:	685a      	ldr	r2, [r3, #4]
 810bb32:	68fb      	ldr	r3, [r7, #12]
 810bb34:	689b      	ldr	r3, [r3, #8]
 810bb36:	429a      	cmp	r2, r3
 810bb38:	d32b      	bcc.n	810bb92 <prvCopyDataToQueue+0xc2>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
 810bb3a:	68fb      	ldr	r3, [r7, #12]
 810bb3c:	681a      	ldr	r2, [r3, #0]
 810bb3e:	68fb      	ldr	r3, [r7, #12]
 810bb40:	605a      	str	r2, [r3, #4]
 810bb42:	e026      	b.n	810bb92 <prvCopyDataToQueue+0xc2>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
 810bb44:	68fb      	ldr	r3, [r7, #12]
 810bb46:	68d8      	ldr	r0, [r3, #12]
 810bb48:	68fb      	ldr	r3, [r7, #12]
 810bb4a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810bb4c:	461a      	mov	r2, r3
 810bb4e:	68b9      	ldr	r1, [r7, #8]
 810bb50:	f004 f953 	bl	810fdfa <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
 810bb54:	68fb      	ldr	r3, [r7, #12]
 810bb56:	68da      	ldr	r2, [r3, #12]
 810bb58:	68fb      	ldr	r3, [r7, #12]
 810bb5a:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810bb5c:	425b      	negs	r3, r3
 810bb5e:	441a      	add	r2, r3
 810bb60:	68fb      	ldr	r3, [r7, #12]
 810bb62:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
 810bb64:	68fb      	ldr	r3, [r7, #12]
 810bb66:	68da      	ldr	r2, [r3, #12]
 810bb68:	68fb      	ldr	r3, [r7, #12]
 810bb6a:	681b      	ldr	r3, [r3, #0]
 810bb6c:	429a      	cmp	r2, r3
 810bb6e:	d207      	bcs.n	810bb80 <prvCopyDataToQueue+0xb0>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
 810bb70:	68fb      	ldr	r3, [r7, #12]
 810bb72:	689a      	ldr	r2, [r3, #8]
 810bb74:	68fb      	ldr	r3, [r7, #12]
 810bb76:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810bb78:	425b      	negs	r3, r3
 810bb7a:	441a      	add	r2, r3
 810bb7c:	68fb      	ldr	r3, [r7, #12]
 810bb7e:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
 810bb80:	687b      	ldr	r3, [r7, #4]
 810bb82:	2b02      	cmp	r3, #2
 810bb84:	d105      	bne.n	810bb92 <prvCopyDataToQueue+0xc2>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
 810bb86:	693b      	ldr	r3, [r7, #16]
 810bb88:	2b00      	cmp	r3, #0
 810bb8a:	d002      	beq.n	810bb92 <prvCopyDataToQueue+0xc2>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
 810bb8c:	693b      	ldr	r3, [r7, #16]
 810bb8e:	3b01      	subs	r3, #1
 810bb90:	613b      	str	r3, [r7, #16]
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
 810bb92:	693b      	ldr	r3, [r7, #16]
 810bb94:	1c5a      	adds	r2, r3, #1
 810bb96:	68fb      	ldr	r3, [r7, #12]
 810bb98:	639a      	str	r2, [r3, #56]	@ 0x38

	return xReturn;
 810bb9a:	697b      	ldr	r3, [r7, #20]
}
 810bb9c:	4618      	mov	r0, r3
 810bb9e:	3718      	adds	r7, #24
 810bba0:	46bd      	mov	sp, r7
 810bba2:	bd80      	pop	{r7, pc}

0810bba4 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
 810bba4:	b580      	push	{r7, lr}
 810bba6:	b082      	sub	sp, #8
 810bba8:	af00      	add	r7, sp, #0
 810bbaa:	6078      	str	r0, [r7, #4]
 810bbac:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
 810bbae:	687b      	ldr	r3, [r7, #4]
 810bbb0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810bbb2:	2b00      	cmp	r3, #0
 810bbb4:	d018      	beq.n	810bbe8 <prvCopyDataFromQueue+0x44>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
 810bbb6:	687b      	ldr	r3, [r7, #4]
 810bbb8:	68da      	ldr	r2, [r3, #12]
 810bbba:	687b      	ldr	r3, [r7, #4]
 810bbbc:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810bbbe:	441a      	add	r2, r3
 810bbc0:	687b      	ldr	r3, [r7, #4]
 810bbc2:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
 810bbc4:	687b      	ldr	r3, [r7, #4]
 810bbc6:	68da      	ldr	r2, [r3, #12]
 810bbc8:	687b      	ldr	r3, [r7, #4]
 810bbca:	689b      	ldr	r3, [r3, #8]
 810bbcc:	429a      	cmp	r2, r3
 810bbce:	d303      	bcc.n	810bbd8 <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
 810bbd0:	687b      	ldr	r3, [r7, #4]
 810bbd2:	681a      	ldr	r2, [r3, #0]
 810bbd4:	687b      	ldr	r3, [r7, #4]
 810bbd6:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
 810bbd8:	687b      	ldr	r3, [r7, #4]
 810bbda:	68d9      	ldr	r1, [r3, #12]
 810bbdc:	687b      	ldr	r3, [r7, #4]
 810bbde:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
 810bbe0:	461a      	mov	r2, r3
 810bbe2:	6838      	ldr	r0, [r7, #0]
 810bbe4:	f004 f909 	bl	810fdfa <memcpy>
	}
}
 810bbe8:	bf00      	nop
 810bbea:	3708      	adds	r7, #8
 810bbec:	46bd      	mov	sp, r7
 810bbee:	bd80      	pop	{r7, pc}

0810bbf0 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
 810bbf0:	b580      	push	{r7, lr}
 810bbf2:	b084      	sub	sp, #16
 810bbf4:	af00      	add	r7, sp, #0
 810bbf6:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
 810bbf8:	f7ff f9ee 	bl	810afd8 <vPortEnterCritical>
	{
		int8_t cTxLock = pxQueue->cTxLock;
 810bbfc:	687b      	ldr	r3, [r7, #4]
 810bbfe:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
 810bc02:	73fb      	strb	r3, [r7, #15]

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
 810bc04:	e011      	b.n	810bc2a <prvUnlockQueue+0x3a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
 810bc06:	687b      	ldr	r3, [r7, #4]
 810bc08:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810bc0a:	2b00      	cmp	r3, #0
 810bc0c:	d012      	beq.n	810bc34 <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
 810bc0e:	687b      	ldr	r3, [r7, #4]
 810bc10:	3324      	adds	r3, #36	@ 0x24
 810bc12:	4618      	mov	r0, r3
 810bc14:	f000 fd5e 	bl	810c6d4 <xTaskRemoveFromEventList>
 810bc18:	4603      	mov	r3, r0
 810bc1a:	2b00      	cmp	r3, #0
 810bc1c:	d001      	beq.n	810bc22 <prvUnlockQueue+0x32>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
 810bc1e:	f000 fe37 	bl	810c890 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
 810bc22:	7bfb      	ldrb	r3, [r7, #15]
 810bc24:	3b01      	subs	r3, #1
 810bc26:	b2db      	uxtb	r3, r3
 810bc28:	73fb      	strb	r3, [r7, #15]
		while( cTxLock > queueLOCKED_UNMODIFIED )
 810bc2a:	f997 300f 	ldrsb.w	r3, [r7, #15]
 810bc2e:	2b00      	cmp	r3, #0
 810bc30:	dce9      	bgt.n	810bc06 <prvUnlockQueue+0x16>
 810bc32:	e000      	b.n	810bc36 <prvUnlockQueue+0x46>
					break;
 810bc34:	bf00      	nop
		}

		pxQueue->cTxLock = queueUNLOCKED;
 810bc36:	687b      	ldr	r3, [r7, #4]
 810bc38:	22ff      	movs	r2, #255	@ 0xff
 810bc3a:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
	}
	taskEXIT_CRITICAL();
 810bc3e:	f7ff f9fd 	bl	810b03c <vPortExitCritical>

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
 810bc42:	f7ff f9c9 	bl	810afd8 <vPortEnterCritical>
	{
		int8_t cRxLock = pxQueue->cRxLock;
 810bc46:	687b      	ldr	r3, [r7, #4]
 810bc48:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
 810bc4c:	73bb      	strb	r3, [r7, #14]

		while( cRxLock > queueLOCKED_UNMODIFIED )
 810bc4e:	e011      	b.n	810bc74 <prvUnlockQueue+0x84>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
 810bc50:	687b      	ldr	r3, [r7, #4]
 810bc52:	691b      	ldr	r3, [r3, #16]
 810bc54:	2b00      	cmp	r3, #0
 810bc56:	d012      	beq.n	810bc7e <prvUnlockQueue+0x8e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
 810bc58:	687b      	ldr	r3, [r7, #4]
 810bc5a:	3310      	adds	r3, #16
 810bc5c:	4618      	mov	r0, r3
 810bc5e:	f000 fd39 	bl	810c6d4 <xTaskRemoveFromEventList>
 810bc62:	4603      	mov	r3, r0
 810bc64:	2b00      	cmp	r3, #0
 810bc66:	d001      	beq.n	810bc6c <prvUnlockQueue+0x7c>
				{
					vTaskMissedYield();
 810bc68:	f000 fe12 	bl	810c890 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
 810bc6c:	7bbb      	ldrb	r3, [r7, #14]
 810bc6e:	3b01      	subs	r3, #1
 810bc70:	b2db      	uxtb	r3, r3
 810bc72:	73bb      	strb	r3, [r7, #14]
		while( cRxLock > queueLOCKED_UNMODIFIED )
 810bc74:	f997 300e 	ldrsb.w	r3, [r7, #14]
 810bc78:	2b00      	cmp	r3, #0
 810bc7a:	dce9      	bgt.n	810bc50 <prvUnlockQueue+0x60>
 810bc7c:	e000      	b.n	810bc80 <prvUnlockQueue+0x90>
			}
			else
			{
				break;
 810bc7e:	bf00      	nop
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
 810bc80:	687b      	ldr	r3, [r7, #4]
 810bc82:	22ff      	movs	r2, #255	@ 0xff
 810bc84:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
	}
	taskEXIT_CRITICAL();
 810bc88:	f7ff f9d8 	bl	810b03c <vPortExitCritical>
}
 810bc8c:	bf00      	nop
 810bc8e:	3710      	adds	r7, #16
 810bc90:	46bd      	mov	sp, r7
 810bc92:	bd80      	pop	{r7, pc}

0810bc94 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
 810bc94:	b580      	push	{r7, lr}
 810bc96:	b084      	sub	sp, #16
 810bc98:	af00      	add	r7, sp, #0
 810bc9a:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 810bc9c:	f7ff f99c 	bl	810afd8 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
 810bca0:	687b      	ldr	r3, [r7, #4]
 810bca2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 810bca4:	2b00      	cmp	r3, #0
 810bca6:	d102      	bne.n	810bcae <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
 810bca8:	2301      	movs	r3, #1
 810bcaa:	60fb      	str	r3, [r7, #12]
 810bcac:	e001      	b.n	810bcb2 <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
 810bcae:	2300      	movs	r3, #0
 810bcb0:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 810bcb2:	f7ff f9c3 	bl	810b03c <vPortExitCritical>

	return xReturn;
 810bcb6:	68fb      	ldr	r3, [r7, #12]
}
 810bcb8:	4618      	mov	r0, r3
 810bcba:	3710      	adds	r7, #16
 810bcbc:	46bd      	mov	sp, r7
 810bcbe:	bd80      	pop	{r7, pc}

0810bcc0 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
 810bcc0:	b580      	push	{r7, lr}
 810bcc2:	b084      	sub	sp, #16
 810bcc4:	af00      	add	r7, sp, #0
 810bcc6:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
 810bcc8:	f7ff f986 	bl	810afd8 <vPortEnterCritical>
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
 810bccc:	687b      	ldr	r3, [r7, #4]
 810bcce:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
 810bcd0:	687b      	ldr	r3, [r7, #4]
 810bcd2:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 810bcd4:	429a      	cmp	r2, r3
 810bcd6:	d102      	bne.n	810bcde <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
 810bcd8:	2301      	movs	r3, #1
 810bcda:	60fb      	str	r3, [r7, #12]
 810bcdc:	e001      	b.n	810bce2 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
 810bcde:	2300      	movs	r3, #0
 810bce0:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
 810bce2:	f7ff f9ab 	bl	810b03c <vPortExitCritical>

	return xReturn;
 810bce6:	68fb      	ldr	r3, [r7, #12]
}
 810bce8:	4618      	mov	r0, r3
 810bcea:	3710      	adds	r7, #16
 810bcec:	46bd      	mov	sp, r7
 810bcee:	bd80      	pop	{r7, pc}

0810bcf0 <vQueueAddToRegistry>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	{
 810bcf0:	b480      	push	{r7}
 810bcf2:	b085      	sub	sp, #20
 810bcf4:	af00      	add	r7, sp, #0
 810bcf6:	6078      	str	r0, [r7, #4]
 810bcf8:	6039      	str	r1, [r7, #0]
	UBaseType_t ux;

		/* See if there is an empty space in the registry.  A NULL name denotes
		a free slot. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 810bcfa:	2300      	movs	r3, #0
 810bcfc:	60fb      	str	r3, [r7, #12]
 810bcfe:	e014      	b.n	810bd2a <vQueueAddToRegistry+0x3a>
		{
			if( xQueueRegistry[ ux ].pcQueueName == NULL )
 810bd00:	4a0f      	ldr	r2, [pc, #60]	@ (810bd40 <vQueueAddToRegistry+0x50>)
 810bd02:	68fb      	ldr	r3, [r7, #12]
 810bd04:	f852 3033 	ldr.w	r3, [r2, r3, lsl #3]
 810bd08:	2b00      	cmp	r3, #0
 810bd0a:	d10b      	bne.n	810bd24 <vQueueAddToRegistry+0x34>
			{
				/* Store the information on this queue. */
				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
 810bd0c:	490c      	ldr	r1, [pc, #48]	@ (810bd40 <vQueueAddToRegistry+0x50>)
 810bd0e:	68fb      	ldr	r3, [r7, #12]
 810bd10:	683a      	ldr	r2, [r7, #0]
 810bd12:	f841 2033 	str.w	r2, [r1, r3, lsl #3]
				xQueueRegistry[ ux ].xHandle = xQueue;
 810bd16:	4a0a      	ldr	r2, [pc, #40]	@ (810bd40 <vQueueAddToRegistry+0x50>)
 810bd18:	68fb      	ldr	r3, [r7, #12]
 810bd1a:	00db      	lsls	r3, r3, #3
 810bd1c:	4413      	add	r3, r2
 810bd1e:	687a      	ldr	r2, [r7, #4]
 810bd20:	605a      	str	r2, [r3, #4]

				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
				break;
 810bd22:	e006      	b.n	810bd32 <vQueueAddToRegistry+0x42>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 810bd24:	68fb      	ldr	r3, [r7, #12]
 810bd26:	3301      	adds	r3, #1
 810bd28:	60fb      	str	r3, [r7, #12]
 810bd2a:	68fb      	ldr	r3, [r7, #12]
 810bd2c:	2b07      	cmp	r3, #7
 810bd2e:	d9e7      	bls.n	810bd00 <vQueueAddToRegistry+0x10>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
 810bd30:	bf00      	nop
 810bd32:	bf00      	nop
 810bd34:	3714      	adds	r7, #20
 810bd36:	46bd      	mov	sp, r7
 810bd38:	f85d 7b04 	ldr.w	r7, [sp], #4
 810bd3c:	4770      	bx	lr
 810bd3e:	bf00      	nop
 810bd40:	10004ec0 	.word	0x10004ec0

0810bd44 <vQueueUnregisterQueue>:
/*-----------------------------------------------------------*/

#if ( configQUEUE_REGISTRY_SIZE > 0 )

	void vQueueUnregisterQueue( QueueHandle_t xQueue )
	{
 810bd44:	b480      	push	{r7}
 810bd46:	b085      	sub	sp, #20
 810bd48:	af00      	add	r7, sp, #0
 810bd4a:	6078      	str	r0, [r7, #4]
	UBaseType_t ux;

		/* See if the handle of the queue being unregistered in actually in the
		registry. */
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 810bd4c:	2300      	movs	r3, #0
 810bd4e:	60fb      	str	r3, [r7, #12]
 810bd50:	e016      	b.n	810bd80 <vQueueUnregisterQueue+0x3c>
		{
			if( xQueueRegistry[ ux ].xHandle == xQueue )
 810bd52:	4a10      	ldr	r2, [pc, #64]	@ (810bd94 <vQueueUnregisterQueue+0x50>)
 810bd54:	68fb      	ldr	r3, [r7, #12]
 810bd56:	00db      	lsls	r3, r3, #3
 810bd58:	4413      	add	r3, r2
 810bd5a:	685b      	ldr	r3, [r3, #4]
 810bd5c:	687a      	ldr	r2, [r7, #4]
 810bd5e:	429a      	cmp	r2, r3
 810bd60:	d10b      	bne.n	810bd7a <vQueueUnregisterQueue+0x36>
			{
				/* Set the name to NULL to show that this slot if free again. */
				xQueueRegistry[ ux ].pcQueueName = NULL;
 810bd62:	4a0c      	ldr	r2, [pc, #48]	@ (810bd94 <vQueueUnregisterQueue+0x50>)
 810bd64:	68fb      	ldr	r3, [r7, #12]
 810bd66:	2100      	movs	r1, #0
 810bd68:	f842 1033 	str.w	r1, [r2, r3, lsl #3]

				/* Set the handle to NULL to ensure the same queue handle cannot
				appear in the registry twice if it is added, removed, then
				added again. */
				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
 810bd6c:	4a09      	ldr	r2, [pc, #36]	@ (810bd94 <vQueueUnregisterQueue+0x50>)
 810bd6e:	68fb      	ldr	r3, [r7, #12]
 810bd70:	00db      	lsls	r3, r3, #3
 810bd72:	4413      	add	r3, r2
 810bd74:	2200      	movs	r2, #0
 810bd76:	605a      	str	r2, [r3, #4]
				break;
 810bd78:	e006      	b.n	810bd88 <vQueueUnregisterQueue+0x44>
		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
 810bd7a:	68fb      	ldr	r3, [r7, #12]
 810bd7c:	3301      	adds	r3, #1
 810bd7e:	60fb      	str	r3, [r7, #12]
 810bd80:	68fb      	ldr	r3, [r7, #12]
 810bd82:	2b07      	cmp	r3, #7
 810bd84:	d9e5      	bls.n	810bd52 <vQueueUnregisterQueue+0xe>
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
 810bd86:	bf00      	nop
 810bd88:	bf00      	nop
 810bd8a:	3714      	adds	r7, #20
 810bd8c:	46bd      	mov	sp, r7
 810bd8e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810bd92:	4770      	bx	lr
 810bd94:	10004ec0 	.word	0x10004ec0

0810bd98 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 810bd98:	b580      	push	{r7, lr}
 810bd9a:	b086      	sub	sp, #24
 810bd9c:	af00      	add	r7, sp, #0
 810bd9e:	60f8      	str	r0, [r7, #12]
 810bda0:	60b9      	str	r1, [r7, #8]
 810bda2:	607a      	str	r2, [r7, #4]
	Queue_t * const pxQueue = xQueue;
 810bda4:	68fb      	ldr	r3, [r7, #12]
 810bda6:	617b      	str	r3, [r7, #20]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
 810bda8:	f7ff f916 	bl	810afd8 <vPortEnterCritical>
 810bdac:	697b      	ldr	r3, [r7, #20]
 810bdae:	f893 3044 	ldrb.w	r3, [r3, #68]	@ 0x44
 810bdb2:	b25b      	sxtb	r3, r3
 810bdb4:	f1b3 3fff 	cmp.w	r3, #4294967295
 810bdb8:	d103      	bne.n	810bdc2 <vQueueWaitForMessageRestricted+0x2a>
 810bdba:	697b      	ldr	r3, [r7, #20]
 810bdbc:	2200      	movs	r2, #0
 810bdbe:	f883 2044 	strb.w	r2, [r3, #68]	@ 0x44
 810bdc2:	697b      	ldr	r3, [r7, #20]
 810bdc4:	f893 3045 	ldrb.w	r3, [r3, #69]	@ 0x45
 810bdc8:	b25b      	sxtb	r3, r3
 810bdca:	f1b3 3fff 	cmp.w	r3, #4294967295
 810bdce:	d103      	bne.n	810bdd8 <vQueueWaitForMessageRestricted+0x40>
 810bdd0:	697b      	ldr	r3, [r7, #20]
 810bdd2:	2200      	movs	r2, #0
 810bdd4:	f883 2045 	strb.w	r2, [r3, #69]	@ 0x45
 810bdd8:	f7ff f930 	bl	810b03c <vPortExitCritical>
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
 810bddc:	697b      	ldr	r3, [r7, #20]
 810bdde:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
 810bde0:	2b00      	cmp	r3, #0
 810bde2:	d106      	bne.n	810bdf2 <vQueueWaitForMessageRestricted+0x5a>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
 810bde4:	697b      	ldr	r3, [r7, #20]
 810bde6:	3324      	adds	r3, #36	@ 0x24
 810bde8:	687a      	ldr	r2, [r7, #4]
 810bdea:	68b9      	ldr	r1, [r7, #8]
 810bdec:	4618      	mov	r0, r3
 810bdee:	f000 fc45 	bl	810c67c <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
 810bdf2:	6978      	ldr	r0, [r7, #20]
 810bdf4:	f7ff fefc 	bl	810bbf0 <prvUnlockQueue>
	}
 810bdf8:	bf00      	nop
 810bdfa:	3718      	adds	r7, #24
 810bdfc:	46bd      	mov	sp, r7
 810bdfe:	bd80      	pop	{r7, pc}

0810be00 <xTaskCreateStatic>:
									const uint32_t ulStackDepth,
									void * const pvParameters,
									UBaseType_t uxPriority,
									StackType_t * const puxStackBuffer,
									StaticTask_t * const pxTaskBuffer )
	{
 810be00:	b580      	push	{r7, lr}
 810be02:	b08e      	sub	sp, #56	@ 0x38
 810be04:	af04      	add	r7, sp, #16
 810be06:	60f8      	str	r0, [r7, #12]
 810be08:	60b9      	str	r1, [r7, #8]
 810be0a:	607a      	str	r2, [r7, #4]
 810be0c:	603b      	str	r3, [r7, #0]
	TCB_t *pxNewTCB;
	TaskHandle_t xReturn;

		configASSERT( puxStackBuffer != NULL );
 810be0e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810be10:	2b00      	cmp	r3, #0
 810be12:	d10b      	bne.n	810be2c <xTaskCreateStatic+0x2c>
	__asm volatile
 810be14:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810be18:	f383 8811 	msr	BASEPRI, r3
 810be1c:	f3bf 8f6f 	isb	sy
 810be20:	f3bf 8f4f 	dsb	sy
 810be24:	623b      	str	r3, [r7, #32]
}
 810be26:	bf00      	nop
 810be28:	bf00      	nop
 810be2a:	e7fd      	b.n	810be28 <xTaskCreateStatic+0x28>
		configASSERT( pxTaskBuffer != NULL );
 810be2c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810be2e:	2b00      	cmp	r3, #0
 810be30:	d10b      	bne.n	810be4a <xTaskCreateStatic+0x4a>
	__asm volatile
 810be32:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810be36:	f383 8811 	msr	BASEPRI, r3
 810be3a:	f3bf 8f6f 	isb	sy
 810be3e:	f3bf 8f4f 	dsb	sy
 810be42:	61fb      	str	r3, [r7, #28]
}
 810be44:	bf00      	nop
 810be46:	bf00      	nop
 810be48:	e7fd      	b.n	810be46 <xTaskCreateStatic+0x46>
		#if( configASSERT_DEFINED == 1 )
		{
			/* Sanity check that the size of the structure used to declare a
			variable of type StaticTask_t equals the size of the real task
			structure. */
			volatile size_t xSize = sizeof( StaticTask_t );
 810be4a:	235c      	movs	r3, #92	@ 0x5c
 810be4c:	613b      	str	r3, [r7, #16]
			configASSERT( xSize == sizeof( TCB_t ) );
 810be4e:	693b      	ldr	r3, [r7, #16]
 810be50:	2b5c      	cmp	r3, #92	@ 0x5c
 810be52:	d00b      	beq.n	810be6c <xTaskCreateStatic+0x6c>
	__asm volatile
 810be54:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810be58:	f383 8811 	msr	BASEPRI, r3
 810be5c:	f3bf 8f6f 	isb	sy
 810be60:	f3bf 8f4f 	dsb	sy
 810be64:	61bb      	str	r3, [r7, #24]
}
 810be66:	bf00      	nop
 810be68:	bf00      	nop
 810be6a:	e7fd      	b.n	810be68 <xTaskCreateStatic+0x68>
			( void ) xSize; /* Prevent lint warning when configASSERT() is not used. */
 810be6c:	693b      	ldr	r3, [r7, #16]
		}
		#endif /* configASSERT_DEFINED */


		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
 810be6e:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810be70:	2b00      	cmp	r3, #0
 810be72:	d01e      	beq.n	810beb2 <xTaskCreateStatic+0xb2>
 810be74:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810be76:	2b00      	cmp	r3, #0
 810be78:	d01b      	beq.n	810beb2 <xTaskCreateStatic+0xb2>
		{
			/* The memory used for the task's TCB and stack are passed into this
			function - use them. */
			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 !e9087 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
 810be7a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810be7c:	627b      	str	r3, [r7, #36]	@ 0x24
			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
 810be7e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810be80:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 810be82:	631a      	str	r2, [r3, #48]	@ 0x30

			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created statically in case the task is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
 810be84:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810be86:	2202      	movs	r2, #2
 810be88:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
 810be8c:	2300      	movs	r3, #0
 810be8e:	9303      	str	r3, [sp, #12]
 810be90:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810be92:	9302      	str	r3, [sp, #8]
 810be94:	f107 0314 	add.w	r3, r7, #20
 810be98:	9301      	str	r3, [sp, #4]
 810be9a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810be9c:	9300      	str	r3, [sp, #0]
 810be9e:	683b      	ldr	r3, [r7, #0]
 810bea0:	687a      	ldr	r2, [r7, #4]
 810bea2:	68b9      	ldr	r1, [r7, #8]
 810bea4:	68f8      	ldr	r0, [r7, #12]
 810bea6:	f000 f850 	bl	810bf4a <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 810beaa:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 810beac:	f000 f8de 	bl	810c06c <prvAddNewTaskToReadyList>
 810beb0:	e001      	b.n	810beb6 <xTaskCreateStatic+0xb6>
		}
		else
		{
			xReturn = NULL;
 810beb2:	2300      	movs	r3, #0
 810beb4:	617b      	str	r3, [r7, #20]
		}

		return xReturn;
 810beb6:	697b      	ldr	r3, [r7, #20]
	}
 810beb8:	4618      	mov	r0, r3
 810beba:	3728      	adds	r7, #40	@ 0x28
 810bebc:	46bd      	mov	sp, r7
 810bebe:	bd80      	pop	{r7, pc}

0810bec0 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
 810bec0:	b580      	push	{r7, lr}
 810bec2:	b08c      	sub	sp, #48	@ 0x30
 810bec4:	af04      	add	r7, sp, #16
 810bec6:	60f8      	str	r0, [r7, #12]
 810bec8:	60b9      	str	r1, [r7, #8]
 810beca:	603b      	str	r3, [r7, #0]
 810becc:	4613      	mov	r3, r2
 810bece:	80fb      	strh	r3, [r7, #6]
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
 810bed0:	88fb      	ldrh	r3, [r7, #6]
 810bed2:	009b      	lsls	r3, r3, #2
 810bed4:	4618      	mov	r0, r3
 810bed6:	f7fe fca9 	bl	810a82c <pvPortMalloc>
 810beda:	6178      	str	r0, [r7, #20]

			if( pxStack != NULL )
 810bedc:	697b      	ldr	r3, [r7, #20]
 810bede:	2b00      	cmp	r3, #0
 810bee0:	d00e      	beq.n	810bf00 <xTaskCreate+0x40>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
 810bee2:	205c      	movs	r0, #92	@ 0x5c
 810bee4:	f7fe fca2 	bl	810a82c <pvPortMalloc>
 810bee8:	61f8      	str	r0, [r7, #28]

				if( pxNewTCB != NULL )
 810beea:	69fb      	ldr	r3, [r7, #28]
 810beec:	2b00      	cmp	r3, #0
 810beee:	d003      	beq.n	810bef8 <xTaskCreate+0x38>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
 810bef0:	69fb      	ldr	r3, [r7, #28]
 810bef2:	697a      	ldr	r2, [r7, #20]
 810bef4:	631a      	str	r2, [r3, #48]	@ 0x30
 810bef6:	e005      	b.n	810bf04 <xTaskCreate+0x44>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
 810bef8:	6978      	ldr	r0, [r7, #20]
 810befa:	f7fe fd65 	bl	810a9c8 <vPortFree>
 810befe:	e001      	b.n	810bf04 <xTaskCreate+0x44>
				}
			}
			else
			{
				pxNewTCB = NULL;
 810bf00:	2300      	movs	r3, #0
 810bf02:	61fb      	str	r3, [r7, #28]
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
 810bf04:	69fb      	ldr	r3, [r7, #28]
 810bf06:	2b00      	cmp	r3, #0
 810bf08:	d017      	beq.n	810bf3a <xTaskCreate+0x7a>
		{
			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e9029 !e731 Macro has been consolidated for readability reasons. */
			{
				/* Tasks can be created statically or dynamically, so note this
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
 810bf0a:	69fb      	ldr	r3, [r7, #28]
 810bf0c:	2200      	movs	r2, #0
 810bf0e:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
 810bf12:	88fa      	ldrh	r2, [r7, #6]
 810bf14:	2300      	movs	r3, #0
 810bf16:	9303      	str	r3, [sp, #12]
 810bf18:	69fb      	ldr	r3, [r7, #28]
 810bf1a:	9302      	str	r3, [sp, #8]
 810bf1c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810bf1e:	9301      	str	r3, [sp, #4]
 810bf20:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810bf22:	9300      	str	r3, [sp, #0]
 810bf24:	683b      	ldr	r3, [r7, #0]
 810bf26:	68b9      	ldr	r1, [r7, #8]
 810bf28:	68f8      	ldr	r0, [r7, #12]
 810bf2a:	f000 f80e 	bl	810bf4a <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
 810bf2e:	69f8      	ldr	r0, [r7, #28]
 810bf30:	f000 f89c 	bl	810c06c <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
 810bf34:	2301      	movs	r3, #1
 810bf36:	61bb      	str	r3, [r7, #24]
 810bf38:	e002      	b.n	810bf40 <xTaskCreate+0x80>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 810bf3a:	f04f 33ff 	mov.w	r3, #4294967295
 810bf3e:	61bb      	str	r3, [r7, #24]
		}

		return xReturn;
 810bf40:	69bb      	ldr	r3, [r7, #24]
	}
 810bf42:	4618      	mov	r0, r3
 810bf44:	3720      	adds	r7, #32
 810bf46:	46bd      	mov	sp, r7
 810bf48:	bd80      	pop	{r7, pc}

0810bf4a <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
 810bf4a:	b580      	push	{r7, lr}
 810bf4c:	b088      	sub	sp, #32
 810bf4e:	af00      	add	r7, sp, #0
 810bf50:	60f8      	str	r0, [r7, #12]
 810bf52:	60b9      	str	r1, [r7, #8]
 810bf54:	607a      	str	r2, [r7, #4]
 810bf56:	603b      	str	r3, [r7, #0]

	/* Avoid dependency on memset() if it is not required. */
	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
	{
		/* Fill the stack with a known value to assist debugging. */
		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
 810bf58:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810bf5a:	6b18      	ldr	r0, [r3, #48]	@ 0x30
 810bf5c:	687b      	ldr	r3, [r7, #4]
 810bf5e:	009b      	lsls	r3, r3, #2
 810bf60:	461a      	mov	r2, r3
 810bf62:	21a5      	movs	r1, #165	@ 0xa5
 810bf64:	f003 fe99 	bl	810fc9a <memset>
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
 810bf68:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810bf6a:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
 810bf6c:	687b      	ldr	r3, [r7, #4]
 810bf6e:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 810bf72:	3b01      	subs	r3, #1
 810bf74:	009b      	lsls	r3, r3, #2
 810bf76:	4413      	add	r3, r2
 810bf78:	61bb      	str	r3, [r7, #24]
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 !e9033 !e9078 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type.  Checked by assert(). */
 810bf7a:	69bb      	ldr	r3, [r7, #24]
 810bf7c:	f023 0307 	bic.w	r3, r3, #7
 810bf80:	61bb      	str	r3, [r7, #24]

		/* Check the alignment of the calculated top of stack is correct. */
		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
 810bf82:	69bb      	ldr	r3, [r7, #24]
 810bf84:	f003 0307 	and.w	r3, r3, #7
 810bf88:	2b00      	cmp	r3, #0
 810bf8a:	d00b      	beq.n	810bfa4 <prvInitialiseNewTask+0x5a>
	__asm volatile
 810bf8c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810bf90:	f383 8811 	msr	BASEPRI, r3
 810bf94:	f3bf 8f6f 	isb	sy
 810bf98:	f3bf 8f4f 	dsb	sy
 810bf9c:	617b      	str	r3, [r7, #20]
}
 810bf9e:	bf00      	nop
 810bfa0:	bf00      	nop
 810bfa2:	e7fd      	b.n	810bfa0 <prvInitialiseNewTask+0x56>
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
 810bfa4:	68bb      	ldr	r3, [r7, #8]
 810bfa6:	2b00      	cmp	r3, #0
 810bfa8:	d01f      	beq.n	810bfea <prvInitialiseNewTask+0xa0>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 810bfaa:	2300      	movs	r3, #0
 810bfac:	61fb      	str	r3, [r7, #28]
 810bfae:	e012      	b.n	810bfd6 <prvInitialiseNewTask+0x8c>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 810bfb0:	68ba      	ldr	r2, [r7, #8]
 810bfb2:	69fb      	ldr	r3, [r7, #28]
 810bfb4:	4413      	add	r3, r2
 810bfb6:	7819      	ldrb	r1, [r3, #0]
 810bfb8:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 810bfba:	69fb      	ldr	r3, [r7, #28]
 810bfbc:	4413      	add	r3, r2
 810bfbe:	3334      	adds	r3, #52	@ 0x34
 810bfc0:	460a      	mov	r2, r1
 810bfc2:	701a      	strb	r2, [r3, #0]

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
 810bfc4:	68ba      	ldr	r2, [r7, #8]
 810bfc6:	69fb      	ldr	r3, [r7, #28]
 810bfc8:	4413      	add	r3, r2
 810bfca:	781b      	ldrb	r3, [r3, #0]
 810bfcc:	2b00      	cmp	r3, #0
 810bfce:	d006      	beq.n	810bfde <prvInitialiseNewTask+0x94>
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 810bfd0:	69fb      	ldr	r3, [r7, #28]
 810bfd2:	3301      	adds	r3, #1
 810bfd4:	61fb      	str	r3, [r7, #28]
 810bfd6:	69fb      	ldr	r3, [r7, #28]
 810bfd8:	2b0f      	cmp	r3, #15
 810bfda:	d9e9      	bls.n	810bfb0 <prvInitialiseNewTask+0x66>
 810bfdc:	e000      	b.n	810bfe0 <prvInitialiseNewTask+0x96>
			{
				break;
 810bfde:	bf00      	nop
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 810bfe0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810bfe2:	2200      	movs	r2, #0
 810bfe4:	f883 2043 	strb.w	r2, [r3, #67]	@ 0x43
 810bfe8:	e003      	b.n	810bff2 <prvInitialiseNewTask+0xa8>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
 810bfea:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810bfec:	2200      	movs	r2, #0
 810bfee:	f883 2034 	strb.w	r2, [r3, #52]	@ 0x34
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
 810bff2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810bff4:	2b37      	cmp	r3, #55	@ 0x37
 810bff6:	d901      	bls.n	810bffc <prvInitialiseNewTask+0xb2>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
 810bff8:	2337      	movs	r3, #55	@ 0x37
 810bffa:	62bb      	str	r3, [r7, #40]	@ 0x28
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
 810bffc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810bffe:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 810c000:	62da      	str	r2, [r3, #44]	@ 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
 810c002:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810c004:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 810c006:	64da      	str	r2, [r3, #76]	@ 0x4c
		pxNewTCB->uxMutexesHeld = 0;
 810c008:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810c00a:	2200      	movs	r2, #0
 810c00c:	651a      	str	r2, [r3, #80]	@ 0x50
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 810c00e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810c010:	3304      	adds	r3, #4
 810c012:	4618      	mov	r0, r3
 810c014:	f7fe fe18 	bl	810ac48 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 810c018:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810c01a:	3318      	adds	r3, #24
 810c01c:	4618      	mov	r0, r3
 810c01e:	f7fe fe13 	bl	810ac48 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 810c022:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810c024:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 810c026:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 810c028:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810c02a:	f1c3 0238 	rsb	r2, r3, #56	@ 0x38
 810c02e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810c030:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 810c032:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810c034:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 810c036:	625a      	str	r2, [r3, #36]	@ 0x24
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
 810c038:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810c03a:	2200      	movs	r2, #0
 810c03c:	655a      	str	r2, [r3, #84]	@ 0x54
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 810c03e:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810c040:	2200      	movs	r2, #0
 810c042:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 810c046:	683a      	ldr	r2, [r7, #0]
 810c048:	68f9      	ldr	r1, [r7, #12]
 810c04a:	69b8      	ldr	r0, [r7, #24]
 810c04c:	f7fe fe90 	bl	810ad70 <pxPortInitialiseStack>
 810c050:	4602      	mov	r2, r0
 810c052:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810c054:	601a      	str	r2, [r3, #0]
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
 810c056:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810c058:	2b00      	cmp	r3, #0
 810c05a:	d002      	beq.n	810c062 <prvInitialiseNewTask+0x118>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 810c05c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810c05e:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 810c060:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 810c062:	bf00      	nop
 810c064:	3720      	adds	r7, #32
 810c066:	46bd      	mov	sp, r7
 810c068:	bd80      	pop	{r7, pc}
	...

0810c06c <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
 810c06c:	b580      	push	{r7, lr}
 810c06e:	b082      	sub	sp, #8
 810c070:	af00      	add	r7, sp, #0
 810c072:	6078      	str	r0, [r7, #4]
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
 810c074:	f7fe ffb0 	bl	810afd8 <vPortEnterCritical>
	{
		uxCurrentNumberOfTasks++;
 810c078:	4b2d      	ldr	r3, [pc, #180]	@ (810c130 <prvAddNewTaskToReadyList+0xc4>)
 810c07a:	681b      	ldr	r3, [r3, #0]
 810c07c:	3301      	adds	r3, #1
 810c07e:	4a2c      	ldr	r2, [pc, #176]	@ (810c130 <prvAddNewTaskToReadyList+0xc4>)
 810c080:	6013      	str	r3, [r2, #0]
		if( pxCurrentTCB == NULL )
 810c082:	4b2c      	ldr	r3, [pc, #176]	@ (810c134 <prvAddNewTaskToReadyList+0xc8>)
 810c084:	681b      	ldr	r3, [r3, #0]
 810c086:	2b00      	cmp	r3, #0
 810c088:	d109      	bne.n	810c09e <prvAddNewTaskToReadyList+0x32>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
 810c08a:	4a2a      	ldr	r2, [pc, #168]	@ (810c134 <prvAddNewTaskToReadyList+0xc8>)
 810c08c:	687b      	ldr	r3, [r7, #4]
 810c08e:	6013      	str	r3, [r2, #0]

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 810c090:	4b27      	ldr	r3, [pc, #156]	@ (810c130 <prvAddNewTaskToReadyList+0xc4>)
 810c092:	681b      	ldr	r3, [r3, #0]
 810c094:	2b01      	cmp	r3, #1
 810c096:	d110      	bne.n	810c0ba <prvAddNewTaskToReadyList+0x4e>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
 810c098:	f000 fc1e 	bl	810c8d8 <prvInitialiseTaskLists>
 810c09c:	e00d      	b.n	810c0ba <prvAddNewTaskToReadyList+0x4e>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
 810c09e:	4b26      	ldr	r3, [pc, #152]	@ (810c138 <prvAddNewTaskToReadyList+0xcc>)
 810c0a0:	681b      	ldr	r3, [r3, #0]
 810c0a2:	2b00      	cmp	r3, #0
 810c0a4:	d109      	bne.n	810c0ba <prvAddNewTaskToReadyList+0x4e>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 810c0a6:	4b23      	ldr	r3, [pc, #140]	@ (810c134 <prvAddNewTaskToReadyList+0xc8>)
 810c0a8:	681b      	ldr	r3, [r3, #0]
 810c0aa:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c0ac:	687b      	ldr	r3, [r7, #4]
 810c0ae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810c0b0:	429a      	cmp	r2, r3
 810c0b2:	d802      	bhi.n	810c0ba <prvAddNewTaskToReadyList+0x4e>
				{
					pxCurrentTCB = pxNewTCB;
 810c0b4:	4a1f      	ldr	r2, [pc, #124]	@ (810c134 <prvAddNewTaskToReadyList+0xc8>)
 810c0b6:	687b      	ldr	r3, [r7, #4]
 810c0b8:	6013      	str	r3, [r2, #0]
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
 810c0ba:	4b20      	ldr	r3, [pc, #128]	@ (810c13c <prvAddNewTaskToReadyList+0xd0>)
 810c0bc:	681b      	ldr	r3, [r3, #0]
 810c0be:	3301      	adds	r3, #1
 810c0c0:	4a1e      	ldr	r2, [pc, #120]	@ (810c13c <prvAddNewTaskToReadyList+0xd0>)
 810c0c2:	6013      	str	r3, [r2, #0]

		#if ( configUSE_TRACE_FACILITY == 1 )
		{
			/* Add a counter into the TCB for tracing only. */
			pxNewTCB->uxTCBNumber = uxTaskNumber;
 810c0c4:	4b1d      	ldr	r3, [pc, #116]	@ (810c13c <prvAddNewTaskToReadyList+0xd0>)
 810c0c6:	681a      	ldr	r2, [r3, #0]
 810c0c8:	687b      	ldr	r3, [r7, #4]
 810c0ca:	645a      	str	r2, [r3, #68]	@ 0x44
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
 810c0cc:	687b      	ldr	r3, [r7, #4]
 810c0ce:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c0d0:	4b1b      	ldr	r3, [pc, #108]	@ (810c140 <prvAddNewTaskToReadyList+0xd4>)
 810c0d2:	681b      	ldr	r3, [r3, #0]
 810c0d4:	429a      	cmp	r2, r3
 810c0d6:	d903      	bls.n	810c0e0 <prvAddNewTaskToReadyList+0x74>
 810c0d8:	687b      	ldr	r3, [r7, #4]
 810c0da:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810c0dc:	4a18      	ldr	r2, [pc, #96]	@ (810c140 <prvAddNewTaskToReadyList+0xd4>)
 810c0de:	6013      	str	r3, [r2, #0]
 810c0e0:	687b      	ldr	r3, [r7, #4]
 810c0e2:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c0e4:	4613      	mov	r3, r2
 810c0e6:	009b      	lsls	r3, r3, #2
 810c0e8:	4413      	add	r3, r2
 810c0ea:	009b      	lsls	r3, r3, #2
 810c0ec:	4a15      	ldr	r2, [pc, #84]	@ (810c144 <prvAddNewTaskToReadyList+0xd8>)
 810c0ee:	441a      	add	r2, r3
 810c0f0:	687b      	ldr	r3, [r7, #4]
 810c0f2:	3304      	adds	r3, #4
 810c0f4:	4619      	mov	r1, r3
 810c0f6:	4610      	mov	r0, r2
 810c0f8:	f7fe fdb3 	bl	810ac62 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
 810c0fc:	f7fe ff9e 	bl	810b03c <vPortExitCritical>

	if( xSchedulerRunning != pdFALSE )
 810c100:	4b0d      	ldr	r3, [pc, #52]	@ (810c138 <prvAddNewTaskToReadyList+0xcc>)
 810c102:	681b      	ldr	r3, [r3, #0]
 810c104:	2b00      	cmp	r3, #0
 810c106:	d00e      	beq.n	810c126 <prvAddNewTaskToReadyList+0xba>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 810c108:	4b0a      	ldr	r3, [pc, #40]	@ (810c134 <prvAddNewTaskToReadyList+0xc8>)
 810c10a:	681b      	ldr	r3, [r3, #0]
 810c10c:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c10e:	687b      	ldr	r3, [r7, #4]
 810c110:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810c112:	429a      	cmp	r2, r3
 810c114:	d207      	bcs.n	810c126 <prvAddNewTaskToReadyList+0xba>
		{
			taskYIELD_IF_USING_PREEMPTION();
 810c116:	4b0c      	ldr	r3, [pc, #48]	@ (810c148 <prvAddNewTaskToReadyList+0xdc>)
 810c118:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 810c11c:	601a      	str	r2, [r3, #0]
 810c11e:	f3bf 8f4f 	dsb	sy
 810c122:	f3bf 8f6f 	isb	sy
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
 810c126:	bf00      	nop
 810c128:	3708      	adds	r7, #8
 810c12a:	46bd      	mov	sp, r7
 810c12c:	bd80      	pop	{r7, pc}
 810c12e:	bf00      	nop
 810c130:	100053d4 	.word	0x100053d4
 810c134:	10004f00 	.word	0x10004f00
 810c138:	100053e0 	.word	0x100053e0
 810c13c:	100053f0 	.word	0x100053f0
 810c140:	100053dc 	.word	0x100053dc
 810c144:	10004f04 	.word	0x10004f04
 810c148:	e000ed04 	.word	0xe000ed04

0810c14c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 810c14c:	b580      	push	{r7, lr}
 810c14e:	b084      	sub	sp, #16
 810c150:	af00      	add	r7, sp, #0
 810c152:	6078      	str	r0, [r7, #4]
	BaseType_t xAlreadyYielded = pdFALSE;
 810c154:	2300      	movs	r3, #0
 810c156:	60fb      	str	r3, [r7, #12]

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 810c158:	687b      	ldr	r3, [r7, #4]
 810c15a:	2b00      	cmp	r3, #0
 810c15c:	d018      	beq.n	810c190 <vTaskDelay+0x44>
		{
			configASSERT( uxSchedulerSuspended == 0 );
 810c15e:	4b14      	ldr	r3, [pc, #80]	@ (810c1b0 <vTaskDelay+0x64>)
 810c160:	681b      	ldr	r3, [r3, #0]
 810c162:	2b00      	cmp	r3, #0
 810c164:	d00b      	beq.n	810c17e <vTaskDelay+0x32>
	__asm volatile
 810c166:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810c16a:	f383 8811 	msr	BASEPRI, r3
 810c16e:	f3bf 8f6f 	isb	sy
 810c172:	f3bf 8f4f 	dsb	sy
 810c176:	60bb      	str	r3, [r7, #8]
}
 810c178:	bf00      	nop
 810c17a:	bf00      	nop
 810c17c:	e7fd      	b.n	810c17a <vTaskDelay+0x2e>
			vTaskSuspendAll();
 810c17e:	f000 f883 	bl	810c288 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 810c182:	2100      	movs	r1, #0
 810c184:	6878      	ldr	r0, [r7, #4]
 810c186:	f000 fcf3 	bl	810cb70 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 810c18a:	f000 f88b 	bl	810c2a4 <xTaskResumeAll>
 810c18e:	60f8      	str	r0, [r7, #12]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 810c190:	68fb      	ldr	r3, [r7, #12]
 810c192:	2b00      	cmp	r3, #0
 810c194:	d107      	bne.n	810c1a6 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
 810c196:	4b07      	ldr	r3, [pc, #28]	@ (810c1b4 <vTaskDelay+0x68>)
 810c198:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 810c19c:	601a      	str	r2, [r3, #0]
 810c19e:	f3bf 8f4f 	dsb	sy
 810c1a2:	f3bf 8f6f 	isb	sy
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 810c1a6:	bf00      	nop
 810c1a8:	3710      	adds	r7, #16
 810c1aa:	46bd      	mov	sp, r7
 810c1ac:	bd80      	pop	{r7, pc}
 810c1ae:	bf00      	nop
 810c1b0:	100053fc 	.word	0x100053fc
 810c1b4:	e000ed04 	.word	0xe000ed04

0810c1b8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 810c1b8:	b580      	push	{r7, lr}
 810c1ba:	b08a      	sub	sp, #40	@ 0x28
 810c1bc:	af04      	add	r7, sp, #16
BaseType_t xReturn;

	/* Add the idle task at the lowest priority. */
	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
	{
		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
 810c1be:	2300      	movs	r3, #0
 810c1c0:	60bb      	str	r3, [r7, #8]
		StackType_t *pxIdleTaskStackBuffer = NULL;
 810c1c2:	2300      	movs	r3, #0
 810c1c4:	607b      	str	r3, [r7, #4]
		uint32_t ulIdleTaskStackSize;

		/* The Idle task is created using user provided RAM - obtain the
		address of the RAM then create the idle task. */
		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
 810c1c6:	463a      	mov	r2, r7
 810c1c8:	1d39      	adds	r1, r7, #4
 810c1ca:	f107 0308 	add.w	r3, r7, #8
 810c1ce:	4618      	mov	r0, r3
 810c1d0:	f7fe faf8 	bl	810a7c4 <vApplicationGetIdleTaskMemory>
		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
 810c1d4:	6839      	ldr	r1, [r7, #0]
 810c1d6:	687b      	ldr	r3, [r7, #4]
 810c1d8:	68ba      	ldr	r2, [r7, #8]
 810c1da:	9202      	str	r2, [sp, #8]
 810c1dc:	9301      	str	r3, [sp, #4]
 810c1de:	2300      	movs	r3, #0
 810c1e0:	9300      	str	r3, [sp, #0]
 810c1e2:	2300      	movs	r3, #0
 810c1e4:	460a      	mov	r2, r1
 810c1e6:	4922      	ldr	r1, [pc, #136]	@ (810c270 <vTaskStartScheduler+0xb8>)
 810c1e8:	4822      	ldr	r0, [pc, #136]	@ (810c274 <vTaskStartScheduler+0xbc>)
 810c1ea:	f7ff fe09 	bl	810be00 <xTaskCreateStatic>
 810c1ee:	4603      	mov	r3, r0
 810c1f0:	4a21      	ldr	r2, [pc, #132]	@ (810c278 <vTaskStartScheduler+0xc0>)
 810c1f2:	6013      	str	r3, [r2, #0]
												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
												portPRIVILEGE_BIT, /* In effect ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), but tskIDLE_PRIORITY is zero. */
												pxIdleTaskStackBuffer,
												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */

		if( xIdleTaskHandle != NULL )
 810c1f4:	4b20      	ldr	r3, [pc, #128]	@ (810c278 <vTaskStartScheduler+0xc0>)
 810c1f6:	681b      	ldr	r3, [r3, #0]
 810c1f8:	2b00      	cmp	r3, #0
 810c1fa:	d002      	beq.n	810c202 <vTaskStartScheduler+0x4a>
		{
			xReturn = pdPASS;
 810c1fc:	2301      	movs	r3, #1
 810c1fe:	617b      	str	r3, [r7, #20]
 810c200:	e001      	b.n	810c206 <vTaskStartScheduler+0x4e>
		}
		else
		{
			xReturn = pdFAIL;
 810c202:	2300      	movs	r3, #0
 810c204:	617b      	str	r3, [r7, #20]
	}
	#endif /* configSUPPORT_STATIC_ALLOCATION */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
 810c206:	697b      	ldr	r3, [r7, #20]
 810c208:	2b01      	cmp	r3, #1
 810c20a:	d102      	bne.n	810c212 <vTaskStartScheduler+0x5a>
		{
			xReturn = xTimerCreateTimerTask();
 810c20c:	f000 fd04 	bl	810cc18 <xTimerCreateTimerTask>
 810c210:	6178      	str	r0, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 810c212:	697b      	ldr	r3, [r7, #20]
 810c214:	2b01      	cmp	r3, #1
 810c216:	d116      	bne.n	810c246 <vTaskStartScheduler+0x8e>
	__asm volatile
 810c218:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810c21c:	f383 8811 	msr	BASEPRI, r3
 810c220:	f3bf 8f6f 	isb	sy
 810c224:	f3bf 8f4f 	dsb	sy
 810c228:	613b      	str	r3, [r7, #16]
}
 810c22a:	bf00      	nop
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
 810c22c:	4b13      	ldr	r3, [pc, #76]	@ (810c27c <vTaskStartScheduler+0xc4>)
 810c22e:	f04f 32ff 	mov.w	r2, #4294967295
 810c232:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 810c234:	4b12      	ldr	r3, [pc, #72]	@ (810c280 <vTaskStartScheduler+0xc8>)
 810c236:	2201      	movs	r2, #1
 810c238:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
 810c23a:	4b12      	ldr	r3, [pc, #72]	@ (810c284 <vTaskStartScheduler+0xcc>)
 810c23c:	2200      	movs	r2, #0
 810c23e:	601a      	str	r2, [r3, #0]

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 810c240:	f7fe fe26 	bl	810ae90 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
 810c244:	e00f      	b.n	810c266 <vTaskStartScheduler+0xae>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 810c246:	697b      	ldr	r3, [r7, #20]
 810c248:	f1b3 3fff 	cmp.w	r3, #4294967295
 810c24c:	d10b      	bne.n	810c266 <vTaskStartScheduler+0xae>
	__asm volatile
 810c24e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810c252:	f383 8811 	msr	BASEPRI, r3
 810c256:	f3bf 8f6f 	isb	sy
 810c25a:	f3bf 8f4f 	dsb	sy
 810c25e:	60fb      	str	r3, [r7, #12]
}
 810c260:	bf00      	nop
 810c262:	bf00      	nop
 810c264:	e7fd      	b.n	810c262 <vTaskStartScheduler+0xaa>
}
 810c266:	bf00      	nop
 810c268:	3718      	adds	r7, #24
 810c26a:	46bd      	mov	sp, r7
 810c26c:	bd80      	pop	{r7, pc}
 810c26e:	bf00      	nop
 810c270:	081108b4 	.word	0x081108b4
 810c274:	0810c8a9 	.word	0x0810c8a9
 810c278:	100053f8 	.word	0x100053f8
 810c27c:	100053f4 	.word	0x100053f4
 810c280:	100053e0 	.word	0x100053e0
 810c284:	100053d8 	.word	0x100053d8

0810c288 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
 810c288:	b480      	push	{r7}
 810c28a:	af00      	add	r7, sp, #0
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
 810c28c:	4b04      	ldr	r3, [pc, #16]	@ (810c2a0 <vTaskSuspendAll+0x18>)
 810c28e:	681b      	ldr	r3, [r3, #0]
 810c290:	3301      	adds	r3, #1
 810c292:	4a03      	ldr	r2, [pc, #12]	@ (810c2a0 <vTaskSuspendAll+0x18>)
 810c294:	6013      	str	r3, [r2, #0]

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
 810c296:	bf00      	nop
 810c298:	46bd      	mov	sp, r7
 810c29a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c29e:	4770      	bx	lr
 810c2a0:	100053fc 	.word	0x100053fc

0810c2a4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 810c2a4:	b580      	push	{r7, lr}
 810c2a6:	b084      	sub	sp, #16
 810c2a8:	af00      	add	r7, sp, #0
TCB_t *pxTCB = NULL;
 810c2aa:	2300      	movs	r3, #0
 810c2ac:	60fb      	str	r3, [r7, #12]
BaseType_t xAlreadyYielded = pdFALSE;
 810c2ae:	2300      	movs	r3, #0
 810c2b0:	60bb      	str	r3, [r7, #8]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
 810c2b2:	4b42      	ldr	r3, [pc, #264]	@ (810c3bc <xTaskResumeAll+0x118>)
 810c2b4:	681b      	ldr	r3, [r3, #0]
 810c2b6:	2b00      	cmp	r3, #0
 810c2b8:	d10b      	bne.n	810c2d2 <xTaskResumeAll+0x2e>
	__asm volatile
 810c2ba:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810c2be:	f383 8811 	msr	BASEPRI, r3
 810c2c2:	f3bf 8f6f 	isb	sy
 810c2c6:	f3bf 8f4f 	dsb	sy
 810c2ca:	603b      	str	r3, [r7, #0]
}
 810c2cc:	bf00      	nop
 810c2ce:	bf00      	nop
 810c2d0:	e7fd      	b.n	810c2ce <xTaskResumeAll+0x2a>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 810c2d2:	f7fe fe81 	bl	810afd8 <vPortEnterCritical>
	{
		--uxSchedulerSuspended;
 810c2d6:	4b39      	ldr	r3, [pc, #228]	@ (810c3bc <xTaskResumeAll+0x118>)
 810c2d8:	681b      	ldr	r3, [r3, #0]
 810c2da:	3b01      	subs	r3, #1
 810c2dc:	4a37      	ldr	r2, [pc, #220]	@ (810c3bc <xTaskResumeAll+0x118>)
 810c2de:	6013      	str	r3, [r2, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 810c2e0:	4b36      	ldr	r3, [pc, #216]	@ (810c3bc <xTaskResumeAll+0x118>)
 810c2e2:	681b      	ldr	r3, [r3, #0]
 810c2e4:	2b00      	cmp	r3, #0
 810c2e6:	d162      	bne.n	810c3ae <xTaskResumeAll+0x10a>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 810c2e8:	4b35      	ldr	r3, [pc, #212]	@ (810c3c0 <xTaskResumeAll+0x11c>)
 810c2ea:	681b      	ldr	r3, [r3, #0]
 810c2ec:	2b00      	cmp	r3, #0
 810c2ee:	d05e      	beq.n	810c3ae <xTaskResumeAll+0x10a>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 810c2f0:	e02f      	b.n	810c352 <xTaskResumeAll+0xae>
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 810c2f2:	4b34      	ldr	r3, [pc, #208]	@ (810c3c4 <xTaskResumeAll+0x120>)
 810c2f4:	68db      	ldr	r3, [r3, #12]
 810c2f6:	68db      	ldr	r3, [r3, #12]
 810c2f8:	60fb      	str	r3, [r7, #12]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 810c2fa:	68fb      	ldr	r3, [r7, #12]
 810c2fc:	3318      	adds	r3, #24
 810c2fe:	4618      	mov	r0, r3
 810c300:	f7fe fd0c 	bl	810ad1c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 810c304:	68fb      	ldr	r3, [r7, #12]
 810c306:	3304      	adds	r3, #4
 810c308:	4618      	mov	r0, r3
 810c30a:	f7fe fd07 	bl	810ad1c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 810c30e:	68fb      	ldr	r3, [r7, #12]
 810c310:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c312:	4b2d      	ldr	r3, [pc, #180]	@ (810c3c8 <xTaskResumeAll+0x124>)
 810c314:	681b      	ldr	r3, [r3, #0]
 810c316:	429a      	cmp	r2, r3
 810c318:	d903      	bls.n	810c322 <xTaskResumeAll+0x7e>
 810c31a:	68fb      	ldr	r3, [r7, #12]
 810c31c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810c31e:	4a2a      	ldr	r2, [pc, #168]	@ (810c3c8 <xTaskResumeAll+0x124>)
 810c320:	6013      	str	r3, [r2, #0]
 810c322:	68fb      	ldr	r3, [r7, #12]
 810c324:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c326:	4613      	mov	r3, r2
 810c328:	009b      	lsls	r3, r3, #2
 810c32a:	4413      	add	r3, r2
 810c32c:	009b      	lsls	r3, r3, #2
 810c32e:	4a27      	ldr	r2, [pc, #156]	@ (810c3cc <xTaskResumeAll+0x128>)
 810c330:	441a      	add	r2, r3
 810c332:	68fb      	ldr	r3, [r7, #12]
 810c334:	3304      	adds	r3, #4
 810c336:	4619      	mov	r1, r3
 810c338:	4610      	mov	r0, r2
 810c33a:	f7fe fc92 	bl	810ac62 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 810c33e:	68fb      	ldr	r3, [r7, #12]
 810c340:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c342:	4b23      	ldr	r3, [pc, #140]	@ (810c3d0 <xTaskResumeAll+0x12c>)
 810c344:	681b      	ldr	r3, [r3, #0]
 810c346:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810c348:	429a      	cmp	r2, r3
 810c34a:	d302      	bcc.n	810c352 <xTaskResumeAll+0xae>
					{
						xYieldPending = pdTRUE;
 810c34c:	4b21      	ldr	r3, [pc, #132]	@ (810c3d4 <xTaskResumeAll+0x130>)
 810c34e:	2201      	movs	r2, #1
 810c350:	601a      	str	r2, [r3, #0]
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 810c352:	4b1c      	ldr	r3, [pc, #112]	@ (810c3c4 <xTaskResumeAll+0x120>)
 810c354:	681b      	ldr	r3, [r3, #0]
 810c356:	2b00      	cmp	r3, #0
 810c358:	d1cb      	bne.n	810c2f2 <xTaskResumeAll+0x4e>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 810c35a:	68fb      	ldr	r3, [r7, #12]
 810c35c:	2b00      	cmp	r3, #0
 810c35e:	d001      	beq.n	810c364 <xTaskResumeAll+0xc0>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 810c360:	f000 fb58 	bl	810ca14 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
 810c364:	4b1c      	ldr	r3, [pc, #112]	@ (810c3d8 <xTaskResumeAll+0x134>)
 810c366:	681b      	ldr	r3, [r3, #0]
 810c368:	607b      	str	r3, [r7, #4]

					if( xPendedCounts > ( TickType_t ) 0U )
 810c36a:	687b      	ldr	r3, [r7, #4]
 810c36c:	2b00      	cmp	r3, #0
 810c36e:	d010      	beq.n	810c392 <xTaskResumeAll+0xee>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 810c370:	f000 f846 	bl	810c400 <xTaskIncrementTick>
 810c374:	4603      	mov	r3, r0
 810c376:	2b00      	cmp	r3, #0
 810c378:	d002      	beq.n	810c380 <xTaskResumeAll+0xdc>
							{
								xYieldPending = pdTRUE;
 810c37a:	4b16      	ldr	r3, [pc, #88]	@ (810c3d4 <xTaskResumeAll+0x130>)
 810c37c:	2201      	movs	r2, #1
 810c37e:	601a      	str	r2, [r3, #0]
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
 810c380:	687b      	ldr	r3, [r7, #4]
 810c382:	3b01      	subs	r3, #1
 810c384:	607b      	str	r3, [r7, #4]
						} while( xPendedCounts > ( TickType_t ) 0U );
 810c386:	687b      	ldr	r3, [r7, #4]
 810c388:	2b00      	cmp	r3, #0
 810c38a:	d1f1      	bne.n	810c370 <xTaskResumeAll+0xcc>

						xPendedTicks = 0;
 810c38c:	4b12      	ldr	r3, [pc, #72]	@ (810c3d8 <xTaskResumeAll+0x134>)
 810c38e:	2200      	movs	r2, #0
 810c390:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 810c392:	4b10      	ldr	r3, [pc, #64]	@ (810c3d4 <xTaskResumeAll+0x130>)
 810c394:	681b      	ldr	r3, [r3, #0]
 810c396:	2b00      	cmp	r3, #0
 810c398:	d009      	beq.n	810c3ae <xTaskResumeAll+0x10a>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 810c39a:	2301      	movs	r3, #1
 810c39c:	60bb      	str	r3, [r7, #8]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 810c39e:	4b0f      	ldr	r3, [pc, #60]	@ (810c3dc <xTaskResumeAll+0x138>)
 810c3a0:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 810c3a4:	601a      	str	r2, [r3, #0]
 810c3a6:	f3bf 8f4f 	dsb	sy
 810c3aa:	f3bf 8f6f 	isb	sy
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 810c3ae:	f7fe fe45 	bl	810b03c <vPortExitCritical>

	return xAlreadyYielded;
 810c3b2:	68bb      	ldr	r3, [r7, #8]
}
 810c3b4:	4618      	mov	r0, r3
 810c3b6:	3710      	adds	r7, #16
 810c3b8:	46bd      	mov	sp, r7
 810c3ba:	bd80      	pop	{r7, pc}
 810c3bc:	100053fc 	.word	0x100053fc
 810c3c0:	100053d4 	.word	0x100053d4
 810c3c4:	10005394 	.word	0x10005394
 810c3c8:	100053dc 	.word	0x100053dc
 810c3cc:	10004f04 	.word	0x10004f04
 810c3d0:	10004f00 	.word	0x10004f00
 810c3d4:	100053e8 	.word	0x100053e8
 810c3d8:	100053e4 	.word	0x100053e4
 810c3dc:	e000ed04 	.word	0xe000ed04

0810c3e0 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
 810c3e0:	b480      	push	{r7}
 810c3e2:	b083      	sub	sp, #12
 810c3e4:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
	{
		xTicks = xTickCount;
 810c3e6:	4b05      	ldr	r3, [pc, #20]	@ (810c3fc <xTaskGetTickCount+0x1c>)
 810c3e8:	681b      	ldr	r3, [r3, #0]
 810c3ea:	607b      	str	r3, [r7, #4]
	}
	portTICK_TYPE_EXIT_CRITICAL();

	return xTicks;
 810c3ec:	687b      	ldr	r3, [r7, #4]
}
 810c3ee:	4618      	mov	r0, r3
 810c3f0:	370c      	adds	r7, #12
 810c3f2:	46bd      	mov	sp, r7
 810c3f4:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c3f8:	4770      	bx	lr
 810c3fa:	bf00      	nop
 810c3fc:	100053d8 	.word	0x100053d8

0810c400 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 810c400:	b580      	push	{r7, lr}
 810c402:	b086      	sub	sp, #24
 810c404:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 810c406:	2300      	movs	r3, #0
 810c408:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 810c40a:	4b4f      	ldr	r3, [pc, #316]	@ (810c548 <xTaskIncrementTick+0x148>)
 810c40c:	681b      	ldr	r3, [r3, #0]
 810c40e:	2b00      	cmp	r3, #0
 810c410:	f040 8090 	bne.w	810c534 <xTaskIncrementTick+0x134>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 810c414:	4b4d      	ldr	r3, [pc, #308]	@ (810c54c <xTaskIncrementTick+0x14c>)
 810c416:	681b      	ldr	r3, [r3, #0]
 810c418:	3301      	adds	r3, #1
 810c41a:	613b      	str	r3, [r7, #16]

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 810c41c:	4a4b      	ldr	r2, [pc, #300]	@ (810c54c <xTaskIncrementTick+0x14c>)
 810c41e:	693b      	ldr	r3, [r7, #16]
 810c420:	6013      	str	r3, [r2, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 810c422:	693b      	ldr	r3, [r7, #16]
 810c424:	2b00      	cmp	r3, #0
 810c426:	d121      	bne.n	810c46c <xTaskIncrementTick+0x6c>
		{
			taskSWITCH_DELAYED_LISTS();
 810c428:	4b49      	ldr	r3, [pc, #292]	@ (810c550 <xTaskIncrementTick+0x150>)
 810c42a:	681b      	ldr	r3, [r3, #0]
 810c42c:	681b      	ldr	r3, [r3, #0]
 810c42e:	2b00      	cmp	r3, #0
 810c430:	d00b      	beq.n	810c44a <xTaskIncrementTick+0x4a>
	__asm volatile
 810c432:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810c436:	f383 8811 	msr	BASEPRI, r3
 810c43a:	f3bf 8f6f 	isb	sy
 810c43e:	f3bf 8f4f 	dsb	sy
 810c442:	603b      	str	r3, [r7, #0]
}
 810c444:	bf00      	nop
 810c446:	bf00      	nop
 810c448:	e7fd      	b.n	810c446 <xTaskIncrementTick+0x46>
 810c44a:	4b41      	ldr	r3, [pc, #260]	@ (810c550 <xTaskIncrementTick+0x150>)
 810c44c:	681b      	ldr	r3, [r3, #0]
 810c44e:	60fb      	str	r3, [r7, #12]
 810c450:	4b40      	ldr	r3, [pc, #256]	@ (810c554 <xTaskIncrementTick+0x154>)
 810c452:	681b      	ldr	r3, [r3, #0]
 810c454:	4a3e      	ldr	r2, [pc, #248]	@ (810c550 <xTaskIncrementTick+0x150>)
 810c456:	6013      	str	r3, [r2, #0]
 810c458:	4a3e      	ldr	r2, [pc, #248]	@ (810c554 <xTaskIncrementTick+0x154>)
 810c45a:	68fb      	ldr	r3, [r7, #12]
 810c45c:	6013      	str	r3, [r2, #0]
 810c45e:	4b3e      	ldr	r3, [pc, #248]	@ (810c558 <xTaskIncrementTick+0x158>)
 810c460:	681b      	ldr	r3, [r3, #0]
 810c462:	3301      	adds	r3, #1
 810c464:	4a3c      	ldr	r2, [pc, #240]	@ (810c558 <xTaskIncrementTick+0x158>)
 810c466:	6013      	str	r3, [r2, #0]
 810c468:	f000 fad4 	bl	810ca14 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 810c46c:	4b3b      	ldr	r3, [pc, #236]	@ (810c55c <xTaskIncrementTick+0x15c>)
 810c46e:	681b      	ldr	r3, [r3, #0]
 810c470:	693a      	ldr	r2, [r7, #16]
 810c472:	429a      	cmp	r2, r3
 810c474:	d349      	bcc.n	810c50a <xTaskIncrementTick+0x10a>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 810c476:	4b36      	ldr	r3, [pc, #216]	@ (810c550 <xTaskIncrementTick+0x150>)
 810c478:	681b      	ldr	r3, [r3, #0]
 810c47a:	681b      	ldr	r3, [r3, #0]
 810c47c:	2b00      	cmp	r3, #0
 810c47e:	d104      	bne.n	810c48a <xTaskIncrementTick+0x8a>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 810c480:	4b36      	ldr	r3, [pc, #216]	@ (810c55c <xTaskIncrementTick+0x15c>)
 810c482:	f04f 32ff 	mov.w	r2, #4294967295
 810c486:	601a      	str	r2, [r3, #0]
					break;
 810c488:	e03f      	b.n	810c50a <xTaskIncrementTick+0x10a>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 810c48a:	4b31      	ldr	r3, [pc, #196]	@ (810c550 <xTaskIncrementTick+0x150>)
 810c48c:	681b      	ldr	r3, [r3, #0]
 810c48e:	68db      	ldr	r3, [r3, #12]
 810c490:	68db      	ldr	r3, [r3, #12]
 810c492:	60bb      	str	r3, [r7, #8]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 810c494:	68bb      	ldr	r3, [r7, #8]
 810c496:	685b      	ldr	r3, [r3, #4]
 810c498:	607b      	str	r3, [r7, #4]

					if( xConstTickCount < xItemValue )
 810c49a:	693a      	ldr	r2, [r7, #16]
 810c49c:	687b      	ldr	r3, [r7, #4]
 810c49e:	429a      	cmp	r2, r3
 810c4a0:	d203      	bcs.n	810c4aa <xTaskIncrementTick+0xaa>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 810c4a2:	4a2e      	ldr	r2, [pc, #184]	@ (810c55c <xTaskIncrementTick+0x15c>)
 810c4a4:	687b      	ldr	r3, [r7, #4]
 810c4a6:	6013      	str	r3, [r2, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 810c4a8:	e02f      	b.n	810c50a <xTaskIncrementTick+0x10a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 810c4aa:	68bb      	ldr	r3, [r7, #8]
 810c4ac:	3304      	adds	r3, #4
 810c4ae:	4618      	mov	r0, r3
 810c4b0:	f7fe fc34 	bl	810ad1c <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 810c4b4:	68bb      	ldr	r3, [r7, #8]
 810c4b6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810c4b8:	2b00      	cmp	r3, #0
 810c4ba:	d004      	beq.n	810c4c6 <xTaskIncrementTick+0xc6>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 810c4bc:	68bb      	ldr	r3, [r7, #8]
 810c4be:	3318      	adds	r3, #24
 810c4c0:	4618      	mov	r0, r3
 810c4c2:	f7fe fc2b 	bl	810ad1c <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 810c4c6:	68bb      	ldr	r3, [r7, #8]
 810c4c8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c4ca:	4b25      	ldr	r3, [pc, #148]	@ (810c560 <xTaskIncrementTick+0x160>)
 810c4cc:	681b      	ldr	r3, [r3, #0]
 810c4ce:	429a      	cmp	r2, r3
 810c4d0:	d903      	bls.n	810c4da <xTaskIncrementTick+0xda>
 810c4d2:	68bb      	ldr	r3, [r7, #8]
 810c4d4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810c4d6:	4a22      	ldr	r2, [pc, #136]	@ (810c560 <xTaskIncrementTick+0x160>)
 810c4d8:	6013      	str	r3, [r2, #0]
 810c4da:	68bb      	ldr	r3, [r7, #8]
 810c4dc:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c4de:	4613      	mov	r3, r2
 810c4e0:	009b      	lsls	r3, r3, #2
 810c4e2:	4413      	add	r3, r2
 810c4e4:	009b      	lsls	r3, r3, #2
 810c4e6:	4a1f      	ldr	r2, [pc, #124]	@ (810c564 <xTaskIncrementTick+0x164>)
 810c4e8:	441a      	add	r2, r3
 810c4ea:	68bb      	ldr	r3, [r7, #8]
 810c4ec:	3304      	adds	r3, #4
 810c4ee:	4619      	mov	r1, r3
 810c4f0:	4610      	mov	r0, r2
 810c4f2:	f7fe fbb6 	bl	810ac62 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 810c4f6:	68bb      	ldr	r3, [r7, #8]
 810c4f8:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c4fa:	4b1b      	ldr	r3, [pc, #108]	@ (810c568 <xTaskIncrementTick+0x168>)
 810c4fc:	681b      	ldr	r3, [r3, #0]
 810c4fe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810c500:	429a      	cmp	r2, r3
 810c502:	d3b8      	bcc.n	810c476 <xTaskIncrementTick+0x76>
						{
							xSwitchRequired = pdTRUE;
 810c504:	2301      	movs	r3, #1
 810c506:	617b      	str	r3, [r7, #20]
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 810c508:	e7b5      	b.n	810c476 <xTaskIncrementTick+0x76>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 810c50a:	4b17      	ldr	r3, [pc, #92]	@ (810c568 <xTaskIncrementTick+0x168>)
 810c50c:	681b      	ldr	r3, [r3, #0]
 810c50e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c510:	4914      	ldr	r1, [pc, #80]	@ (810c564 <xTaskIncrementTick+0x164>)
 810c512:	4613      	mov	r3, r2
 810c514:	009b      	lsls	r3, r3, #2
 810c516:	4413      	add	r3, r2
 810c518:	009b      	lsls	r3, r3, #2
 810c51a:	440b      	add	r3, r1
 810c51c:	681b      	ldr	r3, [r3, #0]
 810c51e:	2b01      	cmp	r3, #1
 810c520:	d901      	bls.n	810c526 <xTaskIncrementTick+0x126>
			{
				xSwitchRequired = pdTRUE;
 810c522:	2301      	movs	r3, #1
 810c524:	617b      	str	r3, [r7, #20]
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
 810c526:	4b11      	ldr	r3, [pc, #68]	@ (810c56c <xTaskIncrementTick+0x16c>)
 810c528:	681b      	ldr	r3, [r3, #0]
 810c52a:	2b00      	cmp	r3, #0
 810c52c:	d007      	beq.n	810c53e <xTaskIncrementTick+0x13e>
			{
				xSwitchRequired = pdTRUE;
 810c52e:	2301      	movs	r3, #1
 810c530:	617b      	str	r3, [r7, #20]
 810c532:	e004      	b.n	810c53e <xTaskIncrementTick+0x13e>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
 810c534:	4b0e      	ldr	r3, [pc, #56]	@ (810c570 <xTaskIncrementTick+0x170>)
 810c536:	681b      	ldr	r3, [r3, #0]
 810c538:	3301      	adds	r3, #1
 810c53a:	4a0d      	ldr	r2, [pc, #52]	@ (810c570 <xTaskIncrementTick+0x170>)
 810c53c:	6013      	str	r3, [r2, #0]
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
 810c53e:	697b      	ldr	r3, [r7, #20]
}
 810c540:	4618      	mov	r0, r3
 810c542:	3718      	adds	r7, #24
 810c544:	46bd      	mov	sp, r7
 810c546:	bd80      	pop	{r7, pc}
 810c548:	100053fc 	.word	0x100053fc
 810c54c:	100053d8 	.word	0x100053d8
 810c550:	1000538c 	.word	0x1000538c
 810c554:	10005390 	.word	0x10005390
 810c558:	100053ec 	.word	0x100053ec
 810c55c:	100053f4 	.word	0x100053f4
 810c560:	100053dc 	.word	0x100053dc
 810c564:	10004f04 	.word	0x10004f04
 810c568:	10004f00 	.word	0x10004f00
 810c56c:	100053e8 	.word	0x100053e8
 810c570:	100053e4 	.word	0x100053e4

0810c574 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
 810c574:	b480      	push	{r7}
 810c576:	b085      	sub	sp, #20
 810c578:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 810c57a:	4b28      	ldr	r3, [pc, #160]	@ (810c61c <vTaskSwitchContext+0xa8>)
 810c57c:	681b      	ldr	r3, [r3, #0]
 810c57e:	2b00      	cmp	r3, #0
 810c580:	d003      	beq.n	810c58a <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 810c582:	4b27      	ldr	r3, [pc, #156]	@ (810c620 <vTaskSwitchContext+0xac>)
 810c584:	2201      	movs	r2, #1
 810c586:	601a      	str	r2, [r3, #0]
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
 810c588:	e042      	b.n	810c610 <vTaskSwitchContext+0x9c>
		xYieldPending = pdFALSE;
 810c58a:	4b25      	ldr	r3, [pc, #148]	@ (810c620 <vTaskSwitchContext+0xac>)
 810c58c:	2200      	movs	r2, #0
 810c58e:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 810c590:	4b24      	ldr	r3, [pc, #144]	@ (810c624 <vTaskSwitchContext+0xb0>)
 810c592:	681b      	ldr	r3, [r3, #0]
 810c594:	60fb      	str	r3, [r7, #12]
 810c596:	e011      	b.n	810c5bc <vTaskSwitchContext+0x48>
 810c598:	68fb      	ldr	r3, [r7, #12]
 810c59a:	2b00      	cmp	r3, #0
 810c59c:	d10b      	bne.n	810c5b6 <vTaskSwitchContext+0x42>
	__asm volatile
 810c59e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810c5a2:	f383 8811 	msr	BASEPRI, r3
 810c5a6:	f3bf 8f6f 	isb	sy
 810c5aa:	f3bf 8f4f 	dsb	sy
 810c5ae:	607b      	str	r3, [r7, #4]
}
 810c5b0:	bf00      	nop
 810c5b2:	bf00      	nop
 810c5b4:	e7fd      	b.n	810c5b2 <vTaskSwitchContext+0x3e>
 810c5b6:	68fb      	ldr	r3, [r7, #12]
 810c5b8:	3b01      	subs	r3, #1
 810c5ba:	60fb      	str	r3, [r7, #12]
 810c5bc:	491a      	ldr	r1, [pc, #104]	@ (810c628 <vTaskSwitchContext+0xb4>)
 810c5be:	68fa      	ldr	r2, [r7, #12]
 810c5c0:	4613      	mov	r3, r2
 810c5c2:	009b      	lsls	r3, r3, #2
 810c5c4:	4413      	add	r3, r2
 810c5c6:	009b      	lsls	r3, r3, #2
 810c5c8:	440b      	add	r3, r1
 810c5ca:	681b      	ldr	r3, [r3, #0]
 810c5cc:	2b00      	cmp	r3, #0
 810c5ce:	d0e3      	beq.n	810c598 <vTaskSwitchContext+0x24>
 810c5d0:	68fa      	ldr	r2, [r7, #12]
 810c5d2:	4613      	mov	r3, r2
 810c5d4:	009b      	lsls	r3, r3, #2
 810c5d6:	4413      	add	r3, r2
 810c5d8:	009b      	lsls	r3, r3, #2
 810c5da:	4a13      	ldr	r2, [pc, #76]	@ (810c628 <vTaskSwitchContext+0xb4>)
 810c5dc:	4413      	add	r3, r2
 810c5de:	60bb      	str	r3, [r7, #8]
 810c5e0:	68bb      	ldr	r3, [r7, #8]
 810c5e2:	685b      	ldr	r3, [r3, #4]
 810c5e4:	685a      	ldr	r2, [r3, #4]
 810c5e6:	68bb      	ldr	r3, [r7, #8]
 810c5e8:	605a      	str	r2, [r3, #4]
 810c5ea:	68bb      	ldr	r3, [r7, #8]
 810c5ec:	685a      	ldr	r2, [r3, #4]
 810c5ee:	68bb      	ldr	r3, [r7, #8]
 810c5f0:	3308      	adds	r3, #8
 810c5f2:	429a      	cmp	r2, r3
 810c5f4:	d104      	bne.n	810c600 <vTaskSwitchContext+0x8c>
 810c5f6:	68bb      	ldr	r3, [r7, #8]
 810c5f8:	685b      	ldr	r3, [r3, #4]
 810c5fa:	685a      	ldr	r2, [r3, #4]
 810c5fc:	68bb      	ldr	r3, [r7, #8]
 810c5fe:	605a      	str	r2, [r3, #4]
 810c600:	68bb      	ldr	r3, [r7, #8]
 810c602:	685b      	ldr	r3, [r3, #4]
 810c604:	68db      	ldr	r3, [r3, #12]
 810c606:	4a09      	ldr	r2, [pc, #36]	@ (810c62c <vTaskSwitchContext+0xb8>)
 810c608:	6013      	str	r3, [r2, #0]
 810c60a:	4a06      	ldr	r2, [pc, #24]	@ (810c624 <vTaskSwitchContext+0xb0>)
 810c60c:	68fb      	ldr	r3, [r7, #12]
 810c60e:	6013      	str	r3, [r2, #0]
}
 810c610:	bf00      	nop
 810c612:	3714      	adds	r7, #20
 810c614:	46bd      	mov	sp, r7
 810c616:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c61a:	4770      	bx	lr
 810c61c:	100053fc 	.word	0x100053fc
 810c620:	100053e8 	.word	0x100053e8
 810c624:	100053dc 	.word	0x100053dc
 810c628:	10004f04 	.word	0x10004f04
 810c62c:	10004f00 	.word	0x10004f00

0810c630 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
 810c630:	b580      	push	{r7, lr}
 810c632:	b084      	sub	sp, #16
 810c634:	af00      	add	r7, sp, #0
 810c636:	6078      	str	r0, [r7, #4]
 810c638:	6039      	str	r1, [r7, #0]
	configASSERT( pxEventList );
 810c63a:	687b      	ldr	r3, [r7, #4]
 810c63c:	2b00      	cmp	r3, #0
 810c63e:	d10b      	bne.n	810c658 <vTaskPlaceOnEventList+0x28>
	__asm volatile
 810c640:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810c644:	f383 8811 	msr	BASEPRI, r3
 810c648:	f3bf 8f6f 	isb	sy
 810c64c:	f3bf 8f4f 	dsb	sy
 810c650:	60fb      	str	r3, [r7, #12]
}
 810c652:	bf00      	nop
 810c654:	bf00      	nop
 810c656:	e7fd      	b.n	810c654 <vTaskPlaceOnEventList+0x24>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 810c658:	4b07      	ldr	r3, [pc, #28]	@ (810c678 <vTaskPlaceOnEventList+0x48>)
 810c65a:	681b      	ldr	r3, [r3, #0]
 810c65c:	3318      	adds	r3, #24
 810c65e:	4619      	mov	r1, r3
 810c660:	6878      	ldr	r0, [r7, #4]
 810c662:	f7fe fb22 	bl	810acaa <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
 810c666:	2101      	movs	r1, #1
 810c668:	6838      	ldr	r0, [r7, #0]
 810c66a:	f000 fa81 	bl	810cb70 <prvAddCurrentTaskToDelayedList>
}
 810c66e:	bf00      	nop
 810c670:	3710      	adds	r7, #16
 810c672:	46bd      	mov	sp, r7
 810c674:	bd80      	pop	{r7, pc}
 810c676:	bf00      	nop
 810c678:	10004f00 	.word	0x10004f00

0810c67c <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if( configUSE_TIMERS == 1 )

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
 810c67c:	b580      	push	{r7, lr}
 810c67e:	b086      	sub	sp, #24
 810c680:	af00      	add	r7, sp, #0
 810c682:	60f8      	str	r0, [r7, #12]
 810c684:	60b9      	str	r1, [r7, #8]
 810c686:	607a      	str	r2, [r7, #4]
		configASSERT( pxEventList );
 810c688:	68fb      	ldr	r3, [r7, #12]
 810c68a:	2b00      	cmp	r3, #0
 810c68c:	d10b      	bne.n	810c6a6 <vTaskPlaceOnEventListRestricted+0x2a>
	__asm volatile
 810c68e:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810c692:	f383 8811 	msr	BASEPRI, r3
 810c696:	f3bf 8f6f 	isb	sy
 810c69a:	f3bf 8f4f 	dsb	sy
 810c69e:	617b      	str	r3, [r7, #20]
}
 810c6a0:	bf00      	nop
 810c6a2:	bf00      	nop
 810c6a4:	e7fd      	b.n	810c6a2 <vTaskPlaceOnEventListRestricted+0x26>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
 810c6a6:	4b0a      	ldr	r3, [pc, #40]	@ (810c6d0 <vTaskPlaceOnEventListRestricted+0x54>)
 810c6a8:	681b      	ldr	r3, [r3, #0]
 810c6aa:	3318      	adds	r3, #24
 810c6ac:	4619      	mov	r1, r3
 810c6ae:	68f8      	ldr	r0, [r7, #12]
 810c6b0:	f7fe fad7 	bl	810ac62 <vListInsertEnd>

		/* If the task should block indefinitely then set the block time to a
		value that will be recognised as an indefinite delay inside the
		prvAddCurrentTaskToDelayedList() function. */
		if( xWaitIndefinitely != pdFALSE )
 810c6b4:	687b      	ldr	r3, [r7, #4]
 810c6b6:	2b00      	cmp	r3, #0
 810c6b8:	d002      	beq.n	810c6c0 <vTaskPlaceOnEventListRestricted+0x44>
		{
			xTicksToWait = portMAX_DELAY;
 810c6ba:	f04f 33ff 	mov.w	r3, #4294967295
 810c6be:	60bb      	str	r3, [r7, #8]
		}

		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
 810c6c0:	6879      	ldr	r1, [r7, #4]
 810c6c2:	68b8      	ldr	r0, [r7, #8]
 810c6c4:	f000 fa54 	bl	810cb70 <prvAddCurrentTaskToDelayedList>
	}
 810c6c8:	bf00      	nop
 810c6ca:	3718      	adds	r7, #24
 810c6cc:	46bd      	mov	sp, r7
 810c6ce:	bd80      	pop	{r7, pc}
 810c6d0:	10004f00 	.word	0x10004f00

0810c6d4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
 810c6d4:	b580      	push	{r7, lr}
 810c6d6:	b086      	sub	sp, #24
 810c6d8:	af00      	add	r7, sp, #0
 810c6da:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 810c6dc:	687b      	ldr	r3, [r7, #4]
 810c6de:	68db      	ldr	r3, [r3, #12]
 810c6e0:	68db      	ldr	r3, [r3, #12]
 810c6e2:	613b      	str	r3, [r7, #16]
	configASSERT( pxUnblockedTCB );
 810c6e4:	693b      	ldr	r3, [r7, #16]
 810c6e6:	2b00      	cmp	r3, #0
 810c6e8:	d10b      	bne.n	810c702 <xTaskRemoveFromEventList+0x2e>
	__asm volatile
 810c6ea:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810c6ee:	f383 8811 	msr	BASEPRI, r3
 810c6f2:	f3bf 8f6f 	isb	sy
 810c6f6:	f3bf 8f4f 	dsb	sy
 810c6fa:	60fb      	str	r3, [r7, #12]
}
 810c6fc:	bf00      	nop
 810c6fe:	bf00      	nop
 810c700:	e7fd      	b.n	810c6fe <xTaskRemoveFromEventList+0x2a>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
 810c702:	693b      	ldr	r3, [r7, #16]
 810c704:	3318      	adds	r3, #24
 810c706:	4618      	mov	r0, r3
 810c708:	f7fe fb08 	bl	810ad1c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 810c70c:	4b1d      	ldr	r3, [pc, #116]	@ (810c784 <xTaskRemoveFromEventList+0xb0>)
 810c70e:	681b      	ldr	r3, [r3, #0]
 810c710:	2b00      	cmp	r3, #0
 810c712:	d11d      	bne.n	810c750 <xTaskRemoveFromEventList+0x7c>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
 810c714:	693b      	ldr	r3, [r7, #16]
 810c716:	3304      	adds	r3, #4
 810c718:	4618      	mov	r0, r3
 810c71a:	f7fe faff 	bl	810ad1c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
 810c71e:	693b      	ldr	r3, [r7, #16]
 810c720:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c722:	4b19      	ldr	r3, [pc, #100]	@ (810c788 <xTaskRemoveFromEventList+0xb4>)
 810c724:	681b      	ldr	r3, [r3, #0]
 810c726:	429a      	cmp	r2, r3
 810c728:	d903      	bls.n	810c732 <xTaskRemoveFromEventList+0x5e>
 810c72a:	693b      	ldr	r3, [r7, #16]
 810c72c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810c72e:	4a16      	ldr	r2, [pc, #88]	@ (810c788 <xTaskRemoveFromEventList+0xb4>)
 810c730:	6013      	str	r3, [r2, #0]
 810c732:	693b      	ldr	r3, [r7, #16]
 810c734:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c736:	4613      	mov	r3, r2
 810c738:	009b      	lsls	r3, r3, #2
 810c73a:	4413      	add	r3, r2
 810c73c:	009b      	lsls	r3, r3, #2
 810c73e:	4a13      	ldr	r2, [pc, #76]	@ (810c78c <xTaskRemoveFromEventList+0xb8>)
 810c740:	441a      	add	r2, r3
 810c742:	693b      	ldr	r3, [r7, #16]
 810c744:	3304      	adds	r3, #4
 810c746:	4619      	mov	r1, r3
 810c748:	4610      	mov	r0, r2
 810c74a:	f7fe fa8a 	bl	810ac62 <vListInsertEnd>
 810c74e:	e005      	b.n	810c75c <xTaskRemoveFromEventList+0x88>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
 810c750:	693b      	ldr	r3, [r7, #16]
 810c752:	3318      	adds	r3, #24
 810c754:	4619      	mov	r1, r3
 810c756:	480e      	ldr	r0, [pc, #56]	@ (810c790 <xTaskRemoveFromEventList+0xbc>)
 810c758:	f7fe fa83 	bl	810ac62 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
 810c75c:	693b      	ldr	r3, [r7, #16]
 810c75e:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810c760:	4b0c      	ldr	r3, [pc, #48]	@ (810c794 <xTaskRemoveFromEventList+0xc0>)
 810c762:	681b      	ldr	r3, [r3, #0]
 810c764:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810c766:	429a      	cmp	r2, r3
 810c768:	d905      	bls.n	810c776 <xTaskRemoveFromEventList+0xa2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
 810c76a:	2301      	movs	r3, #1
 810c76c:	617b      	str	r3, [r7, #20]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
 810c76e:	4b0a      	ldr	r3, [pc, #40]	@ (810c798 <xTaskRemoveFromEventList+0xc4>)
 810c770:	2201      	movs	r2, #1
 810c772:	601a      	str	r2, [r3, #0]
 810c774:	e001      	b.n	810c77a <xTaskRemoveFromEventList+0xa6>
	}
	else
	{
		xReturn = pdFALSE;
 810c776:	2300      	movs	r3, #0
 810c778:	617b      	str	r3, [r7, #20]
	}

	return xReturn;
 810c77a:	697b      	ldr	r3, [r7, #20]
}
 810c77c:	4618      	mov	r0, r3
 810c77e:	3718      	adds	r7, #24
 810c780:	46bd      	mov	sp, r7
 810c782:	bd80      	pop	{r7, pc}
 810c784:	100053fc 	.word	0x100053fc
 810c788:	100053dc 	.word	0x100053dc
 810c78c:	10004f04 	.word	0x10004f04
 810c790:	10005394 	.word	0x10005394
 810c794:	10004f00 	.word	0x10004f00
 810c798:	100053e8 	.word	0x100053e8

0810c79c <vTaskInternalSetTimeOutState>:
	taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
 810c79c:	b480      	push	{r7}
 810c79e:	b083      	sub	sp, #12
 810c7a0:	af00      	add	r7, sp, #0
 810c7a2:	6078      	str	r0, [r7, #4]
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
 810c7a4:	4b06      	ldr	r3, [pc, #24]	@ (810c7c0 <vTaskInternalSetTimeOutState+0x24>)
 810c7a6:	681a      	ldr	r2, [r3, #0]
 810c7a8:	687b      	ldr	r3, [r7, #4]
 810c7aa:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
 810c7ac:	4b05      	ldr	r3, [pc, #20]	@ (810c7c4 <vTaskInternalSetTimeOutState+0x28>)
 810c7ae:	681a      	ldr	r2, [r3, #0]
 810c7b0:	687b      	ldr	r3, [r7, #4]
 810c7b2:	605a      	str	r2, [r3, #4]
}
 810c7b4:	bf00      	nop
 810c7b6:	370c      	adds	r7, #12
 810c7b8:	46bd      	mov	sp, r7
 810c7ba:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c7be:	4770      	bx	lr
 810c7c0:	100053ec 	.word	0x100053ec
 810c7c4:	100053d8 	.word	0x100053d8

0810c7c8 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
 810c7c8:	b580      	push	{r7, lr}
 810c7ca:	b088      	sub	sp, #32
 810c7cc:	af00      	add	r7, sp, #0
 810c7ce:	6078      	str	r0, [r7, #4]
 810c7d0:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
 810c7d2:	687b      	ldr	r3, [r7, #4]
 810c7d4:	2b00      	cmp	r3, #0
 810c7d6:	d10b      	bne.n	810c7f0 <xTaskCheckForTimeOut+0x28>
	__asm volatile
 810c7d8:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810c7dc:	f383 8811 	msr	BASEPRI, r3
 810c7e0:	f3bf 8f6f 	isb	sy
 810c7e4:	f3bf 8f4f 	dsb	sy
 810c7e8:	613b      	str	r3, [r7, #16]
}
 810c7ea:	bf00      	nop
 810c7ec:	bf00      	nop
 810c7ee:	e7fd      	b.n	810c7ec <xTaskCheckForTimeOut+0x24>
	configASSERT( pxTicksToWait );
 810c7f0:	683b      	ldr	r3, [r7, #0]
 810c7f2:	2b00      	cmp	r3, #0
 810c7f4:	d10b      	bne.n	810c80e <xTaskCheckForTimeOut+0x46>
	__asm volatile
 810c7f6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810c7fa:	f383 8811 	msr	BASEPRI, r3
 810c7fe:	f3bf 8f6f 	isb	sy
 810c802:	f3bf 8f4f 	dsb	sy
 810c806:	60fb      	str	r3, [r7, #12]
}
 810c808:	bf00      	nop
 810c80a:	bf00      	nop
 810c80c:	e7fd      	b.n	810c80a <xTaskCheckForTimeOut+0x42>

	taskENTER_CRITICAL();
 810c80e:	f7fe fbe3 	bl	810afd8 <vPortEnterCritical>
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
 810c812:	4b1d      	ldr	r3, [pc, #116]	@ (810c888 <xTaskCheckForTimeOut+0xc0>)
 810c814:	681b      	ldr	r3, [r3, #0]
 810c816:	61bb      	str	r3, [r7, #24]
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
 810c818:	687b      	ldr	r3, [r7, #4]
 810c81a:	685b      	ldr	r3, [r3, #4]
 810c81c:	69ba      	ldr	r2, [r7, #24]
 810c81e:	1ad3      	subs	r3, r2, r3
 810c820:	617b      	str	r3, [r7, #20]
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
 810c822:	683b      	ldr	r3, [r7, #0]
 810c824:	681b      	ldr	r3, [r3, #0]
 810c826:	f1b3 3fff 	cmp.w	r3, #4294967295
 810c82a:	d102      	bne.n	810c832 <xTaskCheckForTimeOut+0x6a>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
 810c82c:	2300      	movs	r3, #0
 810c82e:	61fb      	str	r3, [r7, #28]
 810c830:	e023      	b.n	810c87a <xTaskCheckForTimeOut+0xb2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
 810c832:	687b      	ldr	r3, [r7, #4]
 810c834:	681a      	ldr	r2, [r3, #0]
 810c836:	4b15      	ldr	r3, [pc, #84]	@ (810c88c <xTaskCheckForTimeOut+0xc4>)
 810c838:	681b      	ldr	r3, [r3, #0]
 810c83a:	429a      	cmp	r2, r3
 810c83c:	d007      	beq.n	810c84e <xTaskCheckForTimeOut+0x86>
 810c83e:	687b      	ldr	r3, [r7, #4]
 810c840:	685b      	ldr	r3, [r3, #4]
 810c842:	69ba      	ldr	r2, [r7, #24]
 810c844:	429a      	cmp	r2, r3
 810c846:	d302      	bcc.n	810c84e <xTaskCheckForTimeOut+0x86>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
 810c848:	2301      	movs	r3, #1
 810c84a:	61fb      	str	r3, [r7, #28]
 810c84c:	e015      	b.n	810c87a <xTaskCheckForTimeOut+0xb2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
 810c84e:	683b      	ldr	r3, [r7, #0]
 810c850:	681b      	ldr	r3, [r3, #0]
 810c852:	697a      	ldr	r2, [r7, #20]
 810c854:	429a      	cmp	r2, r3
 810c856:	d20b      	bcs.n	810c870 <xTaskCheckForTimeOut+0xa8>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
 810c858:	683b      	ldr	r3, [r7, #0]
 810c85a:	681a      	ldr	r2, [r3, #0]
 810c85c:	697b      	ldr	r3, [r7, #20]
 810c85e:	1ad2      	subs	r2, r2, r3
 810c860:	683b      	ldr	r3, [r7, #0]
 810c862:	601a      	str	r2, [r3, #0]
			vTaskInternalSetTimeOutState( pxTimeOut );
 810c864:	6878      	ldr	r0, [r7, #4]
 810c866:	f7ff ff99 	bl	810c79c <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
 810c86a:	2300      	movs	r3, #0
 810c86c:	61fb      	str	r3, [r7, #28]
 810c86e:	e004      	b.n	810c87a <xTaskCheckForTimeOut+0xb2>
		}
		else
		{
			*pxTicksToWait = 0;
 810c870:	683b      	ldr	r3, [r7, #0]
 810c872:	2200      	movs	r2, #0
 810c874:	601a      	str	r2, [r3, #0]
			xReturn = pdTRUE;
 810c876:	2301      	movs	r3, #1
 810c878:	61fb      	str	r3, [r7, #28]
		}
	}
	taskEXIT_CRITICAL();
 810c87a:	f7fe fbdf 	bl	810b03c <vPortExitCritical>

	return xReturn;
 810c87e:	69fb      	ldr	r3, [r7, #28]
}
 810c880:	4618      	mov	r0, r3
 810c882:	3720      	adds	r7, #32
 810c884:	46bd      	mov	sp, r7
 810c886:	bd80      	pop	{r7, pc}
 810c888:	100053d8 	.word	0x100053d8
 810c88c:	100053ec 	.word	0x100053ec

0810c890 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
 810c890:	b480      	push	{r7}
 810c892:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
 810c894:	4b03      	ldr	r3, [pc, #12]	@ (810c8a4 <vTaskMissedYield+0x14>)
 810c896:	2201      	movs	r2, #1
 810c898:	601a      	str	r2, [r3, #0]
}
 810c89a:	bf00      	nop
 810c89c:	46bd      	mov	sp, r7
 810c89e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810c8a2:	4770      	bx	lr
 810c8a4:	100053e8 	.word	0x100053e8

0810c8a8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
 810c8a8:	b580      	push	{r7, lr}
 810c8aa:	b082      	sub	sp, #8
 810c8ac:	af00      	add	r7, sp, #0
 810c8ae:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
 810c8b0:	f000 f852 	bl	810c958 <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 810c8b4:	4b06      	ldr	r3, [pc, #24]	@ (810c8d0 <prvIdleTask+0x28>)
 810c8b6:	681b      	ldr	r3, [r3, #0]
 810c8b8:	2b01      	cmp	r3, #1
 810c8ba:	d9f9      	bls.n	810c8b0 <prvIdleTask+0x8>
			{
				taskYIELD();
 810c8bc:	4b05      	ldr	r3, [pc, #20]	@ (810c8d4 <prvIdleTask+0x2c>)
 810c8be:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 810c8c2:	601a      	str	r2, [r3, #0]
 810c8c4:	f3bf 8f4f 	dsb	sy
 810c8c8:	f3bf 8f6f 	isb	sy
		prvCheckTasksWaitingTermination();
 810c8cc:	e7f0      	b.n	810c8b0 <prvIdleTask+0x8>
 810c8ce:	bf00      	nop
 810c8d0:	10004f04 	.word	0x10004f04
 810c8d4:	e000ed04 	.word	0xe000ed04

0810c8d8 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
 810c8d8:	b580      	push	{r7, lr}
 810c8da:	b082      	sub	sp, #8
 810c8dc:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 810c8de:	2300      	movs	r3, #0
 810c8e0:	607b      	str	r3, [r7, #4]
 810c8e2:	e00c      	b.n	810c8fe <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 810c8e4:	687a      	ldr	r2, [r7, #4]
 810c8e6:	4613      	mov	r3, r2
 810c8e8:	009b      	lsls	r3, r3, #2
 810c8ea:	4413      	add	r3, r2
 810c8ec:	009b      	lsls	r3, r3, #2
 810c8ee:	4a12      	ldr	r2, [pc, #72]	@ (810c938 <prvInitialiseTaskLists+0x60>)
 810c8f0:	4413      	add	r3, r2
 810c8f2:	4618      	mov	r0, r3
 810c8f4:	f7fe f988 	bl	810ac08 <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 810c8f8:	687b      	ldr	r3, [r7, #4]
 810c8fa:	3301      	adds	r3, #1
 810c8fc:	607b      	str	r3, [r7, #4]
 810c8fe:	687b      	ldr	r3, [r7, #4]
 810c900:	2b37      	cmp	r3, #55	@ 0x37
 810c902:	d9ef      	bls.n	810c8e4 <prvInitialiseTaskLists+0xc>
	}

	vListInitialise( &xDelayedTaskList1 );
 810c904:	480d      	ldr	r0, [pc, #52]	@ (810c93c <prvInitialiseTaskLists+0x64>)
 810c906:	f7fe f97f 	bl	810ac08 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 810c90a:	480d      	ldr	r0, [pc, #52]	@ (810c940 <prvInitialiseTaskLists+0x68>)
 810c90c:	f7fe f97c 	bl	810ac08 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 810c910:	480c      	ldr	r0, [pc, #48]	@ (810c944 <prvInitialiseTaskLists+0x6c>)
 810c912:	f7fe f979 	bl	810ac08 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 810c916:	480c      	ldr	r0, [pc, #48]	@ (810c948 <prvInitialiseTaskLists+0x70>)
 810c918:	f7fe f976 	bl	810ac08 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 810c91c:	480b      	ldr	r0, [pc, #44]	@ (810c94c <prvInitialiseTaskLists+0x74>)
 810c91e:	f7fe f973 	bl	810ac08 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 810c922:	4b0b      	ldr	r3, [pc, #44]	@ (810c950 <prvInitialiseTaskLists+0x78>)
 810c924:	4a05      	ldr	r2, [pc, #20]	@ (810c93c <prvInitialiseTaskLists+0x64>)
 810c926:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 810c928:	4b0a      	ldr	r3, [pc, #40]	@ (810c954 <prvInitialiseTaskLists+0x7c>)
 810c92a:	4a05      	ldr	r2, [pc, #20]	@ (810c940 <prvInitialiseTaskLists+0x68>)
 810c92c:	601a      	str	r2, [r3, #0]
}
 810c92e:	bf00      	nop
 810c930:	3708      	adds	r7, #8
 810c932:	46bd      	mov	sp, r7
 810c934:	bd80      	pop	{r7, pc}
 810c936:	bf00      	nop
 810c938:	10004f04 	.word	0x10004f04
 810c93c:	10005364 	.word	0x10005364
 810c940:	10005378 	.word	0x10005378
 810c944:	10005394 	.word	0x10005394
 810c948:	100053a8 	.word	0x100053a8
 810c94c:	100053c0 	.word	0x100053c0
 810c950:	1000538c 	.word	0x1000538c
 810c954:	10005390 	.word	0x10005390

0810c958 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
 810c958:	b580      	push	{r7, lr}
 810c95a:	b082      	sub	sp, #8
 810c95c:	af00      	add	r7, sp, #0
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 810c95e:	e019      	b.n	810c994 <prvCheckTasksWaitingTermination+0x3c>
		{
			taskENTER_CRITICAL();
 810c960:	f7fe fb3a 	bl	810afd8 <vPortEnterCritical>
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 810c964:	4b10      	ldr	r3, [pc, #64]	@ (810c9a8 <prvCheckTasksWaitingTermination+0x50>)
 810c966:	68db      	ldr	r3, [r3, #12]
 810c968:	68db      	ldr	r3, [r3, #12]
 810c96a:	607b      	str	r3, [r7, #4]
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 810c96c:	687b      	ldr	r3, [r7, #4]
 810c96e:	3304      	adds	r3, #4
 810c970:	4618      	mov	r0, r3
 810c972:	f7fe f9d3 	bl	810ad1c <uxListRemove>
				--uxCurrentNumberOfTasks;
 810c976:	4b0d      	ldr	r3, [pc, #52]	@ (810c9ac <prvCheckTasksWaitingTermination+0x54>)
 810c978:	681b      	ldr	r3, [r3, #0]
 810c97a:	3b01      	subs	r3, #1
 810c97c:	4a0b      	ldr	r2, [pc, #44]	@ (810c9ac <prvCheckTasksWaitingTermination+0x54>)
 810c97e:	6013      	str	r3, [r2, #0]
				--uxDeletedTasksWaitingCleanUp;
 810c980:	4b0b      	ldr	r3, [pc, #44]	@ (810c9b0 <prvCheckTasksWaitingTermination+0x58>)
 810c982:	681b      	ldr	r3, [r3, #0]
 810c984:	3b01      	subs	r3, #1
 810c986:	4a0a      	ldr	r2, [pc, #40]	@ (810c9b0 <prvCheckTasksWaitingTermination+0x58>)
 810c988:	6013      	str	r3, [r2, #0]
			}
			taskEXIT_CRITICAL();
 810c98a:	f7fe fb57 	bl	810b03c <vPortExitCritical>

			prvDeleteTCB( pxTCB );
 810c98e:	6878      	ldr	r0, [r7, #4]
 810c990:	f000 f810 	bl	810c9b4 <prvDeleteTCB>
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 810c994:	4b06      	ldr	r3, [pc, #24]	@ (810c9b0 <prvCheckTasksWaitingTermination+0x58>)
 810c996:	681b      	ldr	r3, [r3, #0]
 810c998:	2b00      	cmp	r3, #0
 810c99a:	d1e1      	bne.n	810c960 <prvCheckTasksWaitingTermination+0x8>
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
 810c99c:	bf00      	nop
 810c99e:	bf00      	nop
 810c9a0:	3708      	adds	r7, #8
 810c9a2:	46bd      	mov	sp, r7
 810c9a4:	bd80      	pop	{r7, pc}
 810c9a6:	bf00      	nop
 810c9a8:	100053a8 	.word	0x100053a8
 810c9ac:	100053d4 	.word	0x100053d4
 810c9b0:	100053bc 	.word	0x100053bc

0810c9b4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
 810c9b4:	b580      	push	{r7, lr}
 810c9b6:	b084      	sub	sp, #16
 810c9b8:	af00      	add	r7, sp, #0
 810c9ba:	6078      	str	r0, [r7, #4]
		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */
		{
			/* The task could have been allocated statically or dynamically, so
			check what was statically allocated before trying to free the
			memory. */
			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
 810c9bc:	687b      	ldr	r3, [r7, #4]
 810c9be:	f893 3059 	ldrb.w	r3, [r3, #89]	@ 0x59
 810c9c2:	2b00      	cmp	r3, #0
 810c9c4:	d108      	bne.n	810c9d8 <prvDeleteTCB+0x24>
			{
				/* Both the stack and TCB were allocated dynamically, so both
				must be freed. */
				vPortFree( pxTCB->pxStack );
 810c9c6:	687b      	ldr	r3, [r7, #4]
 810c9c8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 810c9ca:	4618      	mov	r0, r3
 810c9cc:	f7fd fffc 	bl	810a9c8 <vPortFree>
				vPortFree( pxTCB );
 810c9d0:	6878      	ldr	r0, [r7, #4]
 810c9d2:	f7fd fff9 	bl	810a9c8 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
 810c9d6:	e019      	b.n	810ca0c <prvDeleteTCB+0x58>
			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
 810c9d8:	687b      	ldr	r3, [r7, #4]
 810c9da:	f893 3059 	ldrb.w	r3, [r3, #89]	@ 0x59
 810c9de:	2b01      	cmp	r3, #1
 810c9e0:	d103      	bne.n	810c9ea <prvDeleteTCB+0x36>
				vPortFree( pxTCB );
 810c9e2:	6878      	ldr	r0, [r7, #4]
 810c9e4:	f7fd fff0 	bl	810a9c8 <vPortFree>
	}
 810c9e8:	e010      	b.n	810ca0c <prvDeleteTCB+0x58>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
 810c9ea:	687b      	ldr	r3, [r7, #4]
 810c9ec:	f893 3059 	ldrb.w	r3, [r3, #89]	@ 0x59
 810c9f0:	2b02      	cmp	r3, #2
 810c9f2:	d00b      	beq.n	810ca0c <prvDeleteTCB+0x58>
	__asm volatile
 810c9f4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810c9f8:	f383 8811 	msr	BASEPRI, r3
 810c9fc:	f3bf 8f6f 	isb	sy
 810ca00:	f3bf 8f4f 	dsb	sy
 810ca04:	60fb      	str	r3, [r7, #12]
}
 810ca06:	bf00      	nop
 810ca08:	bf00      	nop
 810ca0a:	e7fd      	b.n	810ca08 <prvDeleteTCB+0x54>
	}
 810ca0c:	bf00      	nop
 810ca0e:	3710      	adds	r7, #16
 810ca10:	46bd      	mov	sp, r7
 810ca12:	bd80      	pop	{r7, pc}

0810ca14 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
 810ca14:	b480      	push	{r7}
 810ca16:	b083      	sub	sp, #12
 810ca18:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 810ca1a:	4b0c      	ldr	r3, [pc, #48]	@ (810ca4c <prvResetNextTaskUnblockTime+0x38>)
 810ca1c:	681b      	ldr	r3, [r3, #0]
 810ca1e:	681b      	ldr	r3, [r3, #0]
 810ca20:	2b00      	cmp	r3, #0
 810ca22:	d104      	bne.n	810ca2e <prvResetNextTaskUnblockTime+0x1a>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 810ca24:	4b0a      	ldr	r3, [pc, #40]	@ (810ca50 <prvResetNextTaskUnblockTime+0x3c>)
 810ca26:	f04f 32ff 	mov.w	r2, #4294967295
 810ca2a:	601a      	str	r2, [r3, #0]
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
	}
}
 810ca2c:	e008      	b.n	810ca40 <prvResetNextTaskUnblockTime+0x2c>
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 810ca2e:	4b07      	ldr	r3, [pc, #28]	@ (810ca4c <prvResetNextTaskUnblockTime+0x38>)
 810ca30:	681b      	ldr	r3, [r3, #0]
 810ca32:	68db      	ldr	r3, [r3, #12]
 810ca34:	68db      	ldr	r3, [r3, #12]
 810ca36:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 810ca38:	687b      	ldr	r3, [r7, #4]
 810ca3a:	685b      	ldr	r3, [r3, #4]
 810ca3c:	4a04      	ldr	r2, [pc, #16]	@ (810ca50 <prvResetNextTaskUnblockTime+0x3c>)
 810ca3e:	6013      	str	r3, [r2, #0]
}
 810ca40:	bf00      	nop
 810ca42:	370c      	adds	r7, #12
 810ca44:	46bd      	mov	sp, r7
 810ca46:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ca4a:	4770      	bx	lr
 810ca4c:	1000538c 	.word	0x1000538c
 810ca50:	100053f4 	.word	0x100053f4

0810ca54 <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
 810ca54:	b480      	push	{r7}
 810ca56:	b083      	sub	sp, #12
 810ca58:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
 810ca5a:	4b0b      	ldr	r3, [pc, #44]	@ (810ca88 <xTaskGetSchedulerState+0x34>)
 810ca5c:	681b      	ldr	r3, [r3, #0]
 810ca5e:	2b00      	cmp	r3, #0
 810ca60:	d102      	bne.n	810ca68 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
 810ca62:	2301      	movs	r3, #1
 810ca64:	607b      	str	r3, [r7, #4]
 810ca66:	e008      	b.n	810ca7a <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 810ca68:	4b08      	ldr	r3, [pc, #32]	@ (810ca8c <xTaskGetSchedulerState+0x38>)
 810ca6a:	681b      	ldr	r3, [r3, #0]
 810ca6c:	2b00      	cmp	r3, #0
 810ca6e:	d102      	bne.n	810ca76 <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
 810ca70:	2302      	movs	r3, #2
 810ca72:	607b      	str	r3, [r7, #4]
 810ca74:	e001      	b.n	810ca7a <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
 810ca76:	2300      	movs	r3, #0
 810ca78:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
 810ca7a:	687b      	ldr	r3, [r7, #4]
	}
 810ca7c:	4618      	mov	r0, r3
 810ca7e:	370c      	adds	r7, #12
 810ca80:	46bd      	mov	sp, r7
 810ca82:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ca86:	4770      	bx	lr
 810ca88:	100053e0 	.word	0x100053e0
 810ca8c:	100053fc 	.word	0x100053fc

0810ca90 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
 810ca90:	b580      	push	{r7, lr}
 810ca92:	b086      	sub	sp, #24
 810ca94:	af00      	add	r7, sp, #0
 810ca96:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = pxMutexHolder;
 810ca98:	687b      	ldr	r3, [r7, #4]
 810ca9a:	613b      	str	r3, [r7, #16]
	BaseType_t xReturn = pdFALSE;
 810ca9c:	2300      	movs	r3, #0
 810ca9e:	617b      	str	r3, [r7, #20]

		if( pxMutexHolder != NULL )
 810caa0:	687b      	ldr	r3, [r7, #4]
 810caa2:	2b00      	cmp	r3, #0
 810caa4:	d058      	beq.n	810cb58 <xTaskPriorityDisinherit+0xc8>
		{
			/* A task can only have an inherited priority if it holds the mutex.
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
 810caa6:	4b2f      	ldr	r3, [pc, #188]	@ (810cb64 <xTaskPriorityDisinherit+0xd4>)
 810caa8:	681b      	ldr	r3, [r3, #0]
 810caaa:	693a      	ldr	r2, [r7, #16]
 810caac:	429a      	cmp	r2, r3
 810caae:	d00b      	beq.n	810cac8 <xTaskPriorityDisinherit+0x38>
	__asm volatile
 810cab0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810cab4:	f383 8811 	msr	BASEPRI, r3
 810cab8:	f3bf 8f6f 	isb	sy
 810cabc:	f3bf 8f4f 	dsb	sy
 810cac0:	60fb      	str	r3, [r7, #12]
}
 810cac2:	bf00      	nop
 810cac4:	bf00      	nop
 810cac6:	e7fd      	b.n	810cac4 <xTaskPriorityDisinherit+0x34>
			configASSERT( pxTCB->uxMutexesHeld );
 810cac8:	693b      	ldr	r3, [r7, #16]
 810caca:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 810cacc:	2b00      	cmp	r3, #0
 810cace:	d10b      	bne.n	810cae8 <xTaskPriorityDisinherit+0x58>
	__asm volatile
 810cad0:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810cad4:	f383 8811 	msr	BASEPRI, r3
 810cad8:	f3bf 8f6f 	isb	sy
 810cadc:	f3bf 8f4f 	dsb	sy
 810cae0:	60bb      	str	r3, [r7, #8]
}
 810cae2:	bf00      	nop
 810cae4:	bf00      	nop
 810cae6:	e7fd      	b.n	810cae4 <xTaskPriorityDisinherit+0x54>
			( pxTCB->uxMutexesHeld )--;
 810cae8:	693b      	ldr	r3, [r7, #16]
 810caea:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 810caec:	1e5a      	subs	r2, r3, #1
 810caee:	693b      	ldr	r3, [r7, #16]
 810caf0:	651a      	str	r2, [r3, #80]	@ 0x50

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
 810caf2:	693b      	ldr	r3, [r7, #16]
 810caf4:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810caf6:	693b      	ldr	r3, [r7, #16]
 810caf8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 810cafa:	429a      	cmp	r2, r3
 810cafc:	d02c      	beq.n	810cb58 <xTaskPriorityDisinherit+0xc8>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
 810cafe:	693b      	ldr	r3, [r7, #16]
 810cb00:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
 810cb02:	2b00      	cmp	r3, #0
 810cb04:	d128      	bne.n	810cb58 <xTaskPriorityDisinherit+0xc8>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready/delayed list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 810cb06:	693b      	ldr	r3, [r7, #16]
 810cb08:	3304      	adds	r3, #4
 810cb0a:	4618      	mov	r0, r3
 810cb0c:	f7fe f906 	bl	810ad1c <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
 810cb10:	693b      	ldr	r3, [r7, #16]
 810cb12:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 810cb14:	693b      	ldr	r3, [r7, #16]
 810cb16:	62da      	str	r2, [r3, #44]	@ 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 810cb18:	693b      	ldr	r3, [r7, #16]
 810cb1a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810cb1c:	f1c3 0238 	rsb	r2, r3, #56	@ 0x38
 810cb20:	693b      	ldr	r3, [r7, #16]
 810cb22:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
 810cb24:	693b      	ldr	r3, [r7, #16]
 810cb26:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810cb28:	4b0f      	ldr	r3, [pc, #60]	@ (810cb68 <xTaskPriorityDisinherit+0xd8>)
 810cb2a:	681b      	ldr	r3, [r3, #0]
 810cb2c:	429a      	cmp	r2, r3
 810cb2e:	d903      	bls.n	810cb38 <xTaskPriorityDisinherit+0xa8>
 810cb30:	693b      	ldr	r3, [r7, #16]
 810cb32:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810cb34:	4a0c      	ldr	r2, [pc, #48]	@ (810cb68 <xTaskPriorityDisinherit+0xd8>)
 810cb36:	6013      	str	r3, [r2, #0]
 810cb38:	693b      	ldr	r3, [r7, #16]
 810cb3a:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
 810cb3c:	4613      	mov	r3, r2
 810cb3e:	009b      	lsls	r3, r3, #2
 810cb40:	4413      	add	r3, r2
 810cb42:	009b      	lsls	r3, r3, #2
 810cb44:	4a09      	ldr	r2, [pc, #36]	@ (810cb6c <xTaskPriorityDisinherit+0xdc>)
 810cb46:	441a      	add	r2, r3
 810cb48:	693b      	ldr	r3, [r7, #16]
 810cb4a:	3304      	adds	r3, #4
 810cb4c:	4619      	mov	r1, r3
 810cb4e:	4610      	mov	r0, r2
 810cb50:	f7fe f887 	bl	810ac62 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
 810cb54:	2301      	movs	r3, #1
 810cb56:	617b      	str	r3, [r7, #20]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
 810cb58:	697b      	ldr	r3, [r7, #20]
	}
 810cb5a:	4618      	mov	r0, r3
 810cb5c:	3718      	adds	r7, #24
 810cb5e:	46bd      	mov	sp, r7
 810cb60:	bd80      	pop	{r7, pc}
 810cb62:	bf00      	nop
 810cb64:	10004f00 	.word	0x10004f00
 810cb68:	100053dc 	.word	0x100053dc
 810cb6c:	10004f04 	.word	0x10004f04

0810cb70 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 810cb70:	b580      	push	{r7, lr}
 810cb72:	b084      	sub	sp, #16
 810cb74:	af00      	add	r7, sp, #0
 810cb76:	6078      	str	r0, [r7, #4]
 810cb78:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 810cb7a:	4b21      	ldr	r3, [pc, #132]	@ (810cc00 <prvAddCurrentTaskToDelayedList+0x90>)
 810cb7c:	681b      	ldr	r3, [r3, #0]
 810cb7e:	60fb      	str	r3, [r7, #12]
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 810cb80:	4b20      	ldr	r3, [pc, #128]	@ (810cc04 <prvAddCurrentTaskToDelayedList+0x94>)
 810cb82:	681b      	ldr	r3, [r3, #0]
 810cb84:	3304      	adds	r3, #4
 810cb86:	4618      	mov	r0, r3
 810cb88:	f7fe f8c8 	bl	810ad1c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 810cb8c:	687b      	ldr	r3, [r7, #4]
 810cb8e:	f1b3 3fff 	cmp.w	r3, #4294967295
 810cb92:	d10a      	bne.n	810cbaa <prvAddCurrentTaskToDelayedList+0x3a>
 810cb94:	683b      	ldr	r3, [r7, #0]
 810cb96:	2b00      	cmp	r3, #0
 810cb98:	d007      	beq.n	810cbaa <prvAddCurrentTaskToDelayedList+0x3a>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 810cb9a:	4b1a      	ldr	r3, [pc, #104]	@ (810cc04 <prvAddCurrentTaskToDelayedList+0x94>)
 810cb9c:	681b      	ldr	r3, [r3, #0]
 810cb9e:	3304      	adds	r3, #4
 810cba0:	4619      	mov	r1, r3
 810cba2:	4819      	ldr	r0, [pc, #100]	@ (810cc08 <prvAddCurrentTaskToDelayedList+0x98>)
 810cba4:	f7fe f85d 	bl	810ac62 <vListInsertEnd>

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 810cba8:	e026      	b.n	810cbf8 <prvAddCurrentTaskToDelayedList+0x88>
			xTimeToWake = xConstTickCount + xTicksToWait;
 810cbaa:	68fa      	ldr	r2, [r7, #12]
 810cbac:	687b      	ldr	r3, [r7, #4]
 810cbae:	4413      	add	r3, r2
 810cbb0:	60bb      	str	r3, [r7, #8]
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 810cbb2:	4b14      	ldr	r3, [pc, #80]	@ (810cc04 <prvAddCurrentTaskToDelayedList+0x94>)
 810cbb4:	681b      	ldr	r3, [r3, #0]
 810cbb6:	68ba      	ldr	r2, [r7, #8]
 810cbb8:	605a      	str	r2, [r3, #4]
			if( xTimeToWake < xConstTickCount )
 810cbba:	68ba      	ldr	r2, [r7, #8]
 810cbbc:	68fb      	ldr	r3, [r7, #12]
 810cbbe:	429a      	cmp	r2, r3
 810cbc0:	d209      	bcs.n	810cbd6 <prvAddCurrentTaskToDelayedList+0x66>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 810cbc2:	4b12      	ldr	r3, [pc, #72]	@ (810cc0c <prvAddCurrentTaskToDelayedList+0x9c>)
 810cbc4:	681a      	ldr	r2, [r3, #0]
 810cbc6:	4b0f      	ldr	r3, [pc, #60]	@ (810cc04 <prvAddCurrentTaskToDelayedList+0x94>)
 810cbc8:	681b      	ldr	r3, [r3, #0]
 810cbca:	3304      	adds	r3, #4
 810cbcc:	4619      	mov	r1, r3
 810cbce:	4610      	mov	r0, r2
 810cbd0:	f7fe f86b 	bl	810acaa <vListInsert>
}
 810cbd4:	e010      	b.n	810cbf8 <prvAddCurrentTaskToDelayedList+0x88>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 810cbd6:	4b0e      	ldr	r3, [pc, #56]	@ (810cc10 <prvAddCurrentTaskToDelayedList+0xa0>)
 810cbd8:	681a      	ldr	r2, [r3, #0]
 810cbda:	4b0a      	ldr	r3, [pc, #40]	@ (810cc04 <prvAddCurrentTaskToDelayedList+0x94>)
 810cbdc:	681b      	ldr	r3, [r3, #0]
 810cbde:	3304      	adds	r3, #4
 810cbe0:	4619      	mov	r1, r3
 810cbe2:	4610      	mov	r0, r2
 810cbe4:	f7fe f861 	bl	810acaa <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 810cbe8:	4b0a      	ldr	r3, [pc, #40]	@ (810cc14 <prvAddCurrentTaskToDelayedList+0xa4>)
 810cbea:	681b      	ldr	r3, [r3, #0]
 810cbec:	68ba      	ldr	r2, [r7, #8]
 810cbee:	429a      	cmp	r2, r3
 810cbf0:	d202      	bcs.n	810cbf8 <prvAddCurrentTaskToDelayedList+0x88>
					xNextTaskUnblockTime = xTimeToWake;
 810cbf2:	4a08      	ldr	r2, [pc, #32]	@ (810cc14 <prvAddCurrentTaskToDelayedList+0xa4>)
 810cbf4:	68bb      	ldr	r3, [r7, #8]
 810cbf6:	6013      	str	r3, [r2, #0]
}
 810cbf8:	bf00      	nop
 810cbfa:	3710      	adds	r7, #16
 810cbfc:	46bd      	mov	sp, r7
 810cbfe:	bd80      	pop	{r7, pc}
 810cc00:	100053d8 	.word	0x100053d8
 810cc04:	10004f00 	.word	0x10004f00
 810cc08:	100053c0 	.word	0x100053c0
 810cc0c:	10005390 	.word	0x10005390
 810cc10:	1000538c 	.word	0x1000538c
 810cc14:	100053f4 	.word	0x100053f4

0810cc18 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
 810cc18:	b580      	push	{r7, lr}
 810cc1a:	b08a      	sub	sp, #40	@ 0x28
 810cc1c:	af04      	add	r7, sp, #16
BaseType_t xReturn = pdFAIL;
 810cc1e:	2300      	movs	r3, #0
 810cc20:	617b      	str	r3, [r7, #20]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
 810cc22:	f000 fb13 	bl	810d24c <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
 810cc26:	4b1d      	ldr	r3, [pc, #116]	@ (810cc9c <xTimerCreateTimerTask+0x84>)
 810cc28:	681b      	ldr	r3, [r3, #0]
 810cc2a:	2b00      	cmp	r3, #0
 810cc2c:	d021      	beq.n	810cc72 <xTimerCreateTimerTask+0x5a>
	{
		#if( configSUPPORT_STATIC_ALLOCATION == 1 )
		{
			StaticTask_t *pxTimerTaskTCBBuffer = NULL;
 810cc2e:	2300      	movs	r3, #0
 810cc30:	60fb      	str	r3, [r7, #12]
			StackType_t *pxTimerTaskStackBuffer = NULL;
 810cc32:	2300      	movs	r3, #0
 810cc34:	60bb      	str	r3, [r7, #8]
			uint32_t ulTimerTaskStackSize;

			vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize );
 810cc36:	1d3a      	adds	r2, r7, #4
 810cc38:	f107 0108 	add.w	r1, r7, #8
 810cc3c:	f107 030c 	add.w	r3, r7, #12
 810cc40:	4618      	mov	r0, r3
 810cc42:	f7fd fdd9 	bl	810a7f8 <vApplicationGetTimerTaskMemory>
			xTimerTaskHandle = xTaskCreateStatic(	prvTimerTask,
 810cc46:	6879      	ldr	r1, [r7, #4]
 810cc48:	68bb      	ldr	r3, [r7, #8]
 810cc4a:	68fa      	ldr	r2, [r7, #12]
 810cc4c:	9202      	str	r2, [sp, #8]
 810cc4e:	9301      	str	r3, [sp, #4]
 810cc50:	2302      	movs	r3, #2
 810cc52:	9300      	str	r3, [sp, #0]
 810cc54:	2300      	movs	r3, #0
 810cc56:	460a      	mov	r2, r1
 810cc58:	4911      	ldr	r1, [pc, #68]	@ (810cca0 <xTimerCreateTimerTask+0x88>)
 810cc5a:	4812      	ldr	r0, [pc, #72]	@ (810cca4 <xTimerCreateTimerTask+0x8c>)
 810cc5c:	f7ff f8d0 	bl	810be00 <xTaskCreateStatic>
 810cc60:	4603      	mov	r3, r0
 810cc62:	4a11      	ldr	r2, [pc, #68]	@ (810cca8 <xTimerCreateTimerTask+0x90>)
 810cc64:	6013      	str	r3, [r2, #0]
													NULL,
													( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT,
													pxTimerTaskStackBuffer,
													pxTimerTaskTCBBuffer );

			if( xTimerTaskHandle != NULL )
 810cc66:	4b10      	ldr	r3, [pc, #64]	@ (810cca8 <xTimerCreateTimerTask+0x90>)
 810cc68:	681b      	ldr	r3, [r3, #0]
 810cc6a:	2b00      	cmp	r3, #0
 810cc6c:	d001      	beq.n	810cc72 <xTimerCreateTimerTask+0x5a>
			{
				xReturn = pdPASS;
 810cc6e:	2301      	movs	r3, #1
 810cc70:	617b      	str	r3, [r7, #20]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
 810cc72:	697b      	ldr	r3, [r7, #20]
 810cc74:	2b00      	cmp	r3, #0
 810cc76:	d10b      	bne.n	810cc90 <xTimerCreateTimerTask+0x78>
	__asm volatile
 810cc78:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810cc7c:	f383 8811 	msr	BASEPRI, r3
 810cc80:	f3bf 8f6f 	isb	sy
 810cc84:	f3bf 8f4f 	dsb	sy
 810cc88:	613b      	str	r3, [r7, #16]
}
 810cc8a:	bf00      	nop
 810cc8c:	bf00      	nop
 810cc8e:	e7fd      	b.n	810cc8c <xTimerCreateTimerTask+0x74>
	return xReturn;
 810cc90:	697b      	ldr	r3, [r7, #20]
}
 810cc92:	4618      	mov	r0, r3
 810cc94:	3718      	adds	r7, #24
 810cc96:	46bd      	mov	sp, r7
 810cc98:	bd80      	pop	{r7, pc}
 810cc9a:	bf00      	nop
 810cc9c:	10005430 	.word	0x10005430
 810cca0:	081108bc 	.word	0x081108bc
 810cca4:	0810cde5 	.word	0x0810cde5
 810cca8:	10005434 	.word	0x10005434

0810ccac <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
 810ccac:	b580      	push	{r7, lr}
 810ccae:	b08a      	sub	sp, #40	@ 0x28
 810ccb0:	af00      	add	r7, sp, #0
 810ccb2:	60f8      	str	r0, [r7, #12]
 810ccb4:	60b9      	str	r1, [r7, #8]
 810ccb6:	607a      	str	r2, [r7, #4]
 810ccb8:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
 810ccba:	2300      	movs	r3, #0
 810ccbc:	627b      	str	r3, [r7, #36]	@ 0x24
DaemonTaskMessage_t xMessage;

	configASSERT( xTimer );
 810ccbe:	68fb      	ldr	r3, [r7, #12]
 810ccc0:	2b00      	cmp	r3, #0
 810ccc2:	d10b      	bne.n	810ccdc <xTimerGenericCommand+0x30>
	__asm volatile
 810ccc4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810ccc8:	f383 8811 	msr	BASEPRI, r3
 810cccc:	f3bf 8f6f 	isb	sy
 810ccd0:	f3bf 8f4f 	dsb	sy
 810ccd4:	623b      	str	r3, [r7, #32]
}
 810ccd6:	bf00      	nop
 810ccd8:	bf00      	nop
 810ccda:	e7fd      	b.n	810ccd8 <xTimerGenericCommand+0x2c>

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
 810ccdc:	4b19      	ldr	r3, [pc, #100]	@ (810cd44 <xTimerGenericCommand+0x98>)
 810ccde:	681b      	ldr	r3, [r3, #0]
 810cce0:	2b00      	cmp	r3, #0
 810cce2:	d02a      	beq.n	810cd3a <xTimerGenericCommand+0x8e>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
 810cce4:	68bb      	ldr	r3, [r7, #8]
 810cce6:	613b      	str	r3, [r7, #16]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
 810cce8:	687b      	ldr	r3, [r7, #4]
 810ccea:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.pxTimer = xTimer;
 810ccec:	68fb      	ldr	r3, [r7, #12]
 810ccee:	61bb      	str	r3, [r7, #24]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
 810ccf0:	68bb      	ldr	r3, [r7, #8]
 810ccf2:	2b05      	cmp	r3, #5
 810ccf4:	dc18      	bgt.n	810cd28 <xTimerGenericCommand+0x7c>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
 810ccf6:	f7ff fead 	bl	810ca54 <xTaskGetSchedulerState>
 810ccfa:	4603      	mov	r3, r0
 810ccfc:	2b02      	cmp	r3, #2
 810ccfe:	d109      	bne.n	810cd14 <xTimerGenericCommand+0x68>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
 810cd00:	4b10      	ldr	r3, [pc, #64]	@ (810cd44 <xTimerGenericCommand+0x98>)
 810cd02:	6818      	ldr	r0, [r3, #0]
 810cd04:	f107 0110 	add.w	r1, r7, #16
 810cd08:	2300      	movs	r3, #0
 810cd0a:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 810cd0c:	f7fe fc3a 	bl	810b584 <xQueueGenericSend>
 810cd10:	6278      	str	r0, [r7, #36]	@ 0x24
 810cd12:	e012      	b.n	810cd3a <xTimerGenericCommand+0x8e>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
 810cd14:	4b0b      	ldr	r3, [pc, #44]	@ (810cd44 <xTimerGenericCommand+0x98>)
 810cd16:	6818      	ldr	r0, [r3, #0]
 810cd18:	f107 0110 	add.w	r1, r7, #16
 810cd1c:	2300      	movs	r3, #0
 810cd1e:	2200      	movs	r2, #0
 810cd20:	f7fe fc30 	bl	810b584 <xQueueGenericSend>
 810cd24:	6278      	str	r0, [r7, #36]	@ 0x24
 810cd26:	e008      	b.n	810cd3a <xTimerGenericCommand+0x8e>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
 810cd28:	4b06      	ldr	r3, [pc, #24]	@ (810cd44 <xTimerGenericCommand+0x98>)
 810cd2a:	6818      	ldr	r0, [r3, #0]
 810cd2c:	f107 0110 	add.w	r1, r7, #16
 810cd30:	2300      	movs	r3, #0
 810cd32:	683a      	ldr	r2, [r7, #0]
 810cd34:	f7fe fd28 	bl	810b788 <xQueueGenericSendFromISR>
 810cd38:	6278      	str	r0, [r7, #36]	@ 0x24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
 810cd3a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
}
 810cd3c:	4618      	mov	r0, r3
 810cd3e:	3728      	adds	r7, #40	@ 0x28
 810cd40:	46bd      	mov	sp, r7
 810cd42:	bd80      	pop	{r7, pc}
 810cd44:	10005430 	.word	0x10005430

0810cd48 <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
 810cd48:	b580      	push	{r7, lr}
 810cd4a:	b088      	sub	sp, #32
 810cd4c:	af02      	add	r7, sp, #8
 810cd4e:	6078      	str	r0, [r7, #4]
 810cd50:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 810cd52:	4b23      	ldr	r3, [pc, #140]	@ (810cde0 <prvProcessExpiredTimer+0x98>)
 810cd54:	681b      	ldr	r3, [r3, #0]
 810cd56:	68db      	ldr	r3, [r3, #12]
 810cd58:	68db      	ldr	r3, [r3, #12]
 810cd5a:	617b      	str	r3, [r7, #20]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 810cd5c:	697b      	ldr	r3, [r7, #20]
 810cd5e:	3304      	adds	r3, #4
 810cd60:	4618      	mov	r0, r3
 810cd62:	f7fd ffdb 	bl	810ad1c <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 810cd66:	697b      	ldr	r3, [r7, #20]
 810cd68:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 810cd6c:	f003 0304 	and.w	r3, r3, #4
 810cd70:	2b00      	cmp	r3, #0
 810cd72:	d023      	beq.n	810cdbc <prvProcessExpiredTimer+0x74>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
 810cd74:	697b      	ldr	r3, [r7, #20]
 810cd76:	699a      	ldr	r2, [r3, #24]
 810cd78:	687b      	ldr	r3, [r7, #4]
 810cd7a:	18d1      	adds	r1, r2, r3
 810cd7c:	687b      	ldr	r3, [r7, #4]
 810cd7e:	683a      	ldr	r2, [r7, #0]
 810cd80:	6978      	ldr	r0, [r7, #20]
 810cd82:	f000 f8d5 	bl	810cf30 <prvInsertTimerInActiveList>
 810cd86:	4603      	mov	r3, r0
 810cd88:	2b00      	cmp	r3, #0
 810cd8a:	d020      	beq.n	810cdce <prvProcessExpiredTimer+0x86>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 810cd8c:	2300      	movs	r3, #0
 810cd8e:	9300      	str	r3, [sp, #0]
 810cd90:	2300      	movs	r3, #0
 810cd92:	687a      	ldr	r2, [r7, #4]
 810cd94:	2100      	movs	r1, #0
 810cd96:	6978      	ldr	r0, [r7, #20]
 810cd98:	f7ff ff88 	bl	810ccac <xTimerGenericCommand>
 810cd9c:	6138      	str	r0, [r7, #16]
			configASSERT( xResult );
 810cd9e:	693b      	ldr	r3, [r7, #16]
 810cda0:	2b00      	cmp	r3, #0
 810cda2:	d114      	bne.n	810cdce <prvProcessExpiredTimer+0x86>
	__asm volatile
 810cda4:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810cda8:	f383 8811 	msr	BASEPRI, r3
 810cdac:	f3bf 8f6f 	isb	sy
 810cdb0:	f3bf 8f4f 	dsb	sy
 810cdb4:	60fb      	str	r3, [r7, #12]
}
 810cdb6:	bf00      	nop
 810cdb8:	bf00      	nop
 810cdba:	e7fd      	b.n	810cdb8 <prvProcessExpiredTimer+0x70>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 810cdbc:	697b      	ldr	r3, [r7, #20]
 810cdbe:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 810cdc2:	f023 0301 	bic.w	r3, r3, #1
 810cdc6:	b2da      	uxtb	r2, r3
 810cdc8:	697b      	ldr	r3, [r7, #20]
 810cdca:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 810cdce:	697b      	ldr	r3, [r7, #20]
 810cdd0:	6a1b      	ldr	r3, [r3, #32]
 810cdd2:	6978      	ldr	r0, [r7, #20]
 810cdd4:	4798      	blx	r3
}
 810cdd6:	bf00      	nop
 810cdd8:	3718      	adds	r7, #24
 810cdda:	46bd      	mov	sp, r7
 810cddc:	bd80      	pop	{r7, pc}
 810cdde:	bf00      	nop
 810cde0:	10005428 	.word	0x10005428

0810cde4 <prvTimerTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
 810cde4:	b580      	push	{r7, lr}
 810cde6:	b084      	sub	sp, #16
 810cde8:	af00      	add	r7, sp, #0
 810cdea:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 810cdec:	f107 0308 	add.w	r3, r7, #8
 810cdf0:	4618      	mov	r0, r3
 810cdf2:	f000 f859 	bl	810cea8 <prvGetNextExpireTime>
 810cdf6:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
 810cdf8:	68bb      	ldr	r3, [r7, #8]
 810cdfa:	4619      	mov	r1, r3
 810cdfc:	68f8      	ldr	r0, [r7, #12]
 810cdfe:	f000 f805 	bl	810ce0c <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
 810ce02:	f000 f8d7 	bl	810cfb4 <prvProcessReceivedCommands>
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
 810ce06:	bf00      	nop
 810ce08:	e7f0      	b.n	810cdec <prvTimerTask+0x8>
	...

0810ce0c <prvProcessTimerOrBlockTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
 810ce0c:	b580      	push	{r7, lr}
 810ce0e:	b084      	sub	sp, #16
 810ce10:	af00      	add	r7, sp, #0
 810ce12:	6078      	str	r0, [r7, #4]
 810ce14:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
 810ce16:	f7ff fa37 	bl	810c288 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 810ce1a:	f107 0308 	add.w	r3, r7, #8
 810ce1e:	4618      	mov	r0, r3
 810ce20:	f000 f866 	bl	810cef0 <prvSampleTimeNow>
 810ce24:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
 810ce26:	68bb      	ldr	r3, [r7, #8]
 810ce28:	2b00      	cmp	r3, #0
 810ce2a:	d130      	bne.n	810ce8e <prvProcessTimerOrBlockTask+0x82>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
 810ce2c:	683b      	ldr	r3, [r7, #0]
 810ce2e:	2b00      	cmp	r3, #0
 810ce30:	d10a      	bne.n	810ce48 <prvProcessTimerOrBlockTask+0x3c>
 810ce32:	687a      	ldr	r2, [r7, #4]
 810ce34:	68fb      	ldr	r3, [r7, #12]
 810ce36:	429a      	cmp	r2, r3
 810ce38:	d806      	bhi.n	810ce48 <prvProcessTimerOrBlockTask+0x3c>
			{
				( void ) xTaskResumeAll();
 810ce3a:	f7ff fa33 	bl	810c2a4 <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
 810ce3e:	68f9      	ldr	r1, [r7, #12]
 810ce40:	6878      	ldr	r0, [r7, #4]
 810ce42:	f7ff ff81 	bl	810cd48 <prvProcessExpiredTimer>
		else
		{
			( void ) xTaskResumeAll();
		}
	}
}
 810ce46:	e024      	b.n	810ce92 <prvProcessTimerOrBlockTask+0x86>
				if( xListWasEmpty != pdFALSE )
 810ce48:	683b      	ldr	r3, [r7, #0]
 810ce4a:	2b00      	cmp	r3, #0
 810ce4c:	d008      	beq.n	810ce60 <prvProcessTimerOrBlockTask+0x54>
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
 810ce4e:	4b13      	ldr	r3, [pc, #76]	@ (810ce9c <prvProcessTimerOrBlockTask+0x90>)
 810ce50:	681b      	ldr	r3, [r3, #0]
 810ce52:	681b      	ldr	r3, [r3, #0]
 810ce54:	2b00      	cmp	r3, #0
 810ce56:	d101      	bne.n	810ce5c <prvProcessTimerOrBlockTask+0x50>
 810ce58:	2301      	movs	r3, #1
 810ce5a:	e000      	b.n	810ce5e <prvProcessTimerOrBlockTask+0x52>
 810ce5c:	2300      	movs	r3, #0
 810ce5e:	603b      	str	r3, [r7, #0]
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
 810ce60:	4b0f      	ldr	r3, [pc, #60]	@ (810cea0 <prvProcessTimerOrBlockTask+0x94>)
 810ce62:	6818      	ldr	r0, [r3, #0]
 810ce64:	687a      	ldr	r2, [r7, #4]
 810ce66:	68fb      	ldr	r3, [r7, #12]
 810ce68:	1ad3      	subs	r3, r2, r3
 810ce6a:	683a      	ldr	r2, [r7, #0]
 810ce6c:	4619      	mov	r1, r3
 810ce6e:	f7fe ff93 	bl	810bd98 <vQueueWaitForMessageRestricted>
				if( xTaskResumeAll() == pdFALSE )
 810ce72:	f7ff fa17 	bl	810c2a4 <xTaskResumeAll>
 810ce76:	4603      	mov	r3, r0
 810ce78:	2b00      	cmp	r3, #0
 810ce7a:	d10a      	bne.n	810ce92 <prvProcessTimerOrBlockTask+0x86>
					portYIELD_WITHIN_API();
 810ce7c:	4b09      	ldr	r3, [pc, #36]	@ (810cea4 <prvProcessTimerOrBlockTask+0x98>)
 810ce7e:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 810ce82:	601a      	str	r2, [r3, #0]
 810ce84:	f3bf 8f4f 	dsb	sy
 810ce88:	f3bf 8f6f 	isb	sy
}
 810ce8c:	e001      	b.n	810ce92 <prvProcessTimerOrBlockTask+0x86>
			( void ) xTaskResumeAll();
 810ce8e:	f7ff fa09 	bl	810c2a4 <xTaskResumeAll>
}
 810ce92:	bf00      	nop
 810ce94:	3710      	adds	r7, #16
 810ce96:	46bd      	mov	sp, r7
 810ce98:	bd80      	pop	{r7, pc}
 810ce9a:	bf00      	nop
 810ce9c:	1000542c 	.word	0x1000542c
 810cea0:	10005430 	.word	0x10005430
 810cea4:	e000ed04 	.word	0xe000ed04

0810cea8 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
 810cea8:	b480      	push	{r7}
 810ceaa:	b085      	sub	sp, #20
 810ceac:	af00      	add	r7, sp, #0
 810ceae:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
 810ceb0:	4b0e      	ldr	r3, [pc, #56]	@ (810ceec <prvGetNextExpireTime+0x44>)
 810ceb2:	681b      	ldr	r3, [r3, #0]
 810ceb4:	681b      	ldr	r3, [r3, #0]
 810ceb6:	2b00      	cmp	r3, #0
 810ceb8:	d101      	bne.n	810cebe <prvGetNextExpireTime+0x16>
 810ceba:	2201      	movs	r2, #1
 810cebc:	e000      	b.n	810cec0 <prvGetNextExpireTime+0x18>
 810cebe:	2200      	movs	r2, #0
 810cec0:	687b      	ldr	r3, [r7, #4]
 810cec2:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
 810cec4:	687b      	ldr	r3, [r7, #4]
 810cec6:	681b      	ldr	r3, [r3, #0]
 810cec8:	2b00      	cmp	r3, #0
 810ceca:	d105      	bne.n	810ced8 <prvGetNextExpireTime+0x30>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 810cecc:	4b07      	ldr	r3, [pc, #28]	@ (810ceec <prvGetNextExpireTime+0x44>)
 810cece:	681b      	ldr	r3, [r3, #0]
 810ced0:	68db      	ldr	r3, [r3, #12]
 810ced2:	681b      	ldr	r3, [r3, #0]
 810ced4:	60fb      	str	r3, [r7, #12]
 810ced6:	e001      	b.n	810cedc <prvGetNextExpireTime+0x34>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
 810ced8:	2300      	movs	r3, #0
 810ceda:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
 810cedc:	68fb      	ldr	r3, [r7, #12]
}
 810cede:	4618      	mov	r0, r3
 810cee0:	3714      	adds	r7, #20
 810cee2:	46bd      	mov	sp, r7
 810cee4:	f85d 7b04 	ldr.w	r7, [sp], #4
 810cee8:	4770      	bx	lr
 810ceea:	bf00      	nop
 810ceec:	10005428 	.word	0x10005428

0810cef0 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
 810cef0:	b580      	push	{r7, lr}
 810cef2:	b084      	sub	sp, #16
 810cef4:	af00      	add	r7, sp, #0
 810cef6:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
 810cef8:	f7ff fa72 	bl	810c3e0 <xTaskGetTickCount>
 810cefc:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
 810cefe:	4b0b      	ldr	r3, [pc, #44]	@ (810cf2c <prvSampleTimeNow+0x3c>)
 810cf00:	681b      	ldr	r3, [r3, #0]
 810cf02:	68fa      	ldr	r2, [r7, #12]
 810cf04:	429a      	cmp	r2, r3
 810cf06:	d205      	bcs.n	810cf14 <prvSampleTimeNow+0x24>
	{
		prvSwitchTimerLists();
 810cf08:	f000 f93a 	bl	810d180 <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
 810cf0c:	687b      	ldr	r3, [r7, #4]
 810cf0e:	2201      	movs	r2, #1
 810cf10:	601a      	str	r2, [r3, #0]
 810cf12:	e002      	b.n	810cf1a <prvSampleTimeNow+0x2a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
 810cf14:	687b      	ldr	r3, [r7, #4]
 810cf16:	2200      	movs	r2, #0
 810cf18:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
 810cf1a:	4a04      	ldr	r2, [pc, #16]	@ (810cf2c <prvSampleTimeNow+0x3c>)
 810cf1c:	68fb      	ldr	r3, [r7, #12]
 810cf1e:	6013      	str	r3, [r2, #0]

	return xTimeNow;
 810cf20:	68fb      	ldr	r3, [r7, #12]
}
 810cf22:	4618      	mov	r0, r3
 810cf24:	3710      	adds	r7, #16
 810cf26:	46bd      	mov	sp, r7
 810cf28:	bd80      	pop	{r7, pc}
 810cf2a:	bf00      	nop
 810cf2c:	10005438 	.word	0x10005438

0810cf30 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
 810cf30:	b580      	push	{r7, lr}
 810cf32:	b086      	sub	sp, #24
 810cf34:	af00      	add	r7, sp, #0
 810cf36:	60f8      	str	r0, [r7, #12]
 810cf38:	60b9      	str	r1, [r7, #8]
 810cf3a:	607a      	str	r2, [r7, #4]
 810cf3c:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
 810cf3e:	2300      	movs	r3, #0
 810cf40:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
 810cf42:	68fb      	ldr	r3, [r7, #12]
 810cf44:	68ba      	ldr	r2, [r7, #8]
 810cf46:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 810cf48:	68fb      	ldr	r3, [r7, #12]
 810cf4a:	68fa      	ldr	r2, [r7, #12]
 810cf4c:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
 810cf4e:	68ba      	ldr	r2, [r7, #8]
 810cf50:	687b      	ldr	r3, [r7, #4]
 810cf52:	429a      	cmp	r2, r3
 810cf54:	d812      	bhi.n	810cf7c <prvInsertTimerInActiveList+0x4c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 810cf56:	687a      	ldr	r2, [r7, #4]
 810cf58:	683b      	ldr	r3, [r7, #0]
 810cf5a:	1ad2      	subs	r2, r2, r3
 810cf5c:	68fb      	ldr	r3, [r7, #12]
 810cf5e:	699b      	ldr	r3, [r3, #24]
 810cf60:	429a      	cmp	r2, r3
 810cf62:	d302      	bcc.n	810cf6a <prvInsertTimerInActiveList+0x3a>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
 810cf64:	2301      	movs	r3, #1
 810cf66:	617b      	str	r3, [r7, #20]
 810cf68:	e01b      	b.n	810cfa2 <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
 810cf6a:	4b10      	ldr	r3, [pc, #64]	@ (810cfac <prvInsertTimerInActiveList+0x7c>)
 810cf6c:	681a      	ldr	r2, [r3, #0]
 810cf6e:	68fb      	ldr	r3, [r7, #12]
 810cf70:	3304      	adds	r3, #4
 810cf72:	4619      	mov	r1, r3
 810cf74:	4610      	mov	r0, r2
 810cf76:	f7fd fe98 	bl	810acaa <vListInsert>
 810cf7a:	e012      	b.n	810cfa2 <prvInsertTimerInActiveList+0x72>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
 810cf7c:	687a      	ldr	r2, [r7, #4]
 810cf7e:	683b      	ldr	r3, [r7, #0]
 810cf80:	429a      	cmp	r2, r3
 810cf82:	d206      	bcs.n	810cf92 <prvInsertTimerInActiveList+0x62>
 810cf84:	68ba      	ldr	r2, [r7, #8]
 810cf86:	683b      	ldr	r3, [r7, #0]
 810cf88:	429a      	cmp	r2, r3
 810cf8a:	d302      	bcc.n	810cf92 <prvInsertTimerInActiveList+0x62>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
 810cf8c:	2301      	movs	r3, #1
 810cf8e:	617b      	str	r3, [r7, #20]
 810cf90:	e007      	b.n	810cfa2 <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 810cf92:	4b07      	ldr	r3, [pc, #28]	@ (810cfb0 <prvInsertTimerInActiveList+0x80>)
 810cf94:	681a      	ldr	r2, [r3, #0]
 810cf96:	68fb      	ldr	r3, [r7, #12]
 810cf98:	3304      	adds	r3, #4
 810cf9a:	4619      	mov	r1, r3
 810cf9c:	4610      	mov	r0, r2
 810cf9e:	f7fd fe84 	bl	810acaa <vListInsert>
		}
	}

	return xProcessTimerNow;
 810cfa2:	697b      	ldr	r3, [r7, #20]
}
 810cfa4:	4618      	mov	r0, r3
 810cfa6:	3718      	adds	r7, #24
 810cfa8:	46bd      	mov	sp, r7
 810cfaa:	bd80      	pop	{r7, pc}
 810cfac:	1000542c 	.word	0x1000542c
 810cfb0:	10005428 	.word	0x10005428

0810cfb4 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
 810cfb4:	b580      	push	{r7, lr}
 810cfb6:	b08e      	sub	sp, #56	@ 0x38
 810cfb8:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 810cfba:	e0ce      	b.n	810d15a <prvProcessReceivedCommands+0x1a6>
	{
		#if ( INCLUDE_xTimerPendFunctionCall == 1 )
		{
			/* Negative commands are pended function calls rather than timer
			commands. */
			if( xMessage.xMessageID < ( BaseType_t ) 0 )
 810cfbc:	687b      	ldr	r3, [r7, #4]
 810cfbe:	2b00      	cmp	r3, #0
 810cfc0:	da19      	bge.n	810cff6 <prvProcessReceivedCommands+0x42>
			{
				const CallbackParameters_t * const pxCallback = &( xMessage.u.xCallbackParameters );
 810cfc2:	1d3b      	adds	r3, r7, #4
 810cfc4:	3304      	adds	r3, #4
 810cfc6:	62fb      	str	r3, [r7, #44]	@ 0x2c

				/* The timer uses the xCallbackParameters member to request a
				callback be executed.  Check the callback is not NULL. */
				configASSERT( pxCallback );
 810cfc8:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810cfca:	2b00      	cmp	r3, #0
 810cfcc:	d10b      	bne.n	810cfe6 <prvProcessReceivedCommands+0x32>
	__asm volatile
 810cfce:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810cfd2:	f383 8811 	msr	BASEPRI, r3
 810cfd6:	f3bf 8f6f 	isb	sy
 810cfda:	f3bf 8f4f 	dsb	sy
 810cfde:	61fb      	str	r3, [r7, #28]
}
 810cfe0:	bf00      	nop
 810cfe2:	bf00      	nop
 810cfe4:	e7fd      	b.n	810cfe2 <prvProcessReceivedCommands+0x2e>

				/* Call the function. */
				pxCallback->pxCallbackFunction( pxCallback->pvParameter1, pxCallback->ulParameter2 );
 810cfe6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810cfe8:	681b      	ldr	r3, [r3, #0]
 810cfea:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 810cfec:	6850      	ldr	r0, [r2, #4]
 810cfee:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 810cff0:	6892      	ldr	r2, [r2, #8]
 810cff2:	4611      	mov	r1, r2
 810cff4:	4798      	blx	r3
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
 810cff6:	687b      	ldr	r3, [r7, #4]
 810cff8:	2b00      	cmp	r3, #0
 810cffa:	f2c0 80ae 	blt.w	810d15a <prvProcessReceivedCommands+0x1a6>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
 810cffe:	68fb      	ldr	r3, [r7, #12]
 810d000:	62bb      	str	r3, [r7, #40]	@ 0x28

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
 810d002:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d004:	695b      	ldr	r3, [r3, #20]
 810d006:	2b00      	cmp	r3, #0
 810d008:	d004      	beq.n	810d014 <prvProcessReceivedCommands+0x60>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 810d00a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d00c:	3304      	adds	r3, #4
 810d00e:	4618      	mov	r0, r3
 810d010:	f7fd fe84 	bl	810ad1c <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
 810d014:	463b      	mov	r3, r7
 810d016:	4618      	mov	r0, r3
 810d018:	f7ff ff6a 	bl	810cef0 <prvSampleTimeNow>
 810d01c:	6278      	str	r0, [r7, #36]	@ 0x24

			switch( xMessage.xMessageID )
 810d01e:	687b      	ldr	r3, [r7, #4]
 810d020:	2b09      	cmp	r3, #9
 810d022:	f200 8097 	bhi.w	810d154 <prvProcessReceivedCommands+0x1a0>
 810d026:	a201      	add	r2, pc, #4	@ (adr r2, 810d02c <prvProcessReceivedCommands+0x78>)
 810d028:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 810d02c:	0810d055 	.word	0x0810d055
 810d030:	0810d055 	.word	0x0810d055
 810d034:	0810d055 	.word	0x0810d055
 810d038:	0810d0cb 	.word	0x0810d0cb
 810d03c:	0810d0df 	.word	0x0810d0df
 810d040:	0810d12b 	.word	0x0810d12b
 810d044:	0810d055 	.word	0x0810d055
 810d048:	0810d055 	.word	0x0810d055
 810d04c:	0810d0cb 	.word	0x0810d0cb
 810d050:	0810d0df 	.word	0x0810d0df
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 810d054:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d056:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 810d05a:	f043 0301 	orr.w	r3, r3, #1
 810d05e:	b2da      	uxtb	r2, r3
 810d060:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d062:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
 810d066:	68ba      	ldr	r2, [r7, #8]
 810d068:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d06a:	699b      	ldr	r3, [r3, #24]
 810d06c:	18d1      	adds	r1, r2, r3
 810d06e:	68bb      	ldr	r3, [r7, #8]
 810d070:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 810d072:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810d074:	f7ff ff5c 	bl	810cf30 <prvInsertTimerInActiveList>
 810d078:	4603      	mov	r3, r0
 810d07a:	2b00      	cmp	r3, #0
 810d07c:	d06c      	beq.n	810d158 <prvProcessReceivedCommands+0x1a4>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 810d07e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d080:	6a1b      	ldr	r3, [r3, #32]
 810d082:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810d084:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 810d086:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d088:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 810d08c:	f003 0304 	and.w	r3, r3, #4
 810d090:	2b00      	cmp	r3, #0
 810d092:	d061      	beq.n	810d158 <prvProcessReceivedCommands+0x1a4>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
 810d094:	68ba      	ldr	r2, [r7, #8]
 810d096:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d098:	699b      	ldr	r3, [r3, #24]
 810d09a:	441a      	add	r2, r3
 810d09c:	2300      	movs	r3, #0
 810d09e:	9300      	str	r3, [sp, #0]
 810d0a0:	2300      	movs	r3, #0
 810d0a2:	2100      	movs	r1, #0
 810d0a4:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810d0a6:	f7ff fe01 	bl	810ccac <xTimerGenericCommand>
 810d0aa:	6238      	str	r0, [r7, #32]
							configASSERT( xResult );
 810d0ac:	6a3b      	ldr	r3, [r7, #32]
 810d0ae:	2b00      	cmp	r3, #0
 810d0b0:	d152      	bne.n	810d158 <prvProcessReceivedCommands+0x1a4>
	__asm volatile
 810d0b2:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810d0b6:	f383 8811 	msr	BASEPRI, r3
 810d0ba:	f3bf 8f6f 	isb	sy
 810d0be:	f3bf 8f4f 	dsb	sy
 810d0c2:	61bb      	str	r3, [r7, #24]
}
 810d0c4:	bf00      	nop
 810d0c6:	bf00      	nop
 810d0c8:	e7fd      	b.n	810d0c6 <prvProcessReceivedCommands+0x112>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 810d0ca:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d0cc:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 810d0d0:	f023 0301 	bic.w	r3, r3, #1
 810d0d4:	b2da      	uxtb	r2, r3
 810d0d6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d0d8:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
					break;
 810d0dc:	e03d      	b.n	810d15a <prvProcessReceivedCommands+0x1a6>

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
 810d0de:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d0e0:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 810d0e4:	f043 0301 	orr.w	r3, r3, #1
 810d0e8:	b2da      	uxtb	r2, r3
 810d0ea:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d0ec:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
 810d0f0:	68ba      	ldr	r2, [r7, #8]
 810d0f2:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d0f4:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
 810d0f6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d0f8:	699b      	ldr	r3, [r3, #24]
 810d0fa:	2b00      	cmp	r3, #0
 810d0fc:	d10b      	bne.n	810d116 <prvProcessReceivedCommands+0x162>
	__asm volatile
 810d0fe:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810d102:	f383 8811 	msr	BASEPRI, r3
 810d106:	f3bf 8f6f 	isb	sy
 810d10a:	f3bf 8f4f 	dsb	sy
 810d10e:	617b      	str	r3, [r7, #20]
}
 810d110:	bf00      	nop
 810d112:	bf00      	nop
 810d114:	e7fd      	b.n	810d112 <prvProcessReceivedCommands+0x15e>
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
 810d116:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d118:	699a      	ldr	r2, [r3, #24]
 810d11a:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810d11c:	18d1      	adds	r1, r2, r3
 810d11e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810d120:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 810d122:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810d124:	f7ff ff04 	bl	810cf30 <prvInsertTimerInActiveList>
					break;
 810d128:	e017      	b.n	810d15a <prvProcessReceivedCommands+0x1a6>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
 810d12a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d12c:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 810d130:	f003 0302 	and.w	r3, r3, #2
 810d134:	2b00      	cmp	r3, #0
 810d136:	d103      	bne.n	810d140 <prvProcessReceivedCommands+0x18c>
						{
							vPortFree( pxTimer );
 810d138:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810d13a:	f7fd fc45 	bl	810a9c8 <vPortFree>
						no need to free the memory - just mark the timer as
						"not active". */
						pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
					}
					#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
					break;
 810d13e:	e00c      	b.n	810d15a <prvProcessReceivedCommands+0x1a6>
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
 810d140:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d142:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 810d146:	f023 0301 	bic.w	r3, r3, #1
 810d14a:	b2da      	uxtb	r2, r3
 810d14c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810d14e:	f883 2028 	strb.w	r2, [r3, #40]	@ 0x28
					break;
 810d152:	e002      	b.n	810d15a <prvProcessReceivedCommands+0x1a6>

				default	:
					/* Don't expect to get here. */
					break;
 810d154:	bf00      	nop
 810d156:	e000      	b.n	810d15a <prvProcessReceivedCommands+0x1a6>
					break;
 810d158:	bf00      	nop
	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
 810d15a:	4b08      	ldr	r3, [pc, #32]	@ (810d17c <prvProcessReceivedCommands+0x1c8>)
 810d15c:	681b      	ldr	r3, [r3, #0]
 810d15e:	1d39      	adds	r1, r7, #4
 810d160:	2200      	movs	r2, #0
 810d162:	4618      	mov	r0, r3
 810d164:	f7fe fbae 	bl	810b8c4 <xQueueReceive>
 810d168:	4603      	mov	r3, r0
 810d16a:	2b00      	cmp	r3, #0
 810d16c:	f47f af26 	bne.w	810cfbc <prvProcessReceivedCommands+0x8>
			}
		}
	}
}
 810d170:	bf00      	nop
 810d172:	bf00      	nop
 810d174:	3730      	adds	r7, #48	@ 0x30
 810d176:	46bd      	mov	sp, r7
 810d178:	bd80      	pop	{r7, pc}
 810d17a:	bf00      	nop
 810d17c:	10005430 	.word	0x10005430

0810d180 <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
 810d180:	b580      	push	{r7, lr}
 810d182:	b088      	sub	sp, #32
 810d184:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 810d186:	e049      	b.n	810d21c <prvSwitchTimerLists+0x9c>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
 810d188:	4b2e      	ldr	r3, [pc, #184]	@ (810d244 <prvSwitchTimerLists+0xc4>)
 810d18a:	681b      	ldr	r3, [r3, #0]
 810d18c:	68db      	ldr	r3, [r3, #12]
 810d18e:	681b      	ldr	r3, [r3, #0]
 810d190:	613b      	str	r3, [r7, #16]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 810d192:	4b2c      	ldr	r3, [pc, #176]	@ (810d244 <prvSwitchTimerLists+0xc4>)
 810d194:	681b      	ldr	r3, [r3, #0]
 810d196:	68db      	ldr	r3, [r3, #12]
 810d198:	68db      	ldr	r3, [r3, #12]
 810d19a:	60fb      	str	r3, [r7, #12]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
 810d19c:	68fb      	ldr	r3, [r7, #12]
 810d19e:	3304      	adds	r3, #4
 810d1a0:	4618      	mov	r0, r3
 810d1a2:	f7fd fdbb 	bl	810ad1c <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
 810d1a6:	68fb      	ldr	r3, [r7, #12]
 810d1a8:	6a1b      	ldr	r3, [r3, #32]
 810d1aa:	68f8      	ldr	r0, [r7, #12]
 810d1ac:	4798      	blx	r3

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
 810d1ae:	68fb      	ldr	r3, [r7, #12]
 810d1b0:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
 810d1b4:	f003 0304 	and.w	r3, r3, #4
 810d1b8:	2b00      	cmp	r3, #0
 810d1ba:	d02f      	beq.n	810d21c <prvSwitchTimerLists+0x9c>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
 810d1bc:	68fb      	ldr	r3, [r7, #12]
 810d1be:	699b      	ldr	r3, [r3, #24]
 810d1c0:	693a      	ldr	r2, [r7, #16]
 810d1c2:	4413      	add	r3, r2
 810d1c4:	60bb      	str	r3, [r7, #8]
			if( xReloadTime > xNextExpireTime )
 810d1c6:	68ba      	ldr	r2, [r7, #8]
 810d1c8:	693b      	ldr	r3, [r7, #16]
 810d1ca:	429a      	cmp	r2, r3
 810d1cc:	d90e      	bls.n	810d1ec <prvSwitchTimerLists+0x6c>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
 810d1ce:	68fb      	ldr	r3, [r7, #12]
 810d1d0:	68ba      	ldr	r2, [r7, #8]
 810d1d2:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
 810d1d4:	68fb      	ldr	r3, [r7, #12]
 810d1d6:	68fa      	ldr	r2, [r7, #12]
 810d1d8:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
 810d1da:	4b1a      	ldr	r3, [pc, #104]	@ (810d244 <prvSwitchTimerLists+0xc4>)
 810d1dc:	681a      	ldr	r2, [r3, #0]
 810d1de:	68fb      	ldr	r3, [r7, #12]
 810d1e0:	3304      	adds	r3, #4
 810d1e2:	4619      	mov	r1, r3
 810d1e4:	4610      	mov	r0, r2
 810d1e6:	f7fd fd60 	bl	810acaa <vListInsert>
 810d1ea:	e017      	b.n	810d21c <prvSwitchTimerLists+0x9c>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
 810d1ec:	2300      	movs	r3, #0
 810d1ee:	9300      	str	r3, [sp, #0]
 810d1f0:	2300      	movs	r3, #0
 810d1f2:	693a      	ldr	r2, [r7, #16]
 810d1f4:	2100      	movs	r1, #0
 810d1f6:	68f8      	ldr	r0, [r7, #12]
 810d1f8:	f7ff fd58 	bl	810ccac <xTimerGenericCommand>
 810d1fc:	6078      	str	r0, [r7, #4]
				configASSERT( xResult );
 810d1fe:	687b      	ldr	r3, [r7, #4]
 810d200:	2b00      	cmp	r3, #0
 810d202:	d10b      	bne.n	810d21c <prvSwitchTimerLists+0x9c>
	__asm volatile
 810d204:	f04f 0350 	mov.w	r3, #80	@ 0x50
 810d208:	f383 8811 	msr	BASEPRI, r3
 810d20c:	f3bf 8f6f 	isb	sy
 810d210:	f3bf 8f4f 	dsb	sy
 810d214:	603b      	str	r3, [r7, #0]
}
 810d216:	bf00      	nop
 810d218:	bf00      	nop
 810d21a:	e7fd      	b.n	810d218 <prvSwitchTimerLists+0x98>
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
 810d21c:	4b09      	ldr	r3, [pc, #36]	@ (810d244 <prvSwitchTimerLists+0xc4>)
 810d21e:	681b      	ldr	r3, [r3, #0]
 810d220:	681b      	ldr	r3, [r3, #0]
 810d222:	2b00      	cmp	r3, #0
 810d224:	d1b0      	bne.n	810d188 <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
 810d226:	4b07      	ldr	r3, [pc, #28]	@ (810d244 <prvSwitchTimerLists+0xc4>)
 810d228:	681b      	ldr	r3, [r3, #0]
 810d22a:	617b      	str	r3, [r7, #20]
	pxCurrentTimerList = pxOverflowTimerList;
 810d22c:	4b06      	ldr	r3, [pc, #24]	@ (810d248 <prvSwitchTimerLists+0xc8>)
 810d22e:	681b      	ldr	r3, [r3, #0]
 810d230:	4a04      	ldr	r2, [pc, #16]	@ (810d244 <prvSwitchTimerLists+0xc4>)
 810d232:	6013      	str	r3, [r2, #0]
	pxOverflowTimerList = pxTemp;
 810d234:	4a04      	ldr	r2, [pc, #16]	@ (810d248 <prvSwitchTimerLists+0xc8>)
 810d236:	697b      	ldr	r3, [r7, #20]
 810d238:	6013      	str	r3, [r2, #0]
}
 810d23a:	bf00      	nop
 810d23c:	3718      	adds	r7, #24
 810d23e:	46bd      	mov	sp, r7
 810d240:	bd80      	pop	{r7, pc}
 810d242:	bf00      	nop
 810d244:	10005428 	.word	0x10005428
 810d248:	1000542c 	.word	0x1000542c

0810d24c <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
 810d24c:	b580      	push	{r7, lr}
 810d24e:	b082      	sub	sp, #8
 810d250:	af02      	add	r7, sp, #8
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
 810d252:	f7fd fec1 	bl	810afd8 <vPortEnterCritical>
	{
		if( xTimerQueue == NULL )
 810d256:	4b15      	ldr	r3, [pc, #84]	@ (810d2ac <prvCheckForValidListAndQueue+0x60>)
 810d258:	681b      	ldr	r3, [r3, #0]
 810d25a:	2b00      	cmp	r3, #0
 810d25c:	d120      	bne.n	810d2a0 <prvCheckForValidListAndQueue+0x54>
		{
			vListInitialise( &xActiveTimerList1 );
 810d25e:	4814      	ldr	r0, [pc, #80]	@ (810d2b0 <prvCheckForValidListAndQueue+0x64>)
 810d260:	f7fd fcd2 	bl	810ac08 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
 810d264:	4813      	ldr	r0, [pc, #76]	@ (810d2b4 <prvCheckForValidListAndQueue+0x68>)
 810d266:	f7fd fccf 	bl	810ac08 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
 810d26a:	4b13      	ldr	r3, [pc, #76]	@ (810d2b8 <prvCheckForValidListAndQueue+0x6c>)
 810d26c:	4a10      	ldr	r2, [pc, #64]	@ (810d2b0 <prvCheckForValidListAndQueue+0x64>)
 810d26e:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
 810d270:	4b12      	ldr	r3, [pc, #72]	@ (810d2bc <prvCheckForValidListAndQueue+0x70>)
 810d272:	4a10      	ldr	r2, [pc, #64]	@ (810d2b4 <prvCheckForValidListAndQueue+0x68>)
 810d274:	601a      	str	r2, [r3, #0]
				/* The timer queue is allocated statically in case
				configSUPPORT_DYNAMIC_ALLOCATION is 0. */
				static StaticQueue_t xStaticTimerQueue; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */
				static uint8_t ucStaticTimerQueueStorage[ ( size_t ) configTIMER_QUEUE_LENGTH * sizeof( DaemonTaskMessage_t ) ]; /*lint !e956 Ok to declare in this manner to prevent additional conditional compilation guards in other locations. */

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
 810d276:	2300      	movs	r3, #0
 810d278:	9300      	str	r3, [sp, #0]
 810d27a:	4b11      	ldr	r3, [pc, #68]	@ (810d2c0 <prvCheckForValidListAndQueue+0x74>)
 810d27c:	4a11      	ldr	r2, [pc, #68]	@ (810d2c4 <prvCheckForValidListAndQueue+0x78>)
 810d27e:	2110      	movs	r1, #16
 810d280:	200a      	movs	r0, #10
 810d282:	f7fe f835 	bl	810b2f0 <xQueueGenericCreateStatic>
 810d286:	4603      	mov	r3, r0
 810d288:	4a08      	ldr	r2, [pc, #32]	@ (810d2ac <prvCheckForValidListAndQueue+0x60>)
 810d28a:	6013      	str	r3, [r2, #0]
			}
			#endif

			#if ( configQUEUE_REGISTRY_SIZE > 0 )
			{
				if( xTimerQueue != NULL )
 810d28c:	4b07      	ldr	r3, [pc, #28]	@ (810d2ac <prvCheckForValidListAndQueue+0x60>)
 810d28e:	681b      	ldr	r3, [r3, #0]
 810d290:	2b00      	cmp	r3, #0
 810d292:	d005      	beq.n	810d2a0 <prvCheckForValidListAndQueue+0x54>
				{
					vQueueAddToRegistry( xTimerQueue, "TmrQ" );
 810d294:	4b05      	ldr	r3, [pc, #20]	@ (810d2ac <prvCheckForValidListAndQueue+0x60>)
 810d296:	681b      	ldr	r3, [r3, #0]
 810d298:	490b      	ldr	r1, [pc, #44]	@ (810d2c8 <prvCheckForValidListAndQueue+0x7c>)
 810d29a:	4618      	mov	r0, r3
 810d29c:	f7fe fd28 	bl	810bcf0 <vQueueAddToRegistry>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 810d2a0:	f7fd fecc 	bl	810b03c <vPortExitCritical>
}
 810d2a4:	bf00      	nop
 810d2a6:	46bd      	mov	sp, r7
 810d2a8:	bd80      	pop	{r7, pc}
 810d2aa:	bf00      	nop
 810d2ac:	10005430 	.word	0x10005430
 810d2b0:	10005400 	.word	0x10005400
 810d2b4:	10005414 	.word	0x10005414
 810d2b8:	10005428 	.word	0x10005428
 810d2bc:	1000542c 	.word	0x1000542c
 810d2c0:	100054dc 	.word	0x100054dc
 810d2c4:	1000543c 	.word	0x1000543c
 810d2c8:	081108c4 	.word	0x081108c4

0810d2cc <metal_list_init>:
 */
#define METAL_DECLARE_LIST(name)			\
	struct metal_list name = METAL_INIT_LIST(name)

static inline void metal_list_init(struct metal_list *list)
{
 810d2cc:	b480      	push	{r7}
 810d2ce:	b083      	sub	sp, #12
 810d2d0:	af00      	add	r7, sp, #0
 810d2d2:	6078      	str	r0, [r7, #4]
	list->next = list->prev = list;
 810d2d4:	687b      	ldr	r3, [r7, #4]
 810d2d6:	687a      	ldr	r2, [r7, #4]
 810d2d8:	605a      	str	r2, [r3, #4]
 810d2da:	687b      	ldr	r3, [r7, #4]
 810d2dc:	685a      	ldr	r2, [r3, #4]
 810d2de:	687b      	ldr	r3, [r7, #4]
 810d2e0:	601a      	str	r2, [r3, #0]
}
 810d2e2:	bf00      	nop
 810d2e4:	370c      	adds	r7, #12
 810d2e6:	46bd      	mov	sp, r7
 810d2e8:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d2ec:	4770      	bx	lr

0810d2ee <metal_list_add_before>:

static inline void metal_list_add_before(struct metal_list *node,
					 struct metal_list *new_node)
{
 810d2ee:	b480      	push	{r7}
 810d2f0:	b083      	sub	sp, #12
 810d2f2:	af00      	add	r7, sp, #0
 810d2f4:	6078      	str	r0, [r7, #4]
 810d2f6:	6039      	str	r1, [r7, #0]
	new_node->prev = node->prev;
 810d2f8:	687b      	ldr	r3, [r7, #4]
 810d2fa:	685a      	ldr	r2, [r3, #4]
 810d2fc:	683b      	ldr	r3, [r7, #0]
 810d2fe:	605a      	str	r2, [r3, #4]
	new_node->next = node;
 810d300:	683b      	ldr	r3, [r7, #0]
 810d302:	687a      	ldr	r2, [r7, #4]
 810d304:	601a      	str	r2, [r3, #0]
	new_node->next->prev = new_node;
 810d306:	683b      	ldr	r3, [r7, #0]
 810d308:	681b      	ldr	r3, [r3, #0]
 810d30a:	683a      	ldr	r2, [r7, #0]
 810d30c:	605a      	str	r2, [r3, #4]
	new_node->prev->next = new_node;
 810d30e:	683b      	ldr	r3, [r7, #0]
 810d310:	685b      	ldr	r3, [r3, #4]
 810d312:	683a      	ldr	r2, [r7, #0]
 810d314:	601a      	str	r2, [r3, #0]
}
 810d316:	bf00      	nop
 810d318:	370c      	adds	r7, #12
 810d31a:	46bd      	mov	sp, r7
 810d31c:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d320:	4770      	bx	lr

0810d322 <metal_list_add_tail>:
	metal_list_add_after(list, node);
}

static inline void metal_list_add_tail(struct metal_list *list,
				       struct metal_list *node)
{
 810d322:	b580      	push	{r7, lr}
 810d324:	b082      	sub	sp, #8
 810d326:	af00      	add	r7, sp, #0
 810d328:	6078      	str	r0, [r7, #4]
 810d32a:	6039      	str	r1, [r7, #0]
	metal_list_add_before(list, node);
 810d32c:	6839      	ldr	r1, [r7, #0]
 810d32e:	6878      	ldr	r0, [r7, #4]
 810d330:	f7ff ffdd 	bl	810d2ee <metal_list_add_before>
}
 810d334:	bf00      	nop
 810d336:	3708      	adds	r7, #8
 810d338:	46bd      	mov	sp, r7
 810d33a:	bd80      	pop	{r7, pc}

0810d33c <__metal_cache_flush>:

extern void metal_machine_cache_flush(void *addr, unsigned int len);
extern void metal_machine_cache_invalidate(void *addr, unsigned int len);

static inline void __metal_cache_flush(void *addr, unsigned int len)
{
 810d33c:	b580      	push	{r7, lr}
 810d33e:	b082      	sub	sp, #8
 810d340:	af00      	add	r7, sp, #0
 810d342:	6078      	str	r0, [r7, #4]
 810d344:	6039      	str	r1, [r7, #0]
	metal_machine_cache_flush(addr, len);
 810d346:	6839      	ldr	r1, [r7, #0]
 810d348:	6878      	ldr	r0, [r7, #4]
 810d34a:	f001 fdbf 	bl	810eecc <metal_machine_cache_flush>
}
 810d34e:	bf00      	nop
 810d350:	3708      	adds	r7, #8
 810d352:	46bd      	mov	sp, r7
 810d354:	bd80      	pop	{r7, pc}

0810d356 <__metal_cache_invalidate>:

static inline void __metal_cache_invalidate(void *addr, unsigned int len)
{
 810d356:	b580      	push	{r7, lr}
 810d358:	b082      	sub	sp, #8
 810d35a:	af00      	add	r7, sp, #0
 810d35c:	6078      	str	r0, [r7, #4]
 810d35e:	6039      	str	r1, [r7, #0]
	metal_machine_cache_invalidate(addr, len);
 810d360:	6839      	ldr	r1, [r7, #0]
 810d362:	6878      	ldr	r0, [r7, #4]
 810d364:	f001 fdbd 	bl	810eee2 <metal_machine_cache_invalidate>
}
 810d368:	bf00      	nop
 810d36a:	3708      	adds	r7, #8
 810d36c:	46bd      	mov	sp, r7
 810d36e:	bd80      	pop	{r7, pc}

0810d370 <metal_cache_flush>:
 * @param[in] len  length of memory
 *                 If addr is NULL, and len is 0,
 *                 It will flush the whole data cache.
 */
static inline void metal_cache_flush(void *addr, unsigned int len)
{
 810d370:	b580      	push	{r7, lr}
 810d372:	b082      	sub	sp, #8
 810d374:	af00      	add	r7, sp, #0
 810d376:	6078      	str	r0, [r7, #4]
 810d378:	6039      	str	r1, [r7, #0]
	__metal_cache_flush(addr, len);
 810d37a:	6839      	ldr	r1, [r7, #0]
 810d37c:	6878      	ldr	r0, [r7, #4]
 810d37e:	f7ff ffdd 	bl	810d33c <__metal_cache_flush>
}
 810d382:	bf00      	nop
 810d384:	3708      	adds	r7, #8
 810d386:	46bd      	mov	sp, r7
 810d388:	bd80      	pop	{r7, pc}

0810d38a <metal_cache_invalidate>:
 * @param[in] len  length of memory
 *                 If addr is NULL, and len is 0,
 *                 It will invalidate the whole data cache.
 */
static inline void metal_cache_invalidate(void *addr, unsigned int len)
{
 810d38a:	b580      	push	{r7, lr}
 810d38c:	b082      	sub	sp, #8
 810d38e:	af00      	add	r7, sp, #0
 810d390:	6078      	str	r0, [r7, #4]
 810d392:	6039      	str	r1, [r7, #0]
	__metal_cache_invalidate(addr, len);
 810d394:	6839      	ldr	r1, [r7, #0]
 810d396:	6878      	ldr	r0, [r7, #4]
 810d398:	f7ff ffdd 	bl	810d356 <__metal_cache_invalidate>
}
 810d39c:	bf00      	nop
 810d39e:	3708      	adds	r7, #8
 810d3a0:	46bd      	mov	sp, r7
 810d3a2:	bd80      	pop	{r7, pc}

0810d3a4 <metal_bus_register>:
#include <metal/utilities.h>
#include <metal/dma.h>
#include <metal/cache.h>

int metal_bus_register(struct metal_bus *bus)
{
 810d3a4:	b580      	push	{r7, lr}
 810d3a6:	b082      	sub	sp, #8
 810d3a8:	af00      	add	r7, sp, #0
 810d3aa:	6078      	str	r0, [r7, #4]
	if (!bus || !bus->name || !strlen(bus->name))
 810d3ac:	687b      	ldr	r3, [r7, #4]
 810d3ae:	2b00      	cmp	r3, #0
 810d3b0:	d008      	beq.n	810d3c4 <metal_bus_register+0x20>
 810d3b2:	687b      	ldr	r3, [r7, #4]
 810d3b4:	681b      	ldr	r3, [r3, #0]
 810d3b6:	2b00      	cmp	r3, #0
 810d3b8:	d004      	beq.n	810d3c4 <metal_bus_register+0x20>
 810d3ba:	687b      	ldr	r3, [r7, #4]
 810d3bc:	681b      	ldr	r3, [r3, #0]
 810d3be:	781b      	ldrb	r3, [r3, #0]
 810d3c0:	2b00      	cmp	r3, #0
 810d3c2:	d102      	bne.n	810d3ca <metal_bus_register+0x26>
		return -EINVAL;
 810d3c4:	f06f 0315 	mvn.w	r3, #21
 810d3c8:	e026      	b.n	810d418 <metal_bus_register+0x74>
	if (metal_bus_find(bus->name, NULL) == 0)
 810d3ca:	687b      	ldr	r3, [r7, #4]
 810d3cc:	681b      	ldr	r3, [r3, #0]
 810d3ce:	2100      	movs	r1, #0
 810d3d0:	4618      	mov	r0, r3
 810d3d2:	f000 f82b 	bl	810d42c <metal_bus_find>
 810d3d6:	4603      	mov	r3, r0
 810d3d8:	2b00      	cmp	r3, #0
 810d3da:	d102      	bne.n	810d3e2 <metal_bus_register+0x3e>
		return -EEXIST;
 810d3dc:	f06f 0310 	mvn.w	r3, #16
 810d3e0:	e01a      	b.n	810d418 <metal_bus_register+0x74>
	metal_list_init(&bus->devices);
 810d3e2:	687b      	ldr	r3, [r7, #4]
 810d3e4:	331c      	adds	r3, #28
 810d3e6:	4618      	mov	r0, r3
 810d3e8:	f7ff ff70 	bl	810d2cc <metal_list_init>
	metal_list_add_tail(&_metal.common.bus_list, &bus->node);
 810d3ec:	687b      	ldr	r3, [r7, #4]
 810d3ee:	3324      	adds	r3, #36	@ 0x24
 810d3f0:	4619      	mov	r1, r3
 810d3f2:	480b      	ldr	r0, [pc, #44]	@ (810d420 <metal_bus_register+0x7c>)
 810d3f4:	f7ff ff95 	bl	810d322 <metal_list_add_tail>
	metal_log(METAL_LOG_DEBUG, "registered %s bus\n", bus->name);
 810d3f8:	4b0a      	ldr	r3, [pc, #40]	@ (810d424 <metal_bus_register+0x80>)
 810d3fa:	781b      	ldrb	r3, [r3, #0]
 810d3fc:	2b06      	cmp	r3, #6
 810d3fe:	d90a      	bls.n	810d416 <metal_bus_register+0x72>
 810d400:	4b08      	ldr	r3, [pc, #32]	@ (810d424 <metal_bus_register+0x80>)
 810d402:	685b      	ldr	r3, [r3, #4]
 810d404:	2b00      	cmp	r3, #0
 810d406:	d006      	beq.n	810d416 <metal_bus_register+0x72>
 810d408:	4b06      	ldr	r3, [pc, #24]	@ (810d424 <metal_bus_register+0x80>)
 810d40a:	685b      	ldr	r3, [r3, #4]
 810d40c:	687a      	ldr	r2, [r7, #4]
 810d40e:	6812      	ldr	r2, [r2, #0]
 810d410:	4905      	ldr	r1, [pc, #20]	@ (810d428 <metal_bus_register+0x84>)
 810d412:	2007      	movs	r0, #7
 810d414:	4798      	blx	r3
	return 0;
 810d416:	2300      	movs	r3, #0
}
 810d418:	4618      	mov	r0, r3
 810d41a:	3708      	adds	r7, #8
 810d41c:	46bd      	mov	sp, r7
 810d41e:	bd80      	pop	{r7, pc}
 810d420:	10005534 	.word	0x10005534
 810d424:	1000552c 	.word	0x1000552c
 810d428:	081108cc 	.word	0x081108cc

0810d42c <metal_bus_find>:
	metal_log(METAL_LOG_DEBUG, "unregistered %s bus\n", bus->name);
	return 0;
}

int metal_bus_find(const char *name, struct metal_bus **result)
{
 810d42c:	b580      	push	{r7, lr}
 810d42e:	b084      	sub	sp, #16
 810d430:	af00      	add	r7, sp, #0
 810d432:	6078      	str	r0, [r7, #4]
 810d434:	6039      	str	r1, [r7, #0]
	struct metal_list *node;
	struct metal_bus *bus;

	metal_list_for_each(&_metal.common.bus_list, node) {
 810d436:	4b13      	ldr	r3, [pc, #76]	@ (810d484 <metal_bus_find+0x58>)
 810d438:	689b      	ldr	r3, [r3, #8]
 810d43a:	60fb      	str	r3, [r7, #12]
 810d43c:	e017      	b.n	810d46e <metal_bus_find+0x42>
		bus = metal_container_of(node, struct metal_bus, node);
 810d43e:	68fb      	ldr	r3, [r7, #12]
 810d440:	3b24      	subs	r3, #36	@ 0x24
 810d442:	60bb      	str	r3, [r7, #8]
		if (strcmp(bus->name, name) != 0)
 810d444:	68bb      	ldr	r3, [r7, #8]
 810d446:	681b      	ldr	r3, [r3, #0]
 810d448:	6879      	ldr	r1, [r7, #4]
 810d44a:	4618      	mov	r0, r3
 810d44c:	f7f2 ff48 	bl	81002e0 <strcmp>
 810d450:	4603      	mov	r3, r0
 810d452:	2b00      	cmp	r3, #0
 810d454:	d107      	bne.n	810d466 <metal_bus_find+0x3a>
			continue;
		if (result)
 810d456:	683b      	ldr	r3, [r7, #0]
 810d458:	2b00      	cmp	r3, #0
 810d45a:	d002      	beq.n	810d462 <metal_bus_find+0x36>
			*result = bus;
 810d45c:	683b      	ldr	r3, [r7, #0]
 810d45e:	68ba      	ldr	r2, [r7, #8]
 810d460:	601a      	str	r2, [r3, #0]
		return 0;
 810d462:	2300      	movs	r3, #0
 810d464:	e009      	b.n	810d47a <metal_bus_find+0x4e>
			continue;
 810d466:	bf00      	nop
	metal_list_for_each(&_metal.common.bus_list, node) {
 810d468:	68fb      	ldr	r3, [r7, #12]
 810d46a:	681b      	ldr	r3, [r3, #0]
 810d46c:	60fb      	str	r3, [r7, #12]
 810d46e:	68fb      	ldr	r3, [r7, #12]
 810d470:	4a05      	ldr	r2, [pc, #20]	@ (810d488 <metal_bus_find+0x5c>)
 810d472:	4293      	cmp	r3, r2
 810d474:	d1e3      	bne.n	810d43e <metal_bus_find+0x12>
	}
	return -ENOENT;
 810d476:	f06f 0301 	mvn.w	r3, #1
}
 810d47a:	4618      	mov	r0, r3
 810d47c:	3710      	adds	r7, #16
 810d47e:	46bd      	mov	sp, r7
 810d480:	bd80      	pop	{r7, pc}
 810d482:	bf00      	nop
 810d484:	1000552c 	.word	0x1000552c
 810d488:	10005534 	.word	0x10005534

0810d48c <metal_device_open>:

int metal_device_open(const char *bus_name, const char *dev_name,
		      struct metal_device **device)
{
 810d48c:	b580      	push	{r7, lr}
 810d48e:	b086      	sub	sp, #24
 810d490:	af00      	add	r7, sp, #0
 810d492:	60f8      	str	r0, [r7, #12]
 810d494:	60b9      	str	r1, [r7, #8]
 810d496:	607a      	str	r2, [r7, #4]
	struct metal_bus *bus;
	int error;

	if (!bus_name || !strlen(bus_name) ||
 810d498:	68fb      	ldr	r3, [r7, #12]
 810d49a:	2b00      	cmp	r3, #0
 810d49c:	d00d      	beq.n	810d4ba <metal_device_open+0x2e>
 810d49e:	68fb      	ldr	r3, [r7, #12]
 810d4a0:	781b      	ldrb	r3, [r3, #0]
 810d4a2:	2b00      	cmp	r3, #0
 810d4a4:	d009      	beq.n	810d4ba <metal_device_open+0x2e>
 810d4a6:	68bb      	ldr	r3, [r7, #8]
 810d4a8:	2b00      	cmp	r3, #0
 810d4aa:	d006      	beq.n	810d4ba <metal_device_open+0x2e>
	    !dev_name || !strlen(dev_name) ||
 810d4ac:	68bb      	ldr	r3, [r7, #8]
 810d4ae:	781b      	ldrb	r3, [r3, #0]
 810d4b0:	2b00      	cmp	r3, #0
 810d4b2:	d002      	beq.n	810d4ba <metal_device_open+0x2e>
 810d4b4:	687b      	ldr	r3, [r7, #4]
 810d4b6:	2b00      	cmp	r3, #0
 810d4b8:	d102      	bne.n	810d4c0 <metal_device_open+0x34>
	    !device)
		return -EINVAL;
 810d4ba:	f06f 0315 	mvn.w	r3, #21
 810d4be:	e01f      	b.n	810d500 <metal_device_open+0x74>

	error = metal_bus_find(bus_name, &bus);
 810d4c0:	f107 0310 	add.w	r3, r7, #16
 810d4c4:	4619      	mov	r1, r3
 810d4c6:	68f8      	ldr	r0, [r7, #12]
 810d4c8:	f7ff ffb0 	bl	810d42c <metal_bus_find>
 810d4cc:	6178      	str	r0, [r7, #20]
	if (error)
 810d4ce:	697b      	ldr	r3, [r7, #20]
 810d4d0:	2b00      	cmp	r3, #0
 810d4d2:	d001      	beq.n	810d4d8 <metal_device_open+0x4c>
		return error;
 810d4d4:	697b      	ldr	r3, [r7, #20]
 810d4d6:	e013      	b.n	810d500 <metal_device_open+0x74>

	if (!bus->ops.dev_open)
 810d4d8:	693b      	ldr	r3, [r7, #16]
 810d4da:	689b      	ldr	r3, [r3, #8]
 810d4dc:	2b00      	cmp	r3, #0
 810d4de:	d102      	bne.n	810d4e6 <metal_device_open+0x5a>
		return -ENODEV;
 810d4e0:	f06f 0312 	mvn.w	r3, #18
 810d4e4:	e00c      	b.n	810d500 <metal_device_open+0x74>

	error = (*bus->ops.dev_open)(bus, dev_name, device);
 810d4e6:	693b      	ldr	r3, [r7, #16]
 810d4e8:	689b      	ldr	r3, [r3, #8]
 810d4ea:	6938      	ldr	r0, [r7, #16]
 810d4ec:	687a      	ldr	r2, [r7, #4]
 810d4ee:	68b9      	ldr	r1, [r7, #8]
 810d4f0:	4798      	blx	r3
 810d4f2:	6178      	str	r0, [r7, #20]
	if (error)
 810d4f4:	697b      	ldr	r3, [r7, #20]
 810d4f6:	2b00      	cmp	r3, #0
 810d4f8:	d001      	beq.n	810d4fe <metal_device_open+0x72>
		return error;
 810d4fa:	697b      	ldr	r3, [r7, #20]
 810d4fc:	e000      	b.n	810d500 <metal_device_open+0x74>

	return 0;
 810d4fe:	2300      	movs	r3, #0
}
 810d500:	4618      	mov	r0, r3
 810d502:	3718      	adds	r7, #24
 810d504:	46bd      	mov	sp, r7
 810d506:	bd80      	pop	{r7, pc}

0810d508 <metal_register_generic_device>:
	if (device->bus->ops.dev_close)
		device->bus->ops.dev_close(device->bus, device);
}

int metal_register_generic_device(struct metal_device *device)
{
 810d508:	b580      	push	{r7, lr}
 810d50a:	b082      	sub	sp, #8
 810d50c:	af00      	add	r7, sp, #0
 810d50e:	6078      	str	r0, [r7, #4]
	if (!device->name || !strlen(device->name) ||
 810d510:	687b      	ldr	r3, [r7, #4]
 810d512:	681b      	ldr	r3, [r3, #0]
 810d514:	2b00      	cmp	r3, #0
 810d516:	d008      	beq.n	810d52a <metal_register_generic_device+0x22>
 810d518:	687b      	ldr	r3, [r7, #4]
 810d51a:	681b      	ldr	r3, [r3, #0]
 810d51c:	781b      	ldrb	r3, [r3, #0]
 810d51e:	2b00      	cmp	r3, #0
 810d520:	d003      	beq.n	810d52a <metal_register_generic_device+0x22>
	    device->num_regions > METAL_MAX_DEVICE_REGIONS)
 810d522:	687b      	ldr	r3, [r7, #4]
 810d524:	689b      	ldr	r3, [r3, #8]
	if (!device->name || !strlen(device->name) ||
 810d526:	2b02      	cmp	r3, #2
 810d528:	d902      	bls.n	810d530 <metal_register_generic_device+0x28>
		return -EINVAL;
 810d52a:	f06f 0315 	mvn.w	r3, #21
 810d52e:	e009      	b.n	810d544 <metal_register_generic_device+0x3c>

	device->bus = &metal_generic_bus;
 810d530:	687b      	ldr	r3, [r7, #4]
 810d532:	4a06      	ldr	r2, [pc, #24]	@ (810d54c <metal_register_generic_device+0x44>)
 810d534:	605a      	str	r2, [r3, #4]
	metal_list_add_tail(&_metal.common.generic_device_list,
 810d536:	687b      	ldr	r3, [r7, #4]
 810d538:	336c      	adds	r3, #108	@ 0x6c
 810d53a:	4619      	mov	r1, r3
 810d53c:	4804      	ldr	r0, [pc, #16]	@ (810d550 <metal_register_generic_device+0x48>)
 810d53e:	f7ff fef0 	bl	810d322 <metal_list_add_tail>
			    &device->node);
	return 0;
 810d542:	2300      	movs	r3, #0
}
 810d544:	4618      	mov	r0, r3
 810d546:	3708      	adds	r7, #8
 810d548:	46bd      	mov	sp, r7
 810d54a:	bd80      	pop	{r7, pc}
 810d54c:	10000494 	.word	0x10000494
 810d550:	10005544 	.word	0x10005544

0810d554 <metal_generic_dev_open>:

int metal_generic_dev_open(struct metal_bus *bus, const char *dev_name,
			   struct metal_device **device)
{
 810d554:	b580      	push	{r7, lr}
 810d556:	b086      	sub	sp, #24
 810d558:	af00      	add	r7, sp, #0
 810d55a:	60f8      	str	r0, [r7, #12]
 810d55c:	60b9      	str	r1, [r7, #8]
 810d55e:	607a      	str	r2, [r7, #4]
	struct metal_list *node;
	struct metal_device *dev;

	(void)bus;

	metal_list_for_each(&_metal.common.generic_device_list, node) {
 810d560:	4b12      	ldr	r3, [pc, #72]	@ (810d5ac <metal_generic_dev_open+0x58>)
 810d562:	699b      	ldr	r3, [r3, #24]
 810d564:	617b      	str	r3, [r7, #20]
 810d566:	e017      	b.n	810d598 <metal_generic_dev_open+0x44>
		dev = metal_container_of(node, struct metal_device, node);
 810d568:	697b      	ldr	r3, [r7, #20]
 810d56a:	3b6c      	subs	r3, #108	@ 0x6c
 810d56c:	613b      	str	r3, [r7, #16]
		if (strcmp(dev->name, dev_name) != 0)
 810d56e:	693b      	ldr	r3, [r7, #16]
 810d570:	681b      	ldr	r3, [r3, #0]
 810d572:	68b9      	ldr	r1, [r7, #8]
 810d574:	4618      	mov	r0, r3
 810d576:	f7f2 feb3 	bl	81002e0 <strcmp>
 810d57a:	4603      	mov	r3, r0
 810d57c:	2b00      	cmp	r3, #0
 810d57e:	d107      	bne.n	810d590 <metal_generic_dev_open+0x3c>
			continue;
		*device = dev;
 810d580:	687b      	ldr	r3, [r7, #4]
 810d582:	693a      	ldr	r2, [r7, #16]
 810d584:	601a      	str	r2, [r3, #0]
		return metal_generic_dev_sys_open(dev);
 810d586:	6938      	ldr	r0, [r7, #16]
 810d588:	f000 f890 	bl	810d6ac <metal_generic_dev_sys_open>
 810d58c:	4603      	mov	r3, r0
 810d58e:	e009      	b.n	810d5a4 <metal_generic_dev_open+0x50>
			continue;
 810d590:	bf00      	nop
	metal_list_for_each(&_metal.common.generic_device_list, node) {
 810d592:	697b      	ldr	r3, [r7, #20]
 810d594:	681b      	ldr	r3, [r3, #0]
 810d596:	617b      	str	r3, [r7, #20]
 810d598:	697b      	ldr	r3, [r7, #20]
 810d59a:	4a05      	ldr	r2, [pc, #20]	@ (810d5b0 <metal_generic_dev_open+0x5c>)
 810d59c:	4293      	cmp	r3, r2
 810d59e:	d1e3      	bne.n	810d568 <metal_generic_dev_open+0x14>
	}

	return -ENODEV;
 810d5a0:	f06f 0312 	mvn.w	r3, #18
}
 810d5a4:	4618      	mov	r0, r3
 810d5a6:	3718      	adds	r7, #24
 810d5a8:	46bd      	mov	sp, r7
 810d5aa:	bd80      	pop	{r7, pc}
 810d5ac:	1000552c 	.word	0x1000552c
 810d5b0:	10005544 	.word	0x10005544

0810d5b4 <metal_generic_dev_dma_map>:
			     struct metal_device *device,
			     uint32_t dir,
			     struct metal_sg *sg_in,
			     int nents_in,
			     struct metal_sg *sg_out)
{
 810d5b4:	b580      	push	{r7, lr}
 810d5b6:	b086      	sub	sp, #24
 810d5b8:	af00      	add	r7, sp, #0
 810d5ba:	60f8      	str	r0, [r7, #12]
 810d5bc:	60b9      	str	r1, [r7, #8]
 810d5be:	607a      	str	r2, [r7, #4]
 810d5c0:	603b      	str	r3, [r7, #0]
	(void)bus;
	(void)device;
	int i;

	if (sg_out != sg_in)
 810d5c2:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 810d5c4:	683b      	ldr	r3, [r7, #0]
 810d5c6:	429a      	cmp	r2, r3
 810d5c8:	d009      	beq.n	810d5de <metal_generic_dev_dma_map+0x2a>
		memcpy(sg_out, sg_in, nents_in*(sizeof(struct metal_sg)));
 810d5ca:	6a3a      	ldr	r2, [r7, #32]
 810d5cc:	4613      	mov	r3, r2
 810d5ce:	005b      	lsls	r3, r3, #1
 810d5d0:	4413      	add	r3, r2
 810d5d2:	009b      	lsls	r3, r3, #2
 810d5d4:	461a      	mov	r2, r3
 810d5d6:	6839      	ldr	r1, [r7, #0]
 810d5d8:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 810d5da:	f002 fc0e 	bl	810fdfa <memcpy>
	for (i = 0; i < nents_in; i++) {
 810d5de:	2300      	movs	r3, #0
 810d5e0:	617b      	str	r3, [r7, #20]
 810d5e2:	e02f      	b.n	810d644 <metal_generic_dev_dma_map+0x90>
		if (dir == METAL_DMA_DEV_W) {
 810d5e4:	687b      	ldr	r3, [r7, #4]
 810d5e6:	2b02      	cmp	r3, #2
 810d5e8:	d114      	bne.n	810d614 <metal_generic_dev_dma_map+0x60>
			metal_cache_flush(sg_out[i].virt, sg_out[i].len);
 810d5ea:	697a      	ldr	r2, [r7, #20]
 810d5ec:	4613      	mov	r3, r2
 810d5ee:	005b      	lsls	r3, r3, #1
 810d5f0:	4413      	add	r3, r2
 810d5f2:	009b      	lsls	r3, r3, #2
 810d5f4:	461a      	mov	r2, r3
 810d5f6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810d5f8:	4413      	add	r3, r2
 810d5fa:	6818      	ldr	r0, [r3, #0]
 810d5fc:	697a      	ldr	r2, [r7, #20]
 810d5fe:	4613      	mov	r3, r2
 810d600:	005b      	lsls	r3, r3, #1
 810d602:	4413      	add	r3, r2
 810d604:	009b      	lsls	r3, r3, #2
 810d606:	461a      	mov	r2, r3
 810d608:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810d60a:	4413      	add	r3, r2
 810d60c:	689b      	ldr	r3, [r3, #8]
 810d60e:	4619      	mov	r1, r3
 810d610:	f7ff feae 	bl	810d370 <metal_cache_flush>
		}
		metal_cache_invalidate(sg_out[i].virt, sg_out[i].len);
 810d614:	697a      	ldr	r2, [r7, #20]
 810d616:	4613      	mov	r3, r2
 810d618:	005b      	lsls	r3, r3, #1
 810d61a:	4413      	add	r3, r2
 810d61c:	009b      	lsls	r3, r3, #2
 810d61e:	461a      	mov	r2, r3
 810d620:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810d622:	4413      	add	r3, r2
 810d624:	6818      	ldr	r0, [r3, #0]
 810d626:	697a      	ldr	r2, [r7, #20]
 810d628:	4613      	mov	r3, r2
 810d62a:	005b      	lsls	r3, r3, #1
 810d62c:	4413      	add	r3, r2
 810d62e:	009b      	lsls	r3, r3, #2
 810d630:	461a      	mov	r2, r3
 810d632:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810d634:	4413      	add	r3, r2
 810d636:	689b      	ldr	r3, [r3, #8]
 810d638:	4619      	mov	r1, r3
 810d63a:	f7ff fea6 	bl	810d38a <metal_cache_invalidate>
	for (i = 0; i < nents_in; i++) {
 810d63e:	697b      	ldr	r3, [r7, #20]
 810d640:	3301      	adds	r3, #1
 810d642:	617b      	str	r3, [r7, #20]
 810d644:	697a      	ldr	r2, [r7, #20]
 810d646:	6a3b      	ldr	r3, [r7, #32]
 810d648:	429a      	cmp	r2, r3
 810d64a:	dbcb      	blt.n	810d5e4 <metal_generic_dev_dma_map+0x30>
	}

	return nents_in;
 810d64c:	6a3b      	ldr	r3, [r7, #32]
}
 810d64e:	4618      	mov	r0, r3
 810d650:	3718      	adds	r7, #24
 810d652:	46bd      	mov	sp, r7
 810d654:	bd80      	pop	{r7, pc}

0810d656 <metal_generic_dev_dma_unmap>:
void metal_generic_dev_dma_unmap(struct metal_bus *bus,
				 struct metal_device *device,
				 uint32_t dir,
				 struct metal_sg *sg,
				 int nents)
{
 810d656:	b580      	push	{r7, lr}
 810d658:	b086      	sub	sp, #24
 810d65a:	af00      	add	r7, sp, #0
 810d65c:	60f8      	str	r0, [r7, #12]
 810d65e:	60b9      	str	r1, [r7, #8]
 810d660:	607a      	str	r2, [r7, #4]
 810d662:	603b      	str	r3, [r7, #0]
	(void)bus;
	(void)device;
	(void)dir;
	int i;

	for (i = 0; i < nents; i++) {
 810d664:	2300      	movs	r3, #0
 810d666:	617b      	str	r3, [r7, #20]
 810d668:	e017      	b.n	810d69a <metal_generic_dev_dma_unmap+0x44>
		metal_cache_invalidate(sg[i].virt, sg[i].len);
 810d66a:	697a      	ldr	r2, [r7, #20]
 810d66c:	4613      	mov	r3, r2
 810d66e:	005b      	lsls	r3, r3, #1
 810d670:	4413      	add	r3, r2
 810d672:	009b      	lsls	r3, r3, #2
 810d674:	461a      	mov	r2, r3
 810d676:	683b      	ldr	r3, [r7, #0]
 810d678:	4413      	add	r3, r2
 810d67a:	6818      	ldr	r0, [r3, #0]
 810d67c:	697a      	ldr	r2, [r7, #20]
 810d67e:	4613      	mov	r3, r2
 810d680:	005b      	lsls	r3, r3, #1
 810d682:	4413      	add	r3, r2
 810d684:	009b      	lsls	r3, r3, #2
 810d686:	461a      	mov	r2, r3
 810d688:	683b      	ldr	r3, [r7, #0]
 810d68a:	4413      	add	r3, r2
 810d68c:	689b      	ldr	r3, [r3, #8]
 810d68e:	4619      	mov	r1, r3
 810d690:	f7ff fe7b 	bl	810d38a <metal_cache_invalidate>
	for (i = 0; i < nents; i++) {
 810d694:	697b      	ldr	r3, [r7, #20]
 810d696:	3301      	adds	r3, #1
 810d698:	617b      	str	r3, [r7, #20]
 810d69a:	697a      	ldr	r2, [r7, #20]
 810d69c:	6a3b      	ldr	r3, [r7, #32]
 810d69e:	429a      	cmp	r2, r3
 810d6a0:	dbe3      	blt.n	810d66a <metal_generic_dev_dma_unmap+0x14>
	}
}
 810d6a2:	bf00      	nop
 810d6a4:	bf00      	nop
 810d6a6:	3718      	adds	r7, #24
 810d6a8:	46bd      	mov	sp, r7
 810d6aa:	bd80      	pop	{r7, pc}

0810d6ac <metal_generic_dev_sys_open>:
#include <metal/io.h>
#include <metal/sys.h>
#include <metal/utilities.h>

int metal_generic_dev_sys_open(struct metal_device *dev)
{
 810d6ac:	b580      	push	{r7, lr}
 810d6ae:	b084      	sub	sp, #16
 810d6b0:	af00      	add	r7, sp, #0
 810d6b2:	6078      	str	r0, [r7, #4]
	struct metal_io_region *io;
	unsigned i;

	/* map I/O memory regions */
	for (i = 0; i < dev->num_regions; i++) {
 810d6b4:	2300      	movs	r3, #0
 810d6b6:	60fb      	str	r3, [r7, #12]
 810d6b8:	e013      	b.n	810d6e2 <metal_generic_dev_sys_open+0x36>
		io = &dev->regions[i];
 810d6ba:	68fa      	ldr	r2, [r7, #12]
 810d6bc:	4613      	mov	r3, r2
 810d6be:	005b      	lsls	r3, r3, #1
 810d6c0:	4413      	add	r3, r2
 810d6c2:	011b      	lsls	r3, r3, #4
 810d6c4:	3308      	adds	r3, #8
 810d6c6:	687a      	ldr	r2, [r7, #4]
 810d6c8:	4413      	add	r3, r2
 810d6ca:	3304      	adds	r3, #4
 810d6cc:	60bb      	str	r3, [r7, #8]
		if (!io->size)
 810d6ce:	68bb      	ldr	r3, [r7, #8]
 810d6d0:	689b      	ldr	r3, [r3, #8]
 810d6d2:	2b00      	cmp	r3, #0
 810d6d4:	d00b      	beq.n	810d6ee <metal_generic_dev_sys_open+0x42>
			break;
		metal_sys_io_mem_map(io);
 810d6d6:	68b8      	ldr	r0, [r7, #8]
 810d6d8:	f000 f81e 	bl	810d718 <metal_sys_io_mem_map>
	for (i = 0; i < dev->num_regions; i++) {
 810d6dc:	68fb      	ldr	r3, [r7, #12]
 810d6de:	3301      	adds	r3, #1
 810d6e0:	60fb      	str	r3, [r7, #12]
 810d6e2:	687b      	ldr	r3, [r7, #4]
 810d6e4:	689b      	ldr	r3, [r3, #8]
 810d6e6:	68fa      	ldr	r2, [r7, #12]
 810d6e8:	429a      	cmp	r2, r3
 810d6ea:	d3e6      	bcc.n	810d6ba <metal_generic_dev_sys_open+0xe>
 810d6ec:	e000      	b.n	810d6f0 <metal_generic_dev_sys_open+0x44>
			break;
 810d6ee:	bf00      	nop
	}

	return 0;
 810d6f0:	2300      	movs	r3, #0
}
 810d6f2:	4618      	mov	r0, r3
 810d6f4:	3710      	adds	r7, #16
 810d6f6:	46bd      	mov	sp, r7
 810d6f8:	bd80      	pop	{r7, pc}
	...

0810d6fc <metal_sys_init>:
#include <metal/device.h>

struct metal_state _metal;

int metal_sys_init(const struct metal_init_params *params)
{
 810d6fc:	b580      	push	{r7, lr}
 810d6fe:	b082      	sub	sp, #8
 810d700:	af00      	add	r7, sp, #0
 810d702:	6078      	str	r0, [r7, #4]
	metal_unused(params);
	metal_bus_register(&metal_generic_bus);
 810d704:	4803      	ldr	r0, [pc, #12]	@ (810d714 <metal_sys_init+0x18>)
 810d706:	f7ff fe4d 	bl	810d3a4 <metal_bus_register>
	return 0;
 810d70a:	2300      	movs	r3, #0
}
 810d70c:	4618      	mov	r0, r3
 810d70e:	3708      	adds	r7, #8
 810d710:	46bd      	mov	sp, r7
 810d712:	bd80      	pop	{r7, pc}
 810d714:	10000494 	.word	0x10000494

0810d718 <metal_sys_io_mem_map>:
 */

#include <metal/io.h>

void metal_sys_io_mem_map(struct metal_io_region *io)
{
 810d718:	b580      	push	{r7, lr}
 810d71a:	b086      	sub	sp, #24
 810d71c:	af00      	add	r7, sp, #0
 810d71e:	6078      	str	r0, [r7, #4]
	unsigned long p;
	size_t psize;
	size_t *va;

	va = (size_t *)io->virt;
 810d720:	687b      	ldr	r3, [r7, #4]
 810d722:	681b      	ldr	r3, [r3, #0]
 810d724:	60fb      	str	r3, [r7, #12]
	psize = io->size;
 810d726:	687b      	ldr	r3, [r7, #4]
 810d728:	689b      	ldr	r3, [r3, #8]
 810d72a:	613b      	str	r3, [r7, #16]
	if (psize) {
 810d72c:	693b      	ldr	r3, [r7, #16]
 810d72e:	2b00      	cmp	r3, #0
 810d730:	d02c      	beq.n	810d78c <metal_sys_io_mem_map+0x74>
		if (psize >> io->page_shift)
 810d732:	687b      	ldr	r3, [r7, #4]
 810d734:	68db      	ldr	r3, [r3, #12]
 810d736:	693a      	ldr	r2, [r7, #16]
 810d738:	fa22 f303 	lsr.w	r3, r2, r3
 810d73c:	2b00      	cmp	r3, #0
 810d73e:	d005      	beq.n	810d74c <metal_sys_io_mem_map+0x34>
			psize = (size_t)1 << io->page_shift;
 810d740:	687b      	ldr	r3, [r7, #4]
 810d742:	68db      	ldr	r3, [r3, #12]
 810d744:	2201      	movs	r2, #1
 810d746:	fa02 f303 	lsl.w	r3, r2, r3
 810d74a:	613b      	str	r3, [r7, #16]
		for (p = 0; p <= (io->size >> io->page_shift); p++) {
 810d74c:	2300      	movs	r3, #0
 810d74e:	617b      	str	r3, [r7, #20]
 810d750:	e013      	b.n	810d77a <metal_sys_io_mem_map+0x62>
			metal_machine_io_mem_map(va, io->physmap[p],
 810d752:	687b      	ldr	r3, [r7, #4]
 810d754:	685a      	ldr	r2, [r3, #4]
 810d756:	697b      	ldr	r3, [r7, #20]
 810d758:	009b      	lsls	r3, r3, #2
 810d75a:	4413      	add	r3, r2
 810d75c:	6819      	ldr	r1, [r3, #0]
 810d75e:	687b      	ldr	r3, [r7, #4]
 810d760:	695b      	ldr	r3, [r3, #20]
 810d762:	693a      	ldr	r2, [r7, #16]
 810d764:	68f8      	ldr	r0, [r7, #12]
 810d766:	f001 fbc7 	bl	810eef8 <metal_machine_io_mem_map>
						 psize, io->mem_flags);
			va += psize;
 810d76a:	693b      	ldr	r3, [r7, #16]
 810d76c:	009b      	lsls	r3, r3, #2
 810d76e:	68fa      	ldr	r2, [r7, #12]
 810d770:	4413      	add	r3, r2
 810d772:	60fb      	str	r3, [r7, #12]
		for (p = 0; p <= (io->size >> io->page_shift); p++) {
 810d774:	697b      	ldr	r3, [r7, #20]
 810d776:	3301      	adds	r3, #1
 810d778:	617b      	str	r3, [r7, #20]
 810d77a:	687b      	ldr	r3, [r7, #4]
 810d77c:	689a      	ldr	r2, [r3, #8]
 810d77e:	687b      	ldr	r3, [r7, #4]
 810d780:	68db      	ldr	r3, [r3, #12]
 810d782:	fa22 f303 	lsr.w	r3, r2, r3
 810d786:	697a      	ldr	r2, [r7, #20]
 810d788:	429a      	cmp	r2, r3
 810d78a:	d9e2      	bls.n	810d752 <metal_sys_io_mem_map+0x3a>
		}
	}
}
 810d78c:	bf00      	nop
 810d78e:	3718      	adds	r7, #24
 810d790:	46bd      	mov	sp, r7
 810d792:	bd80      	pop	{r7, pc}

0810d794 <metal_list_init>:
{
 810d794:	b480      	push	{r7}
 810d796:	b083      	sub	sp, #12
 810d798:	af00      	add	r7, sp, #0
 810d79a:	6078      	str	r0, [r7, #4]
	list->next = list->prev = list;
 810d79c:	687b      	ldr	r3, [r7, #4]
 810d79e:	687a      	ldr	r2, [r7, #4]
 810d7a0:	605a      	str	r2, [r3, #4]
 810d7a2:	687b      	ldr	r3, [r7, #4]
 810d7a4:	685a      	ldr	r2, [r3, #4]
 810d7a6:	687b      	ldr	r3, [r7, #4]
 810d7a8:	601a      	str	r2, [r3, #0]
}
 810d7aa:	bf00      	nop
 810d7ac:	370c      	adds	r7, #12
 810d7ae:	46bd      	mov	sp, r7
 810d7b0:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d7b4:	4770      	bx	lr
	...

0810d7b8 <metal_init>:

#include <string.h>
#include <metal/sys.h>

int metal_init(const struct metal_init_params *params)
{
 810d7b8:	b580      	push	{r7, lr}
 810d7ba:	b084      	sub	sp, #16
 810d7bc:	af00      	add	r7, sp, #0
 810d7be:	6078      	str	r0, [r7, #4]
	int error = 0;
 810d7c0:	2300      	movs	r3, #0
 810d7c2:	60fb      	str	r3, [r7, #12]

	memset(&_metal, 0, sizeof(_metal));
 810d7c4:	2220      	movs	r2, #32
 810d7c6:	2100      	movs	r1, #0
 810d7c8:	4810      	ldr	r0, [pc, #64]	@ (810d80c <metal_init+0x54>)
 810d7ca:	f002 fa66 	bl	810fc9a <memset>

	_metal.common.log_handler   = params->log_handler;
 810d7ce:	687b      	ldr	r3, [r7, #4]
 810d7d0:	681b      	ldr	r3, [r3, #0]
 810d7d2:	4a0e      	ldr	r2, [pc, #56]	@ (810d80c <metal_init+0x54>)
 810d7d4:	6053      	str	r3, [r2, #4]
	_metal.common.log_level     = params->log_level;
 810d7d6:	687b      	ldr	r3, [r7, #4]
 810d7d8:	791a      	ldrb	r2, [r3, #4]
 810d7da:	4b0c      	ldr	r3, [pc, #48]	@ (810d80c <metal_init+0x54>)
 810d7dc:	701a      	strb	r2, [r3, #0]

	metal_list_init(&_metal.common.bus_list);
 810d7de:	480c      	ldr	r0, [pc, #48]	@ (810d810 <metal_init+0x58>)
 810d7e0:	f7ff ffd8 	bl	810d794 <metal_list_init>
	metal_list_init(&_metal.common.generic_shmem_list);
 810d7e4:	480b      	ldr	r0, [pc, #44]	@ (810d814 <metal_init+0x5c>)
 810d7e6:	f7ff ffd5 	bl	810d794 <metal_list_init>
	metal_list_init(&_metal.common.generic_device_list);
 810d7ea:	480b      	ldr	r0, [pc, #44]	@ (810d818 <metal_init+0x60>)
 810d7ec:	f7ff ffd2 	bl	810d794 <metal_list_init>

	error = metal_sys_init(params);
 810d7f0:	6878      	ldr	r0, [r7, #4]
 810d7f2:	f7ff ff83 	bl	810d6fc <metal_sys_init>
 810d7f6:	60f8      	str	r0, [r7, #12]
	if (error)
 810d7f8:	68fb      	ldr	r3, [r7, #12]
 810d7fa:	2b00      	cmp	r3, #0
 810d7fc:	d001      	beq.n	810d802 <metal_init+0x4a>
		return error;
 810d7fe:	68fb      	ldr	r3, [r7, #12]
 810d800:	e000      	b.n	810d804 <metal_init+0x4c>

	return error;
 810d802:	68fb      	ldr	r3, [r7, #12]
}
 810d804:	4618      	mov	r0, r3
 810d806:	3710      	adds	r7, #16
 810d808:	46bd      	mov	sp, r7
 810d80a:	bd80      	pop	{r7, pc}
 810d80c:	1000552c 	.word	0x1000552c
 810d810:	10005534 	.word	0x10005534
 810d814:	1000553c 	.word	0x1000553c
 810d818:	10005544 	.word	0x10005544

0810d81c <metal_io_virt>:
 * @param[in]	offset	Offset into shared memory segment.
 * @return	NULL if offset is out of range, or pointer to offset.
 */
static inline void *
metal_io_virt(struct metal_io_region *io, unsigned long offset)
{
 810d81c:	b480      	push	{r7}
 810d81e:	b083      	sub	sp, #12
 810d820:	af00      	add	r7, sp, #0
 810d822:	6078      	str	r0, [r7, #4]
 810d824:	6039      	str	r1, [r7, #0]
	return (io->virt != METAL_BAD_VA && offset <= io->size
 810d826:	687b      	ldr	r3, [r7, #4]
 810d828:	681b      	ldr	r3, [r3, #0]
		? (uint8_t *)io->virt + offset
		: NULL);
 810d82a:	f1b3 3fff 	cmp.w	r3, #4294967295
 810d82e:	d009      	beq.n	810d844 <metal_io_virt+0x28>
	return (io->virt != METAL_BAD_VA && offset <= io->size
 810d830:	687b      	ldr	r3, [r7, #4]
 810d832:	689b      	ldr	r3, [r3, #8]
 810d834:	683a      	ldr	r2, [r7, #0]
 810d836:	429a      	cmp	r2, r3
 810d838:	d804      	bhi.n	810d844 <metal_io_virt+0x28>
		? (uint8_t *)io->virt + offset
 810d83a:	687b      	ldr	r3, [r7, #4]
 810d83c:	681a      	ldr	r2, [r3, #0]
		: NULL);
 810d83e:	683b      	ldr	r3, [r7, #0]
 810d840:	4413      	add	r3, r2
 810d842:	e000      	b.n	810d846 <metal_io_virt+0x2a>
 810d844:	2300      	movs	r3, #0
}
 810d846:	4618      	mov	r0, r3
 810d848:	370c      	adds	r7, #12
 810d84a:	46bd      	mov	sp, r7
 810d84c:	f85d 7b04 	ldr.w	r7, [sp], #4
 810d850:	4770      	bx	lr

0810d852 <metal_io_init>:

void metal_io_init(struct metal_io_region *io, void *virt,
	      const metal_phys_addr_t *physmap, size_t size,
	      unsigned page_shift, unsigned int mem_flags,
	      const struct metal_io_ops *ops)
{
 810d852:	b5b0      	push	{r4, r5, r7, lr}
 810d854:	b08a      	sub	sp, #40	@ 0x28
 810d856:	af00      	add	r7, sp, #0
 810d858:	60f8      	str	r0, [r7, #12]
 810d85a:	60b9      	str	r1, [r7, #8]
 810d85c:	607a      	str	r2, [r7, #4]
 810d85e:	603b      	str	r3, [r7, #0]
	const struct metal_io_ops nops = {NULL, NULL, NULL, NULL, NULL, NULL};
 810d860:	f107 0310 	add.w	r3, r7, #16
 810d864:	2200      	movs	r2, #0
 810d866:	601a      	str	r2, [r3, #0]
 810d868:	605a      	str	r2, [r3, #4]
 810d86a:	609a      	str	r2, [r3, #8]
 810d86c:	60da      	str	r2, [r3, #12]
 810d86e:	611a      	str	r2, [r3, #16]
 810d870:	615a      	str	r2, [r3, #20]

	io->virt = virt;
 810d872:	68fb      	ldr	r3, [r7, #12]
 810d874:	68ba      	ldr	r2, [r7, #8]
 810d876:	601a      	str	r2, [r3, #0]
	io->physmap = physmap;
 810d878:	68fb      	ldr	r3, [r7, #12]
 810d87a:	687a      	ldr	r2, [r7, #4]
 810d87c:	605a      	str	r2, [r3, #4]
	io->size = size;
 810d87e:	68fb      	ldr	r3, [r7, #12]
 810d880:	683a      	ldr	r2, [r7, #0]
 810d882:	609a      	str	r2, [r3, #8]
	io->page_shift = page_shift;
 810d884:	68fb      	ldr	r3, [r7, #12]
 810d886:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 810d888:	60da      	str	r2, [r3, #12]
	if (page_shift >= sizeof(io->page_mask) * CHAR_BIT)
 810d88a:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810d88c:	2b1f      	cmp	r3, #31
 810d88e:	d904      	bls.n	810d89a <metal_io_init+0x48>
		/* avoid overflow */
		io->page_mask = -1UL;
 810d890:	68fb      	ldr	r3, [r7, #12]
 810d892:	f04f 32ff 	mov.w	r2, #4294967295
 810d896:	611a      	str	r2, [r3, #16]
 810d898:	e006      	b.n	810d8a8 <metal_io_init+0x56>
	else
		io->page_mask = (1UL << page_shift) - 1UL;
 810d89a:	2201      	movs	r2, #1
 810d89c:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810d89e:	fa02 f303 	lsl.w	r3, r2, r3
 810d8a2:	1e5a      	subs	r2, r3, #1
 810d8a4:	68fb      	ldr	r3, [r7, #12]
 810d8a6:	611a      	str	r2, [r3, #16]
	io->mem_flags = mem_flags;
 810d8a8:	68fb      	ldr	r3, [r7, #12]
 810d8aa:	6bfa      	ldr	r2, [r7, #60]	@ 0x3c
 810d8ac:	615a      	str	r2, [r3, #20]
	io->ops = ops ? *ops : nops;
 810d8ae:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 810d8b0:	2b00      	cmp	r3, #0
 810d8b2:	d00b      	beq.n	810d8cc <metal_io_init+0x7a>
 810d8b4:	68fb      	ldr	r3, [r7, #12]
 810d8b6:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 810d8b8:	f103 0418 	add.w	r4, r3, #24
 810d8bc:	4615      	mov	r5, r2
 810d8be:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 810d8c0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 810d8c2:	e895 0003 	ldmia.w	r5, {r0, r1}
 810d8c6:	e884 0003 	stmia.w	r4, {r0, r1}
 810d8ca:	e00a      	b.n	810d8e2 <metal_io_init+0x90>
 810d8cc:	68fb      	ldr	r3, [r7, #12]
 810d8ce:	f103 0418 	add.w	r4, r3, #24
 810d8d2:	f107 0510 	add.w	r5, r7, #16
 810d8d6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 810d8d8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 810d8da:	e895 0003 	ldmia.w	r5, {r0, r1}
 810d8de:	e884 0003 	stmia.w	r4, {r0, r1}
	metal_sys_io_mem_map(io);
 810d8e2:	68f8      	ldr	r0, [r7, #12]
 810d8e4:	f7ff ff18 	bl	810d718 <metal_sys_io_mem_map>
}
 810d8e8:	bf00      	nop
 810d8ea:	3728      	adds	r7, #40	@ 0x28
 810d8ec:	46bd      	mov	sp, r7
 810d8ee:	bdb0      	pop	{r4, r5, r7, pc}

0810d8f0 <metal_io_block_read>:

int metal_io_block_read(struct metal_io_region *io, unsigned long offset,
	       void *restrict dst, int len)
{
 810d8f0:	b590      	push	{r4, r7, lr}
 810d8f2:	b08b      	sub	sp, #44	@ 0x2c
 810d8f4:	af02      	add	r7, sp, #8
 810d8f6:	60f8      	str	r0, [r7, #12]
 810d8f8:	60b9      	str	r1, [r7, #8]
 810d8fa:	607a      	str	r2, [r7, #4]
 810d8fc:	603b      	str	r3, [r7, #0]
	unsigned char *ptr = metal_io_virt(io, offset);
 810d8fe:	68b9      	ldr	r1, [r7, #8]
 810d900:	68f8      	ldr	r0, [r7, #12]
 810d902:	f7ff ff8b 	bl	810d81c <metal_io_virt>
 810d906:	61f8      	str	r0, [r7, #28]
	unsigned char *dest = dst;
 810d908:	687b      	ldr	r3, [r7, #4]
 810d90a:	61bb      	str	r3, [r7, #24]
	int retlen;

	if (offset > io->size)
 810d90c:	68fb      	ldr	r3, [r7, #12]
 810d90e:	689b      	ldr	r3, [r3, #8]
 810d910:	68ba      	ldr	r2, [r7, #8]
 810d912:	429a      	cmp	r2, r3
 810d914:	d902      	bls.n	810d91c <metal_io_block_read+0x2c>
		return -ERANGE;
 810d916:	f06f 0321 	mvn.w	r3, #33	@ 0x21
 810d91a:	e05c      	b.n	810d9d6 <metal_io_block_read+0xe6>
	if ((offset + len) > io->size)
 810d91c:	683a      	ldr	r2, [r7, #0]
 810d91e:	68bb      	ldr	r3, [r7, #8]
 810d920:	441a      	add	r2, r3
 810d922:	68fb      	ldr	r3, [r7, #12]
 810d924:	689b      	ldr	r3, [r3, #8]
 810d926:	429a      	cmp	r2, r3
 810d928:	d904      	bls.n	810d934 <metal_io_block_read+0x44>
		len = io->size - offset;
 810d92a:	68fb      	ldr	r3, [r7, #12]
 810d92c:	689a      	ldr	r2, [r3, #8]
 810d92e:	68bb      	ldr	r3, [r7, #8]
 810d930:	1ad3      	subs	r3, r2, r3
 810d932:	603b      	str	r3, [r7, #0]
	retlen = len;
 810d934:	683b      	ldr	r3, [r7, #0]
 810d936:	617b      	str	r3, [r7, #20]
	if (io->ops.block_read) {
 810d938:	68fb      	ldr	r3, [r7, #12]
 810d93a:	6a1b      	ldr	r3, [r3, #32]
 810d93c:	2b00      	cmp	r3, #0
 810d93e:	d00a      	beq.n	810d956 <metal_io_block_read+0x66>
		retlen = (*io->ops.block_read)(
 810d940:	68fb      	ldr	r3, [r7, #12]
 810d942:	6a1c      	ldr	r4, [r3, #32]
 810d944:	683b      	ldr	r3, [r7, #0]
 810d946:	9300      	str	r3, [sp, #0]
 810d948:	2305      	movs	r3, #5
 810d94a:	687a      	ldr	r2, [r7, #4]
 810d94c:	68b9      	ldr	r1, [r7, #8]
 810d94e:	68f8      	ldr	r0, [r7, #12]
 810d950:	47a0      	blx	r4
 810d952:	6178      	str	r0, [r7, #20]
 810d954:	e03e      	b.n	810d9d4 <metal_io_block_read+0xe4>
			io, offset, dst, memory_order_seq_cst, len);
	} else {
		atomic_thread_fence(memory_order_seq_cst);
 810d956:	f3bf 8f5b 	dmb	ish
		while ( len && (
 810d95a:	e00c      	b.n	810d976 <metal_io_block_read+0x86>
			((uintptr_t)dest % sizeof(int)) ||
			((uintptr_t)ptr % sizeof(int)))) {
			*(unsigned char *)dest =
				*(const unsigned char *)ptr;
 810d95c:	69fb      	ldr	r3, [r7, #28]
 810d95e:	781a      	ldrb	r2, [r3, #0]
			*(unsigned char *)dest =
 810d960:	69bb      	ldr	r3, [r7, #24]
 810d962:	701a      	strb	r2, [r3, #0]
			dest++;
 810d964:	69bb      	ldr	r3, [r7, #24]
 810d966:	3301      	adds	r3, #1
 810d968:	61bb      	str	r3, [r7, #24]
			ptr++;
 810d96a:	69fb      	ldr	r3, [r7, #28]
 810d96c:	3301      	adds	r3, #1
 810d96e:	61fb      	str	r3, [r7, #28]
			len--;
 810d970:	683b      	ldr	r3, [r7, #0]
 810d972:	3b01      	subs	r3, #1
 810d974:	603b      	str	r3, [r7, #0]
		while ( len && (
 810d976:	683b      	ldr	r3, [r7, #0]
 810d978:	2b00      	cmp	r3, #0
 810d97a:	d017      	beq.n	810d9ac <metal_io_block_read+0xbc>
			((uintptr_t)dest % sizeof(int)) ||
 810d97c:	69bb      	ldr	r3, [r7, #24]
 810d97e:	f003 0303 	and.w	r3, r3, #3
		while ( len && (
 810d982:	2b00      	cmp	r3, #0
 810d984:	d1ea      	bne.n	810d95c <metal_io_block_read+0x6c>
			((uintptr_t)ptr % sizeof(int)))) {
 810d986:	69fb      	ldr	r3, [r7, #28]
 810d988:	f003 0303 	and.w	r3, r3, #3
			((uintptr_t)dest % sizeof(int)) ||
 810d98c:	2b00      	cmp	r3, #0
 810d98e:	d1e5      	bne.n	810d95c <metal_io_block_read+0x6c>
		}
		for (; len >= (int)sizeof(int); dest += sizeof(int),
 810d990:	e00c      	b.n	810d9ac <metal_io_block_read+0xbc>
					ptr += sizeof(int),
					len -= sizeof(int))
			*(unsigned int *)dest = *(const unsigned int *)ptr;
 810d992:	69fb      	ldr	r3, [r7, #28]
 810d994:	681a      	ldr	r2, [r3, #0]
 810d996:	69bb      	ldr	r3, [r7, #24]
 810d998:	601a      	str	r2, [r3, #0]
		for (; len >= (int)sizeof(int); dest += sizeof(int),
 810d99a:	69bb      	ldr	r3, [r7, #24]
 810d99c:	3304      	adds	r3, #4
 810d99e:	61bb      	str	r3, [r7, #24]
					ptr += sizeof(int),
 810d9a0:	69fb      	ldr	r3, [r7, #28]
 810d9a2:	3304      	adds	r3, #4
 810d9a4:	61fb      	str	r3, [r7, #28]
					len -= sizeof(int))
 810d9a6:	683b      	ldr	r3, [r7, #0]
 810d9a8:	3b04      	subs	r3, #4
 810d9aa:	603b      	str	r3, [r7, #0]
		for (; len >= (int)sizeof(int); dest += sizeof(int),
 810d9ac:	683b      	ldr	r3, [r7, #0]
 810d9ae:	2b03      	cmp	r3, #3
 810d9b0:	dcef      	bgt.n	810d992 <metal_io_block_read+0xa2>
		for (; len != 0; dest++, ptr++, len--)
 810d9b2:	e00c      	b.n	810d9ce <metal_io_block_read+0xde>
			*(unsigned char *)dest =
				*(const unsigned char *)ptr;
 810d9b4:	69fb      	ldr	r3, [r7, #28]
 810d9b6:	781a      	ldrb	r2, [r3, #0]
			*(unsigned char *)dest =
 810d9b8:	69bb      	ldr	r3, [r7, #24]
 810d9ba:	701a      	strb	r2, [r3, #0]
		for (; len != 0; dest++, ptr++, len--)
 810d9bc:	69bb      	ldr	r3, [r7, #24]
 810d9be:	3301      	adds	r3, #1
 810d9c0:	61bb      	str	r3, [r7, #24]
 810d9c2:	69fb      	ldr	r3, [r7, #28]
 810d9c4:	3301      	adds	r3, #1
 810d9c6:	61fb      	str	r3, [r7, #28]
 810d9c8:	683b      	ldr	r3, [r7, #0]
 810d9ca:	3b01      	subs	r3, #1
 810d9cc:	603b      	str	r3, [r7, #0]
 810d9ce:	683b      	ldr	r3, [r7, #0]
 810d9d0:	2b00      	cmp	r3, #0
 810d9d2:	d1ef      	bne.n	810d9b4 <metal_io_block_read+0xc4>
	}
	return retlen;
 810d9d4:	697b      	ldr	r3, [r7, #20]
}
 810d9d6:	4618      	mov	r0, r3
 810d9d8:	3724      	adds	r7, #36	@ 0x24
 810d9da:	46bd      	mov	sp, r7
 810d9dc:	bd90      	pop	{r4, r7, pc}

0810d9de <metal_io_block_write>:

int metal_io_block_write(struct metal_io_region *io, unsigned long offset,
	       const void *restrict src, int len)
{
 810d9de:	b590      	push	{r4, r7, lr}
 810d9e0:	b08b      	sub	sp, #44	@ 0x2c
 810d9e2:	af02      	add	r7, sp, #8
 810d9e4:	60f8      	str	r0, [r7, #12]
 810d9e6:	60b9      	str	r1, [r7, #8]
 810d9e8:	607a      	str	r2, [r7, #4]
 810d9ea:	603b      	str	r3, [r7, #0]
	unsigned char *ptr = metal_io_virt(io, offset);
 810d9ec:	68b9      	ldr	r1, [r7, #8]
 810d9ee:	68f8      	ldr	r0, [r7, #12]
 810d9f0:	f7ff ff14 	bl	810d81c <metal_io_virt>
 810d9f4:	61f8      	str	r0, [r7, #28]
	const unsigned char *source = src;
 810d9f6:	687b      	ldr	r3, [r7, #4]
 810d9f8:	61bb      	str	r3, [r7, #24]
	int retlen;

	if (offset > io->size)
 810d9fa:	68fb      	ldr	r3, [r7, #12]
 810d9fc:	689b      	ldr	r3, [r3, #8]
 810d9fe:	68ba      	ldr	r2, [r7, #8]
 810da00:	429a      	cmp	r2, r3
 810da02:	d902      	bls.n	810da0a <metal_io_block_write+0x2c>
		return -ERANGE;
 810da04:	f06f 0321 	mvn.w	r3, #33	@ 0x21
 810da08:	e05b      	b.n	810dac2 <metal_io_block_write+0xe4>
	if ((offset + len) > io->size)
 810da0a:	683a      	ldr	r2, [r7, #0]
 810da0c:	68bb      	ldr	r3, [r7, #8]
 810da0e:	441a      	add	r2, r3
 810da10:	68fb      	ldr	r3, [r7, #12]
 810da12:	689b      	ldr	r3, [r3, #8]
 810da14:	429a      	cmp	r2, r3
 810da16:	d904      	bls.n	810da22 <metal_io_block_write+0x44>
		len = io->size - offset;
 810da18:	68fb      	ldr	r3, [r7, #12]
 810da1a:	689a      	ldr	r2, [r3, #8]
 810da1c:	68bb      	ldr	r3, [r7, #8]
 810da1e:	1ad3      	subs	r3, r2, r3
 810da20:	603b      	str	r3, [r7, #0]
	retlen = len;
 810da22:	683b      	ldr	r3, [r7, #0]
 810da24:	617b      	str	r3, [r7, #20]
	if (io->ops.block_write) {
 810da26:	68fb      	ldr	r3, [r7, #12]
 810da28:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810da2a:	2b00      	cmp	r3, #0
 810da2c:	d017      	beq.n	810da5e <metal_io_block_write+0x80>
		retlen = (*io->ops.block_write)(
 810da2e:	68fb      	ldr	r3, [r7, #12]
 810da30:	6a5c      	ldr	r4, [r3, #36]	@ 0x24
 810da32:	683b      	ldr	r3, [r7, #0]
 810da34:	9300      	str	r3, [sp, #0]
 810da36:	2305      	movs	r3, #5
 810da38:	687a      	ldr	r2, [r7, #4]
 810da3a:	68b9      	ldr	r1, [r7, #8]
 810da3c:	68f8      	ldr	r0, [r7, #12]
 810da3e:	47a0      	blx	r4
 810da40:	6178      	str	r0, [r7, #20]
 810da42:	e03d      	b.n	810dac0 <metal_io_block_write+0xe2>
	} else {
		while ( len && (
			((uintptr_t)ptr % sizeof(int)) ||
			((uintptr_t)source % sizeof(int)))) {
			*(unsigned char *)ptr =
				*(const unsigned char *)source;
 810da44:	69bb      	ldr	r3, [r7, #24]
 810da46:	781a      	ldrb	r2, [r3, #0]
			*(unsigned char *)ptr =
 810da48:	69fb      	ldr	r3, [r7, #28]
 810da4a:	701a      	strb	r2, [r3, #0]
			ptr++;
 810da4c:	69fb      	ldr	r3, [r7, #28]
 810da4e:	3301      	adds	r3, #1
 810da50:	61fb      	str	r3, [r7, #28]
			source++;
 810da52:	69bb      	ldr	r3, [r7, #24]
 810da54:	3301      	adds	r3, #1
 810da56:	61bb      	str	r3, [r7, #24]
			len--;
 810da58:	683b      	ldr	r3, [r7, #0]
 810da5a:	3b01      	subs	r3, #1
 810da5c:	603b      	str	r3, [r7, #0]
		while ( len && (
 810da5e:	683b      	ldr	r3, [r7, #0]
 810da60:	2b00      	cmp	r3, #0
 810da62:	d017      	beq.n	810da94 <metal_io_block_write+0xb6>
			((uintptr_t)ptr % sizeof(int)) ||
 810da64:	69fb      	ldr	r3, [r7, #28]
 810da66:	f003 0303 	and.w	r3, r3, #3
		while ( len && (
 810da6a:	2b00      	cmp	r3, #0
 810da6c:	d1ea      	bne.n	810da44 <metal_io_block_write+0x66>
			((uintptr_t)source % sizeof(int)))) {
 810da6e:	69bb      	ldr	r3, [r7, #24]
 810da70:	f003 0303 	and.w	r3, r3, #3
			((uintptr_t)ptr % sizeof(int)) ||
 810da74:	2b00      	cmp	r3, #0
 810da76:	d1e5      	bne.n	810da44 <metal_io_block_write+0x66>
		}
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 810da78:	e00c      	b.n	810da94 <metal_io_block_write+0xb6>
					source += sizeof(int),
					len -= sizeof(int))
			*(unsigned int *)ptr = *(const unsigned int *)source;
 810da7a:	69bb      	ldr	r3, [r7, #24]
 810da7c:	681a      	ldr	r2, [r3, #0]
 810da7e:	69fb      	ldr	r3, [r7, #28]
 810da80:	601a      	str	r2, [r3, #0]
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 810da82:	69fb      	ldr	r3, [r7, #28]
 810da84:	3304      	adds	r3, #4
 810da86:	61fb      	str	r3, [r7, #28]
					source += sizeof(int),
 810da88:	69bb      	ldr	r3, [r7, #24]
 810da8a:	3304      	adds	r3, #4
 810da8c:	61bb      	str	r3, [r7, #24]
					len -= sizeof(int))
 810da8e:	683b      	ldr	r3, [r7, #0]
 810da90:	3b04      	subs	r3, #4
 810da92:	603b      	str	r3, [r7, #0]
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 810da94:	683b      	ldr	r3, [r7, #0]
 810da96:	2b03      	cmp	r3, #3
 810da98:	dcef      	bgt.n	810da7a <metal_io_block_write+0x9c>
		for (; len != 0; ptr++, source++, len--)
 810da9a:	e00c      	b.n	810dab6 <metal_io_block_write+0xd8>
			*(unsigned char *)ptr =
				*(const unsigned char *)source;
 810da9c:	69bb      	ldr	r3, [r7, #24]
 810da9e:	781a      	ldrb	r2, [r3, #0]
			*(unsigned char *)ptr =
 810daa0:	69fb      	ldr	r3, [r7, #28]
 810daa2:	701a      	strb	r2, [r3, #0]
		for (; len != 0; ptr++, source++, len--)
 810daa4:	69fb      	ldr	r3, [r7, #28]
 810daa6:	3301      	adds	r3, #1
 810daa8:	61fb      	str	r3, [r7, #28]
 810daaa:	69bb      	ldr	r3, [r7, #24]
 810daac:	3301      	adds	r3, #1
 810daae:	61bb      	str	r3, [r7, #24]
 810dab0:	683b      	ldr	r3, [r7, #0]
 810dab2:	3b01      	subs	r3, #1
 810dab4:	603b      	str	r3, [r7, #0]
 810dab6:	683b      	ldr	r3, [r7, #0]
 810dab8:	2b00      	cmp	r3, #0
 810daba:	d1ef      	bne.n	810da9c <metal_io_block_write+0xbe>
		atomic_thread_fence(memory_order_seq_cst);
 810dabc:	f3bf 8f5b 	dmb	ish
	}
	return retlen;
 810dac0:	697b      	ldr	r3, [r7, #20]
}
 810dac2:	4618      	mov	r0, r3
 810dac4:	3724      	adds	r7, #36	@ 0x24
 810dac6:	46bd      	mov	sp, r7
 810dac8:	bd90      	pop	{r4, r7, pc}

0810daca <metal_default_log_handler>:
#include <metal/log.h>
#include <metal/sys.h>

void metal_default_log_handler(enum metal_log_level level,
			       const char *format, ...)
{
 810daca:	b40e      	push	{r1, r2, r3}
 810dacc:	b480      	push	{r7}
 810dace:	b082      	sub	sp, #8
 810dad0:	af00      	add	r7, sp, #0
 810dad2:	4603      	mov	r3, r0
 810dad4:	71fb      	strb	r3, [r7, #7]
	fprintf(stderr, "%s%s", level_strs[level], msg);
#else
	(void)level;
	(void)format;
#endif
}
 810dad6:	bf00      	nop
 810dad8:	3708      	adds	r7, #8
 810dada:	46bd      	mov	sp, r7
 810dadc:	f85d 7b04 	ldr.w	r7, [sp], #4
 810dae0:	b003      	add	sp, #12
 810dae2:	4770      	bx	lr

0810dae4 <metal_io_virt>:
{
 810dae4:	b480      	push	{r7}
 810dae6:	b083      	sub	sp, #12
 810dae8:	af00      	add	r7, sp, #0
 810daea:	6078      	str	r0, [r7, #4]
 810daec:	6039      	str	r1, [r7, #0]
	return (io->virt != METAL_BAD_VA && offset <= io->size
 810daee:	687b      	ldr	r3, [r7, #4]
 810daf0:	681b      	ldr	r3, [r3, #0]
		: NULL);
 810daf2:	f1b3 3fff 	cmp.w	r3, #4294967295
 810daf6:	d009      	beq.n	810db0c <metal_io_virt+0x28>
	return (io->virt != METAL_BAD_VA && offset <= io->size
 810daf8:	687b      	ldr	r3, [r7, #4]
 810dafa:	689b      	ldr	r3, [r3, #8]
 810dafc:	683a      	ldr	r2, [r7, #0]
 810dafe:	429a      	cmp	r2, r3
 810db00:	d804      	bhi.n	810db0c <metal_io_virt+0x28>
		? (uint8_t *)io->virt + offset
 810db02:	687b      	ldr	r3, [r7, #4]
 810db04:	681a      	ldr	r2, [r3, #0]
		: NULL);
 810db06:	683b      	ldr	r3, [r7, #0]
 810db08:	4413      	add	r3, r2
 810db0a:	e000      	b.n	810db0e <metal_io_virt+0x2a>
 810db0c:	2300      	movs	r3, #0
}
 810db0e:	4618      	mov	r0, r3
 810db10:	370c      	adds	r7, #12
 810db12:	46bd      	mov	sp, r7
 810db14:	f85d 7b04 	ldr.w	r7, [sp], #4
 810db18:	4770      	bx	lr

0810db1a <metal_io_virt_to_offset>:
 * @param[in]	virt	Virtual address within segment.
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_virt_to_offset(struct metal_io_region *io, void *virt)
{
 810db1a:	b480      	push	{r7}
 810db1c:	b085      	sub	sp, #20
 810db1e:	af00      	add	r7, sp, #0
 810db20:	6078      	str	r0, [r7, #4]
 810db22:	6039      	str	r1, [r7, #0]
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 810db24:	687b      	ldr	r3, [r7, #4]
 810db26:	681b      	ldr	r3, [r3, #0]
 810db28:	683a      	ldr	r2, [r7, #0]
 810db2a:	1ad3      	subs	r3, r2, r3
 810db2c:	60fb      	str	r3, [r7, #12]
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 810db2e:	687b      	ldr	r3, [r7, #4]
 810db30:	689b      	ldr	r3, [r3, #8]
 810db32:	68fa      	ldr	r2, [r7, #12]
 810db34:	429a      	cmp	r2, r3
 810db36:	d201      	bcs.n	810db3c <metal_io_virt_to_offset+0x22>
 810db38:	68fb      	ldr	r3, [r7, #12]
 810db3a:	e001      	b.n	810db40 <metal_io_virt_to_offset+0x26>
 810db3c:	f04f 33ff 	mov.w	r3, #4294967295
}
 810db40:	4618      	mov	r0, r3
 810db42:	3714      	adds	r7, #20
 810db44:	46bd      	mov	sp, r7
 810db46:	f85d 7b04 	ldr.w	r7, [sp], #4
 810db4a:	4770      	bx	lr

0810db4c <metal_io_read>:
 * @return	Value.
 */
static inline uint64_t
metal_io_read(struct metal_io_region *io, unsigned long offset,
	      memory_order order, int width)
{
 810db4c:	b5b0      	push	{r4, r5, r7, lr}
 810db4e:	b08c      	sub	sp, #48	@ 0x30
 810db50:	af00      	add	r7, sp, #0
 810db52:	60f8      	str	r0, [r7, #12]
 810db54:	60b9      	str	r1, [r7, #8]
 810db56:	603b      	str	r3, [r7, #0]
 810db58:	4613      	mov	r3, r2
 810db5a:	71fb      	strb	r3, [r7, #7]
	void *ptr = metal_io_virt(io, offset);
 810db5c:	68b9      	ldr	r1, [r7, #8]
 810db5e:	68f8      	ldr	r0, [r7, #12]
 810db60:	f7ff ffc0 	bl	810dae4 <metal_io_virt>
 810db64:	62f8      	str	r0, [r7, #44]	@ 0x2c

	if (io->ops.read)
 810db66:	68fb      	ldr	r3, [r7, #12]
 810db68:	699b      	ldr	r3, [r3, #24]
 810db6a:	2b00      	cmp	r3, #0
 810db6c:	d009      	beq.n	810db82 <metal_io_read+0x36>
		return (*io->ops.read)(io, offset, order, width);
 810db6e:	68fb      	ldr	r3, [r7, #12]
 810db70:	699c      	ldr	r4, [r3, #24]
 810db72:	79fa      	ldrb	r2, [r7, #7]
 810db74:	683b      	ldr	r3, [r7, #0]
 810db76:	68b9      	ldr	r1, [r7, #8]
 810db78:	68f8      	ldr	r0, [r7, #12]
 810db7a:	47a0      	blx	r4
 810db7c:	4604      	mov	r4, r0
 810db7e:	460d      	mov	r5, r1
 810db80:	e059      	b.n	810dc36 <metal_io_read+0xea>
	else if (ptr && sizeof(atomic_uchar) == width)
 810db82:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810db84:	2b00      	cmp	r3, #0
 810db86:	d012      	beq.n	810dbae <metal_io_read+0x62>
 810db88:	683b      	ldr	r3, [r7, #0]
 810db8a:	2b01      	cmp	r3, #1
 810db8c:	d10f      	bne.n	810dbae <metal_io_read+0x62>
		return atomic_load_explicit((atomic_uchar *)ptr, order);
 810db8e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810db90:	62bb      	str	r3, [r7, #40]	@ 0x28
 810db92:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810db94:	f3bf 8f5b 	dmb	ish
 810db98:	781b      	ldrb	r3, [r3, #0]
 810db9a:	f3bf 8f5b 	dmb	ish
 810db9e:	b2db      	uxtb	r3, r3
 810dba0:	76fb      	strb	r3, [r7, #27]
 810dba2:	7efb      	ldrb	r3, [r7, #27]
 810dba4:	b2db      	uxtb	r3, r3
 810dba6:	2200      	movs	r2, #0
 810dba8:	461c      	mov	r4, r3
 810dbaa:	4615      	mov	r5, r2
 810dbac:	e043      	b.n	810dc36 <metal_io_read+0xea>
	else if (ptr && sizeof(atomic_ushort) == width)
 810dbae:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810dbb0:	2b00      	cmp	r3, #0
 810dbb2:	d012      	beq.n	810dbda <metal_io_read+0x8e>
 810dbb4:	683b      	ldr	r3, [r7, #0]
 810dbb6:	2b02      	cmp	r3, #2
 810dbb8:	d10f      	bne.n	810dbda <metal_io_read+0x8e>
		return atomic_load_explicit((atomic_ushort *)ptr, order);
 810dbba:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810dbbc:	627b      	str	r3, [r7, #36]	@ 0x24
 810dbbe:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810dbc0:	f3bf 8f5b 	dmb	ish
 810dbc4:	881b      	ldrh	r3, [r3, #0]
 810dbc6:	f3bf 8f5b 	dmb	ish
 810dbca:	b29b      	uxth	r3, r3
 810dbcc:	833b      	strh	r3, [r7, #24]
 810dbce:	8b3b      	ldrh	r3, [r7, #24]
 810dbd0:	b29b      	uxth	r3, r3
 810dbd2:	2200      	movs	r2, #0
 810dbd4:	461c      	mov	r4, r3
 810dbd6:	4615      	mov	r5, r2
 810dbd8:	e02d      	b.n	810dc36 <metal_io_read+0xea>
	else if (ptr && sizeof(atomic_uint) == width)
 810dbda:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810dbdc:	2b00      	cmp	r3, #0
 810dbde:	d010      	beq.n	810dc02 <metal_io_read+0xb6>
 810dbe0:	683b      	ldr	r3, [r7, #0]
 810dbe2:	2b04      	cmp	r3, #4
 810dbe4:	d10d      	bne.n	810dc02 <metal_io_read+0xb6>
		return atomic_load_explicit((atomic_uint *)ptr, order);
 810dbe6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810dbe8:	623b      	str	r3, [r7, #32]
 810dbea:	6a3b      	ldr	r3, [r7, #32]
 810dbec:	f3bf 8f5b 	dmb	ish
 810dbf0:	681b      	ldr	r3, [r3, #0]
 810dbf2:	f3bf 8f5b 	dmb	ish
 810dbf6:	617b      	str	r3, [r7, #20]
 810dbf8:	697b      	ldr	r3, [r7, #20]
 810dbfa:	2200      	movs	r2, #0
 810dbfc:	461c      	mov	r4, r3
 810dbfe:	4615      	mov	r5, r2
 810dc00:	e019      	b.n	810dc36 <metal_io_read+0xea>
	else if (ptr && sizeof(atomic_ulong) == width)
 810dc02:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810dc04:	2b00      	cmp	r3, #0
 810dc06:	d010      	beq.n	810dc2a <metal_io_read+0xde>
 810dc08:	683b      	ldr	r3, [r7, #0]
 810dc0a:	2b04      	cmp	r3, #4
 810dc0c:	d10d      	bne.n	810dc2a <metal_io_read+0xde>
		return atomic_load_explicit((atomic_ulong *)ptr, order);
 810dc0e:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810dc10:	61fb      	str	r3, [r7, #28]
 810dc12:	69fb      	ldr	r3, [r7, #28]
 810dc14:	f3bf 8f5b 	dmb	ish
 810dc18:	681b      	ldr	r3, [r3, #0]
 810dc1a:	f3bf 8f5b 	dmb	ish
 810dc1e:	613b      	str	r3, [r7, #16]
 810dc20:	693b      	ldr	r3, [r7, #16]
 810dc22:	2200      	movs	r2, #0
 810dc24:	461c      	mov	r4, r3
 810dc26:	4615      	mov	r5, r2
 810dc28:	e005      	b.n	810dc36 <metal_io_read+0xea>
#ifndef NO_ATOMIC_64_SUPPORT
	else if (ptr && sizeof(atomic_ullong) == width)
		return atomic_load_explicit((atomic_ullong *)ptr, order);
#endif
	metal_assert(0);
 810dc2a:	4b06      	ldr	r3, [pc, #24]	@ (810dc44 <metal_io_read+0xf8>)
 810dc2c:	4a06      	ldr	r2, [pc, #24]	@ (810dc48 <metal_io_read+0xfc>)
 810dc2e:	21f0      	movs	r1, #240	@ 0xf0
 810dc30:	4806      	ldr	r0, [pc, #24]	@ (810dc4c <metal_io_read+0x100>)
 810dc32:	f001 fe3f 	bl	810f8b4 <__assert_func>
	return 0; /* quiet compiler */
}
 810dc36:	4622      	mov	r2, r4
 810dc38:	462b      	mov	r3, r5
 810dc3a:	4610      	mov	r0, r2
 810dc3c:	4619      	mov	r1, r3
 810dc3e:	3730      	adds	r7, #48	@ 0x30
 810dc40:	46bd      	mov	sp, r7
 810dc42:	bdb0      	pop	{r4, r5, r7, pc}
 810dc44:	08110978 	.word	0x08110978
 810dc48:	0811135c 	.word	0x0811135c
 810dc4c:	0811097c 	.word	0x0811097c

0810dc50 <metal_allocate_memory>:
#ifdef __cplusplus
extern "C" {
#endif

static inline void *metal_allocate_memory(unsigned int size)
{
 810dc50:	b580      	push	{r7, lr}
 810dc52:	b082      	sub	sp, #8
 810dc54:	af00      	add	r7, sp, #0
 810dc56:	6078      	str	r0, [r7, #4]
	return (malloc(size));
 810dc58:	6878      	ldr	r0, [r7, #4]
 810dc5a:	f001 fe49 	bl	810f8f0 <malloc>
 810dc5e:	4603      	mov	r3, r0
}
 810dc60:	4618      	mov	r0, r3
 810dc62:	3708      	adds	r7, #8
 810dc64:	46bd      	mov	sp, r7
 810dc66:	bd80      	pop	{r7, pc}

0810dc68 <metal_free_memory>:

static inline void metal_free_memory(void *ptr)
{
 810dc68:	b580      	push	{r7, lr}
 810dc6a:	b082      	sub	sp, #8
 810dc6c:	af00      	add	r7, sp, #0
 810dc6e:	6078      	str	r0, [r7, #4]
	free(ptr);
 810dc70:	6878      	ldr	r0, [r7, #4]
 810dc72:	f001 fe45 	bl	810f900 <free>
}
 810dc76:	bf00      	nop
 810dc78:	3708      	adds	r7, #8
 810dc7a:	46bd      	mov	sp, r7
 810dc7c:	bd80      	pop	{r7, pc}

0810dc7e <virtqueue_allocate>:
int virtqueue_enable_cb(struct virtqueue *vq);

void virtqueue_kick(struct virtqueue *vq);

static inline struct virtqueue *virtqueue_allocate(unsigned int num_desc_extra)
{
 810dc7e:	b580      	push	{r7, lr}
 810dc80:	b084      	sub	sp, #16
 810dc82:	af00      	add	r7, sp, #0
 810dc84:	6078      	str	r0, [r7, #4]
	struct virtqueue *vqs;
	uint32_t vq_size = sizeof(struct virtqueue) +
 810dc86:	687b      	ldr	r3, [r7, #4]
 810dc88:	3307      	adds	r3, #7
 810dc8a:	00db      	lsls	r3, r3, #3
 810dc8c:	60fb      	str	r3, [r7, #12]
		 num_desc_extra * sizeof(struct vq_desc_extra);

	vqs = (struct virtqueue *)metal_allocate_memory(vq_size);
 810dc8e:	68f8      	ldr	r0, [r7, #12]
 810dc90:	f7ff ffde 	bl	810dc50 <metal_allocate_memory>
 810dc94:	60b8      	str	r0, [r7, #8]

	if (vqs) {
 810dc96:	68bb      	ldr	r3, [r7, #8]
 810dc98:	2b00      	cmp	r3, #0
 810dc9a:	d004      	beq.n	810dca6 <virtqueue_allocate+0x28>
		memset(vqs, 0x00, vq_size);
 810dc9c:	68fa      	ldr	r2, [r7, #12]
 810dc9e:	2100      	movs	r1, #0
 810dca0:	68b8      	ldr	r0, [r7, #8]
 810dca2:	f001 fffa 	bl	810fc9a <memset>
	}

	return vqs;
 810dca6:	68bb      	ldr	r3, [r7, #8]
}
 810dca8:	4618      	mov	r0, r3
 810dcaa:	3710      	adds	r7, #16
 810dcac:	46bd      	mov	sp, r7
 810dcae:	bd80      	pop	{r7, pc}

0810dcb0 <rproc_virtio_virtqueue_notify>:
#include <openamp/virtqueue.h>
#include <metal/utilities.h>
#include <metal/alloc.h>

static void rproc_virtio_virtqueue_notify(struct virtqueue *vq)
{
 810dcb0:	b580      	push	{r7, lr}
 810dcb2:	b086      	sub	sp, #24
 810dcb4:	af00      	add	r7, sp, #0
 810dcb6:	6078      	str	r0, [r7, #4]
	struct remoteproc_virtio *rpvdev;
	struct virtio_vring_info *vring_info;
	struct virtio_device *vdev;
	unsigned int vq_id = vq->vq_queue_index;
 810dcb8:	687b      	ldr	r3, [r7, #4]
 810dcba:	891b      	ldrh	r3, [r3, #8]
 810dcbc:	617b      	str	r3, [r7, #20]

	vdev = vq->vq_dev;
 810dcbe:	687b      	ldr	r3, [r7, #4]
 810dcc0:	681b      	ldr	r3, [r3, #0]
 810dcc2:	613b      	str	r3, [r7, #16]
	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
 810dcc4:	693b      	ldr	r3, [r7, #16]
 810dcc6:	3b18      	subs	r3, #24
 810dcc8:	60fb      	str	r3, [r7, #12]
	metal_assert(vq_id <= vdev->vrings_num);
 810dcca:	693b      	ldr	r3, [r7, #16]
 810dccc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810dcce:	697a      	ldr	r2, [r7, #20]
 810dcd0:	429a      	cmp	r2, r3
 810dcd2:	d905      	bls.n	810dce0 <rproc_virtio_virtqueue_notify+0x30>
 810dcd4:	4b0d      	ldr	r3, [pc, #52]	@ (810dd0c <rproc_virtio_virtqueue_notify+0x5c>)
 810dcd6:	4a0e      	ldr	r2, [pc, #56]	@ (810dd10 <rproc_virtio_virtqueue_notify+0x60>)
 810dcd8:	2133      	movs	r1, #51	@ 0x33
 810dcda:	480e      	ldr	r0, [pc, #56]	@ (810dd14 <rproc_virtio_virtqueue_notify+0x64>)
 810dcdc:	f001 fdea 	bl	810f8b4 <__assert_func>
	vring_info = &vdev->vrings_info[vq_id];
 810dce0:	693b      	ldr	r3, [r7, #16]
 810dce2:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 810dce4:	697a      	ldr	r2, [r7, #20]
 810dce6:	4613      	mov	r3, r2
 810dce8:	005b      	lsls	r3, r3, #1
 810dcea:	4413      	add	r3, r2
 810dcec:	00db      	lsls	r3, r3, #3
 810dcee:	440b      	add	r3, r1
 810dcf0:	60bb      	str	r3, [r7, #8]
	rpvdev->notify(rpvdev->priv, vring_info->notifyid);
 810dcf2:	68fb      	ldr	r3, [r7, #12]
 810dcf4:	691b      	ldr	r3, [r3, #16]
 810dcf6:	68fa      	ldr	r2, [r7, #12]
 810dcf8:	6810      	ldr	r0, [r2, #0]
 810dcfa:	68ba      	ldr	r2, [r7, #8]
 810dcfc:	6912      	ldr	r2, [r2, #16]
 810dcfe:	4611      	mov	r1, r2
 810dd00:	4798      	blx	r3
}
 810dd02:	bf00      	nop
 810dd04:	3718      	adds	r7, #24
 810dd06:	46bd      	mov	sp, r7
 810dd08:	bd80      	pop	{r7, pc}
 810dd0a:	bf00      	nop
 810dd0c:	081109c4 	.word	0x081109c4
 810dd10:	0811133c 	.word	0x0811133c
 810dd14:	081109e0 	.word	0x081109e0

0810dd18 <rproc_virtio_get_status>:

static unsigned char rproc_virtio_get_status(struct virtio_device *vdev)
{
 810dd18:	b580      	push	{r7, lr}
 810dd1a:	b086      	sub	sp, #24
 810dd1c:	af00      	add	r7, sp, #0
 810dd1e:	6078      	str	r0, [r7, #4]
	struct remoteproc_virtio *rpvdev;
	struct fw_rsc_vdev *vdev_rsc;
	struct metal_io_region *io;
	char status;

	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
 810dd20:	687b      	ldr	r3, [r7, #4]
 810dd22:	3b18      	subs	r3, #24
 810dd24:	617b      	str	r3, [r7, #20]
	vdev_rsc = rpvdev->vdev_rsc;
 810dd26:	697b      	ldr	r3, [r7, #20]
 810dd28:	689b      	ldr	r3, [r3, #8]
 810dd2a:	613b      	str	r3, [r7, #16]
	io = rpvdev->vdev_rsc_io;
 810dd2c:	697b      	ldr	r3, [r7, #20]
 810dd2e:	68db      	ldr	r3, [r3, #12]
 810dd30:	60fb      	str	r3, [r7, #12]
	status = metal_io_read8(io,
 810dd32:	693b      	ldr	r3, [r7, #16]
 810dd34:	3318      	adds	r3, #24
 810dd36:	4619      	mov	r1, r3
 810dd38:	68f8      	ldr	r0, [r7, #12]
 810dd3a:	f7ff feee 	bl	810db1a <metal_io_virt_to_offset>
 810dd3e:	4601      	mov	r1, r0
 810dd40:	2301      	movs	r3, #1
 810dd42:	2205      	movs	r2, #5
 810dd44:	68f8      	ldr	r0, [r7, #12]
 810dd46:	f7ff ff01 	bl	810db4c <metal_io_read>
 810dd4a:	4602      	mov	r2, r0
 810dd4c:	460b      	mov	r3, r1
 810dd4e:	4613      	mov	r3, r2
 810dd50:	72fb      	strb	r3, [r7, #11]
				metal_io_virt_to_offset(io, &vdev_rsc->status));
	return status;
 810dd52:	7afb      	ldrb	r3, [r7, #11]
}
 810dd54:	4618      	mov	r0, r3
 810dd56:	3718      	adds	r7, #24
 810dd58:	46bd      	mov	sp, r7
 810dd5a:	bd80      	pop	{r7, pc}

0810dd5c <rproc_virtio_get_features>:
	rpvdev->notify(rpvdev->priv, vdev->index);
}
#endif

static uint32_t rproc_virtio_get_features(struct virtio_device *vdev)
{
 810dd5c:	b580      	push	{r7, lr}
 810dd5e:	b086      	sub	sp, #24
 810dd60:	af00      	add	r7, sp, #0
 810dd62:	6078      	str	r0, [r7, #4]
	struct remoteproc_virtio *rpvdev;
	struct fw_rsc_vdev *vdev_rsc;
	struct metal_io_region *io;
	uint32_t features;

	rpvdev = metal_container_of(vdev, struct remoteproc_virtio, vdev);
 810dd64:	687b      	ldr	r3, [r7, #4]
 810dd66:	3b18      	subs	r3, #24
 810dd68:	617b      	str	r3, [r7, #20]
	vdev_rsc = rpvdev->vdev_rsc;
 810dd6a:	697b      	ldr	r3, [r7, #20]
 810dd6c:	689b      	ldr	r3, [r3, #8]
 810dd6e:	613b      	str	r3, [r7, #16]
	io = rpvdev->vdev_rsc_io;
 810dd70:	697b      	ldr	r3, [r7, #20]
 810dd72:	68db      	ldr	r3, [r3, #12]
 810dd74:	60fb      	str	r3, [r7, #12]
	/* TODO: shall we get features based on the role ? */
	features = metal_io_read32(io,
 810dd76:	693b      	ldr	r3, [r7, #16]
 810dd78:	330c      	adds	r3, #12
 810dd7a:	4619      	mov	r1, r3
 810dd7c:	68f8      	ldr	r0, [r7, #12]
 810dd7e:	f7ff fecc 	bl	810db1a <metal_io_virt_to_offset>
 810dd82:	4601      	mov	r1, r0
 810dd84:	2304      	movs	r3, #4
 810dd86:	2205      	movs	r2, #5
 810dd88:	68f8      	ldr	r0, [r7, #12]
 810dd8a:	f7ff fedf 	bl	810db4c <metal_io_read>
 810dd8e:	4602      	mov	r2, r0
 810dd90:	460b      	mov	r3, r1
 810dd92:	4613      	mov	r3, r2
 810dd94:	60bb      	str	r3, [r7, #8]
			metal_io_virt_to_offset(io, &vdev_rsc->dfeatures));

	return features;
 810dd96:	68bb      	ldr	r3, [r7, #8]
}
 810dd98:	4618      	mov	r0, r3
 810dd9a:	3718      	adds	r7, #24
 810dd9c:	46bd      	mov	sp, r7
 810dd9e:	bd80      	pop	{r7, pc}

0810dda0 <rproc_virtio_negotiate_features>:
}
#endif

static uint32_t rproc_virtio_negotiate_features(struct virtio_device *vdev,
						uint32_t features)
{
 810dda0:	b480      	push	{r7}
 810dda2:	b083      	sub	sp, #12
 810dda4:	af00      	add	r7, sp, #0
 810dda6:	6078      	str	r0, [r7, #4]
 810dda8:	6039      	str	r1, [r7, #0]
	(void)vdev;
	(void)features;

	return 0;
 810ddaa:	2300      	movs	r3, #0
}
 810ddac:	4618      	mov	r0, r3
 810ddae:	370c      	adds	r7, #12
 810ddb0:	46bd      	mov	sp, r7
 810ddb2:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ddb6:	4770      	bx	lr

0810ddb8 <rproc_virtio_read_config>:

static void rproc_virtio_read_config(struct virtio_device *vdev,
				     uint32_t offset, void *dst, int length)
{
 810ddb8:	b480      	push	{r7}
 810ddba:	b085      	sub	sp, #20
 810ddbc:	af00      	add	r7, sp, #0
 810ddbe:	60f8      	str	r0, [r7, #12]
 810ddc0:	60b9      	str	r1, [r7, #8]
 810ddc2:	607a      	str	r2, [r7, #4]
 810ddc4:	603b      	str	r3, [r7, #0]
	(void)vdev;
	(void)offset;
	(void)dst;
	(void)length;
}
 810ddc6:	bf00      	nop
 810ddc8:	3714      	adds	r7, #20
 810ddca:	46bd      	mov	sp, r7
 810ddcc:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ddd0:	4770      	bx	lr
	...

0810ddd4 <rproc_virtio_create_vdev>:
rproc_virtio_create_vdev(unsigned int role, unsigned int notifyid,
			 void *rsc, struct metal_io_region *rsc_io,
			 void *priv,
			 rpvdev_notify_func notify,
			 virtio_dev_reset_cb rst_cb)
{
 810ddd4:	b580      	push	{r7, lr}
 810ddd6:	b08e      	sub	sp, #56	@ 0x38
 810ddd8:	af00      	add	r7, sp, #0
 810ddda:	60f8      	str	r0, [r7, #12]
 810dddc:	60b9      	str	r1, [r7, #8]
 810ddde:	607a      	str	r2, [r7, #4]
 810dde0:	603b      	str	r3, [r7, #0]
	struct remoteproc_virtio *rpvdev;
	struct virtio_vring_info *vrings_info;
	struct fw_rsc_vdev *vdev_rsc = rsc;
 810dde2:	687b      	ldr	r3, [r7, #4]
 810dde4:	62fb      	str	r3, [r7, #44]	@ 0x2c
	struct virtio_device *vdev;
	unsigned int num_vrings = vdev_rsc->num_of_vrings;
 810dde6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810dde8:	7e5b      	ldrb	r3, [r3, #25]
 810ddea:	62bb      	str	r3, [r7, #40]	@ 0x28
	unsigned int i;

	rpvdev = metal_allocate_memory(sizeof(*rpvdev));
 810ddec:	2050      	movs	r0, #80	@ 0x50
 810ddee:	f7ff ff2f 	bl	810dc50 <metal_allocate_memory>
 810ddf2:	6278      	str	r0, [r7, #36]	@ 0x24
	if (!rpvdev)
 810ddf4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810ddf6:	2b00      	cmp	r3, #0
 810ddf8:	d101      	bne.n	810ddfe <rproc_virtio_create_vdev+0x2a>
		return NULL;
 810ddfa:	2300      	movs	r3, #0
 810ddfc:	e092      	b.n	810df24 <rproc_virtio_create_vdev+0x150>
	vrings_info = metal_allocate_memory(sizeof(*vrings_info) * num_vrings);
 810ddfe:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 810de00:	4613      	mov	r3, r2
 810de02:	005b      	lsls	r3, r3, #1
 810de04:	4413      	add	r3, r2
 810de06:	00db      	lsls	r3, r3, #3
 810de08:	4618      	mov	r0, r3
 810de0a:	f7ff ff21 	bl	810dc50 <metal_allocate_memory>
 810de0e:	6238      	str	r0, [r7, #32]
	if (!vrings_info)
 810de10:	6a3b      	ldr	r3, [r7, #32]
 810de12:	2b00      	cmp	r3, #0
 810de14:	f000 8081 	beq.w	810df1a <rproc_virtio_create_vdev+0x146>
		goto err0;
	memset(rpvdev, 0, sizeof(*rpvdev));
 810de18:	2250      	movs	r2, #80	@ 0x50
 810de1a:	2100      	movs	r1, #0
 810de1c:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 810de1e:	f001 ff3c 	bl	810fc9a <memset>
	memset(vrings_info, 0, sizeof(*vrings_info));
 810de22:	2218      	movs	r2, #24
 810de24:	2100      	movs	r1, #0
 810de26:	6a38      	ldr	r0, [r7, #32]
 810de28:	f001 ff37 	bl	810fc9a <memset>
	vdev = &rpvdev->vdev;
 810de2c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810de2e:	3318      	adds	r3, #24
 810de30:	61fb      	str	r3, [r7, #28]

	for (i = 0; i < num_vrings; i++) {
 810de32:	2300      	movs	r3, #0
 810de34:	637b      	str	r3, [r7, #52]	@ 0x34
 810de36:	e025      	b.n	810de84 <rproc_virtio_create_vdev+0xb0>
		struct virtqueue *vq;
		struct fw_rsc_vdev_vring *vring_rsc;
		unsigned int num_extra_desc = 0;
 810de38:	2300      	movs	r3, #0
 810de3a:	633b      	str	r3, [r7, #48]	@ 0x30

		vring_rsc = &vdev_rsc->vring[i];
 810de3c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 810de3e:	4613      	mov	r3, r2
 810de40:	009b      	lsls	r3, r3, #2
 810de42:	4413      	add	r3, r2
 810de44:	009b      	lsls	r3, r3, #2
 810de46:	3318      	adds	r3, #24
 810de48:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 810de4a:	4413      	add	r3, r2
 810de4c:	3304      	adds	r3, #4
 810de4e:	61bb      	str	r3, [r7, #24]
		if (role == VIRTIO_DEV_MASTER) {
 810de50:	68fb      	ldr	r3, [r7, #12]
 810de52:	2b00      	cmp	r3, #0
 810de54:	d102      	bne.n	810de5c <rproc_virtio_create_vdev+0x88>
			num_extra_desc = vring_rsc->num;
 810de56:	69bb      	ldr	r3, [r7, #24]
 810de58:	689b      	ldr	r3, [r3, #8]
 810de5a:	633b      	str	r3, [r7, #48]	@ 0x30
		}
		vq = virtqueue_allocate(num_extra_desc);
 810de5c:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 810de5e:	f7ff ff0e 	bl	810dc7e <virtqueue_allocate>
 810de62:	6178      	str	r0, [r7, #20]
		if (!vq)
 810de64:	697b      	ldr	r3, [r7, #20]
 810de66:	2b00      	cmp	r3, #0
 810de68:	d031      	beq.n	810dece <rproc_virtio_create_vdev+0xfa>
			goto err1;
		vrings_info[i].vq = vq;
 810de6a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 810de6c:	4613      	mov	r3, r2
 810de6e:	005b      	lsls	r3, r3, #1
 810de70:	4413      	add	r3, r2
 810de72:	00db      	lsls	r3, r3, #3
 810de74:	461a      	mov	r2, r3
 810de76:	6a3b      	ldr	r3, [r7, #32]
 810de78:	4413      	add	r3, r2
 810de7a:	697a      	ldr	r2, [r7, #20]
 810de7c:	601a      	str	r2, [r3, #0]
	for (i = 0; i < num_vrings; i++) {
 810de7e:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810de80:	3301      	adds	r3, #1
 810de82:	637b      	str	r3, [r7, #52]	@ 0x34
 810de84:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 810de86:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810de88:	429a      	cmp	r2, r3
 810de8a:	d3d5      	bcc.n	810de38 <rproc_virtio_create_vdev+0x64>
	}

	/* FIXME commended as seems not nedded, already stored in vdev */
	//rpvdev->notifyid = notifyid;
	rpvdev->notify = notify;
 810de8c:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810de8e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
 810de90:	611a      	str	r2, [r3, #16]
	rpvdev->priv = priv;
 810de92:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810de94:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
 810de96:	601a      	str	r2, [r3, #0]
	vdev->vrings_info = vrings_info;
 810de98:	69fb      	ldr	r3, [r7, #28]
 810de9a:	6a3a      	ldr	r2, [r7, #32]
 810de9c:	62da      	str	r2, [r3, #44]	@ 0x2c
	/* Assuming the shared memory has been mapped and registered if
	 * necessary
	 */
	rpvdev->vdev_rsc = vdev_rsc;
 810de9e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810dea0:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
 810dea2:	609a      	str	r2, [r3, #8]
	rpvdev->vdev_rsc_io = rsc_io;
 810dea4:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810dea6:	683a      	ldr	r2, [r7, #0]
 810dea8:	60da      	str	r2, [r3, #12]

	vdev->index = notifyid;
 810deaa:	69fb      	ldr	r3, [r7, #28]
 810deac:	68ba      	ldr	r2, [r7, #8]
 810deae:	601a      	str	r2, [r3, #0]
	vdev->role = role;
 810deb0:	69fb      	ldr	r3, [r7, #28]
 810deb2:	68fa      	ldr	r2, [r7, #12]
 810deb4:	619a      	str	r2, [r3, #24]
	vdev->reset_cb = rst_cb;
 810deb6:	69fb      	ldr	r3, [r7, #28]
 810deb8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 810deba:	61da      	str	r2, [r3, #28]
	vdev->vrings_num = num_vrings;
 810debc:	69fb      	ldr	r3, [r7, #28]
 810debe:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 810dec0:	629a      	str	r2, [r3, #40]	@ 0x28
	vdev->func = &remoteproc_virtio_dispatch_funcs;
 810dec2:	69fb      	ldr	r3, [r7, #28]
 810dec4:	4a19      	ldr	r2, [pc, #100]	@ (810df2c <rproc_virtio_create_vdev+0x158>)
 810dec6:	621a      	str	r2, [r3, #32]
	/* TODO: Shall we set features here ? */

	return &rpvdev->vdev;
 810dec8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810deca:	3318      	adds	r3, #24
 810decc:	e02a      	b.n	810df24 <rproc_virtio_create_vdev+0x150>
			goto err1;
 810dece:	bf00      	nop

err1:
	for (i = 0; i < num_vrings; i++) {
 810ded0:	2300      	movs	r3, #0
 810ded2:	637b      	str	r3, [r7, #52]	@ 0x34
 810ded4:	e019      	b.n	810df0a <rproc_virtio_create_vdev+0x136>
		if (vrings_info[i].vq)
 810ded6:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 810ded8:	4613      	mov	r3, r2
 810deda:	005b      	lsls	r3, r3, #1
 810dedc:	4413      	add	r3, r2
 810dede:	00db      	lsls	r3, r3, #3
 810dee0:	461a      	mov	r2, r3
 810dee2:	6a3b      	ldr	r3, [r7, #32]
 810dee4:	4413      	add	r3, r2
 810dee6:	681b      	ldr	r3, [r3, #0]
 810dee8:	2b00      	cmp	r3, #0
 810deea:	d00b      	beq.n	810df04 <rproc_virtio_create_vdev+0x130>
			metal_free_memory(vrings_info[i].vq);
 810deec:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 810deee:	4613      	mov	r3, r2
 810def0:	005b      	lsls	r3, r3, #1
 810def2:	4413      	add	r3, r2
 810def4:	00db      	lsls	r3, r3, #3
 810def6:	461a      	mov	r2, r3
 810def8:	6a3b      	ldr	r3, [r7, #32]
 810defa:	4413      	add	r3, r2
 810defc:	681b      	ldr	r3, [r3, #0]
 810defe:	4618      	mov	r0, r3
 810df00:	f7ff feb2 	bl	810dc68 <metal_free_memory>
	for (i = 0; i < num_vrings; i++) {
 810df04:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810df06:	3301      	adds	r3, #1
 810df08:	637b      	str	r3, [r7, #52]	@ 0x34
 810df0a:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 810df0c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810df0e:	429a      	cmp	r2, r3
 810df10:	d3e1      	bcc.n	810ded6 <rproc_virtio_create_vdev+0x102>
	}
	metal_free_memory(vrings_info);
 810df12:	6a38      	ldr	r0, [r7, #32]
 810df14:	f7ff fea8 	bl	810dc68 <metal_free_memory>
 810df18:	e000      	b.n	810df1c <rproc_virtio_create_vdev+0x148>
		goto err0;
 810df1a:	bf00      	nop
err0:
	metal_free_memory(rpvdev);
 810df1c:	6a78      	ldr	r0, [r7, #36]	@ 0x24
 810df1e:	f7ff fea3 	bl	810dc68 <metal_free_memory>
	return NULL;
 810df22:	2300      	movs	r3, #0
}
 810df24:	4618      	mov	r0, r3
 810df26:	3738      	adds	r7, #56	@ 0x38
 810df28:	46bd      	mov	sp, r7
 810df2a:	bd80      	pop	{r7, pc}
 810df2c:	08111318 	.word	0x08111318

0810df30 <rproc_virtio_init_vring>:

int rproc_virtio_init_vring(struct virtio_device *vdev, unsigned int index,
			    unsigned int notifyid, void *va,
			    struct metal_io_region *io,
			    unsigned int num_descs, unsigned int align)
{
 810df30:	b480      	push	{r7}
 810df32:	b087      	sub	sp, #28
 810df34:	af00      	add	r7, sp, #0
 810df36:	60f8      	str	r0, [r7, #12]
 810df38:	60b9      	str	r1, [r7, #8]
 810df3a:	607a      	str	r2, [r7, #4]
 810df3c:	603b      	str	r3, [r7, #0]
	struct virtio_vring_info *vring_info;
	unsigned int num_vrings;

	num_vrings = vdev->vrings_num;
 810df3e:	68fb      	ldr	r3, [r7, #12]
 810df40:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810df42:	617b      	str	r3, [r7, #20]
	if (index >= num_vrings)
 810df44:	68ba      	ldr	r2, [r7, #8]
 810df46:	697b      	ldr	r3, [r7, #20]
 810df48:	429a      	cmp	r2, r3
 810df4a:	d302      	bcc.n	810df52 <rproc_virtio_init_vring+0x22>
		return -RPROC_EINVAL;
 810df4c:	f06f 0301 	mvn.w	r3, #1
 810df50:	e019      	b.n	810df86 <rproc_virtio_init_vring+0x56>
	vring_info = &vdev->vrings_info[index];
 810df52:	68fb      	ldr	r3, [r7, #12]
 810df54:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 810df56:	68ba      	ldr	r2, [r7, #8]
 810df58:	4613      	mov	r3, r2
 810df5a:	005b      	lsls	r3, r3, #1
 810df5c:	4413      	add	r3, r2
 810df5e:	00db      	lsls	r3, r3, #3
 810df60:	440b      	add	r3, r1
 810df62:	613b      	str	r3, [r7, #16]
	vring_info->io = io;
 810df64:	693b      	ldr	r3, [r7, #16]
 810df66:	6a3a      	ldr	r2, [r7, #32]
 810df68:	615a      	str	r2, [r3, #20]
	vring_info->notifyid = notifyid;
 810df6a:	693b      	ldr	r3, [r7, #16]
 810df6c:	687a      	ldr	r2, [r7, #4]
 810df6e:	611a      	str	r2, [r3, #16]
	vring_info->info.vaddr = va;
 810df70:	693b      	ldr	r3, [r7, #16]
 810df72:	683a      	ldr	r2, [r7, #0]
 810df74:	605a      	str	r2, [r3, #4]
	vring_info->info.num_descs = num_descs;
 810df76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810df78:	b29a      	uxth	r2, r3
 810df7a:	693b      	ldr	r3, [r7, #16]
 810df7c:	819a      	strh	r2, [r3, #12]
	vring_info->info.align = align;
 810df7e:	693b      	ldr	r3, [r7, #16]
 810df80:	6aba      	ldr	r2, [r7, #40]	@ 0x28
 810df82:	609a      	str	r2, [r3, #8]

	return 0;
 810df84:	2300      	movs	r3, #0
}
 810df86:	4618      	mov	r0, r3
 810df88:	371c      	adds	r7, #28
 810df8a:	46bd      	mov	sp, r7
 810df8c:	f85d 7b04 	ldr.w	r7, [sp], #4
 810df90:	4770      	bx	lr

0810df92 <rproc_virtio_notified>:

int rproc_virtio_notified(struct virtio_device *vdev, uint32_t notifyid)
{
 810df92:	b580      	push	{r7, lr}
 810df94:	b086      	sub	sp, #24
 810df96:	af00      	add	r7, sp, #0
 810df98:	6078      	str	r0, [r7, #4]
 810df9a:	6039      	str	r1, [r7, #0]
	unsigned int num_vrings, i;
	struct virtio_vring_info *vring_info;
	struct virtqueue *vq;

	if (!vdev)
 810df9c:	687b      	ldr	r3, [r7, #4]
 810df9e:	2b00      	cmp	r3, #0
 810dfa0:	d102      	bne.n	810dfa8 <rproc_virtio_notified+0x16>
		return -EINVAL;
 810dfa2:	f06f 0315 	mvn.w	r3, #21
 810dfa6:	e02c      	b.n	810e002 <rproc_virtio_notified+0x70>
	/* We do nothing for vdev notification in this implementation */
	if (vdev->index == notifyid)
 810dfa8:	687b      	ldr	r3, [r7, #4]
 810dfaa:	681b      	ldr	r3, [r3, #0]
 810dfac:	683a      	ldr	r2, [r7, #0]
 810dfae:	429a      	cmp	r2, r3
 810dfb0:	d101      	bne.n	810dfb6 <rproc_virtio_notified+0x24>
		return 0;
 810dfb2:	2300      	movs	r3, #0
 810dfb4:	e025      	b.n	810e002 <rproc_virtio_notified+0x70>
	num_vrings = vdev->vrings_num;
 810dfb6:	687b      	ldr	r3, [r7, #4]
 810dfb8:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810dfba:	613b      	str	r3, [r7, #16]
	for (i = 0; i < num_vrings; i++) {
 810dfbc:	2300      	movs	r3, #0
 810dfbe:	617b      	str	r3, [r7, #20]
 810dfc0:	e01a      	b.n	810dff8 <rproc_virtio_notified+0x66>
		vring_info = &vdev->vrings_info[i];
 810dfc2:	687b      	ldr	r3, [r7, #4]
 810dfc4:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 810dfc6:	697a      	ldr	r2, [r7, #20]
 810dfc8:	4613      	mov	r3, r2
 810dfca:	005b      	lsls	r3, r3, #1
 810dfcc:	4413      	add	r3, r2
 810dfce:	00db      	lsls	r3, r3, #3
 810dfd0:	440b      	add	r3, r1
 810dfd2:	60fb      	str	r3, [r7, #12]
		if (vring_info->notifyid == notifyid ||
 810dfd4:	68fb      	ldr	r3, [r7, #12]
 810dfd6:	691b      	ldr	r3, [r3, #16]
 810dfd8:	683a      	ldr	r2, [r7, #0]
 810dfda:	429a      	cmp	r2, r3
 810dfdc:	d003      	beq.n	810dfe6 <rproc_virtio_notified+0x54>
 810dfde:	683b      	ldr	r3, [r7, #0]
 810dfe0:	f1b3 3fff 	cmp.w	r3, #4294967295
 810dfe4:	d105      	bne.n	810dff2 <rproc_virtio_notified+0x60>
		    notifyid == RSC_NOTIFY_ID_ANY) {
			vq = vring_info->vq;
 810dfe6:	68fb      	ldr	r3, [r7, #12]
 810dfe8:	681b      	ldr	r3, [r3, #0]
 810dfea:	60bb      	str	r3, [r7, #8]
			virtqueue_notification(vq);
 810dfec:	68b8      	ldr	r0, [r7, #8]
 810dfee:	f001 fa1b 	bl	810f428 <virtqueue_notification>
	for (i = 0; i < num_vrings; i++) {
 810dff2:	697b      	ldr	r3, [r7, #20]
 810dff4:	3301      	adds	r3, #1
 810dff6:	617b      	str	r3, [r7, #20]
 810dff8:	697a      	ldr	r2, [r7, #20]
 810dffa:	693b      	ldr	r3, [r7, #16]
 810dffc:	429a      	cmp	r2, r3
 810dffe:	d3e0      	bcc.n	810dfc2 <rproc_virtio_notified+0x30>
		}
	}
	return 0;
 810e000:	2300      	movs	r3, #0
}
 810e002:	4618      	mov	r0, r3
 810e004:	3718      	adds	r7, #24
 810e006:	46bd      	mov	sp, r7
 810e008:	bd80      	pop	{r7, pc}

0810e00a <rproc_virtio_wait_remote_ready>:

void rproc_virtio_wait_remote_ready(struct virtio_device *vdev)
{
 810e00a:	b580      	push	{r7, lr}
 810e00c:	b084      	sub	sp, #16
 810e00e:	af00      	add	r7, sp, #0
 810e010:	6078      	str	r0, [r7, #4]
	/*
	 * No status available for slave. As Master has not to wait
	 * slave action, we can return. Behavior should be updated
	 * in future if a slave status is added.
	 */
	if (vdev->role == VIRTIO_DEV_MASTER)
 810e012:	687b      	ldr	r3, [r7, #4]
 810e014:	699b      	ldr	r3, [r3, #24]
 810e016:	2b00      	cmp	r3, #0
 810e018:	d00a      	beq.n	810e030 <rproc_virtio_wait_remote_ready+0x26>
		return;

	while (1) {
		status = rproc_virtio_get_status(vdev);
 810e01a:	6878      	ldr	r0, [r7, #4]
 810e01c:	f7ff fe7c 	bl	810dd18 <rproc_virtio_get_status>
 810e020:	4603      	mov	r3, r0
 810e022:	73fb      	strb	r3, [r7, #15]
		if (status & VIRTIO_CONFIG_STATUS_DRIVER_OK)
 810e024:	7bfb      	ldrb	r3, [r7, #15]
 810e026:	f003 0304 	and.w	r3, r3, #4
 810e02a:	2b00      	cmp	r3, #0
 810e02c:	d102      	bne.n	810e034 <rproc_virtio_wait_remote_ready+0x2a>
		status = rproc_virtio_get_status(vdev);
 810e02e:	e7f4      	b.n	810e01a <rproc_virtio_wait_remote_ready+0x10>
		return;
 810e030:	bf00      	nop
 810e032:	e000      	b.n	810e036 <rproc_virtio_wait_remote_ready+0x2c>
			return;
 810e034:	bf00      	nop
	}
}
 810e036:	3710      	adds	r7, #16
 810e038:	46bd      	mov	sp, r7
 810e03a:	bd80      	pop	{r7, pc}

0810e03c <__metal_mutex_acquire>:
{
	return 1 - atomic_flag_test_and_set(&mutex->w);
}

static inline void __metal_mutex_acquire(metal_mutex_t *mutex)
{
 810e03c:	b480      	push	{r7}
 810e03e:	b083      	sub	sp, #12
 810e040:	af00      	add	r7, sp, #0
 810e042:	6078      	str	r0, [r7, #4]
	while (atomic_flag_test_and_set(&mutex->w)) {
 810e044:	bf00      	nop
 810e046:	687b      	ldr	r3, [r7, #4]
 810e048:	2201      	movs	r2, #1
 810e04a:	4611      	mov	r1, r2
 810e04c:	f3bf 8f5b 	dmb	ish
 810e050:	e8d3 2f4f 	ldrexb	r2, [r3]
 810e054:	e8c3 1f40 	strexb	r0, r1, [r3]
 810e058:	2800      	cmp	r0, #0
 810e05a:	d1f9      	bne.n	810e050 <__metal_mutex_acquire+0x14>
 810e05c:	f3bf 8f5b 	dmb	ish
 810e060:	b2d3      	uxtb	r3, r2
 810e062:	2b00      	cmp	r3, #0
 810e064:	d1ef      	bne.n	810e046 <__metal_mutex_acquire+0xa>
		;
	}
}
 810e066:	bf00      	nop
 810e068:	bf00      	nop
 810e06a:	370c      	adds	r7, #12
 810e06c:	46bd      	mov	sp, r7
 810e06e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e072:	4770      	bx	lr

0810e074 <__metal_mutex_release>:

static inline void __metal_mutex_release(metal_mutex_t *mutex)
{
 810e074:	b480      	push	{r7}
 810e076:	b083      	sub	sp, #12
 810e078:	af00      	add	r7, sp, #0
 810e07a:	6078      	str	r0, [r7, #4]
	atomic_flag_clear(&mutex->w);
 810e07c:	687b      	ldr	r3, [r7, #4]
 810e07e:	f3bf 8f5b 	dmb	ish
 810e082:	2200      	movs	r2, #0
 810e084:	701a      	strb	r2, [r3, #0]
 810e086:	f3bf 8f5b 	dmb	ish
}
 810e08a:	bf00      	nop
 810e08c:	370c      	adds	r7, #12
 810e08e:	46bd      	mov	sp, r7
 810e090:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e094:	4770      	bx	lr

0810e096 <metal_mutex_acquire>:
/**
 * @brief	Acquire a mutex
 * @param[in]	mutex	Mutex to mutex.
 */
static inline void metal_mutex_acquire(metal_mutex_t *mutex)
{
 810e096:	b580      	push	{r7, lr}
 810e098:	b082      	sub	sp, #8
 810e09a:	af00      	add	r7, sp, #0
 810e09c:	6078      	str	r0, [r7, #4]
	__metal_mutex_acquire(mutex);
 810e09e:	6878      	ldr	r0, [r7, #4]
 810e0a0:	f7ff ffcc 	bl	810e03c <__metal_mutex_acquire>
}
 810e0a4:	bf00      	nop
 810e0a6:	3708      	adds	r7, #8
 810e0a8:	46bd      	mov	sp, r7
 810e0aa:	bd80      	pop	{r7, pc}

0810e0ac <metal_mutex_release>:
 * @brief	Release a previously acquired mutex.
 * @param[in]	mutex	Mutex to mutex.
 * @see metal_mutex_try_acquire, metal_mutex_acquire
 */
static inline void metal_mutex_release(metal_mutex_t *mutex)
{
 810e0ac:	b580      	push	{r7, lr}
 810e0ae:	b082      	sub	sp, #8
 810e0b0:	af00      	add	r7, sp, #0
 810e0b2:	6078      	str	r0, [r7, #4]
	__metal_mutex_release(mutex);
 810e0b4:	6878      	ldr	r0, [r7, #4]
 810e0b6:	f7ff ffdd 	bl	810e074 <__metal_mutex_release>
}
 810e0ba:	bf00      	nop
 810e0bc:	3708      	adds	r7, #8
 810e0be:	46bd      	mov	sp, r7
 810e0c0:	bd80      	pop	{r7, pc}

0810e0c2 <metal_list_add_before>:
{
 810e0c2:	b480      	push	{r7}
 810e0c4:	b083      	sub	sp, #12
 810e0c6:	af00      	add	r7, sp, #0
 810e0c8:	6078      	str	r0, [r7, #4]
 810e0ca:	6039      	str	r1, [r7, #0]
	new_node->prev = node->prev;
 810e0cc:	687b      	ldr	r3, [r7, #4]
 810e0ce:	685a      	ldr	r2, [r3, #4]
 810e0d0:	683b      	ldr	r3, [r7, #0]
 810e0d2:	605a      	str	r2, [r3, #4]
	new_node->next = node;
 810e0d4:	683b      	ldr	r3, [r7, #0]
 810e0d6:	687a      	ldr	r2, [r7, #4]
 810e0d8:	601a      	str	r2, [r3, #0]
	new_node->next->prev = new_node;
 810e0da:	683b      	ldr	r3, [r7, #0]
 810e0dc:	681b      	ldr	r3, [r3, #0]
 810e0de:	683a      	ldr	r2, [r7, #0]
 810e0e0:	605a      	str	r2, [r3, #4]
	new_node->prev->next = new_node;
 810e0e2:	683b      	ldr	r3, [r7, #0]
 810e0e4:	685b      	ldr	r3, [r3, #4]
 810e0e6:	683a      	ldr	r2, [r7, #0]
 810e0e8:	601a      	str	r2, [r3, #0]
}
 810e0ea:	bf00      	nop
 810e0ec:	370c      	adds	r7, #12
 810e0ee:	46bd      	mov	sp, r7
 810e0f0:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e0f4:	4770      	bx	lr

0810e0f6 <metal_list_add_tail>:
{
 810e0f6:	b580      	push	{r7, lr}
 810e0f8:	b082      	sub	sp, #8
 810e0fa:	af00      	add	r7, sp, #0
 810e0fc:	6078      	str	r0, [r7, #4]
 810e0fe:	6039      	str	r1, [r7, #0]
	metal_list_add_before(list, node);
 810e100:	6839      	ldr	r1, [r7, #0]
 810e102:	6878      	ldr	r0, [r7, #4]
 810e104:	f7ff ffdd 	bl	810e0c2 <metal_list_add_before>
}
 810e108:	bf00      	nop
 810e10a:	3708      	adds	r7, #8
 810e10c:	46bd      	mov	sp, r7
 810e10e:	bd80      	pop	{r7, pc}

0810e110 <metal_list_del>:
{
	return list->next == list;
}

static inline void metal_list_del(struct metal_list *node)
{
 810e110:	b480      	push	{r7}
 810e112:	b083      	sub	sp, #12
 810e114:	af00      	add	r7, sp, #0
 810e116:	6078      	str	r0, [r7, #4]
	node->next->prev = node->prev;
 810e118:	687b      	ldr	r3, [r7, #4]
 810e11a:	681b      	ldr	r3, [r3, #0]
 810e11c:	687a      	ldr	r2, [r7, #4]
 810e11e:	6852      	ldr	r2, [r2, #4]
 810e120:	605a      	str	r2, [r3, #4]
	node->prev->next = node->next;
 810e122:	687b      	ldr	r3, [r7, #4]
 810e124:	685b      	ldr	r3, [r3, #4]
 810e126:	687a      	ldr	r2, [r7, #4]
 810e128:	6812      	ldr	r2, [r2, #0]
 810e12a:	601a      	str	r2, [r3, #0]
	node->next = node->prev = node;
 810e12c:	687b      	ldr	r3, [r7, #4]
 810e12e:	687a      	ldr	r2, [r7, #4]
 810e130:	605a      	str	r2, [r3, #4]
 810e132:	687b      	ldr	r3, [r7, #4]
 810e134:	685a      	ldr	r2, [r3, #4]
 810e136:	687b      	ldr	r3, [r7, #4]
 810e138:	601a      	str	r2, [r3, #0]
}
 810e13a:	bf00      	nop
 810e13c:	370c      	adds	r7, #12
 810e13e:	46bd      	mov	sp, r7
 810e140:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e144:	4770      	bx	lr

0810e146 <metal_bitmap_set_bit>:
#define metal_bit(bit)		(1UL << (bit))

#define metal_bitmap_longs(x)	metal_div_round_up((x), METAL_BITS_PER_ULONG)

static inline void metal_bitmap_set_bit(unsigned long *bitmap, int bit)
{
 810e146:	b480      	push	{r7}
 810e148:	b083      	sub	sp, #12
 810e14a:	af00      	add	r7, sp, #0
 810e14c:	6078      	str	r0, [r7, #4]
 810e14e:	6039      	str	r1, [r7, #0]
	bitmap[bit / METAL_BITS_PER_ULONG] |=
 810e150:	683b      	ldr	r3, [r7, #0]
 810e152:	095b      	lsrs	r3, r3, #5
 810e154:	009a      	lsls	r2, r3, #2
 810e156:	6879      	ldr	r1, [r7, #4]
 810e158:	440a      	add	r2, r1
 810e15a:	6811      	ldr	r1, [r2, #0]
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 810e15c:	683a      	ldr	r2, [r7, #0]
 810e15e:	f002 021f 	and.w	r2, r2, #31
 810e162:	2001      	movs	r0, #1
 810e164:	fa00 f202 	lsl.w	r2, r0, r2
	bitmap[bit / METAL_BITS_PER_ULONG] |=
 810e168:	009b      	lsls	r3, r3, #2
 810e16a:	6878      	ldr	r0, [r7, #4]
 810e16c:	4403      	add	r3, r0
 810e16e:	430a      	orrs	r2, r1
 810e170:	601a      	str	r2, [r3, #0]
}
 810e172:	bf00      	nop
 810e174:	370c      	adds	r7, #12
 810e176:	46bd      	mov	sp, r7
 810e178:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e17c:	4770      	bx	lr

0810e17e <metal_bitmap_is_bit_set>:

static inline int metal_bitmap_is_bit_set(unsigned long *bitmap, int bit)
{
 810e17e:	b480      	push	{r7}
 810e180:	b083      	sub	sp, #12
 810e182:	af00      	add	r7, sp, #0
 810e184:	6078      	str	r0, [r7, #4]
 810e186:	6039      	str	r1, [r7, #0]
	return bitmap[bit / METAL_BITS_PER_ULONG] &
 810e188:	683b      	ldr	r3, [r7, #0]
 810e18a:	095b      	lsrs	r3, r3, #5
 810e18c:	009b      	lsls	r3, r3, #2
 810e18e:	687a      	ldr	r2, [r7, #4]
 810e190:	4413      	add	r3, r2
 810e192:	681a      	ldr	r2, [r3, #0]
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 810e194:	683b      	ldr	r3, [r7, #0]
 810e196:	f003 031f 	and.w	r3, r3, #31
 810e19a:	2101      	movs	r1, #1
 810e19c:	fa01 f303 	lsl.w	r3, r1, r3
	return bitmap[bit / METAL_BITS_PER_ULONG] &
 810e1a0:	4013      	ands	r3, r2
}
 810e1a2:	4618      	mov	r0, r3
 810e1a4:	370c      	adds	r7, #12
 810e1a6:	46bd      	mov	sp, r7
 810e1a8:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e1ac:	4770      	bx	lr

0810e1ae <metal_bitmap_clear_bit>:

static inline void metal_bitmap_clear_bit(unsigned long *bitmap, int bit)
{
 810e1ae:	b480      	push	{r7}
 810e1b0:	b083      	sub	sp, #12
 810e1b2:	af00      	add	r7, sp, #0
 810e1b4:	6078      	str	r0, [r7, #4]
 810e1b6:	6039      	str	r1, [r7, #0]
	bitmap[bit / METAL_BITS_PER_ULONG] &=
 810e1b8:	683b      	ldr	r3, [r7, #0]
 810e1ba:	095b      	lsrs	r3, r3, #5
 810e1bc:	009a      	lsls	r2, r3, #2
 810e1be:	6879      	ldr	r1, [r7, #4]
 810e1c0:	440a      	add	r2, r1
 810e1c2:	6811      	ldr	r1, [r2, #0]
		~metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 810e1c4:	683a      	ldr	r2, [r7, #0]
 810e1c6:	f002 021f 	and.w	r2, r2, #31
 810e1ca:	2001      	movs	r0, #1
 810e1cc:	fa00 f202 	lsl.w	r2, r0, r2
 810e1d0:	43d2      	mvns	r2, r2
	bitmap[bit / METAL_BITS_PER_ULONG] &=
 810e1d2:	009b      	lsls	r3, r3, #2
 810e1d4:	6878      	ldr	r0, [r7, #4]
 810e1d6:	4403      	add	r3, r0
 810e1d8:	400a      	ands	r2, r1
 810e1da:	601a      	str	r2, [r3, #0]
}
 810e1dc:	bf00      	nop
 810e1de:	370c      	adds	r7, #12
 810e1e0:	46bd      	mov	sp, r7
 810e1e2:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e1e6:	4770      	bx	lr

0810e1e8 <metal_bitmap_is_bit_clear>:

static inline int metal_bitmap_is_bit_clear(unsigned long *bitmap, int bit)
{
 810e1e8:	b580      	push	{r7, lr}
 810e1ea:	b082      	sub	sp, #8
 810e1ec:	af00      	add	r7, sp, #0
 810e1ee:	6078      	str	r0, [r7, #4]
 810e1f0:	6039      	str	r1, [r7, #0]
	return !metal_bitmap_is_bit_set(bitmap, bit);
 810e1f2:	6839      	ldr	r1, [r7, #0]
 810e1f4:	6878      	ldr	r0, [r7, #4]
 810e1f6:	f7ff ffc2 	bl	810e17e <metal_bitmap_is_bit_set>
 810e1fa:	4603      	mov	r3, r0
 810e1fc:	2b00      	cmp	r3, #0
 810e1fe:	bf0c      	ite	eq
 810e200:	2301      	moveq	r3, #1
 810e202:	2300      	movne	r3, #0
 810e204:	b2db      	uxtb	r3, r3
}
 810e206:	4618      	mov	r0, r3
 810e208:	3708      	adds	r7, #8
 810e20a:	46bd      	mov	sp, r7
 810e20c:	bd80      	pop	{r7, pc}

0810e20e <metal_bitmap_next_clear_bit>:
	     (bit) = metal_bitmap_next_set_bit((bitmap), (bit), (max)))

static inline unsigned int
metal_bitmap_next_clear_bit(unsigned long *bitmap, unsigned int start,
			    unsigned int max)
{
 810e20e:	b580      	push	{r7, lr}
 810e210:	b086      	sub	sp, #24
 810e212:	af00      	add	r7, sp, #0
 810e214:	60f8      	str	r0, [r7, #12]
 810e216:	60b9      	str	r1, [r7, #8]
 810e218:	607a      	str	r2, [r7, #4]
	unsigned int bit;
	for (bit = start;
 810e21a:	68bb      	ldr	r3, [r7, #8]
 810e21c:	617b      	str	r3, [r7, #20]
 810e21e:	e002      	b.n	810e226 <metal_bitmap_next_clear_bit+0x18>
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
	     bit ++)
 810e220:	697b      	ldr	r3, [r7, #20]
 810e222:	3301      	adds	r3, #1
 810e224:	617b      	str	r3, [r7, #20]
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
 810e226:	697a      	ldr	r2, [r7, #20]
 810e228:	687b      	ldr	r3, [r7, #4]
 810e22a:	429a      	cmp	r2, r3
 810e22c:	d207      	bcs.n	810e23e <metal_bitmap_next_clear_bit+0x30>
 810e22e:	697b      	ldr	r3, [r7, #20]
 810e230:	4619      	mov	r1, r3
 810e232:	68f8      	ldr	r0, [r7, #12]
 810e234:	f7ff ffd8 	bl	810e1e8 <metal_bitmap_is_bit_clear>
 810e238:	4603      	mov	r3, r0
 810e23a:	2b00      	cmp	r3, #0
 810e23c:	d0f0      	beq.n	810e220 <metal_bitmap_next_clear_bit+0x12>
		;
	return bit;
 810e23e:	697b      	ldr	r3, [r7, #20]
}
 810e240:	4618      	mov	r0, r3
 810e242:	3718      	adds	r7, #24
 810e244:	46bd      	mov	sp, r7
 810e246:	bd80      	pop	{r7, pc}

0810e248 <rpmsg_init_ept>:
static inline void rpmsg_init_ept(struct rpmsg_endpoint *ept,
				  const char *name,
				  uint32_t src, uint32_t dest,
				  rpmsg_ept_cb cb,
				  rpmsg_ns_unbind_cb ns_unbind_cb)
{
 810e248:	b580      	push	{r7, lr}
 810e24a:	b084      	sub	sp, #16
 810e24c:	af00      	add	r7, sp, #0
 810e24e:	60f8      	str	r0, [r7, #12]
 810e250:	60b9      	str	r1, [r7, #8]
 810e252:	607a      	str	r2, [r7, #4]
 810e254:	603b      	str	r3, [r7, #0]
	strncpy(ept->name, name, sizeof(ept->name));
 810e256:	68fb      	ldr	r3, [r7, #12]
 810e258:	2220      	movs	r2, #32
 810e25a:	68b9      	ldr	r1, [r7, #8]
 810e25c:	4618      	mov	r0, r3
 810e25e:	f001 fd36 	bl	810fcce <strncpy>
	ept->addr = src;
 810e262:	68fb      	ldr	r3, [r7, #12]
 810e264:	687a      	ldr	r2, [r7, #4]
 810e266:	625a      	str	r2, [r3, #36]	@ 0x24
	ept->dest_addr = dest;
 810e268:	68fb      	ldr	r3, [r7, #12]
 810e26a:	683a      	ldr	r2, [r7, #0]
 810e26c:	629a      	str	r2, [r3, #40]	@ 0x28
	ept->cb = cb;
 810e26e:	68fb      	ldr	r3, [r7, #12]
 810e270:	69ba      	ldr	r2, [r7, #24]
 810e272:	62da      	str	r2, [r3, #44]	@ 0x2c
	ept->ns_unbind_cb = ns_unbind_cb;
 810e274:	68fb      	ldr	r3, [r7, #12]
 810e276:	69fa      	ldr	r2, [r7, #28]
 810e278:	631a      	str	r2, [r3, #48]	@ 0x30
}
 810e27a:	bf00      	nop
 810e27c:	3710      	adds	r7, #16
 810e27e:	46bd      	mov	sp, r7
 810e280:	bd80      	pop	{r7, pc}

0810e282 <rpmsg_get_address>:
 * @param size   - size of bitmap
 *
 * return - a unique address
 */
static uint32_t rpmsg_get_address(unsigned long *bitmap, int size)
{
 810e282:	b580      	push	{r7, lr}
 810e284:	b084      	sub	sp, #16
 810e286:	af00      	add	r7, sp, #0
 810e288:	6078      	str	r0, [r7, #4]
 810e28a:	6039      	str	r1, [r7, #0]
	unsigned int addr = RPMSG_ADDR_ANY;
 810e28c:	f04f 33ff 	mov.w	r3, #4294967295
 810e290:	60fb      	str	r3, [r7, #12]
	unsigned int nextbit;

	nextbit = metal_bitmap_next_clear_bit(bitmap, 0, size);
 810e292:	683b      	ldr	r3, [r7, #0]
 810e294:	461a      	mov	r2, r3
 810e296:	2100      	movs	r1, #0
 810e298:	6878      	ldr	r0, [r7, #4]
 810e29a:	f7ff ffb8 	bl	810e20e <metal_bitmap_next_clear_bit>
 810e29e:	60b8      	str	r0, [r7, #8]
	if (nextbit < (uint32_t)size) {
 810e2a0:	683b      	ldr	r3, [r7, #0]
 810e2a2:	68ba      	ldr	r2, [r7, #8]
 810e2a4:	429a      	cmp	r2, r3
 810e2a6:	d206      	bcs.n	810e2b6 <rpmsg_get_address+0x34>
		addr = nextbit;
 810e2a8:	68bb      	ldr	r3, [r7, #8]
 810e2aa:	60fb      	str	r3, [r7, #12]
		metal_bitmap_set_bit(bitmap, nextbit);
 810e2ac:	68bb      	ldr	r3, [r7, #8]
 810e2ae:	4619      	mov	r1, r3
 810e2b0:	6878      	ldr	r0, [r7, #4]
 810e2b2:	f7ff ff48 	bl	810e146 <metal_bitmap_set_bit>
	}

	return addr;
 810e2b6:	68fb      	ldr	r3, [r7, #12]
}
 810e2b8:	4618      	mov	r0, r3
 810e2ba:	3710      	adds	r7, #16
 810e2bc:	46bd      	mov	sp, r7
 810e2be:	bd80      	pop	{r7, pc}

0810e2c0 <rpmsg_release_address>:
 * @param size   - size of bitmap
 * @param addr   - address to free
 */
static void rpmsg_release_address(unsigned long *bitmap, int size,
				  int addr)
{
 810e2c0:	b580      	push	{r7, lr}
 810e2c2:	b084      	sub	sp, #16
 810e2c4:	af00      	add	r7, sp, #0
 810e2c6:	60f8      	str	r0, [r7, #12]
 810e2c8:	60b9      	str	r1, [r7, #8]
 810e2ca:	607a      	str	r2, [r7, #4]
	if (addr < size)
 810e2cc:	687a      	ldr	r2, [r7, #4]
 810e2ce:	68bb      	ldr	r3, [r7, #8]
 810e2d0:	429a      	cmp	r2, r3
 810e2d2:	da03      	bge.n	810e2dc <rpmsg_release_address+0x1c>
		metal_bitmap_clear_bit(bitmap, addr);
 810e2d4:	6879      	ldr	r1, [r7, #4]
 810e2d6:	68f8      	ldr	r0, [r7, #12]
 810e2d8:	f7ff ff69 	bl	810e1ae <metal_bitmap_clear_bit>
}
 810e2dc:	bf00      	nop
 810e2de:	3710      	adds	r7, #16
 810e2e0:	46bd      	mov	sp, r7
 810e2e2:	bd80      	pop	{r7, pc}

0810e2e4 <rpmsg_is_address_set>:
 * @param addr   - address to free
 *
 * return - TRUE/FALSE
 */
static int rpmsg_is_address_set(unsigned long *bitmap, int size, int addr)
{
 810e2e4:	b580      	push	{r7, lr}
 810e2e6:	b084      	sub	sp, #16
 810e2e8:	af00      	add	r7, sp, #0
 810e2ea:	60f8      	str	r0, [r7, #12]
 810e2ec:	60b9      	str	r1, [r7, #8]
 810e2ee:	607a      	str	r2, [r7, #4]
	if (addr < size)
 810e2f0:	687a      	ldr	r2, [r7, #4]
 810e2f2:	68bb      	ldr	r3, [r7, #8]
 810e2f4:	429a      	cmp	r2, r3
 810e2f6:	da05      	bge.n	810e304 <rpmsg_is_address_set+0x20>
		return metal_bitmap_is_bit_set(bitmap, addr);
 810e2f8:	6879      	ldr	r1, [r7, #4]
 810e2fa:	68f8      	ldr	r0, [r7, #12]
 810e2fc:	f7ff ff3f 	bl	810e17e <metal_bitmap_is_bit_set>
 810e300:	4603      	mov	r3, r0
 810e302:	e000      	b.n	810e306 <rpmsg_is_address_set+0x22>
	else
		return RPMSG_ERR_PARAM;
 810e304:	4b02      	ldr	r3, [pc, #8]	@ (810e310 <rpmsg_is_address_set+0x2c>)
}
 810e306:	4618      	mov	r0, r3
 810e308:	3710      	adds	r7, #16
 810e30a:	46bd      	mov	sp, r7
 810e30c:	bd80      	pop	{r7, pc}
 810e30e:	bf00      	nop
 810e310:	fffff82d 	.word	0xfffff82d

0810e314 <rpmsg_set_address>:
 * @param addr   - address to free
 *
 * return - none
 */
static int rpmsg_set_address(unsigned long *bitmap, int size, int addr)
{
 810e314:	b580      	push	{r7, lr}
 810e316:	b084      	sub	sp, #16
 810e318:	af00      	add	r7, sp, #0
 810e31a:	60f8      	str	r0, [r7, #12]
 810e31c:	60b9      	str	r1, [r7, #8]
 810e31e:	607a      	str	r2, [r7, #4]
	if (addr < size) {
 810e320:	687a      	ldr	r2, [r7, #4]
 810e322:	68bb      	ldr	r3, [r7, #8]
 810e324:	429a      	cmp	r2, r3
 810e326:	da05      	bge.n	810e334 <rpmsg_set_address+0x20>
		metal_bitmap_set_bit(bitmap, addr);
 810e328:	6879      	ldr	r1, [r7, #4]
 810e32a:	68f8      	ldr	r0, [r7, #12]
 810e32c:	f7ff ff0b 	bl	810e146 <metal_bitmap_set_bit>
		return RPMSG_SUCCESS;
 810e330:	2300      	movs	r3, #0
 810e332:	e000      	b.n	810e336 <rpmsg_set_address+0x22>
	} else {
		return RPMSG_ERR_PARAM;
 810e334:	4b02      	ldr	r3, [pc, #8]	@ (810e340 <rpmsg_set_address+0x2c>)
	}
}
 810e336:	4618      	mov	r0, r3
 810e338:	3710      	adds	r7, #16
 810e33a:	46bd      	mov	sp, r7
 810e33c:	bd80      	pop	{r7, pc}
 810e33e:	bf00      	nop
 810e340:	fffff82d 	.word	0xfffff82d

0810e344 <rpmsg_send_offchannel_raw>:
 *
 */
int rpmsg_send_offchannel_raw(struct rpmsg_endpoint *ept, uint32_t src,
			      uint32_t dst, const void *data, int size,
			      int wait)
{
 810e344:	b590      	push	{r4, r7, lr}
 810e346:	b089      	sub	sp, #36	@ 0x24
 810e348:	af02      	add	r7, sp, #8
 810e34a:	60f8      	str	r0, [r7, #12]
 810e34c:	60b9      	str	r1, [r7, #8]
 810e34e:	607a      	str	r2, [r7, #4]
 810e350:	603b      	str	r3, [r7, #0]
	struct rpmsg_device *rdev;

	if (!ept || !ept->rdev || !data || dst == RPMSG_ADDR_ANY)
 810e352:	68fb      	ldr	r3, [r7, #12]
 810e354:	2b00      	cmp	r3, #0
 810e356:	d00a      	beq.n	810e36e <rpmsg_send_offchannel_raw+0x2a>
 810e358:	68fb      	ldr	r3, [r7, #12]
 810e35a:	6a1b      	ldr	r3, [r3, #32]
 810e35c:	2b00      	cmp	r3, #0
 810e35e:	d006      	beq.n	810e36e <rpmsg_send_offchannel_raw+0x2a>
 810e360:	683b      	ldr	r3, [r7, #0]
 810e362:	2b00      	cmp	r3, #0
 810e364:	d003      	beq.n	810e36e <rpmsg_send_offchannel_raw+0x2a>
 810e366:	687b      	ldr	r3, [r7, #4]
 810e368:	f1b3 3fff 	cmp.w	r3, #4294967295
 810e36c:	d101      	bne.n	810e372 <rpmsg_send_offchannel_raw+0x2e>
		return RPMSG_ERR_PARAM;
 810e36e:	4b0d      	ldr	r3, [pc, #52]	@ (810e3a4 <rpmsg_send_offchannel_raw+0x60>)
 810e370:	e014      	b.n	810e39c <rpmsg_send_offchannel_raw+0x58>

	rdev = ept->rdev;
 810e372:	68fb      	ldr	r3, [r7, #12]
 810e374:	6a1b      	ldr	r3, [r3, #32]
 810e376:	617b      	str	r3, [r7, #20]

	if (rdev->ops.send_offchannel_raw)
 810e378:	697b      	ldr	r3, [r7, #20]
 810e37a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 810e37c:	2b00      	cmp	r3, #0
 810e37e:	d00c      	beq.n	810e39a <rpmsg_send_offchannel_raw+0x56>
		return rdev->ops.send_offchannel_raw(rdev, src, dst, data,
 810e380:	697b      	ldr	r3, [r7, #20]
 810e382:	6e1c      	ldr	r4, [r3, #96]	@ 0x60
 810e384:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810e386:	9301      	str	r3, [sp, #4]
 810e388:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810e38a:	9300      	str	r3, [sp, #0]
 810e38c:	683b      	ldr	r3, [r7, #0]
 810e38e:	687a      	ldr	r2, [r7, #4]
 810e390:	68b9      	ldr	r1, [r7, #8]
 810e392:	6978      	ldr	r0, [r7, #20]
 810e394:	47a0      	blx	r4
 810e396:	4603      	mov	r3, r0
 810e398:	e000      	b.n	810e39c <rpmsg_send_offchannel_raw+0x58>
						      size, wait);

	return RPMSG_ERR_PARAM;
 810e39a:	4b02      	ldr	r3, [pc, #8]	@ (810e3a4 <rpmsg_send_offchannel_raw+0x60>)
}
 810e39c:	4618      	mov	r0, r3
 810e39e:	371c      	adds	r7, #28
 810e3a0:	46bd      	mov	sp, r7
 810e3a2:	bd90      	pop	{r4, r7, pc}
 810e3a4:	fffff82d 	.word	0xfffff82d

0810e3a8 <rpmsg_send_ns_message>:

int rpmsg_send_ns_message(struct rpmsg_endpoint *ept, unsigned long flags)
{
 810e3a8:	b580      	push	{r7, lr}
 810e3aa:	b090      	sub	sp, #64	@ 0x40
 810e3ac:	af02      	add	r7, sp, #8
 810e3ae:	6078      	str	r0, [r7, #4]
 810e3b0:	6039      	str	r1, [r7, #0]
	struct rpmsg_ns_msg ns_msg;
	int ret;

	ns_msg.flags = flags;
 810e3b2:	683b      	ldr	r3, [r7, #0]
 810e3b4:	633b      	str	r3, [r7, #48]	@ 0x30
	ns_msg.addr = ept->addr;
 810e3b6:	687b      	ldr	r3, [r7, #4]
 810e3b8:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810e3ba:	62fb      	str	r3, [r7, #44]	@ 0x2c
	strncpy(ns_msg.name, ept->name, sizeof(ns_msg.name));
 810e3bc:	6879      	ldr	r1, [r7, #4]
 810e3be:	f107 030c 	add.w	r3, r7, #12
 810e3c2:	2220      	movs	r2, #32
 810e3c4:	4618      	mov	r0, r3
 810e3c6:	f001 fc82 	bl	810fcce <strncpy>
	ret = rpmsg_send_offchannel_raw(ept, ept->addr,
 810e3ca:	687b      	ldr	r3, [r7, #4]
 810e3cc:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 810e3ce:	f107 030c 	add.w	r3, r7, #12
 810e3d2:	2201      	movs	r2, #1
 810e3d4:	9201      	str	r2, [sp, #4]
 810e3d6:	2228      	movs	r2, #40	@ 0x28
 810e3d8:	9200      	str	r2, [sp, #0]
 810e3da:	2235      	movs	r2, #53	@ 0x35
 810e3dc:	6878      	ldr	r0, [r7, #4]
 810e3de:	f7ff ffb1 	bl	810e344 <rpmsg_send_offchannel_raw>
 810e3e2:	6378      	str	r0, [r7, #52]	@ 0x34
					RPMSG_NS_EPT_ADDR,
					&ns_msg, sizeof(ns_msg), true);
	if (ret < 0)
 810e3e4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810e3e6:	2b00      	cmp	r3, #0
 810e3e8:	da01      	bge.n	810e3ee <rpmsg_send_ns_message+0x46>
		return ret;
 810e3ea:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810e3ec:	e000      	b.n	810e3f0 <rpmsg_send_ns_message+0x48>
	else
		return RPMSG_SUCCESS;
 810e3ee:	2300      	movs	r3, #0
}
 810e3f0:	4618      	mov	r0, r3
 810e3f2:	3738      	adds	r7, #56	@ 0x38
 810e3f4:	46bd      	mov	sp, r7
 810e3f6:	bd80      	pop	{r7, pc}

0810e3f8 <rpmsg_get_endpoint>:

struct rpmsg_endpoint *rpmsg_get_endpoint(struct rpmsg_device *rdev,
					  const char *name, uint32_t addr,
					  uint32_t dest_addr)
{
 810e3f8:	b580      	push	{r7, lr}
 810e3fa:	b088      	sub	sp, #32
 810e3fc:	af00      	add	r7, sp, #0
 810e3fe:	60f8      	str	r0, [r7, #12]
 810e400:	60b9      	str	r1, [r7, #8]
 810e402:	607a      	str	r2, [r7, #4]
 810e404:	603b      	str	r3, [r7, #0]
	struct metal_list *node;
	struct rpmsg_endpoint *ept;

	metal_list_for_each(&rdev->endpoints, node) {
 810e406:	68fb      	ldr	r3, [r7, #12]
 810e408:	681b      	ldr	r3, [r3, #0]
 810e40a:	61fb      	str	r3, [r7, #28]
 810e40c:	e04b      	b.n	810e4a6 <rpmsg_get_endpoint+0xae>
		int name_match = 0;
 810e40e:	2300      	movs	r3, #0
 810e410:	61bb      	str	r3, [r7, #24]

		ept = metal_container_of(node, struct rpmsg_endpoint, node);
 810e412:	69fb      	ldr	r3, [r7, #28]
 810e414:	3b34      	subs	r3, #52	@ 0x34
 810e416:	617b      	str	r3, [r7, #20]
		/* try to get by local address only */
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
 810e418:	687b      	ldr	r3, [r7, #4]
 810e41a:	f1b3 3fff 	cmp.w	r3, #4294967295
 810e41e:	d006      	beq.n	810e42e <rpmsg_get_endpoint+0x36>
 810e420:	697b      	ldr	r3, [r7, #20]
 810e422:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810e424:	687a      	ldr	r2, [r7, #4]
 810e426:	429a      	cmp	r2, r3
 810e428:	d101      	bne.n	810e42e <rpmsg_get_endpoint+0x36>
			return ept;
 810e42a:	697b      	ldr	r3, [r7, #20]
 810e42c:	e040      	b.n	810e4b0 <rpmsg_get_endpoint+0xb8>
		/* try to find match on local end remote address */
		if (addr == ept->addr && dest_addr == ept->dest_addr)
 810e42e:	697b      	ldr	r3, [r7, #20]
 810e430:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810e432:	687a      	ldr	r2, [r7, #4]
 810e434:	429a      	cmp	r2, r3
 810e436:	d106      	bne.n	810e446 <rpmsg_get_endpoint+0x4e>
 810e438:	697b      	ldr	r3, [r7, #20]
 810e43a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810e43c:	683a      	ldr	r2, [r7, #0]
 810e43e:	429a      	cmp	r2, r3
 810e440:	d101      	bne.n	810e446 <rpmsg_get_endpoint+0x4e>
			return ept;
 810e442:	697b      	ldr	r3, [r7, #20]
 810e444:	e034      	b.n	810e4b0 <rpmsg_get_endpoint+0xb8>
		/* else use name service and destination address */
		if (name)
 810e446:	68bb      	ldr	r3, [r7, #8]
 810e448:	2b00      	cmp	r3, #0
 810e44a:	d00c      	beq.n	810e466 <rpmsg_get_endpoint+0x6e>
			name_match = !strncmp(ept->name, name,
 810e44c:	697b      	ldr	r3, [r7, #20]
 810e44e:	2220      	movs	r2, #32
 810e450:	68b9      	ldr	r1, [r7, #8]
 810e452:	4618      	mov	r0, r3
 810e454:	f001 fc29 	bl	810fcaa <strncmp>
 810e458:	4603      	mov	r3, r0
 810e45a:	2b00      	cmp	r3, #0
 810e45c:	bf0c      	ite	eq
 810e45e:	2301      	moveq	r3, #1
 810e460:	2300      	movne	r3, #0
 810e462:	b2db      	uxtb	r3, r3
 810e464:	61bb      	str	r3, [r7, #24]
					      sizeof(ept->name));
		if (!name || !name_match)
 810e466:	68bb      	ldr	r3, [r7, #8]
 810e468:	2b00      	cmp	r3, #0
 810e46a:	d018      	beq.n	810e49e <rpmsg_get_endpoint+0xa6>
 810e46c:	69bb      	ldr	r3, [r7, #24]
 810e46e:	2b00      	cmp	r3, #0
 810e470:	d015      	beq.n	810e49e <rpmsg_get_endpoint+0xa6>
			continue;
		/* destination address is known, equal to ept remote address*/
		if (dest_addr != RPMSG_ADDR_ANY && ept->dest_addr == dest_addr)
 810e472:	683b      	ldr	r3, [r7, #0]
 810e474:	f1b3 3fff 	cmp.w	r3, #4294967295
 810e478:	d006      	beq.n	810e488 <rpmsg_get_endpoint+0x90>
 810e47a:	697b      	ldr	r3, [r7, #20]
 810e47c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810e47e:	683a      	ldr	r2, [r7, #0]
 810e480:	429a      	cmp	r2, r3
 810e482:	d101      	bne.n	810e488 <rpmsg_get_endpoint+0x90>
			return ept;
 810e484:	697b      	ldr	r3, [r7, #20]
 810e486:	e013      	b.n	810e4b0 <rpmsg_get_endpoint+0xb8>
		/* ept is registered but not associated to remote ept*/
		if (addr == RPMSG_ADDR_ANY && ept->dest_addr == RPMSG_ADDR_ANY)
 810e488:	687b      	ldr	r3, [r7, #4]
 810e48a:	f1b3 3fff 	cmp.w	r3, #4294967295
 810e48e:	d107      	bne.n	810e4a0 <rpmsg_get_endpoint+0xa8>
 810e490:	697b      	ldr	r3, [r7, #20]
 810e492:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810e494:	f1b3 3fff 	cmp.w	r3, #4294967295
 810e498:	d102      	bne.n	810e4a0 <rpmsg_get_endpoint+0xa8>
			return ept;
 810e49a:	697b      	ldr	r3, [r7, #20]
 810e49c:	e008      	b.n	810e4b0 <rpmsg_get_endpoint+0xb8>
			continue;
 810e49e:	bf00      	nop
	metal_list_for_each(&rdev->endpoints, node) {
 810e4a0:	69fb      	ldr	r3, [r7, #28]
 810e4a2:	681b      	ldr	r3, [r3, #0]
 810e4a4:	61fb      	str	r3, [r7, #28]
 810e4a6:	68fb      	ldr	r3, [r7, #12]
 810e4a8:	69fa      	ldr	r2, [r7, #28]
 810e4aa:	429a      	cmp	r2, r3
 810e4ac:	d1af      	bne.n	810e40e <rpmsg_get_endpoint+0x16>
	}
	return NULL;
 810e4ae:	2300      	movs	r3, #0
}
 810e4b0:	4618      	mov	r0, r3
 810e4b2:	3720      	adds	r7, #32
 810e4b4:	46bd      	mov	sp, r7
 810e4b6:	bd80      	pop	{r7, pc}

0810e4b8 <rpmsg_unregister_endpoint>:

static void rpmsg_unregister_endpoint(struct rpmsg_endpoint *ept)
{
 810e4b8:	b580      	push	{r7, lr}
 810e4ba:	b084      	sub	sp, #16
 810e4bc:	af00      	add	r7, sp, #0
 810e4be:	6078      	str	r0, [r7, #4]
	struct rpmsg_device *rdev;

	if (!ept)
 810e4c0:	687b      	ldr	r3, [r7, #4]
 810e4c2:	2b00      	cmp	r3, #0
 810e4c4:	d016      	beq.n	810e4f4 <rpmsg_unregister_endpoint+0x3c>
		return;

	rdev = ept->rdev;
 810e4c6:	687b      	ldr	r3, [r7, #4]
 810e4c8:	6a1b      	ldr	r3, [r3, #32]
 810e4ca:	60fb      	str	r3, [r7, #12]

	if (ept->addr != RPMSG_ADDR_ANY)
 810e4cc:	687b      	ldr	r3, [r7, #4]
 810e4ce:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810e4d0:	f1b3 3fff 	cmp.w	r3, #4294967295
 810e4d4:	d008      	beq.n	810e4e8 <rpmsg_unregister_endpoint+0x30>
		rpmsg_release_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
 810e4d6:	68fb      	ldr	r3, [r7, #12]
 810e4d8:	f103 0048 	add.w	r0, r3, #72	@ 0x48
				      ept->addr);
 810e4dc:	687b      	ldr	r3, [r7, #4]
 810e4de:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
		rpmsg_release_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
 810e4e0:	461a      	mov	r2, r3
 810e4e2:	2180      	movs	r1, #128	@ 0x80
 810e4e4:	f7ff feec 	bl	810e2c0 <rpmsg_release_address>
	metal_list_del(&ept->node);
 810e4e8:	687b      	ldr	r3, [r7, #4]
 810e4ea:	3334      	adds	r3, #52	@ 0x34
 810e4ec:	4618      	mov	r0, r3
 810e4ee:	f7ff fe0f 	bl	810e110 <metal_list_del>
 810e4f2:	e000      	b.n	810e4f6 <rpmsg_unregister_endpoint+0x3e>
		return;
 810e4f4:	bf00      	nop
}
 810e4f6:	3710      	adds	r7, #16
 810e4f8:	46bd      	mov	sp, r7
 810e4fa:	bd80      	pop	{r7, pc}

0810e4fc <rpmsg_register_endpoint>:

int rpmsg_register_endpoint(struct rpmsg_device *rdev,
			    struct rpmsg_endpoint *ept)
{
 810e4fc:	b580      	push	{r7, lr}
 810e4fe:	b082      	sub	sp, #8
 810e500:	af00      	add	r7, sp, #0
 810e502:	6078      	str	r0, [r7, #4]
 810e504:	6039      	str	r1, [r7, #0]
	ept->rdev = rdev;
 810e506:	683b      	ldr	r3, [r7, #0]
 810e508:	687a      	ldr	r2, [r7, #4]
 810e50a:	621a      	str	r2, [r3, #32]

	metal_list_add_tail(&rdev->endpoints, &ept->node);
 810e50c:	687a      	ldr	r2, [r7, #4]
 810e50e:	683b      	ldr	r3, [r7, #0]
 810e510:	3334      	adds	r3, #52	@ 0x34
 810e512:	4619      	mov	r1, r3
 810e514:	4610      	mov	r0, r2
 810e516:	f7ff fdee 	bl	810e0f6 <metal_list_add_tail>
	return RPMSG_SUCCESS;
 810e51a:	2300      	movs	r3, #0
}
 810e51c:	4618      	mov	r0, r3
 810e51e:	3708      	adds	r7, #8
 810e520:	46bd      	mov	sp, r7
 810e522:	bd80      	pop	{r7, pc}

0810e524 <rpmsg_create_ept>:

int rpmsg_create_ept(struct rpmsg_endpoint *ept, struct rpmsg_device *rdev,
		     const char *name, uint32_t src, uint32_t dest,
		     rpmsg_ept_cb cb, rpmsg_ns_unbind_cb unbind_cb)
{
 810e524:	b580      	push	{r7, lr}
 810e526:	b088      	sub	sp, #32
 810e528:	af02      	add	r7, sp, #8
 810e52a:	60f8      	str	r0, [r7, #12]
 810e52c:	60b9      	str	r1, [r7, #8]
 810e52e:	607a      	str	r2, [r7, #4]
 810e530:	603b      	str	r3, [r7, #0]
	int status;
	uint32_t addr = src;
 810e532:	683b      	ldr	r3, [r7, #0]
 810e534:	613b      	str	r3, [r7, #16]

	if (!ept)
 810e536:	68fb      	ldr	r3, [r7, #12]
 810e538:	2b00      	cmp	r3, #0
 810e53a:	d101      	bne.n	810e540 <rpmsg_create_ept+0x1c>
		return RPMSG_ERR_PARAM;
 810e53c:	4b37      	ldr	r3, [pc, #220]	@ (810e61c <rpmsg_create_ept+0xf8>)
 810e53e:	e068      	b.n	810e612 <rpmsg_create_ept+0xee>

	metal_mutex_acquire(&rdev->lock);
 810e540:	68bb      	ldr	r3, [r7, #8]
 810e542:	3358      	adds	r3, #88	@ 0x58
 810e544:	4618      	mov	r0, r3
 810e546:	f7ff fda6 	bl	810e096 <metal_mutex_acquire>
	if (src != RPMSG_ADDR_ANY) {
 810e54a:	683b      	ldr	r3, [r7, #0]
 810e54c:	f1b3 3fff 	cmp.w	r3, #4294967295
 810e550:	d018      	beq.n	810e584 <rpmsg_create_ept+0x60>
		status = rpmsg_is_address_set(rdev->bitmap,
 810e552:	68bb      	ldr	r3, [r7, #8]
 810e554:	3348      	adds	r3, #72	@ 0x48
 810e556:	683a      	ldr	r2, [r7, #0]
 810e558:	2180      	movs	r1, #128	@ 0x80
 810e55a:	4618      	mov	r0, r3
 810e55c:	f7ff fec2 	bl	810e2e4 <rpmsg_is_address_set>
 810e560:	6178      	str	r0, [r7, #20]
					      RPMSG_ADDR_BMP_SIZE, src);
		if (!status) {
 810e562:	697b      	ldr	r3, [r7, #20]
 810e564:	2b00      	cmp	r3, #0
 810e566:	d107      	bne.n	810e578 <rpmsg_create_ept+0x54>
			/* Mark the address as used in the address bitmap. */
			rpmsg_set_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
 810e568:	68bb      	ldr	r3, [r7, #8]
 810e56a:	3348      	adds	r3, #72	@ 0x48
 810e56c:	683a      	ldr	r2, [r7, #0]
 810e56e:	2180      	movs	r1, #128	@ 0x80
 810e570:	4618      	mov	r0, r3
 810e572:	f7ff fecf 	bl	810e314 <rpmsg_set_address>
 810e576:	e00c      	b.n	810e592 <rpmsg_create_ept+0x6e>
					  src);
		} else if (status > 0) {
 810e578:	697b      	ldr	r3, [r7, #20]
 810e57a:	2b00      	cmp	r3, #0
 810e57c:	dd40      	ble.n	810e600 <rpmsg_create_ept+0xdc>
			status = RPMSG_SUCCESS;
 810e57e:	2300      	movs	r3, #0
 810e580:	617b      	str	r3, [r7, #20]
			goto ret_status;
 810e582:	e040      	b.n	810e606 <rpmsg_create_ept+0xe2>
		} else {
			goto ret_status;
		}
	} else {
		addr = rpmsg_get_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE);
 810e584:	68bb      	ldr	r3, [r7, #8]
 810e586:	3348      	adds	r3, #72	@ 0x48
 810e588:	2180      	movs	r1, #128	@ 0x80
 810e58a:	4618      	mov	r0, r3
 810e58c:	f7ff fe79 	bl	810e282 <rpmsg_get_address>
 810e590:	6138      	str	r0, [r7, #16]
	}

	rpmsg_init_ept(ept, name, addr, dest, cb, unbind_cb);
 810e592:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810e594:	9301      	str	r3, [sp, #4]
 810e596:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810e598:	9300      	str	r3, [sp, #0]
 810e59a:	6a3b      	ldr	r3, [r7, #32]
 810e59c:	693a      	ldr	r2, [r7, #16]
 810e59e:	6879      	ldr	r1, [r7, #4]
 810e5a0:	68f8      	ldr	r0, [r7, #12]
 810e5a2:	f7ff fe51 	bl	810e248 <rpmsg_init_ept>

	status = rpmsg_register_endpoint(rdev, ept);
 810e5a6:	68f9      	ldr	r1, [r7, #12]
 810e5a8:	68b8      	ldr	r0, [r7, #8]
 810e5aa:	f7ff ffa7 	bl	810e4fc <rpmsg_register_endpoint>
 810e5ae:	6178      	str	r0, [r7, #20]
	if (status < 0)
 810e5b0:	697b      	ldr	r3, [r7, #20]
 810e5b2:	2b00      	cmp	r3, #0
 810e5b4:	da06      	bge.n	810e5c4 <rpmsg_create_ept+0xa0>
		rpmsg_release_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE, addr);
 810e5b6:	68bb      	ldr	r3, [r7, #8]
 810e5b8:	3348      	adds	r3, #72	@ 0x48
 810e5ba:	693a      	ldr	r2, [r7, #16]
 810e5bc:	2180      	movs	r1, #128	@ 0x80
 810e5be:	4618      	mov	r0, r3
 810e5c0:	f7ff fe7e 	bl	810e2c0 <rpmsg_release_address>

	if (!status  && ept->dest_addr == RPMSG_ADDR_ANY) {
 810e5c4:	697b      	ldr	r3, [r7, #20]
 810e5c6:	2b00      	cmp	r3, #0
 810e5c8:	d11c      	bne.n	810e604 <rpmsg_create_ept+0xe0>
 810e5ca:	68fb      	ldr	r3, [r7, #12]
 810e5cc:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810e5ce:	f1b3 3fff 	cmp.w	r3, #4294967295
 810e5d2:	d117      	bne.n	810e604 <rpmsg_create_ept+0xe0>
		/* Send NS announcement to remote processor */
		metal_mutex_release(&rdev->lock);
 810e5d4:	68bb      	ldr	r3, [r7, #8]
 810e5d6:	3358      	adds	r3, #88	@ 0x58
 810e5d8:	4618      	mov	r0, r3
 810e5da:	f7ff fd67 	bl	810e0ac <metal_mutex_release>
		status = rpmsg_send_ns_message(ept, RPMSG_NS_CREATE);
 810e5de:	2100      	movs	r1, #0
 810e5e0:	68f8      	ldr	r0, [r7, #12]
 810e5e2:	f7ff fee1 	bl	810e3a8 <rpmsg_send_ns_message>
 810e5e6:	6178      	str	r0, [r7, #20]
		metal_mutex_acquire(&rdev->lock);
 810e5e8:	68bb      	ldr	r3, [r7, #8]
 810e5ea:	3358      	adds	r3, #88	@ 0x58
 810e5ec:	4618      	mov	r0, r3
 810e5ee:	f7ff fd52 	bl	810e096 <metal_mutex_acquire>
		if (status)
 810e5f2:	697b      	ldr	r3, [r7, #20]
 810e5f4:	2b00      	cmp	r3, #0
 810e5f6:	d005      	beq.n	810e604 <rpmsg_create_ept+0xe0>
			rpmsg_unregister_endpoint(ept);
 810e5f8:	68f8      	ldr	r0, [r7, #12]
 810e5fa:	f7ff ff5d 	bl	810e4b8 <rpmsg_unregister_endpoint>
 810e5fe:	e002      	b.n	810e606 <rpmsg_create_ept+0xe2>
			goto ret_status;
 810e600:	bf00      	nop
 810e602:	e000      	b.n	810e606 <rpmsg_create_ept+0xe2>
	}

ret_status:
 810e604:	bf00      	nop
	metal_mutex_release(&rdev->lock);
 810e606:	68bb      	ldr	r3, [r7, #8]
 810e608:	3358      	adds	r3, #88	@ 0x58
 810e60a:	4618      	mov	r0, r3
 810e60c:	f7ff fd4e 	bl	810e0ac <metal_mutex_release>
	return status;
 810e610:	697b      	ldr	r3, [r7, #20]
}
 810e612:	4618      	mov	r0, r3
 810e614:	3718      	adds	r7, #24
 810e616:	46bd      	mov	sp, r7
 810e618:	bd80      	pop	{r7, pc}
 810e61a:	bf00      	nop
 810e61c:	fffff82d 	.word	0xfffff82d

0810e620 <__metal_cache_invalidate>:
{
 810e620:	b580      	push	{r7, lr}
 810e622:	b082      	sub	sp, #8
 810e624:	af00      	add	r7, sp, #0
 810e626:	6078      	str	r0, [r7, #4]
 810e628:	6039      	str	r1, [r7, #0]
	metal_machine_cache_invalidate(addr, len);
 810e62a:	6839      	ldr	r1, [r7, #0]
 810e62c:	6878      	ldr	r0, [r7, #4]
 810e62e:	f000 fc58 	bl	810eee2 <metal_machine_cache_invalidate>
}
 810e632:	bf00      	nop
 810e634:	3708      	adds	r7, #8
 810e636:	46bd      	mov	sp, r7
 810e638:	bd80      	pop	{r7, pc}

0810e63a <metal_cache_invalidate>:
{
 810e63a:	b580      	push	{r7, lr}
 810e63c:	b082      	sub	sp, #8
 810e63e:	af00      	add	r7, sp, #0
 810e640:	6078      	str	r0, [r7, #4]
 810e642:	6039      	str	r1, [r7, #0]
	__metal_cache_invalidate(addr, len);
 810e644:	6839      	ldr	r1, [r7, #0]
 810e646:	6878      	ldr	r0, [r7, #4]
 810e648:	f7ff ffea 	bl	810e620 <__metal_cache_invalidate>
}
 810e64c:	bf00      	nop
 810e64e:	3708      	adds	r7, #8
 810e650:	46bd      	mov	sp, r7
 810e652:	bd80      	pop	{r7, pc}

0810e654 <__metal_sleep_usec>:
#ifdef __cplusplus
extern "C" {
#endif

static inline int __metal_sleep_usec(unsigned int usec)
{
 810e654:	b480      	push	{r7}
 810e656:	b083      	sub	sp, #12
 810e658:	af00      	add	r7, sp, #0
 810e65a:	6078      	str	r0, [r7, #4]
	metal_unused(usec);
	/* Fix me */
	return 0;
 810e65c:	2300      	movs	r3, #0
}
 810e65e:	4618      	mov	r0, r3
 810e660:	370c      	adds	r7, #12
 810e662:	46bd      	mov	sp, r7
 810e664:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e668:	4770      	bx	lr

0810e66a <metal_sleep_usec>:
 *
 * @param[in]  usec      microsecond intervals
 * @return     0 on success, non-zero for failures
 */
static inline int metal_sleep_usec(unsigned int usec)
{
 810e66a:	b580      	push	{r7, lr}
 810e66c:	b082      	sub	sp, #8
 810e66e:	af00      	add	r7, sp, #0
 810e670:	6078      	str	r0, [r7, #4]
	return __metal_sleep_usec(usec);
 810e672:	6878      	ldr	r0, [r7, #4]
 810e674:	f7ff ffee 	bl	810e654 <__metal_sleep_usec>
 810e678:	4603      	mov	r3, r0
}
 810e67a:	4618      	mov	r0, r3
 810e67c:	3708      	adds	r7, #8
 810e67e:	46bd      	mov	sp, r7
 810e680:	bd80      	pop	{r7, pc}

0810e682 <metal_list_init>:
{
 810e682:	b480      	push	{r7}
 810e684:	b083      	sub	sp, #12
 810e686:	af00      	add	r7, sp, #0
 810e688:	6078      	str	r0, [r7, #4]
	list->next = list->prev = list;
 810e68a:	687b      	ldr	r3, [r7, #4]
 810e68c:	687a      	ldr	r2, [r7, #4]
 810e68e:	605a      	str	r2, [r3, #4]
 810e690:	687b      	ldr	r3, [r7, #4]
 810e692:	685a      	ldr	r2, [r3, #4]
 810e694:	687b      	ldr	r3, [r7, #4]
 810e696:	601a      	str	r2, [r3, #0]
}
 810e698:	bf00      	nop
 810e69a:	370c      	adds	r7, #12
 810e69c:	46bd      	mov	sp, r7
 810e69e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e6a2:	4770      	bx	lr

0810e6a4 <metal_io_virt_to_offset>:
{
 810e6a4:	b480      	push	{r7}
 810e6a6:	b085      	sub	sp, #20
 810e6a8:	af00      	add	r7, sp, #0
 810e6aa:	6078      	str	r0, [r7, #4]
 810e6ac:	6039      	str	r1, [r7, #0]
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 810e6ae:	687b      	ldr	r3, [r7, #4]
 810e6b0:	681b      	ldr	r3, [r3, #0]
 810e6b2:	683a      	ldr	r2, [r7, #0]
 810e6b4:	1ad3      	subs	r3, r2, r3
 810e6b6:	60fb      	str	r3, [r7, #12]
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 810e6b8:	687b      	ldr	r3, [r7, #4]
 810e6ba:	689b      	ldr	r3, [r3, #8]
 810e6bc:	68fa      	ldr	r2, [r7, #12]
 810e6be:	429a      	cmp	r2, r3
 810e6c0:	d201      	bcs.n	810e6c6 <metal_io_virt_to_offset+0x22>
 810e6c2:	68fb      	ldr	r3, [r7, #12]
 810e6c4:	e001      	b.n	810e6ca <metal_io_virt_to_offset+0x26>
 810e6c6:	f04f 33ff 	mov.w	r3, #4294967295
}
 810e6ca:	4618      	mov	r0, r3
 810e6cc:	3714      	adds	r7, #20
 810e6ce:	46bd      	mov	sp, r7
 810e6d0:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e6d4:	4770      	bx	lr

0810e6d6 <__metal_mutex_init>:
{
 810e6d6:	b480      	push	{r7}
 810e6d8:	b085      	sub	sp, #20
 810e6da:	af00      	add	r7, sp, #0
 810e6dc:	6078      	str	r0, [r7, #4]
	atomic_store(&mutex->v, 0);
 810e6de:	687b      	ldr	r3, [r7, #4]
 810e6e0:	60fb      	str	r3, [r7, #12]
 810e6e2:	2300      	movs	r3, #0
 810e6e4:	60bb      	str	r3, [r7, #8]
 810e6e6:	68bb      	ldr	r3, [r7, #8]
 810e6e8:	461a      	mov	r2, r3
 810e6ea:	68fb      	ldr	r3, [r7, #12]
 810e6ec:	f3bf 8f5b 	dmb	ish
 810e6f0:	601a      	str	r2, [r3, #0]
 810e6f2:	f3bf 8f5b 	dmb	ish
}
 810e6f6:	bf00      	nop
 810e6f8:	3714      	adds	r7, #20
 810e6fa:	46bd      	mov	sp, r7
 810e6fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e700:	4770      	bx	lr

0810e702 <__metal_mutex_acquire>:
{
 810e702:	b480      	push	{r7}
 810e704:	b083      	sub	sp, #12
 810e706:	af00      	add	r7, sp, #0
 810e708:	6078      	str	r0, [r7, #4]
	while (atomic_flag_test_and_set(&mutex->w)) {
 810e70a:	bf00      	nop
 810e70c:	687b      	ldr	r3, [r7, #4]
 810e70e:	2201      	movs	r2, #1
 810e710:	4611      	mov	r1, r2
 810e712:	f3bf 8f5b 	dmb	ish
 810e716:	e8d3 2f4f 	ldrexb	r2, [r3]
 810e71a:	e8c3 1f40 	strexb	r0, r1, [r3]
 810e71e:	2800      	cmp	r0, #0
 810e720:	d1f9      	bne.n	810e716 <__metal_mutex_acquire+0x14>
 810e722:	f3bf 8f5b 	dmb	ish
 810e726:	b2d3      	uxtb	r3, r2
 810e728:	2b00      	cmp	r3, #0
 810e72a:	d1ef      	bne.n	810e70c <__metal_mutex_acquire+0xa>
}
 810e72c:	bf00      	nop
 810e72e:	bf00      	nop
 810e730:	370c      	adds	r7, #12
 810e732:	46bd      	mov	sp, r7
 810e734:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e738:	4770      	bx	lr

0810e73a <__metal_mutex_release>:
{
 810e73a:	b480      	push	{r7}
 810e73c:	b083      	sub	sp, #12
 810e73e:	af00      	add	r7, sp, #0
 810e740:	6078      	str	r0, [r7, #4]
	atomic_flag_clear(&mutex->w);
 810e742:	687b      	ldr	r3, [r7, #4]
 810e744:	f3bf 8f5b 	dmb	ish
 810e748:	2200      	movs	r2, #0
 810e74a:	701a      	strb	r2, [r3, #0]
 810e74c:	f3bf 8f5b 	dmb	ish
}
 810e750:	bf00      	nop
 810e752:	370c      	adds	r7, #12
 810e754:	46bd      	mov	sp, r7
 810e756:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e75a:	4770      	bx	lr

0810e75c <metal_mutex_init>:
{
 810e75c:	b580      	push	{r7, lr}
 810e75e:	b082      	sub	sp, #8
 810e760:	af00      	add	r7, sp, #0
 810e762:	6078      	str	r0, [r7, #4]
	__metal_mutex_init(mutex);
 810e764:	6878      	ldr	r0, [r7, #4]
 810e766:	f7ff ffb6 	bl	810e6d6 <__metal_mutex_init>
}
 810e76a:	bf00      	nop
 810e76c:	3708      	adds	r7, #8
 810e76e:	46bd      	mov	sp, r7
 810e770:	bd80      	pop	{r7, pc}

0810e772 <metal_mutex_acquire>:
{
 810e772:	b580      	push	{r7, lr}
 810e774:	b082      	sub	sp, #8
 810e776:	af00      	add	r7, sp, #0
 810e778:	6078      	str	r0, [r7, #4]
	__metal_mutex_acquire(mutex);
 810e77a:	6878      	ldr	r0, [r7, #4]
 810e77c:	f7ff ffc1 	bl	810e702 <__metal_mutex_acquire>
}
 810e780:	bf00      	nop
 810e782:	3708      	adds	r7, #8
 810e784:	46bd      	mov	sp, r7
 810e786:	bd80      	pop	{r7, pc}

0810e788 <metal_mutex_release>:
{
 810e788:	b580      	push	{r7, lr}
 810e78a:	b082      	sub	sp, #8
 810e78c:	af00      	add	r7, sp, #0
 810e78e:	6078      	str	r0, [r7, #4]
	__metal_mutex_release(mutex);
 810e790:	6878      	ldr	r0, [r7, #4]
 810e792:	f7ff ffd2 	bl	810e73a <__metal_mutex_release>
}
 810e796:	bf00      	nop
 810e798:	3708      	adds	r7, #8
 810e79a:	46bd      	mov	sp, r7
 810e79c:	bd80      	pop	{r7, pc}

0810e79e <rpmsg_init_ept>:
{
 810e79e:	b580      	push	{r7, lr}
 810e7a0:	b084      	sub	sp, #16
 810e7a2:	af00      	add	r7, sp, #0
 810e7a4:	60f8      	str	r0, [r7, #12]
 810e7a6:	60b9      	str	r1, [r7, #8]
 810e7a8:	607a      	str	r2, [r7, #4]
 810e7aa:	603b      	str	r3, [r7, #0]
	strncpy(ept->name, name, sizeof(ept->name));
 810e7ac:	68fb      	ldr	r3, [r7, #12]
 810e7ae:	2220      	movs	r2, #32
 810e7b0:	68b9      	ldr	r1, [r7, #8]
 810e7b2:	4618      	mov	r0, r3
 810e7b4:	f001 fa8b 	bl	810fcce <strncpy>
	ept->addr = src;
 810e7b8:	68fb      	ldr	r3, [r7, #12]
 810e7ba:	687a      	ldr	r2, [r7, #4]
 810e7bc:	625a      	str	r2, [r3, #36]	@ 0x24
	ept->dest_addr = dest;
 810e7be:	68fb      	ldr	r3, [r7, #12]
 810e7c0:	683a      	ldr	r2, [r7, #0]
 810e7c2:	629a      	str	r2, [r3, #40]	@ 0x28
	ept->cb = cb;
 810e7c4:	68fb      	ldr	r3, [r7, #12]
 810e7c6:	69ba      	ldr	r2, [r7, #24]
 810e7c8:	62da      	str	r2, [r3, #44]	@ 0x2c
	ept->ns_unbind_cb = ns_unbind_cb;
 810e7ca:	68fb      	ldr	r3, [r7, #12]
 810e7cc:	69fa      	ldr	r2, [r7, #28]
 810e7ce:	631a      	str	r2, [r3, #48]	@ 0x30
}
 810e7d0:	bf00      	nop
 810e7d2:	3710      	adds	r7, #16
 810e7d4:	46bd      	mov	sp, r7
 810e7d6:	bd80      	pop	{r7, pc}

0810e7d8 <rpmsg_virtio_get_role>:

#define RPMSG_REMOTE	VIRTIO_DEV_SLAVE
#define RPMSG_MASTER	VIRTIO_DEV_MASTER
static inline unsigned int
	rpmsg_virtio_get_role(struct rpmsg_virtio_device *rvdev)
{
 810e7d8:	b480      	push	{r7}
 810e7da:	b083      	sub	sp, #12
 810e7dc:	af00      	add	r7, sp, #0
 810e7de:	6078      	str	r0, [r7, #4]
	return rvdev->vdev->role;
 810e7e0:	687b      	ldr	r3, [r7, #4]
 810e7e2:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810e7e4:	699b      	ldr	r3, [r3, #24]
}
 810e7e6:	4618      	mov	r0, r3
 810e7e8:	370c      	adds	r7, #12
 810e7ea:	46bd      	mov	sp, r7
 810e7ec:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e7f0:	4770      	bx	lr

0810e7f2 <rpmsg_virtio_set_status>:

static inline void rpmsg_virtio_set_status(struct rpmsg_virtio_device *rvdev,
					   uint8_t status)
{
 810e7f2:	b580      	push	{r7, lr}
 810e7f4:	b082      	sub	sp, #8
 810e7f6:	af00      	add	r7, sp, #0
 810e7f8:	6078      	str	r0, [r7, #4]
 810e7fa:	460b      	mov	r3, r1
 810e7fc:	70fb      	strb	r3, [r7, #3]
	rvdev->vdev->func->set_status(rvdev->vdev, status);
 810e7fe:	687b      	ldr	r3, [r7, #4]
 810e800:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810e802:	6a1b      	ldr	r3, [r3, #32]
 810e804:	685b      	ldr	r3, [r3, #4]
 810e806:	687a      	ldr	r2, [r7, #4]
 810e808:	6e52      	ldr	r2, [r2, #100]	@ 0x64
 810e80a:	78f9      	ldrb	r1, [r7, #3]
 810e80c:	4610      	mov	r0, r2
 810e80e:	4798      	blx	r3
}
 810e810:	bf00      	nop
 810e812:	3708      	adds	r7, #8
 810e814:	46bd      	mov	sp, r7
 810e816:	bd80      	pop	{r7, pc}

0810e818 <rpmsg_virtio_get_status>:

static inline uint8_t rpmsg_virtio_get_status(struct rpmsg_virtio_device *rvdev)
{
 810e818:	b580      	push	{r7, lr}
 810e81a:	b082      	sub	sp, #8
 810e81c:	af00      	add	r7, sp, #0
 810e81e:	6078      	str	r0, [r7, #4]
	return rvdev->vdev->func->get_status(rvdev->vdev);
 810e820:	687b      	ldr	r3, [r7, #4]
 810e822:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810e824:	6a1b      	ldr	r3, [r3, #32]
 810e826:	681b      	ldr	r3, [r3, #0]
 810e828:	687a      	ldr	r2, [r7, #4]
 810e82a:	6e52      	ldr	r2, [r2, #100]	@ 0x64
 810e82c:	4610      	mov	r0, r2
 810e82e:	4798      	blx	r3
 810e830:	4603      	mov	r3, r0
}
 810e832:	4618      	mov	r0, r3
 810e834:	3708      	adds	r7, #8
 810e836:	46bd      	mov	sp, r7
 810e838:	bd80      	pop	{r7, pc}

0810e83a <rpmsg_virtio_get_features>:

static inline uint32_t
	rpmsg_virtio_get_features(struct rpmsg_virtio_device *rvdev)
{
 810e83a:	b580      	push	{r7, lr}
 810e83c:	b082      	sub	sp, #8
 810e83e:	af00      	add	r7, sp, #0
 810e840:	6078      	str	r0, [r7, #4]
	return rvdev->vdev->func->get_features(rvdev->vdev);
 810e842:	687b      	ldr	r3, [r7, #4]
 810e844:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810e846:	6a1b      	ldr	r3, [r3, #32]
 810e848:	689b      	ldr	r3, [r3, #8]
 810e84a:	687a      	ldr	r2, [r7, #4]
 810e84c:	6e52      	ldr	r2, [r2, #100]	@ 0x64
 810e84e:	4610      	mov	r0, r2
 810e850:	4798      	blx	r3
 810e852:	4603      	mov	r3, r0
}
 810e854:	4618      	mov	r0, r3
 810e856:	3708      	adds	r7, #8
 810e858:	46bd      	mov	sp, r7
 810e85a:	bd80      	pop	{r7, pc}

0810e85c <rpmsg_virtio_create_virtqueues>:
static inline int
	rpmsg_virtio_create_virtqueues(struct rpmsg_virtio_device *rvdev,
				       int flags, unsigned int nvqs,
				       const char *names[],
				       vq_callback * callbacks[])
{
 810e85c:	b580      	push	{r7, lr}
 810e85e:	b086      	sub	sp, #24
 810e860:	af02      	add	r7, sp, #8
 810e862:	60f8      	str	r0, [r7, #12]
 810e864:	60b9      	str	r1, [r7, #8]
 810e866:	607a      	str	r2, [r7, #4]
 810e868:	603b      	str	r3, [r7, #0]
	return virtio_create_virtqueues(rvdev->vdev, flags, nvqs, names,
 810e86a:	68fb      	ldr	r3, [r7, #12]
 810e86c:	6e58      	ldr	r0, [r3, #100]	@ 0x64
 810e86e:	68b9      	ldr	r1, [r7, #8]
 810e870:	69bb      	ldr	r3, [r7, #24]
 810e872:	9300      	str	r3, [sp, #0]
 810e874:	683b      	ldr	r3, [r7, #0]
 810e876:	687a      	ldr	r2, [r7, #4]
 810e878:	f000 fb4c 	bl	810ef14 <virtio_create_virtqueues>
 810e87c:	4603      	mov	r3, r0
					callbacks);
}
 810e87e:	4618      	mov	r0, r3
 810e880:	3710      	adds	r7, #16
 810e882:	46bd      	mov	sp, r7
 810e884:	bd80      	pop	{r7, pc}

0810e886 <rpmsg_get_ept_from_addr>:
int rpmsg_register_endpoint(struct rpmsg_device *rdev,
			    struct rpmsg_endpoint *ept);

static inline struct rpmsg_endpoint *
rpmsg_get_ept_from_addr(struct rpmsg_device *rdev, uint32_t addr)
{
 810e886:	b580      	push	{r7, lr}
 810e888:	b082      	sub	sp, #8
 810e88a:	af00      	add	r7, sp, #0
 810e88c:	6078      	str	r0, [r7, #4]
 810e88e:	6039      	str	r1, [r7, #0]
	return rpmsg_get_endpoint(rdev, NULL, addr, RPMSG_ADDR_ANY);
 810e890:	f04f 33ff 	mov.w	r3, #4294967295
 810e894:	683a      	ldr	r2, [r7, #0]
 810e896:	2100      	movs	r1, #0
 810e898:	6878      	ldr	r0, [r7, #4]
 810e89a:	f7ff fdad 	bl	810e3f8 <rpmsg_get_endpoint>
 810e89e:	4603      	mov	r3, r0
}
 810e8a0:	4618      	mov	r0, r3
 810e8a2:	3708      	adds	r7, #8
 810e8a4:	46bd      	mov	sp, r7
 810e8a6:	bd80      	pop	{r7, pc}

0810e8a8 <rpmsg_virtio_init_shm_pool>:
}
#endif /*!VIRTIO_SLAVE_ONLY*/

void rpmsg_virtio_init_shm_pool(struct rpmsg_virtio_shm_pool *shpool,
				void *shb, size_t size)
{
 810e8a8:	b480      	push	{r7}
 810e8aa:	b085      	sub	sp, #20
 810e8ac:	af00      	add	r7, sp, #0
 810e8ae:	60f8      	str	r0, [r7, #12]
 810e8b0:	60b9      	str	r1, [r7, #8]
 810e8b2:	607a      	str	r2, [r7, #4]
	if (!shpool)
 810e8b4:	68fb      	ldr	r3, [r7, #12]
 810e8b6:	2b00      	cmp	r3, #0
 810e8b8:	d01d      	beq.n	810e8f6 <rpmsg_virtio_init_shm_pool+0x4e>
		return;
	shpool->base = shb;
 810e8ba:	68fb      	ldr	r3, [r7, #12]
 810e8bc:	68ba      	ldr	r2, [r7, #8]
 810e8be:	601a      	str	r2, [r3, #0]
	shpool->size = WORD_ALIGN(size);
 810e8c0:	687b      	ldr	r3, [r7, #4]
 810e8c2:	f003 0303 	and.w	r3, r3, #3
 810e8c6:	2b00      	cmp	r3, #0
 810e8c8:	d004      	beq.n	810e8d4 <rpmsg_virtio_init_shm_pool+0x2c>
 810e8ca:	687b      	ldr	r3, [r7, #4]
 810e8cc:	f023 0303 	bic.w	r3, r3, #3
 810e8d0:	3304      	adds	r3, #4
 810e8d2:	e000      	b.n	810e8d6 <rpmsg_virtio_init_shm_pool+0x2e>
 810e8d4:	687b      	ldr	r3, [r7, #4]
 810e8d6:	68fa      	ldr	r2, [r7, #12]
 810e8d8:	6093      	str	r3, [r2, #8]
	shpool->avail = WORD_ALIGN(size);
 810e8da:	687b      	ldr	r3, [r7, #4]
 810e8dc:	f003 0303 	and.w	r3, r3, #3
 810e8e0:	2b00      	cmp	r3, #0
 810e8e2:	d004      	beq.n	810e8ee <rpmsg_virtio_init_shm_pool+0x46>
 810e8e4:	687b      	ldr	r3, [r7, #4]
 810e8e6:	f023 0303 	bic.w	r3, r3, #3
 810e8ea:	3304      	adds	r3, #4
 810e8ec:	e000      	b.n	810e8f0 <rpmsg_virtio_init_shm_pool+0x48>
 810e8ee:	687b      	ldr	r3, [r7, #4]
 810e8f0:	68fa      	ldr	r2, [r7, #12]
 810e8f2:	6053      	str	r3, [r2, #4]
 810e8f4:	e000      	b.n	810e8f8 <rpmsg_virtio_init_shm_pool+0x50>
		return;
 810e8f6:	bf00      	nop
}
 810e8f8:	3714      	adds	r7, #20
 810e8fa:	46bd      	mov	sp, r7
 810e8fc:	f85d 7b04 	ldr.w	r7, [sp], #4
 810e900:	4770      	bx	lr

0810e902 <rpmsg_virtio_return_buffer>:
 *
 */
static void rpmsg_virtio_return_buffer(struct rpmsg_virtio_device *rvdev,
				       void *buffer, unsigned long len,
				       unsigned short idx)
{
 810e902:	b580      	push	{r7, lr}
 810e904:	b086      	sub	sp, #24
 810e906:	af00      	add	r7, sp, #0
 810e908:	60f8      	str	r0, [r7, #12]
 810e90a:	60b9      	str	r1, [r7, #8]
 810e90c:	607a      	str	r2, [r7, #4]
 810e90e:	807b      	strh	r3, [r7, #2]
	unsigned int role = rpmsg_virtio_get_role(rvdev);
 810e910:	68f8      	ldr	r0, [r7, #12]
 810e912:	f7ff ff61 	bl	810e7d8 <rpmsg_virtio_get_role>
 810e916:	6178      	str	r0, [r7, #20]
		virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1, buffer);
	}
#endif /*VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 810e918:	697b      	ldr	r3, [r7, #20]
 810e91a:	2b01      	cmp	r3, #1
 810e91c:	d106      	bne.n	810e92c <rpmsg_virtio_return_buffer+0x2a>
		(void)buffer;
		virtqueue_add_consumed_buffer(rvdev->rvq, idx, len);
 810e91e:	68fb      	ldr	r3, [r7, #12]
 810e920:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 810e922:	8879      	ldrh	r1, [r7, #2]
 810e924:	687a      	ldr	r2, [r7, #4]
 810e926:	4618      	mov	r0, r3
 810e928:	f000 fc9e 	bl	810f268 <virtqueue_add_consumed_buffer>
	}
#endif /*VIRTIO_MASTER_ONLY*/
}
 810e92c:	bf00      	nop
 810e92e:	3718      	adds	r7, #24
 810e930:	46bd      	mov	sp, r7
 810e932:	bd80      	pop	{r7, pc}

0810e934 <rpmsg_virtio_enqueue_buffer>:
 * @return - status of function execution
 */
static int rpmsg_virtio_enqueue_buffer(struct rpmsg_virtio_device *rvdev,
				       void *buffer, unsigned long len,
				       unsigned short idx)
{
 810e934:	b580      	push	{r7, lr}
 810e936:	b086      	sub	sp, #24
 810e938:	af00      	add	r7, sp, #0
 810e93a:	60f8      	str	r0, [r7, #12]
 810e93c:	60b9      	str	r1, [r7, #8]
 810e93e:	607a      	str	r2, [r7, #4]
 810e940:	807b      	strh	r3, [r7, #2]
	unsigned int role = rpmsg_virtio_get_role(rvdev);
 810e942:	68f8      	ldr	r0, [r7, #12]
 810e944:	f7ff ff48 	bl	810e7d8 <rpmsg_virtio_get_role>
 810e948:	6178      	str	r0, [r7, #20]
		return virtqueue_add_buffer(rvdev->svq, &vqbuf, 0, 1, buffer);
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 810e94a:	697b      	ldr	r3, [r7, #20]
 810e94c:	2b01      	cmp	r3, #1
 810e94e:	d108      	bne.n	810e962 <rpmsg_virtio_enqueue_buffer+0x2e>
		(void)buffer;
		return virtqueue_add_consumed_buffer(rvdev->svq, idx, len);
 810e950:	68fb      	ldr	r3, [r7, #12]
 810e952:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 810e954:	8879      	ldrh	r1, [r7, #2]
 810e956:	687a      	ldr	r2, [r7, #4]
 810e958:	4618      	mov	r0, r3
 810e95a:	f000 fc85 	bl	810f268 <virtqueue_add_consumed_buffer>
 810e95e:	4603      	mov	r3, r0
 810e960:	e000      	b.n	810e964 <rpmsg_virtio_enqueue_buffer+0x30>
	}
#endif /*!VIRTIO_MASTER_ONLY*/
	return 0;
 810e962:	2300      	movs	r3, #0
}
 810e964:	4618      	mov	r0, r3
 810e966:	3718      	adds	r7, #24
 810e968:	46bd      	mov	sp, r7
 810e96a:	bd80      	pop	{r7, pc}

0810e96c <rpmsg_virtio_get_tx_buffer>:
 * return - pointer to buffer.
 */
static void *rpmsg_virtio_get_tx_buffer(struct rpmsg_virtio_device *rvdev,
					unsigned long *len,
					unsigned short *idx)
{
 810e96c:	b580      	push	{r7, lr}
 810e96e:	b086      	sub	sp, #24
 810e970:	af00      	add	r7, sp, #0
 810e972:	60f8      	str	r0, [r7, #12]
 810e974:	60b9      	str	r1, [r7, #8]
 810e976:	607a      	str	r2, [r7, #4]
	unsigned int role = rpmsg_virtio_get_role(rvdev);
 810e978:	68f8      	ldr	r0, [r7, #12]
 810e97a:	f7ff ff2d 	bl	810e7d8 <rpmsg_virtio_get_role>
 810e97e:	6138      	str	r0, [r7, #16]
	void *data = NULL;
 810e980:	2300      	movs	r3, #0
 810e982:	617b      	str	r3, [r7, #20]
		}
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 810e984:	693b      	ldr	r3, [r7, #16]
 810e986:	2b01      	cmp	r3, #1
 810e988:	d107      	bne.n	810e99a <rpmsg_virtio_get_tx_buffer+0x2e>
		data = virtqueue_get_available_buffer(rvdev->svq, idx,
 810e98a:	68fb      	ldr	r3, [r7, #12]
 810e98c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 810e98e:	68ba      	ldr	r2, [r7, #8]
 810e990:	6879      	ldr	r1, [r7, #4]
 810e992:	4618      	mov	r0, r3
 810e994:	f000 fc22 	bl	810f1dc <virtqueue_get_available_buffer>
 810e998:	6178      	str	r0, [r7, #20]
						      (uint32_t *)len);
	}
#endif /*!VIRTIO_MASTER_ONLY*/

	return data;
 810e99a:	697b      	ldr	r3, [r7, #20]
}
 810e99c:	4618      	mov	r0, r3
 810e99e:	3718      	adds	r7, #24
 810e9a0:	46bd      	mov	sp, r7
 810e9a2:	bd80      	pop	{r7, pc}

0810e9a4 <rpmsg_virtio_get_rx_buffer>:
 *
 */
static void *rpmsg_virtio_get_rx_buffer(struct rpmsg_virtio_device *rvdev,
					unsigned long *len,
					unsigned short *idx)
{
 810e9a4:	b580      	push	{r7, lr}
 810e9a6:	b086      	sub	sp, #24
 810e9a8:	af00      	add	r7, sp, #0
 810e9aa:	60f8      	str	r0, [r7, #12]
 810e9ac:	60b9      	str	r1, [r7, #8]
 810e9ae:	607a      	str	r2, [r7, #4]
	unsigned int role = rpmsg_virtio_get_role(rvdev);
 810e9b0:	68f8      	ldr	r0, [r7, #12]
 810e9b2:	f7ff ff11 	bl	810e7d8 <rpmsg_virtio_get_role>
 810e9b6:	6138      	str	r0, [r7, #16]
	void *data = NULL;
 810e9b8:	2300      	movs	r3, #0
 810e9ba:	617b      	str	r3, [r7, #20]
		data = virtqueue_get_buffer(rvdev->rvq, (uint32_t *)len, idx);
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 810e9bc:	693b      	ldr	r3, [r7, #16]
 810e9be:	2b01      	cmp	r3, #1
 810e9c0:	d107      	bne.n	810e9d2 <rpmsg_virtio_get_rx_buffer+0x2e>
		data =
		    virtqueue_get_available_buffer(rvdev->rvq, idx,
 810e9c2:	68fb      	ldr	r3, [r7, #12]
 810e9c4:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
 810e9c6:	68ba      	ldr	r2, [r7, #8]
 810e9c8:	6879      	ldr	r1, [r7, #4]
 810e9ca:	4618      	mov	r0, r3
 810e9cc:	f000 fc06 	bl	810f1dc <virtqueue_get_available_buffer>
 810e9d0:	6178      	str	r0, [r7, #20]
						   (uint32_t *)len);
	}
#endif /*!VIRTIO_MASTER_ONLY*/

	if (data) {
 810e9d2:	697b      	ldr	r3, [r7, #20]
 810e9d4:	2b00      	cmp	r3, #0
 810e9d6:	d005      	beq.n	810e9e4 <rpmsg_virtio_get_rx_buffer+0x40>
		/* FIX ME: library should not worry about if it needs
		 * to flush/invalidate cache, it is shared memory.
		 * The shared memory should be mapped properly before
		 * using it.
		 */
		metal_cache_invalidate(data, (unsigned int)(*len));
 810e9d8:	68bb      	ldr	r3, [r7, #8]
 810e9da:	681b      	ldr	r3, [r3, #0]
 810e9dc:	4619      	mov	r1, r3
 810e9de:	6978      	ldr	r0, [r7, #20]
 810e9e0:	f7ff fe2b 	bl	810e63a <metal_cache_invalidate>
	}

	return data;
 810e9e4:	697b      	ldr	r3, [r7, #20]
}
 810e9e6:	4618      	mov	r0, r3
 810e9e8:	3718      	adds	r7, #24
 810e9ea:	46bd      	mov	sp, r7
 810e9ec:	bd80      	pop	{r7, pc}

0810e9ee <rpmsg_virtio_wait_remote_ready>:
#ifndef VIRTIO_MASTER_ONLY
/**
 * check if the remote is ready to start RPMsg communication
 */
static int rpmsg_virtio_wait_remote_ready(struct rpmsg_virtio_device *rvdev)
{
 810e9ee:	b580      	push	{r7, lr}
 810e9f0:	b084      	sub	sp, #16
 810e9f2:	af00      	add	r7, sp, #0
 810e9f4:	6078      	str	r0, [r7, #4]
	uint8_t status;

	while (1) {
		status = rpmsg_virtio_get_status(rvdev);
 810e9f6:	6878      	ldr	r0, [r7, #4]
 810e9f8:	f7ff ff0e 	bl	810e818 <rpmsg_virtio_get_status>
 810e9fc:	4603      	mov	r3, r0
 810e9fe:	73fb      	strb	r3, [r7, #15]
		/* Busy wait until the remote is ready */
		if (status & VIRTIO_CONFIG_STATUS_NEEDS_RESET) {
 810ea00:	7bfb      	ldrb	r3, [r7, #15]
 810ea02:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 810ea06:	2b00      	cmp	r3, #0
 810ea08:	d004      	beq.n	810ea14 <rpmsg_virtio_wait_remote_ready+0x26>
			rpmsg_virtio_set_status(rvdev, 0);
 810ea0a:	2100      	movs	r1, #0
 810ea0c:	6878      	ldr	r0, [r7, #4]
 810ea0e:	f7ff fef0 	bl	810e7f2 <rpmsg_virtio_set_status>
 810ea12:	e7f0      	b.n	810e9f6 <rpmsg_virtio_wait_remote_ready+0x8>
			/* TODO notify remote processor */
		} else if (status & VIRTIO_CONFIG_STATUS_DRIVER_OK) {
 810ea14:	7bfb      	ldrb	r3, [r7, #15]
 810ea16:	f003 0304 	and.w	r3, r3, #4
 810ea1a:	2b00      	cmp	r3, #0
 810ea1c:	d0eb      	beq.n	810e9f6 <rpmsg_virtio_wait_remote_ready+0x8>
			return true;
 810ea1e:	2301      	movs	r3, #1
		/* TODO: clarify metal_cpu_yield usage*/
		metal_cpu_yield();
	}

	return false;
}
 810ea20:	4618      	mov	r0, r3
 810ea22:	3710      	adds	r7, #16
 810ea24:	46bd      	mov	sp, r7
 810ea26:	bd80      	pop	{r7, pc}

0810ea28 <_rpmsg_virtio_get_buffer_size>:
 *
 * @return - buffer size
 *
 */
static int _rpmsg_virtio_get_buffer_size(struct rpmsg_virtio_device *rvdev)
{
 810ea28:	b580      	push	{r7, lr}
 810ea2a:	b084      	sub	sp, #16
 810ea2c:	af00      	add	r7, sp, #0
 810ea2e:	6078      	str	r0, [r7, #4]
	unsigned int role = rpmsg_virtio_get_role(rvdev);
 810ea30:	6878      	ldr	r0, [r7, #4]
 810ea32:	f7ff fed1 	bl	810e7d8 <rpmsg_virtio_get_role>
 810ea36:	60b8      	str	r0, [r7, #8]
	int length = 0;
 810ea38:	2300      	movs	r3, #0
 810ea3a:	60fb      	str	r3, [r7, #12]
		length = RPMSG_BUFFER_SIZE - sizeof(struct rpmsg_hdr);
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 810ea3c:	68bb      	ldr	r3, [r7, #8]
 810ea3e:	2b01      	cmp	r3, #1
 810ea40:	d107      	bne.n	810ea52 <_rpmsg_virtio_get_buffer_size+0x2a>
		/*
		 * If other core is Master then buffers are provided by it,
		 * so get the buffer size from the virtqueue.
		 */
		length =
		    (int)virtqueue_get_desc_size(rvdev->svq) -
 810ea42:	687b      	ldr	r3, [r7, #4]
 810ea44:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 810ea46:	4618      	mov	r0, r3
 810ea48:	f000 fc88 	bl	810f35c <virtqueue_get_desc_size>
 810ea4c:	4603      	mov	r3, r0
 810ea4e:	3b10      	subs	r3, #16
		length =
 810ea50:	60fb      	str	r3, [r7, #12]
		    sizeof(struct rpmsg_hdr);
	}
#endif /*!VIRTIO_MASTER_ONLY*/

	return length;
 810ea52:	68fb      	ldr	r3, [r7, #12]
}
 810ea54:	4618      	mov	r0, r3
 810ea56:	3710      	adds	r7, #16
 810ea58:	46bd      	mov	sp, r7
 810ea5a:	bd80      	pop	{r7, pc}

0810ea5c <rpmsg_virtio_send_offchannel_raw>:
 */
static int rpmsg_virtio_send_offchannel_raw(struct rpmsg_device *rdev,
					    uint32_t src, uint32_t dst,
					    const void *data,
					    int size, int wait)
{
 810ea5c:	b580      	push	{r7, lr}
 810ea5e:	b090      	sub	sp, #64	@ 0x40
 810ea60:	af00      	add	r7, sp, #0
 810ea62:	60f8      	str	r0, [r7, #12]
 810ea64:	60b9      	str	r1, [r7, #8]
 810ea66:	607a      	str	r2, [r7, #4]
 810ea68:	603b      	str	r3, [r7, #0]
	struct rpmsg_virtio_device *rvdev;
	struct rpmsg_hdr rp_hdr;
	void *buffer = NULL;
 810ea6a:	2300      	movs	r3, #0
 810ea6c:	63fb      	str	r3, [r7, #60]	@ 0x3c
	unsigned short idx;
	int tick_count = 0;
 810ea6e:	2300      	movs	r3, #0
 810ea70:	63bb      	str	r3, [r7, #56]	@ 0x38
	unsigned long buff_len;
	int status;
	struct metal_io_region *io;

	/* Get the associated remote device for channel. */
	rvdev = metal_container_of(rdev, struct rpmsg_virtio_device, rdev);
 810ea72:	68fb      	ldr	r3, [r7, #12]
 810ea74:	637b      	str	r3, [r7, #52]	@ 0x34

	status = rpmsg_virtio_get_status(rvdev);
 810ea76:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 810ea78:	f7ff fece 	bl	810e818 <rpmsg_virtio_get_status>
 810ea7c:	4603      	mov	r3, r0
 810ea7e:	633b      	str	r3, [r7, #48]	@ 0x30
	/* Validate device state */
	if (!(status & VIRTIO_CONFIG_STATUS_DRIVER_OK)) {
 810ea80:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810ea82:	f003 0304 	and.w	r3, r3, #4
 810ea86:	2b00      	cmp	r3, #0
 810ea88:	d101      	bne.n	810ea8e <rpmsg_virtio_send_offchannel_raw+0x32>
		return RPMSG_ERR_DEV_STATE;
 810ea8a:	4b46      	ldr	r3, [pc, #280]	@ (810eba4 <rpmsg_virtio_send_offchannel_raw+0x148>)
 810ea8c:	e086      	b.n	810eb9c <rpmsg_virtio_send_offchannel_raw+0x140>
	}

	if (wait)
 810ea8e:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
 810ea90:	2b00      	cmp	r3, #0
 810ea92:	d003      	beq.n	810ea9c <rpmsg_virtio_send_offchannel_raw+0x40>
		tick_count = RPMSG_TICK_COUNT / RPMSG_TICKS_PER_INTERVAL;
 810ea94:	f240 53dc 	movw	r3, #1500	@ 0x5dc
 810ea98:	63bb      	str	r3, [r7, #56]	@ 0x38
 810ea9a:	e001      	b.n	810eaa0 <rpmsg_virtio_send_offchannel_raw+0x44>
	else
		tick_count = 0;
 810ea9c:	2300      	movs	r3, #0
 810ea9e:	63bb      	str	r3, [r7, #56]	@ 0x38

	while (1) {
		int avail_size;

		/* Lock the device to enable exclusive access to virtqueues */
		metal_mutex_acquire(&rdev->lock);
 810eaa0:	68fb      	ldr	r3, [r7, #12]
 810eaa2:	3358      	adds	r3, #88	@ 0x58
 810eaa4:	4618      	mov	r0, r3
 810eaa6:	f7ff fe64 	bl	810e772 <metal_mutex_acquire>
		avail_size = _rpmsg_virtio_get_buffer_size(rvdev);
 810eaaa:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 810eaac:	f7ff ffbc 	bl	810ea28 <_rpmsg_virtio_get_buffer_size>
 810eab0:	62f8      	str	r0, [r7, #44]	@ 0x2c
		if (size <= avail_size)
 810eab2:	6cba      	ldr	r2, [r7, #72]	@ 0x48
 810eab4:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810eab6:	429a      	cmp	r2, r3
 810eab8:	dc08      	bgt.n	810eacc <rpmsg_virtio_send_offchannel_raw+0x70>
			buffer = rpmsg_virtio_get_tx_buffer(rvdev, &buff_len,
 810eaba:	f107 0216 	add.w	r2, r7, #22
 810eabe:	f107 0310 	add.w	r3, r7, #16
 810eac2:	4619      	mov	r1, r3
 810eac4:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 810eac6:	f7ff ff51 	bl	810e96c <rpmsg_virtio_get_tx_buffer>
 810eaca:	63f8      	str	r0, [r7, #60]	@ 0x3c
							    &idx);
		metal_mutex_release(&rdev->lock);
 810eacc:	68fb      	ldr	r3, [r7, #12]
 810eace:	3358      	adds	r3, #88	@ 0x58
 810ead0:	4618      	mov	r0, r3
 810ead2:	f7ff fe59 	bl	810e788 <metal_mutex_release>
		if (buffer || !tick_count)
 810ead6:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 810ead8:	2b00      	cmp	r3, #0
 810eada:	d10e      	bne.n	810eafa <rpmsg_virtio_send_offchannel_raw+0x9e>
 810eadc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810eade:	2b00      	cmp	r3, #0
 810eae0:	d00b      	beq.n	810eafa <rpmsg_virtio_send_offchannel_raw+0x9e>
			break;
		if (avail_size != 0)
 810eae2:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810eae4:	2b00      	cmp	r3, #0
 810eae6:	d001      	beq.n	810eaec <rpmsg_virtio_send_offchannel_raw+0x90>
			return RPMSG_ERR_BUFF_SIZE;
 810eae8:	4b2f      	ldr	r3, [pc, #188]	@ (810eba8 <rpmsg_virtio_send_offchannel_raw+0x14c>)
 810eaea:	e057      	b.n	810eb9c <rpmsg_virtio_send_offchannel_raw+0x140>
		metal_sleep_usec(RPMSG_TICKS_PER_INTERVAL);
 810eaec:	200a      	movs	r0, #10
 810eaee:	f7ff fdbc 	bl	810e66a <metal_sleep_usec>
		tick_count--;
 810eaf2:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810eaf4:	3b01      	subs	r3, #1
 810eaf6:	63bb      	str	r3, [r7, #56]	@ 0x38
	while (1) {
 810eaf8:	e7d2      	b.n	810eaa0 <rpmsg_virtio_send_offchannel_raw+0x44>
	}
	if (!buffer)
 810eafa:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 810eafc:	2b00      	cmp	r3, #0
 810eafe:	d101      	bne.n	810eb04 <rpmsg_virtio_send_offchannel_raw+0xa8>
		return RPMSG_ERR_NO_BUFF;
 810eb00:	4b2a      	ldr	r3, [pc, #168]	@ (810ebac <rpmsg_virtio_send_offchannel_raw+0x150>)
 810eb02:	e04b      	b.n	810eb9c <rpmsg_virtio_send_offchannel_raw+0x140>

	/* Initialize RPMSG header. */
	rp_hdr.dst = dst;
 810eb04:	687b      	ldr	r3, [r7, #4]
 810eb06:	61fb      	str	r3, [r7, #28]
	rp_hdr.src = src;
 810eb08:	68bb      	ldr	r3, [r7, #8]
 810eb0a:	61bb      	str	r3, [r7, #24]
	rp_hdr.len = size;
 810eb0c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 810eb0e:	b29b      	uxth	r3, r3
 810eb10:	84bb      	strh	r3, [r7, #36]	@ 0x24
	rp_hdr.reserved = 0;
 810eb12:	2300      	movs	r3, #0
 810eb14:	623b      	str	r3, [r7, #32]

	/* Copy data to rpmsg buffer. */
	io = rvdev->shbuf_io;
 810eb16:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810eb18:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 810eb1a:	62bb      	str	r3, [r7, #40]	@ 0x28
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
 810eb1c:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 810eb1e:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810eb20:	f7ff fdc0 	bl	810e6a4 <metal_io_virt_to_offset>
 810eb24:	4601      	mov	r1, r0
 810eb26:	f107 0218 	add.w	r2, r7, #24
 810eb2a:	2310      	movs	r3, #16
 810eb2c:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810eb2e:	f7fe ff56 	bl	810d9de <metal_io_block_write>
 810eb32:	6338      	str	r0, [r7, #48]	@ 0x30
				      &rp_hdr, sizeof(rp_hdr));
	RPMSG_ASSERT(status == sizeof(rp_hdr), "failed to write header\n");
 810eb34:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810eb36:	2b10      	cmp	r3, #16
 810eb38:	d001      	beq.n	810eb3e <rpmsg_virtio_send_offchannel_raw+0xe2>
 810eb3a:	bf00      	nop
 810eb3c:	e7fd      	b.n	810eb3a <rpmsg_virtio_send_offchannel_raw+0xde>

	status = metal_io_block_write(io,
 810eb3e:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
 810eb40:	3310      	adds	r3, #16
 810eb42:	4619      	mov	r1, r3
 810eb44:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810eb46:	f7ff fdad 	bl	810e6a4 <metal_io_virt_to_offset>
 810eb4a:	4601      	mov	r1, r0
 810eb4c:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 810eb4e:	683a      	ldr	r2, [r7, #0]
 810eb50:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810eb52:	f7fe ff44 	bl	810d9de <metal_io_block_write>
 810eb56:	6338      	str	r0, [r7, #48]	@ 0x30
				      metal_io_virt_to_offset(io,
				      RPMSG_LOCATE_DATA(buffer)),
				      data, size);
	RPMSG_ASSERT(status == size, "failed to write buffer\n");
 810eb58:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
 810eb5a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
 810eb5c:	429a      	cmp	r2, r3
 810eb5e:	d001      	beq.n	810eb64 <rpmsg_virtio_send_offchannel_raw+0x108>
 810eb60:	bf00      	nop
 810eb62:	e7fd      	b.n	810eb60 <rpmsg_virtio_send_offchannel_raw+0x104>
	metal_mutex_acquire(&rdev->lock);
 810eb64:	68fb      	ldr	r3, [r7, #12]
 810eb66:	3358      	adds	r3, #88	@ 0x58
 810eb68:	4618      	mov	r0, r3
 810eb6a:	f7ff fe02 	bl	810e772 <metal_mutex_acquire>

	/* Enqueue buffer on virtqueue. */
	status = rpmsg_virtio_enqueue_buffer(rvdev, buffer, buff_len, idx);
 810eb6e:	693a      	ldr	r2, [r7, #16]
 810eb70:	8afb      	ldrh	r3, [r7, #22]
 810eb72:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
 810eb74:	6b78      	ldr	r0, [r7, #52]	@ 0x34
 810eb76:	f7ff fedd 	bl	810e934 <rpmsg_virtio_enqueue_buffer>
 810eb7a:	6338      	str	r0, [r7, #48]	@ 0x30
	RPMSG_ASSERT(status == VQUEUE_SUCCESS, "failed to enqueue buffer\n");
 810eb7c:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810eb7e:	2b00      	cmp	r3, #0
 810eb80:	d001      	beq.n	810eb86 <rpmsg_virtio_send_offchannel_raw+0x12a>
 810eb82:	bf00      	nop
 810eb84:	e7fd      	b.n	810eb82 <rpmsg_virtio_send_offchannel_raw+0x126>
	/* Let the other side know that there is a job to process. */
	virtqueue_kick(rvdev->svq);
 810eb86:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810eb88:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
 810eb8a:	4618      	mov	r0, r3
 810eb8c:	f000 fbd0 	bl	810f330 <virtqueue_kick>

	metal_mutex_release(&rdev->lock);
 810eb90:	68fb      	ldr	r3, [r7, #12]
 810eb92:	3358      	adds	r3, #88	@ 0x58
 810eb94:	4618      	mov	r0, r3
 810eb96:	f7ff fdf7 	bl	810e788 <metal_mutex_release>

	return size;
 810eb9a:	6cbb      	ldr	r3, [r7, #72]	@ 0x48
}
 810eb9c:	4618      	mov	r0, r3
 810eb9e:	3740      	adds	r7, #64	@ 0x40
 810eba0:	46bd      	mov	sp, r7
 810eba2:	bd80      	pop	{r7, pc}
 810eba4:	fffff82c 	.word	0xfffff82c
 810eba8:	fffff82b 	.word	0xfffff82b
 810ebac:	fffff82e 	.word	0xfffff82e

0810ebb0 <rpmsg_virtio_tx_callback>:
 * @param vq - pointer to virtqueue on which Tx is has been
 *             completed.
 *
 */
static void rpmsg_virtio_tx_callback(struct virtqueue *vq)
{
 810ebb0:	b480      	push	{r7}
 810ebb2:	b083      	sub	sp, #12
 810ebb4:	af00      	add	r7, sp, #0
 810ebb6:	6078      	str	r0, [r7, #4]
	(void)vq;
}
 810ebb8:	bf00      	nop
 810ebba:	370c      	adds	r7, #12
 810ebbc:	46bd      	mov	sp, r7
 810ebbe:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ebc2:	4770      	bx	lr

0810ebc4 <rpmsg_virtio_rx_callback>:
 *
 * @param vq - pointer to virtqueue on which messages is received
 *
 */
static void rpmsg_virtio_rx_callback(struct virtqueue *vq)
{
 810ebc4:	b590      	push	{r4, r7, lr}
 810ebc6:	b08d      	sub	sp, #52	@ 0x34
 810ebc8:	af02      	add	r7, sp, #8
 810ebca:	6078      	str	r0, [r7, #4]
	struct virtio_device *vdev = vq->vq_dev;
 810ebcc:	687b      	ldr	r3, [r7, #4]
 810ebce:	681b      	ldr	r3, [r3, #0]
 810ebd0:	623b      	str	r3, [r7, #32]
	struct rpmsg_virtio_device *rvdev = vdev->priv;
 810ebd2:	6a3b      	ldr	r3, [r7, #32]
 810ebd4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810ebd6:	61fb      	str	r3, [r7, #28]
	struct rpmsg_device *rdev = &rvdev->rdev;
 810ebd8:	69fb      	ldr	r3, [r7, #28]
 810ebda:	61bb      	str	r3, [r7, #24]
	struct rpmsg_hdr *rp_hdr;
	unsigned long len;
	unsigned short idx;
	int status;

	metal_mutex_acquire(&rdev->lock);
 810ebdc:	69bb      	ldr	r3, [r7, #24]
 810ebde:	3358      	adds	r3, #88	@ 0x58
 810ebe0:	4618      	mov	r0, r3
 810ebe2:	f7ff fdc6 	bl	810e772 <metal_mutex_acquire>

	/* Process the received data from remote node */
	rp_hdr = (struct rpmsg_hdr *)rpmsg_virtio_get_rx_buffer(rvdev,
 810ebe6:	f107 020a 	add.w	r2, r7, #10
 810ebea:	f107 030c 	add.w	r3, r7, #12
 810ebee:	4619      	mov	r1, r3
 810ebf0:	69f8      	ldr	r0, [r7, #28]
 810ebf2:	f7ff fed7 	bl	810e9a4 <rpmsg_virtio_get_rx_buffer>
 810ebf6:	6278      	str	r0, [r7, #36]	@ 0x24
								&len, &idx);

	metal_mutex_release(&rdev->lock);
 810ebf8:	69bb      	ldr	r3, [r7, #24]
 810ebfa:	3358      	adds	r3, #88	@ 0x58
 810ebfc:	4618      	mov	r0, r3
 810ebfe:	f7ff fdc3 	bl	810e788 <metal_mutex_release>

	while (rp_hdr) {
 810ec02:	e04d      	b.n	810eca0 <rpmsg_virtio_rx_callback+0xdc>
		/* Get the channel node from the remote device channels list. */
		metal_mutex_acquire(&rdev->lock);
 810ec04:	69bb      	ldr	r3, [r7, #24]
 810ec06:	3358      	adds	r3, #88	@ 0x58
 810ec08:	4618      	mov	r0, r3
 810ec0a:	f7ff fdb2 	bl	810e772 <metal_mutex_acquire>
		ept = rpmsg_get_ept_from_addr(rdev, rp_hdr->dst);
 810ec0e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810ec10:	685b      	ldr	r3, [r3, #4]
 810ec12:	4619      	mov	r1, r3
 810ec14:	69b8      	ldr	r0, [r7, #24]
 810ec16:	f7ff fe36 	bl	810e886 <rpmsg_get_ept_from_addr>
 810ec1a:	6178      	str	r0, [r7, #20]
		metal_mutex_release(&rdev->lock);
 810ec1c:	69bb      	ldr	r3, [r7, #24]
 810ec1e:	3358      	adds	r3, #88	@ 0x58
 810ec20:	4618      	mov	r0, r3
 810ec22:	f7ff fdb1 	bl	810e788 <metal_mutex_release>

		if (!ept)
 810ec26:	697b      	ldr	r3, [r7, #20]
 810ec28:	2b00      	cmp	r3, #0
 810ec2a:	d03d      	beq.n	810eca8 <rpmsg_virtio_rx_callback+0xe4>
			/* Fatal error no endpoint for the given dst addr. */
			return;

		if (ept->dest_addr == RPMSG_ADDR_ANY) {
 810ec2c:	697b      	ldr	r3, [r7, #20]
 810ec2e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810ec30:	f1b3 3fff 	cmp.w	r3, #4294967295
 810ec34:	d103      	bne.n	810ec3e <rpmsg_virtio_rx_callback+0x7a>
			/*
			 * First message received from the remote side,
			 * update channel destination address
			 */
			ept->dest_addr = rp_hdr->src;
 810ec36:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810ec38:	681a      	ldr	r2, [r3, #0]
 810ec3a:	697b      	ldr	r3, [r7, #20]
 810ec3c:	629a      	str	r2, [r3, #40]	@ 0x28
		}
		status = ept->cb(ept, (void *)RPMSG_LOCATE_DATA(rp_hdr),
 810ec3e:	697b      	ldr	r3, [r7, #20]
 810ec40:	6adc      	ldr	r4, [r3, #44]	@ 0x2c
 810ec42:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810ec44:	f103 0110 	add.w	r1, r3, #16
				   rp_hdr->len, ept->addr, ept->priv);
 810ec48:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810ec4a:	899b      	ldrh	r3, [r3, #12]
 810ec4c:	b29b      	uxth	r3, r3
		status = ept->cb(ept, (void *)RPMSG_LOCATE_DATA(rp_hdr),
 810ec4e:	4618      	mov	r0, r3
 810ec50:	697b      	ldr	r3, [r7, #20]
 810ec52:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 810ec54:	697b      	ldr	r3, [r7, #20]
 810ec56:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
 810ec58:	9300      	str	r3, [sp, #0]
 810ec5a:	4613      	mov	r3, r2
 810ec5c:	4602      	mov	r2, r0
 810ec5e:	6978      	ldr	r0, [r7, #20]
 810ec60:	47a0      	blx	r4
 810ec62:	6138      	str	r0, [r7, #16]

		RPMSG_ASSERT(status == RPMSG_SUCCESS,
 810ec64:	693b      	ldr	r3, [r7, #16]
 810ec66:	2b00      	cmp	r3, #0
 810ec68:	d001      	beq.n	810ec6e <rpmsg_virtio_rx_callback+0xaa>
 810ec6a:	bf00      	nop
 810ec6c:	e7fd      	b.n	810ec6a <rpmsg_virtio_rx_callback+0xa6>
			     "unexpected callback status\n");
		metal_mutex_acquire(&rdev->lock);
 810ec6e:	69bb      	ldr	r3, [r7, #24]
 810ec70:	3358      	adds	r3, #88	@ 0x58
 810ec72:	4618      	mov	r0, r3
 810ec74:	f7ff fd7d 	bl	810e772 <metal_mutex_acquire>

		/* Return used buffers. */
		rpmsg_virtio_return_buffer(rvdev, rp_hdr, len, idx);
 810ec78:	68fa      	ldr	r2, [r7, #12]
 810ec7a:	897b      	ldrh	r3, [r7, #10]
 810ec7c:	6a79      	ldr	r1, [r7, #36]	@ 0x24
 810ec7e:	69f8      	ldr	r0, [r7, #28]
 810ec80:	f7ff fe3f 	bl	810e902 <rpmsg_virtio_return_buffer>

		rp_hdr = (struct rpmsg_hdr *)
			 rpmsg_virtio_get_rx_buffer(rvdev, &len, &idx);
 810ec84:	f107 020a 	add.w	r2, r7, #10
 810ec88:	f107 030c 	add.w	r3, r7, #12
 810ec8c:	4619      	mov	r1, r3
 810ec8e:	69f8      	ldr	r0, [r7, #28]
 810ec90:	f7ff fe88 	bl	810e9a4 <rpmsg_virtio_get_rx_buffer>
 810ec94:	6278      	str	r0, [r7, #36]	@ 0x24
		metal_mutex_release(&rdev->lock);
 810ec96:	69bb      	ldr	r3, [r7, #24]
 810ec98:	3358      	adds	r3, #88	@ 0x58
 810ec9a:	4618      	mov	r0, r3
 810ec9c:	f7ff fd74 	bl	810e788 <metal_mutex_release>
	while (rp_hdr) {
 810eca0:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810eca2:	2b00      	cmp	r3, #0
 810eca4:	d1ae      	bne.n	810ec04 <rpmsg_virtio_rx_callback+0x40>
 810eca6:	e000      	b.n	810ecaa <rpmsg_virtio_rx_callback+0xe6>
			return;
 810eca8:	bf00      	nop
	}
}
 810ecaa:	372c      	adds	r7, #44	@ 0x2c
 810ecac:	46bd      	mov	sp, r7
 810ecae:	bd90      	pop	{r4, r7, pc}

0810ecb0 <rpmsg_virtio_ns_callback>:
#pragma push
#pragma O0
#endif
static int rpmsg_virtio_ns_callback(struct rpmsg_endpoint *ept, void *data,
				    size_t len, uint32_t src, void *priv)
{
 810ecb0:	b580      	push	{r7, lr}
 810ecb2:	b092      	sub	sp, #72	@ 0x48
 810ecb4:	af00      	add	r7, sp, #0
 810ecb6:	60f8      	str	r0, [r7, #12]
 810ecb8:	60b9      	str	r1, [r7, #8]
 810ecba:	607a      	str	r2, [r7, #4]
 810ecbc:	603b      	str	r3, [r7, #0]
	struct rpmsg_device *rdev = ept->rdev;
 810ecbe:	68fb      	ldr	r3, [r7, #12]
 810ecc0:	6a1b      	ldr	r3, [r3, #32]
 810ecc2:	647b      	str	r3, [r7, #68]	@ 0x44
	struct rpmsg_virtio_device *rvdev = (struct rpmsg_virtio_device *)rdev;
 810ecc4:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 810ecc6:	643b      	str	r3, [r7, #64]	@ 0x40
	struct metal_io_region *io = rvdev->shbuf_io;
 810ecc8:	6c3b      	ldr	r3, [r7, #64]	@ 0x40
 810ecca:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
 810eccc:	63fb      	str	r3, [r7, #60]	@ 0x3c
	char name[RPMSG_NAME_SIZE];

	(void)priv;
	(void)src;

	ns_msg = (struct rpmsg_ns_msg *)data;
 810ecce:	68bb      	ldr	r3, [r7, #8]
 810ecd0:	63bb      	str	r3, [r7, #56]	@ 0x38
	if (len != sizeof(*ns_msg))
 810ecd2:	687b      	ldr	r3, [r7, #4]
 810ecd4:	2b28      	cmp	r3, #40	@ 0x28
 810ecd6:	d001      	beq.n	810ecdc <rpmsg_virtio_ns_callback+0x2c>
		/* Returns as the message is corrupted */
		return RPMSG_SUCCESS;
 810ecd8:	2300      	movs	r3, #0
 810ecda:	e057      	b.n	810ed8c <rpmsg_virtio_ns_callback+0xdc>
	metal_io_block_read(io,
			    metal_io_virt_to_offset(io, ns_msg->name),
 810ecdc:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
	metal_io_block_read(io,
 810ecde:	4619      	mov	r1, r3
 810ece0:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 810ece2:	f7ff fcdf 	bl	810e6a4 <metal_io_virt_to_offset>
 810ece6:	4601      	mov	r1, r0
 810ece8:	f107 0210 	add.w	r2, r7, #16
 810ecec:	2320      	movs	r3, #32
 810ecee:	6bf8      	ldr	r0, [r7, #60]	@ 0x3c
 810ecf0:	f7fe fdfe 	bl	810d8f0 <metal_io_block_read>
			    &name, sizeof(name));
	dest = ns_msg->addr;
 810ecf4:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810ecf6:	6a1b      	ldr	r3, [r3, #32]
 810ecf8:	637b      	str	r3, [r7, #52]	@ 0x34

	/* check if a Ept has been locally registered */
	metal_mutex_acquire(&rdev->lock);
 810ecfa:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 810ecfc:	3358      	adds	r3, #88	@ 0x58
 810ecfe:	4618      	mov	r0, r3
 810ed00:	f7ff fd37 	bl	810e772 <metal_mutex_acquire>
	_ept = rpmsg_get_endpoint(rdev, name, RPMSG_ADDR_ANY, dest);
 810ed04:	f107 0110 	add.w	r1, r7, #16
 810ed08:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810ed0a:	f04f 32ff 	mov.w	r2, #4294967295
 810ed0e:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 810ed10:	f7ff fb72 	bl	810e3f8 <rpmsg_get_endpoint>
 810ed14:	6338      	str	r0, [r7, #48]	@ 0x30

	if (ns_msg->flags & RPMSG_NS_DESTROY) {
 810ed16:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
 810ed18:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810ed1a:	f003 0301 	and.w	r3, r3, #1
 810ed1e:	2b00      	cmp	r3, #0
 810ed20:	d017      	beq.n	810ed52 <rpmsg_virtio_ns_callback+0xa2>
		if (_ept)
 810ed22:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810ed24:	2b00      	cmp	r3, #0
 810ed26:	d003      	beq.n	810ed30 <rpmsg_virtio_ns_callback+0x80>
			_ept->dest_addr = RPMSG_ADDR_ANY;
 810ed28:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810ed2a:	f04f 32ff 	mov.w	r2, #4294967295
 810ed2e:	629a      	str	r2, [r3, #40]	@ 0x28
		metal_mutex_release(&rdev->lock);
 810ed30:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 810ed32:	3358      	adds	r3, #88	@ 0x58
 810ed34:	4618      	mov	r0, r3
 810ed36:	f7ff fd27 	bl	810e788 <metal_mutex_release>
		if (_ept && _ept->ns_unbind_cb)
 810ed3a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810ed3c:	2b00      	cmp	r3, #0
 810ed3e:	d024      	beq.n	810ed8a <rpmsg_virtio_ns_callback+0xda>
 810ed40:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810ed42:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 810ed44:	2b00      	cmp	r3, #0
 810ed46:	d020      	beq.n	810ed8a <rpmsg_virtio_ns_callback+0xda>
			_ept->ns_unbind_cb(ept);
 810ed48:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810ed4a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
 810ed4c:	68f8      	ldr	r0, [r7, #12]
 810ed4e:	4798      	blx	r3
 810ed50:	e01b      	b.n	810ed8a <rpmsg_virtio_ns_callback+0xda>
	} else {
		if (!_ept) {
 810ed52:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810ed54:	2b00      	cmp	r3, #0
 810ed56:	d110      	bne.n	810ed7a <rpmsg_virtio_ns_callback+0xca>
			 * send callback to application, that can
			 * - create the associated endpoints.
			 * - store information for future use.
			 * - just ignore the request as service not supported.
			 */
			metal_mutex_release(&rdev->lock);
 810ed58:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 810ed5a:	3358      	adds	r3, #88	@ 0x58
 810ed5c:	4618      	mov	r0, r3
 810ed5e:	f7ff fd13 	bl	810e788 <metal_mutex_release>
			if (rdev->ns_bind_cb)
 810ed62:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 810ed64:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 810ed66:	2b00      	cmp	r3, #0
 810ed68:	d00f      	beq.n	810ed8a <rpmsg_virtio_ns_callback+0xda>
				rdev->ns_bind_cb(rdev, name, dest);
 810ed6a:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 810ed6c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
 810ed6e:	f107 0110 	add.w	r1, r7, #16
 810ed72:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 810ed74:	6c78      	ldr	r0, [r7, #68]	@ 0x44
 810ed76:	4798      	blx	r3
 810ed78:	e007      	b.n	810ed8a <rpmsg_virtio_ns_callback+0xda>
		} else {
			_ept->dest_addr = dest;
 810ed7a:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810ed7c:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 810ed7e:	629a      	str	r2, [r3, #40]	@ 0x28
			metal_mutex_release(&rdev->lock);
 810ed80:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
 810ed82:	3358      	adds	r3, #88	@ 0x58
 810ed84:	4618      	mov	r0, r3
 810ed86:	f7ff fcff 	bl	810e788 <metal_mutex_release>
		}
	}

	return RPMSG_SUCCESS;
 810ed8a:	2300      	movs	r3, #0
}
 810ed8c:	4618      	mov	r0, r3
 810ed8e:	3748      	adds	r7, #72	@ 0x48
 810ed90:	46bd      	mov	sp, r7
 810ed92:	bd80      	pop	{r7, pc}

0810ed94 <rpmsg_init_vdev>:
int rpmsg_init_vdev(struct rpmsg_virtio_device *rvdev,
		    struct virtio_device *vdev,
		    rpmsg_ns_bind_cb ns_bind_cb,
		    struct metal_io_region *shm_io,
		    struct rpmsg_virtio_shm_pool *shpool)
{
 810ed94:	b580      	push	{r7, lr}
 810ed96:	b090      	sub	sp, #64	@ 0x40
 810ed98:	af02      	add	r7, sp, #8
 810ed9a:	60f8      	str	r0, [r7, #12]
 810ed9c:	60b9      	str	r1, [r7, #8]
 810ed9e:	607a      	str	r2, [r7, #4]
 810eda0:	603b      	str	r3, [r7, #0]
	vqcallback callback[RPMSG_NUM_VRINGS];
	unsigned long dev_features;
	int status;
	unsigned int i, role;

	rdev = &rvdev->rdev;
 810eda2:	68fb      	ldr	r3, [r7, #12]
 810eda4:	633b      	str	r3, [r7, #48]	@ 0x30
	memset(rdev, 0, sizeof(*rdev));
 810eda6:	2264      	movs	r2, #100	@ 0x64
 810eda8:	2100      	movs	r1, #0
 810edaa:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 810edac:	f000 ff75 	bl	810fc9a <memset>
	metal_mutex_init(&rdev->lock);
 810edb0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810edb2:	3358      	adds	r3, #88	@ 0x58
 810edb4:	4618      	mov	r0, r3
 810edb6:	f7ff fcd1 	bl	810e75c <metal_mutex_init>
	rvdev->vdev = vdev;
 810edba:	68fb      	ldr	r3, [r7, #12]
 810edbc:	68ba      	ldr	r2, [r7, #8]
 810edbe:	665a      	str	r2, [r3, #100]	@ 0x64
	rdev->ns_bind_cb = ns_bind_cb;
 810edc0:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810edc2:	687a      	ldr	r2, [r7, #4]
 810edc4:	65da      	str	r2, [r3, #92]	@ 0x5c
	vdev->priv = rvdev;
 810edc6:	68bb      	ldr	r3, [r7, #8]
 810edc8:	68fa      	ldr	r2, [r7, #12]
 810edca:	625a      	str	r2, [r3, #36]	@ 0x24
	rdev->ops.send_offchannel_raw = rpmsg_virtio_send_offchannel_raw;
 810edcc:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810edce:	4a38      	ldr	r2, [pc, #224]	@ (810eeb0 <rpmsg_init_vdev+0x11c>)
 810edd0:	661a      	str	r2, [r3, #96]	@ 0x60
	role = rpmsg_virtio_get_role(rvdev);
 810edd2:	68f8      	ldr	r0, [r7, #12]
 810edd4:	f7ff fd00 	bl	810e7d8 <rpmsg_virtio_get_role>
 810edd8:	62f8      	str	r0, [r7, #44]	@ 0x2c
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	(void)shpool;
	if (role == RPMSG_REMOTE) {
 810edda:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810eddc:	2b01      	cmp	r3, #1
 810edde:	d112      	bne.n	810ee06 <rpmsg_init_vdev+0x72>
		vq_names[0] = "tx_vq";
 810ede0:	4b34      	ldr	r3, [pc, #208]	@ (810eeb4 <rpmsg_init_vdev+0x120>)
 810ede2:	61bb      	str	r3, [r7, #24]
		vq_names[1] = "rx_vq";
 810ede4:	4b34      	ldr	r3, [pc, #208]	@ (810eeb8 <rpmsg_init_vdev+0x124>)
 810ede6:	61fb      	str	r3, [r7, #28]
		callback[0] = rpmsg_virtio_tx_callback;
 810ede8:	4b34      	ldr	r3, [pc, #208]	@ (810eebc <rpmsg_init_vdev+0x128>)
 810edea:	613b      	str	r3, [r7, #16]
		callback[1] = rpmsg_virtio_rx_callback;
 810edec:	4b34      	ldr	r3, [pc, #208]	@ (810eec0 <rpmsg_init_vdev+0x12c>)
 810edee:	617b      	str	r3, [r7, #20]
		rvdev->rvq  = vdev->vrings_info[1].vq;
 810edf0:	68bb      	ldr	r3, [r7, #8]
 810edf2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810edf4:	3318      	adds	r3, #24
 810edf6:	681a      	ldr	r2, [r3, #0]
 810edf8:	68fb      	ldr	r3, [r7, #12]
 810edfa:	669a      	str	r2, [r3, #104]	@ 0x68
		rvdev->svq  = vdev->vrings_info[0].vq;
 810edfc:	68bb      	ldr	r3, [r7, #8]
 810edfe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810ee00:	681a      	ldr	r2, [r3, #0]
 810ee02:	68fb      	ldr	r3, [r7, #12]
 810ee04:	66da      	str	r2, [r3, #108]	@ 0x6c
	}
#endif /*!VIRTIO_MASTER_ONLY*/
	rvdev->shbuf_io = shm_io;
 810ee06:	68fb      	ldr	r3, [r7, #12]
 810ee08:	683a      	ldr	r2, [r7, #0]
 810ee0a:	671a      	str	r2, [r3, #112]	@ 0x70

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 810ee0c:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
 810ee0e:	2b01      	cmp	r3, #1
 810ee10:	d102      	bne.n	810ee18 <rpmsg_init_vdev+0x84>
		/* wait synchro with the master */
		rpmsg_virtio_wait_remote_ready(rvdev);
 810ee12:	68f8      	ldr	r0, [r7, #12]
 810ee14:	f7ff fdeb 	bl	810e9ee <rpmsg_virtio_wait_remote_ready>
	}
#endif /*!VIRTIO_MASTER_ONLY*/

	/* Create virtqueues for remote device */
	status = rpmsg_virtio_create_virtqueues(rvdev, 0, RPMSG_NUM_VRINGS,
 810ee18:	f107 0218 	add.w	r2, r7, #24
 810ee1c:	f107 0310 	add.w	r3, r7, #16
 810ee20:	9300      	str	r3, [sp, #0]
 810ee22:	4613      	mov	r3, r2
 810ee24:	2202      	movs	r2, #2
 810ee26:	2100      	movs	r1, #0
 810ee28:	68f8      	ldr	r0, [r7, #12]
 810ee2a:	f7ff fd17 	bl	810e85c <rpmsg_virtio_create_virtqueues>
 810ee2e:	62b8      	str	r0, [r7, #40]	@ 0x28
						vq_names, callback);
	if (status != RPMSG_SUCCESS)
 810ee30:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810ee32:	2b00      	cmp	r3, #0
 810ee34:	d001      	beq.n	810ee3a <rpmsg_init_vdev+0xa6>
		return status;
 810ee36:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810ee38:	e035      	b.n	810eea6 <rpmsg_init_vdev+0x112>

	/* TODO: can have a virtio function to set the shared memory I/O */
	for (i = 0; i < RPMSG_NUM_VRINGS; i++) {
 810ee3a:	2300      	movs	r3, #0
 810ee3c:	637b      	str	r3, [r7, #52]	@ 0x34
 810ee3e:	e00f      	b.n	810ee60 <rpmsg_init_vdev+0xcc>
		struct virtqueue *vq;

		vq = vdev->vrings_info[i].vq;
 810ee40:	68bb      	ldr	r3, [r7, #8]
 810ee42:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 810ee44:	6b7a      	ldr	r2, [r7, #52]	@ 0x34
 810ee46:	4613      	mov	r3, r2
 810ee48:	005b      	lsls	r3, r3, #1
 810ee4a:	4413      	add	r3, r2
 810ee4c:	00db      	lsls	r3, r3, #3
 810ee4e:	440b      	add	r3, r1
 810ee50:	681b      	ldr	r3, [r3, #0]
 810ee52:	623b      	str	r3, [r7, #32]
		vq->shm_io = shm_io;
 810ee54:	6a3b      	ldr	r3, [r7, #32]
 810ee56:	683a      	ldr	r2, [r7, #0]
 810ee58:	62da      	str	r2, [r3, #44]	@ 0x2c
	for (i = 0; i < RPMSG_NUM_VRINGS; i++) {
 810ee5a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810ee5c:	3301      	adds	r3, #1
 810ee5e:	637b      	str	r3, [r7, #52]	@ 0x34
 810ee60:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
 810ee62:	2b01      	cmp	r3, #1
 810ee64:	d9ec      	bls.n	810ee40 <rpmsg_init_vdev+0xac>
		}
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

	/* Initialize channels and endpoints list */
	metal_list_init(&rdev->endpoints);
 810ee66:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810ee68:	4618      	mov	r0, r3
 810ee6a:	f7ff fc0a 	bl	810e682 <metal_list_init>

	dev_features = rpmsg_virtio_get_features(rvdev);
 810ee6e:	68f8      	ldr	r0, [r7, #12]
 810ee70:	f7ff fce3 	bl	810e83a <rpmsg_virtio_get_features>
 810ee74:	6278      	str	r0, [r7, #36]	@ 0x24

	/*
	 * Create name service announcement endpoint if device supports name
	 * service announcement feature.
	 */
	if ((dev_features & (1 << VIRTIO_RPMSG_F_NS))) {
 810ee76:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810ee78:	f003 0301 	and.w	r3, r3, #1
 810ee7c:	2b00      	cmp	r3, #0
 810ee7e:	d011      	beq.n	810eea4 <rpmsg_init_vdev+0x110>
		rpmsg_init_ept(&rdev->ns_ept, "NS",
 810ee80:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810ee82:	f103 0008 	add.w	r0, r3, #8
 810ee86:	2300      	movs	r3, #0
 810ee88:	9301      	str	r3, [sp, #4]
 810ee8a:	4b0e      	ldr	r3, [pc, #56]	@ (810eec4 <rpmsg_init_vdev+0x130>)
 810ee8c:	9300      	str	r3, [sp, #0]
 810ee8e:	2335      	movs	r3, #53	@ 0x35
 810ee90:	2235      	movs	r2, #53	@ 0x35
 810ee92:	490d      	ldr	r1, [pc, #52]	@ (810eec8 <rpmsg_init_vdev+0x134>)
 810ee94:	f7ff fc83 	bl	810e79e <rpmsg_init_ept>
			       RPMSG_NS_EPT_ADDR, RPMSG_NS_EPT_ADDR,
			       rpmsg_virtio_ns_callback, NULL);
		(void)rpmsg_register_endpoint(rdev, &rdev->ns_ept);
 810ee98:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
 810ee9a:	3308      	adds	r3, #8
 810ee9c:	4619      	mov	r1, r3
 810ee9e:	6b38      	ldr	r0, [r7, #48]	@ 0x30
 810eea0:	f7ff fb2c 	bl	810e4fc <rpmsg_register_endpoint>
#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER)
		rpmsg_virtio_set_status(rvdev, VIRTIO_CONFIG_STATUS_DRIVER_OK);
#endif /*!VIRTIO_SLAVE_ONLY*/

	return status;
 810eea4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
}
 810eea6:	4618      	mov	r0, r3
 810eea8:	3738      	adds	r7, #56	@ 0x38
 810eeaa:	46bd      	mov	sp, r7
 810eeac:	bd80      	pop	{r7, pc}
 810eeae:	bf00      	nop
 810eeb0:	0810ea5d 	.word	0x0810ea5d
 810eeb4:	08110a54 	.word	0x08110a54
 810eeb8:	08110a5c 	.word	0x08110a5c
 810eebc:	0810ebb1 	.word	0x0810ebb1
 810eec0:	0810ebc5 	.word	0x0810ebc5
 810eec4:	0810ecb1 	.word	0x0810ecb1
 810eec8:	08110a64 	.word	0x08110a64

0810eecc <metal_machine_cache_flush>:
{
  return 0;
}

void metal_machine_cache_flush(void *addr, unsigned int len)
{
 810eecc:	b480      	push	{r7}
 810eece:	b083      	sub	sp, #12
 810eed0:	af00      	add	r7, sp, #0
 810eed2:	6078      	str	r0, [r7, #4]
 810eed4:	6039      	str	r1, [r7, #0]
	(void)addr;
	(void)len;
}
 810eed6:	bf00      	nop
 810eed8:	370c      	adds	r7, #12
 810eeda:	46bd      	mov	sp, r7
 810eedc:	f85d 7b04 	ldr.w	r7, [sp], #4
 810eee0:	4770      	bx	lr

0810eee2 <metal_machine_cache_invalidate>:

void metal_machine_cache_invalidate(void *addr, unsigned int len)
{
 810eee2:	b480      	push	{r7}
 810eee4:	b083      	sub	sp, #12
 810eee6:	af00      	add	r7, sp, #0
 810eee8:	6078      	str	r0, [r7, #4]
 810eeea:	6039      	str	r1, [r7, #0]
	(void)addr;
	(void)len;
}
 810eeec:	bf00      	nop
 810eeee:	370c      	adds	r7, #12
 810eef0:	46bd      	mov	sp, r7
 810eef2:	f85d 7b04 	ldr.w	r7, [sp], #4
 810eef6:	4770      	bx	lr

0810eef8 <metal_machine_io_mem_map>:
{
}

void *metal_machine_io_mem_map(void *va, metal_phys_addr_t pa,
			       size_t size, unsigned int flags)
{
 810eef8:	b480      	push	{r7}
 810eefa:	b085      	sub	sp, #20
 810eefc:	af00      	add	r7, sp, #0
 810eefe:	60f8      	str	r0, [r7, #12]
 810ef00:	60b9      	str	r1, [r7, #8]
 810ef02:	607a      	str	r2, [r7, #4]
 810ef04:	603b      	str	r3, [r7, #0]
	(void)va;
	(void)pa;
	(void)size;
	(void)flags;

	return va;
 810ef06:	68fb      	ldr	r3, [r7, #12]
}
 810ef08:	4618      	mov	r0, r3
 810ef0a:	3714      	adds	r7, #20
 810ef0c:	46bd      	mov	sp, r7
 810ef0e:	f85d 7b04 	ldr.w	r7, [sp], #4
 810ef12:	4770      	bx	lr

0810ef14 <virtio_create_virtqueues>:
}

int virtio_create_virtqueues(struct virtio_device *vdev, unsigned int flags,
			     unsigned int nvqs, const char *names[],
			     vq_callback *callbacks[])
{
 810ef14:	b590      	push	{r4, r7, lr}
 810ef16:	b08f      	sub	sp, #60	@ 0x3c
 810ef18:	af04      	add	r7, sp, #16
 810ef1a:	60f8      	str	r0, [r7, #12]
 810ef1c:	60b9      	str	r1, [r7, #8]
 810ef1e:	607a      	str	r2, [r7, #4]
 810ef20:	603b      	str	r3, [r7, #0]
	struct vring_alloc_info *vring_alloc;
	unsigned int num_vrings, i;
	int ret;
	(void)flags;

	num_vrings = vdev->vrings_num;
 810ef22:	68fb      	ldr	r3, [r7, #12]
 810ef24:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
 810ef26:	623b      	str	r3, [r7, #32]
	if (nvqs > num_vrings)
 810ef28:	687a      	ldr	r2, [r7, #4]
 810ef2a:	6a3b      	ldr	r3, [r7, #32]
 810ef2c:	429a      	cmp	r2, r3
 810ef2e:	d902      	bls.n	810ef36 <virtio_create_virtqueues+0x22>
		return -ERROR_VQUEUE_INVLD_PARAM;
 810ef30:	f44f 633c 	mov.w	r3, #3008	@ 0xbc0
 810ef34:	e036      	b.n	810efa4 <virtio_create_virtqueues+0x90>
	/* Initialize virtqueue for each vring */
	for (i = 0; i < nvqs; i++) {
 810ef36:	2300      	movs	r3, #0
 810ef38:	627b      	str	r3, [r7, #36]	@ 0x24
 810ef3a:	e02e      	b.n	810ef9a <virtio_create_virtqueues+0x86>
		vring_info = &vdev->vrings_info[i];
 810ef3c:	68fb      	ldr	r3, [r7, #12]
 810ef3e:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 810ef40:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 810ef42:	4613      	mov	r3, r2
 810ef44:	005b      	lsls	r3, r3, #1
 810ef46:	4413      	add	r3, r2
 810ef48:	00db      	lsls	r3, r3, #3
 810ef4a:	440b      	add	r3, r1
 810ef4c:	61fb      	str	r3, [r7, #28]

		vring_alloc = &vring_info->info;
 810ef4e:	69fb      	ldr	r3, [r7, #28]
 810ef50:	3304      	adds	r3, #4
 810ef52:	61bb      	str	r3, [r7, #24]
			metal_io_block_set(io, offset, 0,
					   vring_size(vring_alloc->num_descs,
						      vring_alloc->align));
		}
#endif
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
 810ef54:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810ef56:	b298      	uxth	r0, r3
 810ef58:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810ef5a:	009b      	lsls	r3, r3, #2
 810ef5c:	683a      	ldr	r2, [r7, #0]
 810ef5e:	4413      	add	r3, r2
 810ef60:	681c      	ldr	r4, [r3, #0]
				       callbacks[i], vdev->func->notify,
 810ef62:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810ef64:	009b      	lsls	r3, r3, #2
 810ef66:	6bba      	ldr	r2, [r7, #56]	@ 0x38
 810ef68:	4413      	add	r3, r2
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
 810ef6a:	681b      	ldr	r3, [r3, #0]
				       callbacks[i], vdev->func->notify,
 810ef6c:	68fa      	ldr	r2, [r7, #12]
 810ef6e:	6a12      	ldr	r2, [r2, #32]
 810ef70:	6a12      	ldr	r2, [r2, #32]
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
 810ef72:	69f9      	ldr	r1, [r7, #28]
 810ef74:	6809      	ldr	r1, [r1, #0]
 810ef76:	9102      	str	r1, [sp, #8]
 810ef78:	9201      	str	r2, [sp, #4]
 810ef7a:	9300      	str	r3, [sp, #0]
 810ef7c:	69bb      	ldr	r3, [r7, #24]
 810ef7e:	4622      	mov	r2, r4
 810ef80:	4601      	mov	r1, r0
 810ef82:	68f8      	ldr	r0, [r7, #12]
 810ef84:	f000 f8f6 	bl	810f174 <virtqueue_create>
 810ef88:	6178      	str	r0, [r7, #20]
				       vring_info->vq);
		if (ret)
 810ef8a:	697b      	ldr	r3, [r7, #20]
 810ef8c:	2b00      	cmp	r3, #0
 810ef8e:	d001      	beq.n	810ef94 <virtio_create_virtqueues+0x80>
			return ret;
 810ef90:	697b      	ldr	r3, [r7, #20]
 810ef92:	e007      	b.n	810efa4 <virtio_create_virtqueues+0x90>
	for (i = 0; i < nvqs; i++) {
 810ef94:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
 810ef96:	3301      	adds	r3, #1
 810ef98:	627b      	str	r3, [r7, #36]	@ 0x24
 810ef9a:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 810ef9c:	687b      	ldr	r3, [r7, #4]
 810ef9e:	429a      	cmp	r2, r3
 810efa0:	d3cc      	bcc.n	810ef3c <virtio_create_virtqueues+0x28>
	}
	return 0;
 810efa2:	2300      	movs	r3, #0
}
 810efa4:	4618      	mov	r0, r3
 810efa6:	372c      	adds	r7, #44	@ 0x2c
 810efa8:	46bd      	mov	sp, r7
 810efaa:	bd90      	pop	{r4, r7, pc}

0810efac <vring_init>:
	return size;
}

static inline void
vring_init(struct vring *vr, unsigned int num, uint8_t *p, unsigned long align)
{
 810efac:	b480      	push	{r7}
 810efae:	b085      	sub	sp, #20
 810efb0:	af00      	add	r7, sp, #0
 810efb2:	60f8      	str	r0, [r7, #12]
 810efb4:	60b9      	str	r1, [r7, #8]
 810efb6:	607a      	str	r2, [r7, #4]
 810efb8:	603b      	str	r3, [r7, #0]
	vr->num = num;
 810efba:	68fb      	ldr	r3, [r7, #12]
 810efbc:	68ba      	ldr	r2, [r7, #8]
 810efbe:	601a      	str	r2, [r3, #0]
	vr->desc = (struct vring_desc *)p;
 810efc0:	68fb      	ldr	r3, [r7, #12]
 810efc2:	687a      	ldr	r2, [r7, #4]
 810efc4:	605a      	str	r2, [r3, #4]
	vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
 810efc6:	68bb      	ldr	r3, [r7, #8]
 810efc8:	011b      	lsls	r3, r3, #4
 810efca:	687a      	ldr	r2, [r7, #4]
 810efcc:	441a      	add	r2, r3
 810efce:	68fb      	ldr	r3, [r7, #12]
 810efd0:	609a      	str	r2, [r3, #8]
	vr->used = (struct vring_used *)
	    (((unsigned long)&vr->avail->ring[num] + sizeof(uint16_t) +
 810efd2:	68fb      	ldr	r3, [r7, #12]
 810efd4:	689a      	ldr	r2, [r3, #8]
 810efd6:	68bb      	ldr	r3, [r7, #8]
 810efd8:	005b      	lsls	r3, r3, #1
 810efda:	4413      	add	r3, r2
 810efdc:	3304      	adds	r3, #4
 810efde:	461a      	mov	r2, r3
 810efe0:	683b      	ldr	r3, [r7, #0]
 810efe2:	4413      	add	r3, r2
	      align - 1) & ~(align - 1));
 810efe4:	1c5a      	adds	r2, r3, #1
 810efe6:	683b      	ldr	r3, [r7, #0]
 810efe8:	425b      	negs	r3, r3
 810efea:	4013      	ands	r3, r2
	vr->used = (struct vring_used *)
 810efec:	461a      	mov	r2, r3
 810efee:	68fb      	ldr	r3, [r7, #12]
 810eff0:	60da      	str	r2, [r3, #12]
}
 810eff2:	bf00      	nop
 810eff4:	3714      	adds	r7, #20
 810eff6:	46bd      	mov	sp, r7
 810eff8:	f85d 7b04 	ldr.w	r7, [sp], #4
 810effc:	4770      	bx	lr

0810effe <vring_need_event>:
 * just incremented index from old to new_idx, should we trigger an
 * event?
 */
static inline int
vring_need_event(uint16_t event_idx, uint16_t new_idx, uint16_t old)
{
 810effe:	b480      	push	{r7}
 810f000:	b083      	sub	sp, #12
 810f002:	af00      	add	r7, sp, #0
 810f004:	4603      	mov	r3, r0
 810f006:	80fb      	strh	r3, [r7, #6]
 810f008:	460b      	mov	r3, r1
 810f00a:	80bb      	strh	r3, [r7, #4]
 810f00c:	4613      	mov	r3, r2
 810f00e:	807b      	strh	r3, [r7, #2]
	return (uint16_t)(new_idx - event_idx - 1) <
 810f010:	88ba      	ldrh	r2, [r7, #4]
 810f012:	88fb      	ldrh	r3, [r7, #6]
 810f014:	1ad3      	subs	r3, r2, r3
 810f016:	b29b      	uxth	r3, r3
 810f018:	3b01      	subs	r3, #1
 810f01a:	b29a      	uxth	r2, r3
	    (uint16_t)(new_idx - old);
 810f01c:	88b9      	ldrh	r1, [r7, #4]
 810f01e:	887b      	ldrh	r3, [r7, #2]
 810f020:	1acb      	subs	r3, r1, r3
 810f022:	b29b      	uxth	r3, r3
	return (uint16_t)(new_idx - event_idx - 1) <
 810f024:	429a      	cmp	r2, r3
 810f026:	bf34      	ite	cc
 810f028:	2301      	movcc	r3, #1
 810f02a:	2300      	movcs	r3, #0
 810f02c:	b2db      	uxtb	r3, r3
}
 810f02e:	4618      	mov	r0, r3
 810f030:	370c      	adds	r7, #12
 810f032:	46bd      	mov	sp, r7
 810f034:	f85d 7b04 	ldr.w	r7, [sp], #4
 810f038:	4770      	bx	lr

0810f03a <metal_io_virt>:
{
 810f03a:	b480      	push	{r7}
 810f03c:	b083      	sub	sp, #12
 810f03e:	af00      	add	r7, sp, #0
 810f040:	6078      	str	r0, [r7, #4]
 810f042:	6039      	str	r1, [r7, #0]
	return (io->virt != METAL_BAD_VA && offset <= io->size
 810f044:	687b      	ldr	r3, [r7, #4]
 810f046:	681b      	ldr	r3, [r3, #0]
		: NULL);
 810f048:	f1b3 3fff 	cmp.w	r3, #4294967295
 810f04c:	d009      	beq.n	810f062 <metal_io_virt+0x28>
	return (io->virt != METAL_BAD_VA && offset <= io->size
 810f04e:	687b      	ldr	r3, [r7, #4]
 810f050:	689b      	ldr	r3, [r3, #8]
 810f052:	683a      	ldr	r2, [r7, #0]
 810f054:	429a      	cmp	r2, r3
 810f056:	d804      	bhi.n	810f062 <metal_io_virt+0x28>
		? (uint8_t *)io->virt + offset
 810f058:	687b      	ldr	r3, [r7, #4]
 810f05a:	681a      	ldr	r2, [r3, #0]
		: NULL);
 810f05c:	683b      	ldr	r3, [r7, #0]
 810f05e:	4413      	add	r3, r2
 810f060:	e000      	b.n	810f064 <metal_io_virt+0x2a>
 810f062:	2300      	movs	r3, #0
}
 810f064:	4618      	mov	r0, r3
 810f066:	370c      	adds	r7, #12
 810f068:	46bd      	mov	sp, r7
 810f06a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810f06e:	4770      	bx	lr

0810f070 <metal_io_phys>:
{
 810f070:	b480      	push	{r7}
 810f072:	b085      	sub	sp, #20
 810f074:	af00      	add	r7, sp, #0
 810f076:	6078      	str	r0, [r7, #4]
 810f078:	6039      	str	r1, [r7, #0]
	unsigned long page = (io->page_shift >=
 810f07a:	687b      	ldr	r3, [r7, #4]
 810f07c:	68db      	ldr	r3, [r3, #12]
			     0 : offset >> io->page_shift);
 810f07e:	2b1f      	cmp	r3, #31
 810f080:	d805      	bhi.n	810f08e <metal_io_phys+0x1e>
 810f082:	687b      	ldr	r3, [r7, #4]
 810f084:	68db      	ldr	r3, [r3, #12]
 810f086:	683a      	ldr	r2, [r7, #0]
 810f088:	fa22 f303 	lsr.w	r3, r2, r3
 810f08c:	e000      	b.n	810f090 <metal_io_phys+0x20>
 810f08e:	2300      	movs	r3, #0
	unsigned long page = (io->page_shift >=
 810f090:	60fb      	str	r3, [r7, #12]
	return (io->physmap != NULL && offset <= io->size
 810f092:	687b      	ldr	r3, [r7, #4]
 810f094:	685b      	ldr	r3, [r3, #4]
		: METAL_BAD_PHYS);
 810f096:	2b00      	cmp	r3, #0
 810f098:	d010      	beq.n	810f0bc <metal_io_phys+0x4c>
	return (io->physmap != NULL && offset <= io->size
 810f09a:	687b      	ldr	r3, [r7, #4]
 810f09c:	689b      	ldr	r3, [r3, #8]
 810f09e:	683a      	ldr	r2, [r7, #0]
 810f0a0:	429a      	cmp	r2, r3
 810f0a2:	d80b      	bhi.n	810f0bc <metal_io_phys+0x4c>
		? io->physmap[page] + (offset & io->page_mask)
 810f0a4:	687b      	ldr	r3, [r7, #4]
 810f0a6:	685a      	ldr	r2, [r3, #4]
 810f0a8:	68fb      	ldr	r3, [r7, #12]
 810f0aa:	009b      	lsls	r3, r3, #2
 810f0ac:	4413      	add	r3, r2
 810f0ae:	681a      	ldr	r2, [r3, #0]
 810f0b0:	687b      	ldr	r3, [r7, #4]
 810f0b2:	6919      	ldr	r1, [r3, #16]
 810f0b4:	683b      	ldr	r3, [r7, #0]
 810f0b6:	400b      	ands	r3, r1
		: METAL_BAD_PHYS);
 810f0b8:	4413      	add	r3, r2
 810f0ba:	e001      	b.n	810f0c0 <metal_io_phys+0x50>
 810f0bc:	f04f 33ff 	mov.w	r3, #4294967295
}
 810f0c0:	4618      	mov	r0, r3
 810f0c2:	3714      	adds	r7, #20
 810f0c4:	46bd      	mov	sp, r7
 810f0c6:	f85d 7b04 	ldr.w	r7, [sp], #4
 810f0ca:	4770      	bx	lr

0810f0cc <metal_io_phys_to_offset>:
{
 810f0cc:	b580      	push	{r7, lr}
 810f0ce:	b084      	sub	sp, #16
 810f0d0:	af00      	add	r7, sp, #0
 810f0d2:	6078      	str	r0, [r7, #4]
 810f0d4:	6039      	str	r1, [r7, #0]
		(io->page_mask == (metal_phys_addr_t)(-1) ?
 810f0d6:	687b      	ldr	r3, [r7, #4]
 810f0d8:	691b      	ldr	r3, [r3, #16]
		phys - io->physmap[0] :  phys & io->page_mask);
 810f0da:	f1b3 3fff 	cmp.w	r3, #4294967295
 810f0de:	d105      	bne.n	810f0ec <metal_io_phys_to_offset+0x20>
 810f0e0:	687b      	ldr	r3, [r7, #4]
 810f0e2:	685b      	ldr	r3, [r3, #4]
 810f0e4:	681b      	ldr	r3, [r3, #0]
 810f0e6:	683a      	ldr	r2, [r7, #0]
 810f0e8:	1ad3      	subs	r3, r2, r3
 810f0ea:	e003      	b.n	810f0f4 <metal_io_phys_to_offset+0x28>
 810f0ec:	687b      	ldr	r3, [r7, #4]
 810f0ee:	691a      	ldr	r2, [r3, #16]
 810f0f0:	683b      	ldr	r3, [r7, #0]
 810f0f2:	4013      	ands	r3, r2
	unsigned long offset =
 810f0f4:	60fb      	str	r3, [r7, #12]
		if (metal_io_phys(io, offset) == phys)
 810f0f6:	68f9      	ldr	r1, [r7, #12]
 810f0f8:	6878      	ldr	r0, [r7, #4]
 810f0fa:	f7ff ffb9 	bl	810f070 <metal_io_phys>
 810f0fe:	4602      	mov	r2, r0
 810f100:	683b      	ldr	r3, [r7, #0]
 810f102:	4293      	cmp	r3, r2
 810f104:	d101      	bne.n	810f10a <metal_io_phys_to_offset+0x3e>
			return offset;
 810f106:	68fb      	ldr	r3, [r7, #12]
 810f108:	e00c      	b.n	810f124 <metal_io_phys_to_offset+0x58>
		offset += io->page_mask + 1;
 810f10a:	687b      	ldr	r3, [r7, #4]
 810f10c:	691a      	ldr	r2, [r3, #16]
 810f10e:	68fb      	ldr	r3, [r7, #12]
 810f110:	4413      	add	r3, r2
 810f112:	3301      	adds	r3, #1
 810f114:	60fb      	str	r3, [r7, #12]
	} while (offset < io->size);
 810f116:	687b      	ldr	r3, [r7, #4]
 810f118:	689b      	ldr	r3, [r3, #8]
 810f11a:	68fa      	ldr	r2, [r7, #12]
 810f11c:	429a      	cmp	r2, r3
 810f11e:	d3ea      	bcc.n	810f0f6 <metal_io_phys_to_offset+0x2a>
	return METAL_BAD_OFFSET;
 810f120:	f04f 33ff 	mov.w	r3, #4294967295
}
 810f124:	4618      	mov	r0, r3
 810f126:	3710      	adds	r7, #16
 810f128:	46bd      	mov	sp, r7
 810f12a:	bd80      	pop	{r7, pc}

0810f12c <metal_io_phys_to_virt>:
{
 810f12c:	b580      	push	{r7, lr}
 810f12e:	b082      	sub	sp, #8
 810f130:	af00      	add	r7, sp, #0
 810f132:	6078      	str	r0, [r7, #4]
 810f134:	6039      	str	r1, [r7, #0]
	return metal_io_virt(io, metal_io_phys_to_offset(io, phys));
 810f136:	6839      	ldr	r1, [r7, #0]
 810f138:	6878      	ldr	r0, [r7, #4]
 810f13a:	f7ff ffc7 	bl	810f0cc <metal_io_phys_to_offset>
 810f13e:	4603      	mov	r3, r0
 810f140:	4619      	mov	r1, r3
 810f142:	6878      	ldr	r0, [r7, #4]
 810f144:	f7ff ff79 	bl	810f03a <metal_io_virt>
 810f148:	4603      	mov	r3, r0
}
 810f14a:	4618      	mov	r0, r3
 810f14c:	3708      	adds	r7, #8
 810f14e:	46bd      	mov	sp, r7
 810f150:	bd80      	pop	{r7, pc}

0810f152 <virtqueue_phys_to_virt>:
static int virtqueue_nused(struct virtqueue *vq);

/* Default implementation of P2V based on libmetal */
static inline void *virtqueue_phys_to_virt(struct virtqueue *vq,
					   metal_phys_addr_t phys)
{
 810f152:	b580      	push	{r7, lr}
 810f154:	b084      	sub	sp, #16
 810f156:	af00      	add	r7, sp, #0
 810f158:	6078      	str	r0, [r7, #4]
 810f15a:	6039      	str	r1, [r7, #0]
	struct metal_io_region *io = vq->shm_io;
 810f15c:	687b      	ldr	r3, [r7, #4]
 810f15e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 810f160:	60fb      	str	r3, [r7, #12]

	return metal_io_phys_to_virt(io, phys);
 810f162:	6839      	ldr	r1, [r7, #0]
 810f164:	68f8      	ldr	r0, [r7, #12]
 810f166:	f7ff ffe1 	bl	810f12c <metal_io_phys_to_virt>
 810f16a:	4603      	mov	r3, r0
}
 810f16c:	4618      	mov	r0, r3
 810f16e:	3710      	adds	r7, #16
 810f170:	46bd      	mov	sp, r7
 810f172:	bd80      	pop	{r7, pc}

0810f174 <virtqueue_create>:
int virtqueue_create(struct virtio_device *virt_dev, unsigned short id,
		     const char *name, struct vring_alloc_info *ring,
		     void (*callback)(struct virtqueue *vq),
		     void (*notify)(struct virtqueue *vq),
		     struct virtqueue *vq)
{
 810f174:	b580      	push	{r7, lr}
 810f176:	b086      	sub	sp, #24
 810f178:	af00      	add	r7, sp, #0
 810f17a:	60f8      	str	r0, [r7, #12]
 810f17c:	607a      	str	r2, [r7, #4]
 810f17e:	603b      	str	r3, [r7, #0]
 810f180:	460b      	mov	r3, r1
 810f182:	817b      	strh	r3, [r7, #10]
	int status = VQUEUE_SUCCESS;
 810f184:	2300      	movs	r3, #0
 810f186:	617b      	str	r3, [r7, #20]
	VQ_PARAM_CHK(ring->num_descs == 0, status, ERROR_VQUEUE_INVLD_PARAM);
	VQ_PARAM_CHK(ring->num_descs & (ring->num_descs - 1), status,
		     ERROR_VRING_ALIGN);
	VQ_PARAM_CHK(vq == NULL, status, ERROR_NO_MEM);

	if (status == VQUEUE_SUCCESS) {
 810f188:	697b      	ldr	r3, [r7, #20]
 810f18a:	2b00      	cmp	r3, #0
 810f18c:	d121      	bne.n	810f1d2 <virtqueue_create+0x5e>
		vq->vq_dev = virt_dev;
 810f18e:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810f190:	68fa      	ldr	r2, [r7, #12]
 810f192:	601a      	str	r2, [r3, #0]
		vq->vq_name =  name;
 810f194:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810f196:	687a      	ldr	r2, [r7, #4]
 810f198:	605a      	str	r2, [r3, #4]
		vq->vq_queue_index = id;
 810f19a:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810f19c:	897a      	ldrh	r2, [r7, #10]
 810f19e:	811a      	strh	r2, [r3, #8]
		vq->vq_nentries = ring->num_descs;
 810f1a0:	683b      	ldr	r3, [r7, #0]
 810f1a2:	891a      	ldrh	r2, [r3, #8]
 810f1a4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810f1a6:	815a      	strh	r2, [r3, #10]
		vq->vq_free_cnt = vq->vq_nentries;
 810f1a8:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810f1aa:	895a      	ldrh	r2, [r3, #10]
 810f1ac:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810f1ae:	851a      	strh	r2, [r3, #40]	@ 0x28
		vq->callback = callback;
 810f1b0:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810f1b2:	6a3a      	ldr	r2, [r7, #32]
 810f1b4:	611a      	str	r2, [r3, #16]
		vq->notify = notify;
 810f1b6:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 810f1b8:	6a7a      	ldr	r2, [r7, #36]	@ 0x24
 810f1ba:	615a      	str	r2, [r3, #20]

		/* Initialize vring control block in virtqueue. */
		vq_ring_init(vq, (void *)ring->vaddr, ring->align);
 810f1bc:	683b      	ldr	r3, [r7, #0]
 810f1be:	6819      	ldr	r1, [r3, #0]
 810f1c0:	683b      	ldr	r3, [r7, #0]
 810f1c2:	685b      	ldr	r3, [r3, #4]
 810f1c4:	461a      	mov	r2, r3
 810f1c6:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810f1c8:	f000 f8fb 	bl	810f3c2 <vq_ring_init>

		/* Disable callbacks - will be enabled by the application
		 * once initialization is completed.
		 */
		virtqueue_disable_cb(vq);
 810f1cc:	6ab8      	ldr	r0, [r7, #40]	@ 0x28
 810f1ce:	f000 f885 	bl	810f2dc <virtqueue_disable_cb>
	}

	return (status);
 810f1d2:	697b      	ldr	r3, [r7, #20]
}
 810f1d4:	4618      	mov	r0, r3
 810f1d6:	3718      	adds	r7, #24
 810f1d8:	46bd      	mov	sp, r7
 810f1da:	bd80      	pop	{r7, pc}

0810f1dc <virtqueue_get_available_buffer>:
 *
 * @return                          - Pointer to available buffer
 */
void *virtqueue_get_available_buffer(struct virtqueue *vq, uint16_t *avail_idx,
				     uint32_t *len)
{
 810f1dc:	b580      	push	{r7, lr}
 810f1de:	b086      	sub	sp, #24
 810f1e0:	af00      	add	r7, sp, #0
 810f1e2:	60f8      	str	r0, [r7, #12]
 810f1e4:	60b9      	str	r1, [r7, #8]
 810f1e6:	607a      	str	r2, [r7, #4]
	uint16_t head_idx = 0;
 810f1e8:	2300      	movs	r3, #0
 810f1ea:	82fb      	strh	r3, [r7, #22]
	void *buffer;

	atomic_thread_fence(memory_order_seq_cst);
 810f1ec:	f3bf 8f5b 	dmb	ish
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
 810f1f0:	68fb      	ldr	r3, [r7, #12]
 810f1f2:	8e9a      	ldrh	r2, [r3, #52]	@ 0x34
 810f1f4:	68fb      	ldr	r3, [r7, #12]
 810f1f6:	6a1b      	ldr	r3, [r3, #32]
 810f1f8:	885b      	ldrh	r3, [r3, #2]
 810f1fa:	429a      	cmp	r2, r3
 810f1fc:	d101      	bne.n	810f202 <virtqueue_get_available_buffer+0x26>
		return NULL;
 810f1fe:	2300      	movs	r3, #0
 810f200:	e02e      	b.n	810f260 <virtqueue_get_available_buffer+0x84>
	}

	VQUEUE_BUSY(vq);

	head_idx = vq->vq_available_idx++ & (vq->vq_nentries - 1);
 810f202:	68fb      	ldr	r3, [r7, #12]
 810f204:	8e9b      	ldrh	r3, [r3, #52]	@ 0x34
 810f206:	1c5a      	adds	r2, r3, #1
 810f208:	b291      	uxth	r1, r2
 810f20a:	68fa      	ldr	r2, [r7, #12]
 810f20c:	8691      	strh	r1, [r2, #52]	@ 0x34
 810f20e:	b21a      	sxth	r2, r3
 810f210:	68fb      	ldr	r3, [r7, #12]
 810f212:	895b      	ldrh	r3, [r3, #10]
 810f214:	3b01      	subs	r3, #1
 810f216:	b29b      	uxth	r3, r3
 810f218:	b21b      	sxth	r3, r3
 810f21a:	4013      	ands	r3, r2
 810f21c:	b21b      	sxth	r3, r3
 810f21e:	82fb      	strh	r3, [r7, #22]
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
 810f220:	68fb      	ldr	r3, [r7, #12]
 810f222:	6a1a      	ldr	r2, [r3, #32]
 810f224:	8afb      	ldrh	r3, [r7, #22]
 810f226:	005b      	lsls	r3, r3, #1
 810f228:	4413      	add	r3, r2
 810f22a:	889a      	ldrh	r2, [r3, #4]
 810f22c:	68bb      	ldr	r3, [r7, #8]
 810f22e:	801a      	strh	r2, [r3, #0]

	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
 810f230:	68fb      	ldr	r3, [r7, #12]
 810f232:	69da      	ldr	r2, [r3, #28]
 810f234:	68bb      	ldr	r3, [r7, #8]
 810f236:	881b      	ldrh	r3, [r3, #0]
 810f238:	011b      	lsls	r3, r3, #4
 810f23a:	4413      	add	r3, r2
 810f23c:	e9d3 2300 	ldrd	r2, r3, [r3]
 810f240:	4613      	mov	r3, r2
 810f242:	4619      	mov	r1, r3
 810f244:	68f8      	ldr	r0, [r7, #12]
 810f246:	f7ff ff84 	bl	810f152 <virtqueue_phys_to_virt>
 810f24a:	6138      	str	r0, [r7, #16]
	*len = vq->vq_ring.desc[*avail_idx].len;
 810f24c:	68fb      	ldr	r3, [r7, #12]
 810f24e:	69da      	ldr	r2, [r3, #28]
 810f250:	68bb      	ldr	r3, [r7, #8]
 810f252:	881b      	ldrh	r3, [r3, #0]
 810f254:	011b      	lsls	r3, r3, #4
 810f256:	4413      	add	r3, r2
 810f258:	689a      	ldr	r2, [r3, #8]
 810f25a:	687b      	ldr	r3, [r7, #4]
 810f25c:	601a      	str	r2, [r3, #0]

	VQUEUE_IDLE(vq);

	return buffer;
 810f25e:	693b      	ldr	r3, [r7, #16]
}
 810f260:	4618      	mov	r0, r3
 810f262:	3718      	adds	r7, #24
 810f264:	46bd      	mov	sp, r7
 810f266:	bd80      	pop	{r7, pc}

0810f268 <virtqueue_add_consumed_buffer>:
 *
 * @return                       - Function status
 */
int virtqueue_add_consumed_buffer(struct virtqueue *vq, uint16_t head_idx,
				  uint32_t len)
{
 810f268:	b480      	push	{r7}
 810f26a:	b087      	sub	sp, #28
 810f26c:	af00      	add	r7, sp, #0
 810f26e:	60f8      	str	r0, [r7, #12]
 810f270:	460b      	mov	r3, r1
 810f272:	607a      	str	r2, [r7, #4]
 810f274:	817b      	strh	r3, [r7, #10]
	struct vring_used_elem *used_desc = NULL;
 810f276:	2300      	movs	r3, #0
 810f278:	617b      	str	r3, [r7, #20]
	uint16_t used_idx;

	if (head_idx > vq->vq_nentries) {
 810f27a:	68fb      	ldr	r3, [r7, #12]
 810f27c:	895b      	ldrh	r3, [r3, #10]
 810f27e:	897a      	ldrh	r2, [r7, #10]
 810f280:	429a      	cmp	r2, r3
 810f282:	d901      	bls.n	810f288 <virtqueue_add_consumed_buffer+0x20>
		return ERROR_VRING_NO_BUFF;
 810f284:	4b14      	ldr	r3, [pc, #80]	@ (810f2d8 <virtqueue_add_consumed_buffer+0x70>)
 810f286:	e021      	b.n	810f2cc <virtqueue_add_consumed_buffer+0x64>
	}

	VQUEUE_BUSY(vq);

	used_idx = vq->vq_ring.used->idx & (vq->vq_nentries - 1);
 810f288:	68fb      	ldr	r3, [r7, #12]
 810f28a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810f28c:	885b      	ldrh	r3, [r3, #2]
 810f28e:	b21a      	sxth	r2, r3
 810f290:	68fb      	ldr	r3, [r7, #12]
 810f292:	895b      	ldrh	r3, [r3, #10]
 810f294:	3b01      	subs	r3, #1
 810f296:	b29b      	uxth	r3, r3
 810f298:	b21b      	sxth	r3, r3
 810f29a:	4013      	ands	r3, r2
 810f29c:	b21b      	sxth	r3, r3
 810f29e:	827b      	strh	r3, [r7, #18]
	used_desc = &vq->vq_ring.used->ring[used_idx];
 810f2a0:	68fb      	ldr	r3, [r7, #12]
 810f2a2:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 810f2a4:	8a7b      	ldrh	r3, [r7, #18]
 810f2a6:	00db      	lsls	r3, r3, #3
 810f2a8:	4413      	add	r3, r2
 810f2aa:	3304      	adds	r3, #4
 810f2ac:	617b      	str	r3, [r7, #20]
	used_desc->id = head_idx;
 810f2ae:	897a      	ldrh	r2, [r7, #10]
 810f2b0:	697b      	ldr	r3, [r7, #20]
 810f2b2:	601a      	str	r2, [r3, #0]
	used_desc->len = len;
 810f2b4:	697b      	ldr	r3, [r7, #20]
 810f2b6:	687a      	ldr	r2, [r7, #4]
 810f2b8:	605a      	str	r2, [r3, #4]

	atomic_thread_fence(memory_order_seq_cst);
 810f2ba:	f3bf 8f5b 	dmb	ish

	vq->vq_ring.used->idx++;
 810f2be:	68fb      	ldr	r3, [r7, #12]
 810f2c0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810f2c2:	885a      	ldrh	r2, [r3, #2]
 810f2c4:	3201      	adds	r2, #1
 810f2c6:	b292      	uxth	r2, r2
 810f2c8:	805a      	strh	r2, [r3, #2]

	VQUEUE_IDLE(vq);

	return VQUEUE_SUCCESS;
 810f2ca:	2300      	movs	r3, #0
}
 810f2cc:	4618      	mov	r0, r3
 810f2ce:	371c      	adds	r7, #28
 810f2d0:	46bd      	mov	sp, r7
 810f2d2:	f85d 7b04 	ldr.w	r7, [sp], #4
 810f2d6:	4770      	bx	lr
 810f2d8:	fffff441 	.word	0xfffff441

0810f2dc <virtqueue_disable_cb>:
 *
 * @param vq           - Pointer to VirtIO queue control block
 *
 */
void virtqueue_disable_cb(struct virtqueue *vq)
{
 810f2dc:	b480      	push	{r7}
 810f2de:	b083      	sub	sp, #12
 810f2e0:	af00      	add	r7, sp, #0
 810f2e2:	6078      	str	r0, [r7, #4]
	VQUEUE_BUSY(vq);

	if (vq->vq_flags & VIRTQUEUE_FLAG_EVENT_IDX) {
 810f2e4:	687b      	ldr	r3, [r7, #4]
 810f2e6:	68db      	ldr	r3, [r3, #12]
 810f2e8:	f003 0302 	and.w	r3, r3, #2
 810f2ec:	2b00      	cmp	r3, #0
 810f2ee:	d010      	beq.n	810f312 <virtqueue_disable_cb+0x36>
		vring_used_event(&vq->vq_ring) =
		    vq->vq_used_cons_idx - vq->vq_nentries - 1;
 810f2f0:	687b      	ldr	r3, [r7, #4]
 810f2f2:	8e5a      	ldrh	r2, [r3, #50]	@ 0x32
 810f2f4:	687b      	ldr	r3, [r7, #4]
 810f2f6:	895b      	ldrh	r3, [r3, #10]
 810f2f8:	1ad3      	subs	r3, r2, r3
 810f2fa:	b299      	uxth	r1, r3
		vring_used_event(&vq->vq_ring) =
 810f2fc:	687b      	ldr	r3, [r7, #4]
 810f2fe:	6a1a      	ldr	r2, [r3, #32]
 810f300:	687b      	ldr	r3, [r7, #4]
 810f302:	699b      	ldr	r3, [r3, #24]
		    vq->vq_used_cons_idx - vq->vq_nentries - 1;
 810f304:	3901      	subs	r1, #1
 810f306:	b289      	uxth	r1, r1
		vring_used_event(&vq->vq_ring) =
 810f308:	005b      	lsls	r3, r3, #1
 810f30a:	4413      	add	r3, r2
 810f30c:	460a      	mov	r2, r1
 810f30e:	809a      	strh	r2, [r3, #4]
	} else {
		vq->vq_ring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
	}

	VQUEUE_IDLE(vq);
}
 810f310:	e008      	b.n	810f324 <virtqueue_disable_cb+0x48>
		vq->vq_ring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
 810f312:	687b      	ldr	r3, [r7, #4]
 810f314:	6a1b      	ldr	r3, [r3, #32]
 810f316:	881a      	ldrh	r2, [r3, #0]
 810f318:	687b      	ldr	r3, [r7, #4]
 810f31a:	6a1b      	ldr	r3, [r3, #32]
 810f31c:	f042 0201 	orr.w	r2, r2, #1
 810f320:	b292      	uxth	r2, r2
 810f322:	801a      	strh	r2, [r3, #0]
}
 810f324:	bf00      	nop
 810f326:	370c      	adds	r7, #12
 810f328:	46bd      	mov	sp, r7
 810f32a:	f85d 7b04 	ldr.w	r7, [sp], #4
 810f32e:	4770      	bx	lr

0810f330 <virtqueue_kick>:
 * virtqueue_kick - Notifies other side that there is buffer available for it.
 *
 * @param vq      - Pointer to VirtIO queue control block
 */
void virtqueue_kick(struct virtqueue *vq)
{
 810f330:	b580      	push	{r7, lr}
 810f332:	b082      	sub	sp, #8
 810f334:	af00      	add	r7, sp, #0
 810f336:	6078      	str	r0, [r7, #4]
	VQUEUE_BUSY(vq);

	/* Ensure updated avail->idx is visible to host. */
	atomic_thread_fence(memory_order_seq_cst);
 810f338:	f3bf 8f5b 	dmb	ish

	if (vq_ring_must_notify_host(vq))
 810f33c:	6878      	ldr	r0, [r7, #4]
 810f33e:	f000 f885 	bl	810f44c <vq_ring_must_notify_host>
 810f342:	4603      	mov	r3, r0
 810f344:	2b00      	cmp	r3, #0
 810f346:	d002      	beq.n	810f34e <virtqueue_kick+0x1e>
		vq_ring_notify_host(vq);
 810f348:	6878      	ldr	r0, [r7, #4]
 810f34a:	f000 f8b5 	bl	810f4b8 <vq_ring_notify_host>

	vq->vq_queued_cnt = 0;
 810f34e:	687b      	ldr	r3, [r7, #4]
 810f350:	2200      	movs	r2, #0
 810f352:	855a      	strh	r2, [r3, #42]	@ 0x2a

	VQUEUE_IDLE(vq);
}
 810f354:	bf00      	nop
 810f356:	3708      	adds	r7, #8
 810f358:	46bd      	mov	sp, r7
 810f35a:	bd80      	pop	{r7, pc}

0810f35c <virtqueue_get_desc_size>:
 * @param vq            - Pointer to VirtIO queue control block
 *
 * @return              - Descriptor length
 */
uint32_t virtqueue_get_desc_size(struct virtqueue *vq)
{
 810f35c:	b480      	push	{r7}
 810f35e:	b085      	sub	sp, #20
 810f360:	af00      	add	r7, sp, #0
 810f362:	6078      	str	r0, [r7, #4]
	uint16_t head_idx = 0;
 810f364:	2300      	movs	r3, #0
 810f366:	81fb      	strh	r3, [r7, #14]
	uint16_t avail_idx = 0;
 810f368:	2300      	movs	r3, #0
 810f36a:	81bb      	strh	r3, [r7, #12]
	uint32_t len = 0;
 810f36c:	2300      	movs	r3, #0
 810f36e:	60bb      	str	r3, [r7, #8]

	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
 810f370:	687b      	ldr	r3, [r7, #4]
 810f372:	8e9a      	ldrh	r2, [r3, #52]	@ 0x34
 810f374:	687b      	ldr	r3, [r7, #4]
 810f376:	6a1b      	ldr	r3, [r3, #32]
 810f378:	885b      	ldrh	r3, [r3, #2]
 810f37a:	429a      	cmp	r2, r3
 810f37c:	d101      	bne.n	810f382 <virtqueue_get_desc_size+0x26>
		return 0;
 810f37e:	2300      	movs	r3, #0
 810f380:	e019      	b.n	810f3b6 <virtqueue_get_desc_size+0x5a>
	}

	VQUEUE_BUSY(vq);

	head_idx = vq->vq_available_idx & (vq->vq_nentries - 1);
 810f382:	687b      	ldr	r3, [r7, #4]
 810f384:	8e9b      	ldrh	r3, [r3, #52]	@ 0x34
 810f386:	b21a      	sxth	r2, r3
 810f388:	687b      	ldr	r3, [r7, #4]
 810f38a:	895b      	ldrh	r3, [r3, #10]
 810f38c:	3b01      	subs	r3, #1
 810f38e:	b29b      	uxth	r3, r3
 810f390:	b21b      	sxth	r3, r3
 810f392:	4013      	ands	r3, r2
 810f394:	b21b      	sxth	r3, r3
 810f396:	81fb      	strh	r3, [r7, #14]
	avail_idx = vq->vq_ring.avail->ring[head_idx];
 810f398:	687b      	ldr	r3, [r7, #4]
 810f39a:	6a1a      	ldr	r2, [r3, #32]
 810f39c:	89fb      	ldrh	r3, [r7, #14]
 810f39e:	005b      	lsls	r3, r3, #1
 810f3a0:	4413      	add	r3, r2
 810f3a2:	889b      	ldrh	r3, [r3, #4]
 810f3a4:	81bb      	strh	r3, [r7, #12]
	len = vq->vq_ring.desc[avail_idx].len;
 810f3a6:	687b      	ldr	r3, [r7, #4]
 810f3a8:	69da      	ldr	r2, [r3, #28]
 810f3aa:	89bb      	ldrh	r3, [r7, #12]
 810f3ac:	011b      	lsls	r3, r3, #4
 810f3ae:	4413      	add	r3, r2
 810f3b0:	689b      	ldr	r3, [r3, #8]
 810f3b2:	60bb      	str	r3, [r7, #8]

	VQUEUE_IDLE(vq);

	return len;
 810f3b4:	68bb      	ldr	r3, [r7, #8]
}
 810f3b6:	4618      	mov	r0, r3
 810f3b8:	3714      	adds	r7, #20
 810f3ba:	46bd      	mov	sp, r7
 810f3bc:	f85d 7b04 	ldr.w	r7, [sp], #4
 810f3c0:	4770      	bx	lr

0810f3c2 <vq_ring_init>:
 *
 * vq_ring_init
 *
 */
static void vq_ring_init(struct virtqueue *vq, void *ring_mem, int alignment)
{
 810f3c2:	b580      	push	{r7, lr}
 810f3c4:	b088      	sub	sp, #32
 810f3c6:	af00      	add	r7, sp, #0
 810f3c8:	60f8      	str	r0, [r7, #12]
 810f3ca:	60b9      	str	r1, [r7, #8]
 810f3cc:	607a      	str	r2, [r7, #4]
	struct vring *vr;
	int i, size;

	size = vq->vq_nentries;
 810f3ce:	68fb      	ldr	r3, [r7, #12]
 810f3d0:	895b      	ldrh	r3, [r3, #10]
 810f3d2:	61bb      	str	r3, [r7, #24]
	vr = &vq->vq_ring;
 810f3d4:	68fb      	ldr	r3, [r7, #12]
 810f3d6:	3318      	adds	r3, #24
 810f3d8:	617b      	str	r3, [r7, #20]

	vring_init(vr, size, (unsigned char *)ring_mem, alignment);
 810f3da:	69b9      	ldr	r1, [r7, #24]
 810f3dc:	687b      	ldr	r3, [r7, #4]
 810f3de:	68ba      	ldr	r2, [r7, #8]
 810f3e0:	6978      	ldr	r0, [r7, #20]
 810f3e2:	f7ff fde3 	bl	810efac <vring_init>

	for (i = 0; i < size - 1; i++)
 810f3e6:	2300      	movs	r3, #0
 810f3e8:	61fb      	str	r3, [r7, #28]
 810f3ea:	e00c      	b.n	810f406 <vq_ring_init+0x44>
		vr->desc[i].next = i + 1;
 810f3ec:	69fb      	ldr	r3, [r7, #28]
 810f3ee:	b29a      	uxth	r2, r3
 810f3f0:	697b      	ldr	r3, [r7, #20]
 810f3f2:	6859      	ldr	r1, [r3, #4]
 810f3f4:	69fb      	ldr	r3, [r7, #28]
 810f3f6:	011b      	lsls	r3, r3, #4
 810f3f8:	440b      	add	r3, r1
 810f3fa:	3201      	adds	r2, #1
 810f3fc:	b292      	uxth	r2, r2
 810f3fe:	81da      	strh	r2, [r3, #14]
	for (i = 0; i < size - 1; i++)
 810f400:	69fb      	ldr	r3, [r7, #28]
 810f402:	3301      	adds	r3, #1
 810f404:	61fb      	str	r3, [r7, #28]
 810f406:	69bb      	ldr	r3, [r7, #24]
 810f408:	3b01      	subs	r3, #1
 810f40a:	69fa      	ldr	r2, [r7, #28]
 810f40c:	429a      	cmp	r2, r3
 810f40e:	dbed      	blt.n	810f3ec <vq_ring_init+0x2a>
	vr->desc[i].next = VQ_RING_DESC_CHAIN_END;
 810f410:	697b      	ldr	r3, [r7, #20]
 810f412:	685a      	ldr	r2, [r3, #4]
 810f414:	69fb      	ldr	r3, [r7, #28]
 810f416:	011b      	lsls	r3, r3, #4
 810f418:	4413      	add	r3, r2
 810f41a:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
 810f41e:	81da      	strh	r2, [r3, #14]
}
 810f420:	bf00      	nop
 810f422:	3720      	adds	r7, #32
 810f424:	46bd      	mov	sp, r7
 810f426:	bd80      	pop	{r7, pc}

0810f428 <virtqueue_notification>:
 *
 * virtqueue_interrupt
 *
 */
void virtqueue_notification(struct virtqueue *vq)
{
 810f428:	b580      	push	{r7, lr}
 810f42a:	b082      	sub	sp, #8
 810f42c:	af00      	add	r7, sp, #0
 810f42e:	6078      	str	r0, [r7, #4]
	atomic_thread_fence(memory_order_seq_cst);
 810f430:	f3bf 8f5b 	dmb	ish
	if (vq->callback)
 810f434:	687b      	ldr	r3, [r7, #4]
 810f436:	691b      	ldr	r3, [r3, #16]
 810f438:	2b00      	cmp	r3, #0
 810f43a:	d003      	beq.n	810f444 <virtqueue_notification+0x1c>
		vq->callback(vq);
 810f43c:	687b      	ldr	r3, [r7, #4]
 810f43e:	691b      	ldr	r3, [r3, #16]
 810f440:	6878      	ldr	r0, [r7, #4]
 810f442:	4798      	blx	r3
}
 810f444:	bf00      	nop
 810f446:	3708      	adds	r7, #8
 810f448:	46bd      	mov	sp, r7
 810f44a:	bd80      	pop	{r7, pc}

0810f44c <vq_ring_must_notify_host>:
 *
 * vq_ring_must_notify_host
 *
 */
static int vq_ring_must_notify_host(struct virtqueue *vq)
{
 810f44c:	b580      	push	{r7, lr}
 810f44e:	b084      	sub	sp, #16
 810f450:	af00      	add	r7, sp, #0
 810f452:	6078      	str	r0, [r7, #4]
	uint16_t new_idx, prev_idx, event_idx;

	if (vq->vq_flags & VIRTQUEUE_FLAG_EVENT_IDX) {
 810f454:	687b      	ldr	r3, [r7, #4]
 810f456:	68db      	ldr	r3, [r3, #12]
 810f458:	f003 0302 	and.w	r3, r3, #2
 810f45c:	2b00      	cmp	r3, #0
 810f45e:	d01d      	beq.n	810f49c <vq_ring_must_notify_host+0x50>
		new_idx = vq->vq_ring.avail->idx;
 810f460:	687b      	ldr	r3, [r7, #4]
 810f462:	6a1b      	ldr	r3, [r3, #32]
 810f464:	885b      	ldrh	r3, [r3, #2]
 810f466:	81fb      	strh	r3, [r7, #14]
		prev_idx = new_idx - vq->vq_queued_cnt;
 810f468:	687b      	ldr	r3, [r7, #4]
 810f46a:	8d5b      	ldrh	r3, [r3, #42]	@ 0x2a
 810f46c:	89fa      	ldrh	r2, [r7, #14]
 810f46e:	1ad3      	subs	r3, r2, r3
 810f470:	81bb      	strh	r3, [r7, #12]
		event_idx = vring_avail_event(&vq->vq_ring);
 810f472:	687b      	ldr	r3, [r7, #4]
 810f474:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 810f476:	687b      	ldr	r3, [r7, #4]
 810f478:	699b      	ldr	r3, [r3, #24]
 810f47a:	00db      	lsls	r3, r3, #3
 810f47c:	4413      	add	r3, r2
 810f47e:	685b      	ldr	r3, [r3, #4]
 810f480:	817b      	strh	r3, [r7, #10]

		return (vring_need_event(event_idx, new_idx, prev_idx) != 0);
 810f482:	89ba      	ldrh	r2, [r7, #12]
 810f484:	89f9      	ldrh	r1, [r7, #14]
 810f486:	897b      	ldrh	r3, [r7, #10]
 810f488:	4618      	mov	r0, r3
 810f48a:	f7ff fdb8 	bl	810effe <vring_need_event>
 810f48e:	4603      	mov	r3, r0
 810f490:	2b00      	cmp	r3, #0
 810f492:	bf14      	ite	ne
 810f494:	2301      	movne	r3, #1
 810f496:	2300      	moveq	r3, #0
 810f498:	b2db      	uxtb	r3, r3
 810f49a:	e009      	b.n	810f4b0 <vq_ring_must_notify_host+0x64>
	}

	return ((vq->vq_ring.used->flags & VRING_USED_F_NO_NOTIFY) == 0);
 810f49c:	687b      	ldr	r3, [r7, #4]
 810f49e:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 810f4a0:	881b      	ldrh	r3, [r3, #0]
 810f4a2:	f003 0301 	and.w	r3, r3, #1
 810f4a6:	2b00      	cmp	r3, #0
 810f4a8:	bf0c      	ite	eq
 810f4aa:	2301      	moveq	r3, #1
 810f4ac:	2300      	movne	r3, #0
 810f4ae:	b2db      	uxtb	r3, r3
}
 810f4b0:	4618      	mov	r0, r3
 810f4b2:	3710      	adds	r7, #16
 810f4b4:	46bd      	mov	sp, r7
 810f4b6:	bd80      	pop	{r7, pc}

0810f4b8 <vq_ring_notify_host>:
 *
 * vq_ring_notify_host
 *
 */
static void vq_ring_notify_host(struct virtqueue *vq)
{
 810f4b8:	b580      	push	{r7, lr}
 810f4ba:	b082      	sub	sp, #8
 810f4bc:	af00      	add	r7, sp, #0
 810f4be:	6078      	str	r0, [r7, #4]
	if (vq->notify)
 810f4c0:	687b      	ldr	r3, [r7, #4]
 810f4c2:	695b      	ldr	r3, [r3, #20]
 810f4c4:	2b00      	cmp	r3, #0
 810f4c6:	d003      	beq.n	810f4d0 <vq_ring_notify_host+0x18>
		vq->notify(vq);
 810f4c8:	687b      	ldr	r3, [r7, #4]
 810f4ca:	695b      	ldr	r3, [r3, #20]
 810f4cc:	6878      	ldr	r0, [r7, #4]
 810f4ce:	4798      	blx	r3
}
 810f4d0:	bf00      	nop
 810f4d2:	3708      	adds	r7, #8
 810f4d4:	46bd      	mov	sp, r7
 810f4d6:	bd80      	pop	{r7, pc}

0810f4d8 <HAL_HSEM_FreeCallback>:
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

void HAL_HSEM_FreeCallback(uint32_t SemMask)
{
 810f4d8:	b580      	push	{r7, lr}
 810f4da:	b082      	sub	sp, #8
 810f4dc:	af00      	add	r7, sp, #0
 810f4de:	6078      	str	r0, [r7, #4]

  /* USER CODE END HSEM_FREE_CALLBACK */

  /* Prevent unused argument(s) compilation warning */
  UNUSED(SemMask);
  msg_received = RX_NEW_MSG;
 810f4e0:	4b04      	ldr	r3, [pc, #16]	@ (810f4f4 <HAL_HSEM_FreeCallback+0x1c>)
 810f4e2:	2201      	movs	r2, #1
 810f4e4:	601a      	str	r2, [r3, #0]

  /* USER CODE BEGIN PRE_HSEM_FREE_CALLBACK_CM4 */

  /* USER CODE END PRE_HSEM_FREE_CALLBACK_CM4 */

  HAL_HSEM_ActivateNotification(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));
 810f4e6:	2001      	movs	r0, #1
 810f4e8:	f7f2 fcb6 	bl	8101e58 <HAL_HSEM_ActivateNotification>

  /* USER CODE BEGIN POST_HSEM_FREE_CALLBACK_CM4 */

  /* USER CODE END POST_HSEM_FREE_CALLBACK_CM4 */
#endif
}
 810f4ec:	bf00      	nop
 810f4ee:	3708      	adds	r7, #8
 810f4f0:	46bd      	mov	sp, r7
 810f4f2:	bd80      	pop	{r7, pc}
 810f4f4:	1000554c 	.word	0x1000554c

0810f4f8 <MAILBOX_Init>:
  * @brief  Initialize MAILBOX with HSEM peripheral
  * @param  None
  * @retval : Operation result
  */
int MAILBOX_Init(void)
{
 810f4f8:	b580      	push	{r7, lr}
 810f4fa:	b082      	sub	sp, #8
 810f4fc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MAILBOX_INIT */

  /* USER CODE END MAILBOX_INIT */
  __HAL_RCC_HSEM_CLK_ENABLE();
 810f4fe:	4b0b      	ldr	r3, [pc, #44]	@ (810f52c <MAILBOX_Init+0x34>)
 810f500:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810f504:	4a09      	ldr	r2, [pc, #36]	@ (810f52c <MAILBOX_Init+0x34>)
 810f506:	f043 7300 	orr.w	r3, r3, #33554432	@ 0x2000000
 810f50a:	f8c2 30e0 	str.w	r3, [r2, #224]	@ 0xe0
 810f50e:	4b07      	ldr	r3, [pc, #28]	@ (810f52c <MAILBOX_Init+0x34>)
 810f510:	f8d3 30e0 	ldr.w	r3, [r3, #224]	@ 0xe0
 810f514:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
 810f518:	607b      	str	r3, [r7, #4]
 810f51a:	687b      	ldr	r3, [r7, #4]

    /* USER CODE BEGIN MAILBOX_INIT_CM4 */

    /* USER CODE END MAILBOX_INIT_CM4 */

  HAL_HSEM_ActivateNotification(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));
 810f51c:	2001      	movs	r0, #1
 810f51e:	f7f2 fc9b 	bl	8101e58 <HAL_HSEM_ActivateNotification>
  /* USER CODE BEGIN POST_MAILBOX_INIT_CM4 */

  /* USER CODE END POST_MAILBOX_INIT_CM4 */
#endif

  return 0;
 810f522:	2300      	movs	r3, #0
}
 810f524:	4618      	mov	r0, r3
 810f526:	3708      	adds	r7, #8
 810f528:	46bd      	mov	sp, r7
 810f52a:	bd80      	pop	{r7, pc}
 810f52c:	58024400 	.word	0x58024400

0810f530 <MAILBOX_Poll>:
  * @brief  Initialize MAILBOX with HSEM peripheral
  * @param  virtio device
  * @retval : Operation result
  */
int MAILBOX_Poll(struct virtio_device *vdev)
{
 810f530:	b580      	push	{r7, lr}
 810f532:	b082      	sub	sp, #8
 810f534:	af00      	add	r7, sp, #0
 810f536:	6078      	str	r0, [r7, #4]
  /* If we got an interrupt, ask for the corresponding virtqueue processing */

  if (msg_received == RX_NEW_MSG)
 810f538:	4b09      	ldr	r3, [pc, #36]	@ (810f560 <MAILBOX_Poll+0x30>)
 810f53a:	681b      	ldr	r3, [r3, #0]
 810f53c:	2b01      	cmp	r3, #1
 810f53e:	d108      	bne.n	810f552 <MAILBOX_Poll+0x22>

    /* USER CODE BEGIN PRE_NEW_MSG_CM4 */

    /* USER CODE END PRE_NEW_MSG_CM4 */

    rproc_virtio_notified(vdev, VRING1_ID);
 810f540:	2101      	movs	r1, #1
 810f542:	6878      	ldr	r0, [r7, #4]
 810f544:	f7fe fd25 	bl	810df92 <rproc_virtio_notified>

    /* USER CODE BEGIN POST_NEW_MSG_CM4 */

    /* USER CODE END POST_NEW_MSG_CM4 */
#endif
    msg_received = RX_NO_MSG;
 810f548:	4b05      	ldr	r3, [pc, #20]	@ (810f560 <MAILBOX_Poll+0x30>)
 810f54a:	2200      	movs	r2, #0
 810f54c:	601a      	str	r2, [r3, #0]
    return 0;
 810f54e:	2300      	movs	r3, #0
 810f550:	e001      	b.n	810f556 <MAILBOX_Poll+0x26>
  }

    /* USER CODE BEGIN NO_MSG */

    /* USER CODE END NO_MSG */
  return -EAGAIN;
 810f552:	f06f 030a 	mvn.w	r3, #10
}
 810f556:	4618      	mov	r0, r3
 810f558:	3708      	adds	r7, #8
 810f55a:	46bd      	mov	sp, r7
 810f55c:	bd80      	pop	{r7, pc}
 810f55e:	bf00      	nop
 810f560:	1000554c 	.word	0x1000554c

0810f564 <MAILBOX_Notify>:
  * @brief  Callback function called by OpenAMP MW to notify message processing
  * @param  VRING id
  * @retval Operation result
  */
int MAILBOX_Notify(void *priv, uint32_t id)
{
 810f564:	b580      	push	{r7, lr}
 810f566:	b082      	sub	sp, #8
 810f568:	af00      	add	r7, sp, #0
 810f56a:	6078      	str	r0, [r7, #4]
 810f56c:	6039      	str	r1, [r7, #0]

  /* USER CODE BEGIN  PRE_MAILBOX_NOTIFY_CM4 */

  /* USER CODE END PRE_MAILBOX_NOTIFY_CM4 */

  HAL_HSEM_FastTake(HSEM_ID_1);
 810f56e:	2001      	movs	r0, #1
 810f570:	f7f2 fc44 	bl	8101dfc <HAL_HSEM_FastTake>
  HAL_HSEM_Release(HSEM_ID_1,0);
 810f574:	2100      	movs	r1, #0
 810f576:	2001      	movs	r0, #1
 810f578:	f7f2 fc5a 	bl	8101e30 <HAL_HSEM_Release>
  /* USER CODE BEGIN  POST_MAILBOX_NOTIFY_CM4 */

  /* USER CODE END POST_MAILBOX_NOTIFY_CM4 */
#endif

  return 0;
 810f57c:	2300      	movs	r3, #0
}
 810f57e:	4618      	mov	r0, r3
 810f580:	3708      	adds	r7, #8
 810f582:	46bd      	mov	sp, r7
 810f584:	bd80      	pop	{r7, pc}

0810f586 <metal_device_io_region>:
 * @param[in]	index		Region index.
 * @return I/O accessor handle, or NULL on failure.
 */
static inline struct metal_io_region *
metal_device_io_region(struct metal_device *device, unsigned index)
{
 810f586:	b480      	push	{r7}
 810f588:	b083      	sub	sp, #12
 810f58a:	af00      	add	r7, sp, #0
 810f58c:	6078      	str	r0, [r7, #4]
 810f58e:	6039      	str	r1, [r7, #0]
	return (index < device->num_regions
 810f590:	687b      	ldr	r3, [r7, #4]
 810f592:	689b      	ldr	r3, [r3, #8]
		? &device->regions[index]
		: NULL);
 810f594:	683a      	ldr	r2, [r7, #0]
 810f596:	429a      	cmp	r2, r3
 810f598:	d209      	bcs.n	810f5ae <metal_device_io_region+0x28>
 810f59a:	683a      	ldr	r2, [r7, #0]
 810f59c:	4613      	mov	r3, r2
 810f59e:	005b      	lsls	r3, r3, #1
 810f5a0:	4413      	add	r3, r2
 810f5a2:	011b      	lsls	r3, r3, #4
 810f5a4:	3308      	adds	r3, #8
 810f5a6:	687a      	ldr	r2, [r7, #4]
 810f5a8:	4413      	add	r3, r2
 810f5aa:	3304      	adds	r3, #4
 810f5ac:	e000      	b.n	810f5b0 <metal_device_io_region+0x2a>
 810f5ae:	2300      	movs	r3, #0
}
 810f5b0:	4618      	mov	r0, r3
 810f5b2:	370c      	adds	r7, #12
 810f5b4:	46bd      	mov	sp, r7
 810f5b6:	f85d 7b04 	ldr.w	r7, [sp], #4
 810f5ba:	4770      	bx	lr

0810f5bc <OPENAMP_shmem_init>:
/* USER CODE BEGIN PFP */

/* USER CODE END PFP */

static int OPENAMP_shmem_init(int RPMsgRole)
{
 810f5bc:	b590      	push	{r4, r7, lr}
 810f5be:	b08d      	sub	sp, #52	@ 0x34
 810f5c0:	af04      	add	r7, sp, #16
 810f5c2:	6078      	str	r0, [r7, #4]
  int status = 0;
 810f5c4:	2300      	movs	r3, #0
 810f5c6:	61fb      	str	r3, [r7, #28]
  struct metal_device *device = NULL;
 810f5c8:	2300      	movs	r3, #0
 810f5ca:	61bb      	str	r3, [r7, #24]
  struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
 810f5cc:	4a41      	ldr	r2, [pc, #260]	@ (810f6d4 <OPENAMP_shmem_init+0x118>)
 810f5ce:	f107 0310 	add.w	r3, r7, #16
 810f5d2:	e892 0003 	ldmia.w	r2, {r0, r1}
 810f5d6:	e883 0003 	stmia.w	r3, {r0, r1}
  void* rsc_tab_addr = NULL;
 810f5da:	2300      	movs	r3, #0
 810f5dc:	60fb      	str	r3, [r7, #12]
  int rsc_size = 0;
 810f5de:	2300      	movs	r3, #0
 810f5e0:	60bb      	str	r3, [r7, #8]

  /* USER CODE BEGIN PRE_LIB_METAL_INIT */

  /* USER CODE END  PRE_LIB_METAL_INIT */
  metal_init(&metal_params);
 810f5e2:	f107 0310 	add.w	r3, r7, #16
 810f5e6:	4618      	mov	r0, r3
 810f5e8:	f7fe f8e6 	bl	810d7b8 <metal_init>

  status = metal_register_generic_device(&shm_device);
 810f5ec:	483a      	ldr	r0, [pc, #232]	@ (810f6d8 <OPENAMP_shmem_init+0x11c>)
 810f5ee:	f7fd ff8b 	bl	810d508 <metal_register_generic_device>
 810f5f2:	61f8      	str	r0, [r7, #28]
  if (status != 0) {
 810f5f4:	69fb      	ldr	r3, [r7, #28]
 810f5f6:	2b00      	cmp	r3, #0
 810f5f8:	d001      	beq.n	810f5fe <OPENAMP_shmem_init+0x42>
    return status;
 810f5fa:	69fb      	ldr	r3, [r7, #28]
 810f5fc:	e066      	b.n	810f6cc <OPENAMP_shmem_init+0x110>
  }

  status = metal_device_open("generic", SHM_DEVICE_NAME, &device);
 810f5fe:	f107 0318 	add.w	r3, r7, #24
 810f602:	461a      	mov	r2, r3
 810f604:	4935      	ldr	r1, [pc, #212]	@ (810f6dc <OPENAMP_shmem_init+0x120>)
 810f606:	4836      	ldr	r0, [pc, #216]	@ (810f6e0 <OPENAMP_shmem_init+0x124>)
 810f608:	f7fd ff40 	bl	810d48c <metal_device_open>
 810f60c:	61f8      	str	r0, [r7, #28]
  if (status != 0) {
 810f60e:	69fb      	ldr	r3, [r7, #28]
 810f610:	2b00      	cmp	r3, #0
 810f612:	d001      	beq.n	810f618 <OPENAMP_shmem_init+0x5c>
    return status;
 810f614:	69fb      	ldr	r3, [r7, #28]
 810f616:	e059      	b.n	810f6cc <OPENAMP_shmem_init+0x110>
  }

  shm_physmap = SHM_START_ADDRESS;
 810f618:	4a32      	ldr	r2, [pc, #200]	@ (810f6e4 <OPENAMP_shmem_init+0x128>)
 810f61a:	4b33      	ldr	r3, [pc, #204]	@ (810f6e8 <OPENAMP_shmem_init+0x12c>)
 810f61c:	601a      	str	r2, [r3, #0]
  metal_io_init(&device->regions[0], (void *)SHM_START_ADDRESS, &shm_physmap,
 810f61e:	69bb      	ldr	r3, [r7, #24]
 810f620:	f103 000c 	add.w	r0, r3, #12
                SHM_SIZE, -1, 0, NULL);
 810f624:	4a31      	ldr	r2, [pc, #196]	@ (810f6ec <OPENAMP_shmem_init+0x130>)
 810f626:	4b2f      	ldr	r3, [pc, #188]	@ (810f6e4 <OPENAMP_shmem_init+0x128>)
 810f628:	1ad3      	subs	r3, r2, r3
  metal_io_init(&device->regions[0], (void *)SHM_START_ADDRESS, &shm_physmap,
 810f62a:	461a      	mov	r2, r3
 810f62c:	2300      	movs	r3, #0
 810f62e:	9302      	str	r3, [sp, #8]
 810f630:	2300      	movs	r3, #0
 810f632:	9301      	str	r3, [sp, #4]
 810f634:	f04f 33ff 	mov.w	r3, #4294967295
 810f638:	9300      	str	r3, [sp, #0]
 810f63a:	4613      	mov	r3, r2
 810f63c:	4a2a      	ldr	r2, [pc, #168]	@ (810f6e8 <OPENAMP_shmem_init+0x12c>)
 810f63e:	4929      	ldr	r1, [pc, #164]	@ (810f6e4 <OPENAMP_shmem_init+0x128>)
 810f640:	f7fe f907 	bl	810d852 <metal_io_init>

  /* USER CODE BEGIN PRE_SHM_IO_INIT */

  /* USER CODE END PRE_SHM_IO_INIT */
  shm_io = metal_device_io_region(device, 0);
 810f644:	69bb      	ldr	r3, [r7, #24]
 810f646:	2100      	movs	r1, #0
 810f648:	4618      	mov	r0, r3
 810f64a:	f7ff ff9c 	bl	810f586 <metal_device_io_region>
 810f64e:	4603      	mov	r3, r0
 810f650:	4a27      	ldr	r2, [pc, #156]	@ (810f6f0 <OPENAMP_shmem_init+0x134>)
 810f652:	6013      	str	r3, [r2, #0]
  if (shm_io == NULL) {
 810f654:	4b26      	ldr	r3, [pc, #152]	@ (810f6f0 <OPENAMP_shmem_init+0x134>)
 810f656:	681b      	ldr	r3, [r3, #0]
 810f658:	2b00      	cmp	r3, #0
 810f65a:	d102      	bne.n	810f662 <OPENAMP_shmem_init+0xa6>
    return -1;
 810f65c:	f04f 33ff 	mov.w	r3, #4294967295
 810f660:	e034      	b.n	810f6cc <OPENAMP_shmem_init+0x110>
  /* USER CODE BEGIN POST_SHM_IO_INIT */

  /* USER CODE END POST_SHM_IO_INIT */

  /* Initialize resources table variables */
  resource_table_init(RPMsgRole, &rsc_tab_addr, &rsc_size);
 810f662:	f107 0208 	add.w	r2, r7, #8
 810f666:	f107 030c 	add.w	r3, r7, #12
 810f66a:	4619      	mov	r1, r3
 810f66c:	6878      	ldr	r0, [r7, #4]
 810f66e:	f000 f905 	bl	810f87c <resource_table_init>
  rsc_table = (struct shared_resource_table *)rsc_tab_addr;
 810f672:	68fb      	ldr	r3, [r7, #12]
 810f674:	4a1f      	ldr	r2, [pc, #124]	@ (810f6f4 <OPENAMP_shmem_init+0x138>)
 810f676:	6013      	str	r3, [r2, #0]
  if (!rsc_table)
 810f678:	4b1e      	ldr	r3, [pc, #120]	@ (810f6f4 <OPENAMP_shmem_init+0x138>)
 810f67a:	681b      	ldr	r3, [r3, #0]
 810f67c:	2b00      	cmp	r3, #0
 810f67e:	d102      	bne.n	810f686 <OPENAMP_shmem_init+0xca>
  {
    return -1;
 810f680:	f04f 33ff 	mov.w	r3, #4294967295
 810f684:	e022      	b.n	810f6cc <OPENAMP_shmem_init+0x110>

  /* USER CODE BEGIN POST_RSC_TABLE_INIT */

  /* USER CODE END  POST_RSC_TABLE_INIT */

  metal_io_init(&device->regions[1], rsc_table,
 810f686:	69bb      	ldr	r3, [r7, #24]
 810f688:	f103 003c 	add.w	r0, r3, #60	@ 0x3c
 810f68c:	4b19      	ldr	r3, [pc, #100]	@ (810f6f4 <OPENAMP_shmem_init+0x138>)
 810f68e:	6819      	ldr	r1, [r3, #0]
 810f690:	4b18      	ldr	r3, [pc, #96]	@ (810f6f4 <OPENAMP_shmem_init+0x138>)
 810f692:	681a      	ldr	r2, [r3, #0]
 810f694:	68bb      	ldr	r3, [r7, #8]
 810f696:	461c      	mov	r4, r3
 810f698:	2300      	movs	r3, #0
 810f69a:	9302      	str	r3, [sp, #8]
 810f69c:	2300      	movs	r3, #0
 810f69e:	9301      	str	r3, [sp, #4]
 810f6a0:	f04f 33ff 	mov.w	r3, #4294967295
 810f6a4:	9300      	str	r3, [sp, #0]
 810f6a6:	4623      	mov	r3, r4
 810f6a8:	f7fe f8d3 	bl	810d852 <metal_io_init>
               (metal_phys_addr_t *)rsc_table, rsc_size, -1U, 0, NULL);

  /* USER CODE BEGIN POST_METAL_IO_INIT */

  /* USER CODE END  POST_METAL_IO_INIT */
  rsc_io = metal_device_io_region(device, 1);
 810f6ac:	69bb      	ldr	r3, [r7, #24]
 810f6ae:	2101      	movs	r1, #1
 810f6b0:	4618      	mov	r0, r3
 810f6b2:	f7ff ff68 	bl	810f586 <metal_device_io_region>
 810f6b6:	4603      	mov	r3, r0
 810f6b8:	4a0f      	ldr	r2, [pc, #60]	@ (810f6f8 <OPENAMP_shmem_init+0x13c>)
 810f6ba:	6013      	str	r3, [r2, #0]
  if (rsc_io == NULL) {
 810f6bc:	4b0e      	ldr	r3, [pc, #56]	@ (810f6f8 <OPENAMP_shmem_init+0x13c>)
 810f6be:	681b      	ldr	r3, [r3, #0]
 810f6c0:	2b00      	cmp	r3, #0
 810f6c2:	d102      	bne.n	810f6ca <OPENAMP_shmem_init+0x10e>
    return -1;
 810f6c4:	f04f 33ff 	mov.w	r3, #4294967295
 810f6c8:	e000      	b.n	810f6cc <OPENAMP_shmem_init+0x110>
  }

  /* USER CODE BEGIN POST_RSC_IO_INIT */

  /* USER CODE END  POST_RSC_IO_INIT */
  return 0;
 810f6ca:	2300      	movs	r3, #0
}
 810f6cc:	4618      	mov	r0, r3
 810f6ce:	3724      	adds	r7, #36	@ 0x24
 810f6d0:	46bd      	mov	sp, r7
 810f6d2:	bd90      	pop	{r4, r7, pc}
 810f6d4:	08110a7c 	.word	0x08110a7c
 810f6d8:	100004c0 	.word	0x100004c0
 810f6dc:	08110a68 	.word	0x08110a68
 810f6e0:	08110a74 	.word	0x08110a74
 810f6e4:	38000400 	.word	0x38000400
 810f6e8:	100055e0 	.word	0x100055e0
 810f6ec:	38010000 	.word	0x38010000
 810f6f0:	10005550 	.word	0x10005550
 810f6f4:	10005558 	.word	0x10005558
 810f6f8:	10005554 	.word	0x10005554

0810f6fc <MX_OPENAMP_Init>:

int MX_OPENAMP_Init(int RPMsgRole, rpmsg_ns_bind_cb ns_bind_cb)
{
 810f6fc:	b590      	push	{r4, r7, lr}
 810f6fe:	b08b      	sub	sp, #44	@ 0x2c
 810f700:	af04      	add	r7, sp, #16
 810f702:	6078      	str	r0, [r7, #4]
 810f704:	6039      	str	r1, [r7, #0]
  struct fw_rsc_vdev_vring *vring_rsc = NULL;
 810f706:	2300      	movs	r3, #0
 810f708:	617b      	str	r3, [r7, #20]
  struct virtio_device *vdev = NULL;
 810f70a:	2300      	movs	r3, #0
 810f70c:	613b      	str	r3, [r7, #16]
  int status = 0;
 810f70e:	2300      	movs	r3, #0
 810f710:	60fb      	str	r3, [r7, #12]

  /* USER CODE BEGIN MAILBOX_Init */

  /* USER CODE END MAIL_BOX_Init */

  MAILBOX_Init();
 810f712:	f7ff fef1 	bl	810f4f8 <MAILBOX_Init>

  /* Libmetal Initilalization */
  status = OPENAMP_shmem_init(RPMsgRole);
 810f716:	6878      	ldr	r0, [r7, #4]
 810f718:	f7ff ff50 	bl	810f5bc <OPENAMP_shmem_init>
 810f71c:	60f8      	str	r0, [r7, #12]
  if(status)
 810f71e:	68fb      	ldr	r3, [r7, #12]
 810f720:	2b00      	cmp	r3, #0
 810f722:	d001      	beq.n	810f728 <MX_OPENAMP_Init+0x2c>
  {
    return status;
 810f724:	68fb      	ldr	r3, [r7, #12]
 810f726:	e06a      	b.n	810f7fe <MX_OPENAMP_Init+0x102>
  }

  /* USER CODE BEGIN  PRE_VIRTIO_INIT */

  /* USER CODE END PRE_VIRTIO_INIT */
  vdev = rproc_virtio_create_vdev(RPMsgRole, VDEV_ID, &rsc_table->vdev,
 810f728:	6878      	ldr	r0, [r7, #4]
 810f72a:	4b37      	ldr	r3, [pc, #220]	@ (810f808 <MX_OPENAMP_Init+0x10c>)
 810f72c:	681b      	ldr	r3, [r3, #0]
 810f72e:	f103 0218 	add.w	r2, r3, #24
 810f732:	4b36      	ldr	r3, [pc, #216]	@ (810f80c <MX_OPENAMP_Init+0x110>)
 810f734:	681b      	ldr	r3, [r3, #0]
 810f736:	2100      	movs	r1, #0
 810f738:	9102      	str	r1, [sp, #8]
 810f73a:	4935      	ldr	r1, [pc, #212]	@ (810f810 <MX_OPENAMP_Init+0x114>)
 810f73c:	9101      	str	r1, [sp, #4]
 810f73e:	2100      	movs	r1, #0
 810f740:	9100      	str	r1, [sp, #0]
 810f742:	21ff      	movs	r1, #255	@ 0xff
 810f744:	f7fe fb46 	bl	810ddd4 <rproc_virtio_create_vdev>
 810f748:	6138      	str	r0, [r7, #16]
                                  rsc_io, NULL, MAILBOX_Notify, NULL);
  if (vdev == NULL)
 810f74a:	693b      	ldr	r3, [r7, #16]
 810f74c:	2b00      	cmp	r3, #0
 810f74e:	d102      	bne.n	810f756 <MX_OPENAMP_Init+0x5a>
  {
    return -1;
 810f750:	f04f 33ff 	mov.w	r3, #4294967295
 810f754:	e053      	b.n	810f7fe <MX_OPENAMP_Init+0x102>
  }

  rproc_virtio_wait_remote_ready(vdev);
 810f756:	6938      	ldr	r0, [r7, #16]
 810f758:	f7fe fc57 	bl	810e00a <rproc_virtio_wait_remote_ready>

  /* USER CODE BEGIN  POST_VIRTIO_INIT */

  /* USER CODE END POST_VIRTIO_INIT */
  vring_rsc = &rsc_table->vring0;
 810f75c:	4b2a      	ldr	r3, [pc, #168]	@ (810f808 <MX_OPENAMP_Init+0x10c>)
 810f75e:	681b      	ldr	r3, [r3, #0]
 810f760:	3334      	adds	r3, #52	@ 0x34
 810f762:	617b      	str	r3, [r7, #20]
  status = rproc_virtio_init_vring(vdev, 0, vring_rsc->notifyid,
 810f764:	697b      	ldr	r3, [r7, #20]
 810f766:	68d8      	ldr	r0, [r3, #12]
                                   (void *)vring_rsc->da, shm_io,
 810f768:	697b      	ldr	r3, [r7, #20]
 810f76a:	681b      	ldr	r3, [r3, #0]
  status = rproc_virtio_init_vring(vdev, 0, vring_rsc->notifyid,
 810f76c:	461c      	mov	r4, r3
 810f76e:	4b29      	ldr	r3, [pc, #164]	@ (810f814 <MX_OPENAMP_Init+0x118>)
 810f770:	681b      	ldr	r3, [r3, #0]
                                   vring_rsc->num, vring_rsc->align);
 810f772:	697a      	ldr	r2, [r7, #20]
 810f774:	6892      	ldr	r2, [r2, #8]
 810f776:	6979      	ldr	r1, [r7, #20]
 810f778:	6849      	ldr	r1, [r1, #4]
  status = rproc_virtio_init_vring(vdev, 0, vring_rsc->notifyid,
 810f77a:	9102      	str	r1, [sp, #8]
 810f77c:	9201      	str	r2, [sp, #4]
 810f77e:	9300      	str	r3, [sp, #0]
 810f780:	4623      	mov	r3, r4
 810f782:	4602      	mov	r2, r0
 810f784:	2100      	movs	r1, #0
 810f786:	6938      	ldr	r0, [r7, #16]
 810f788:	f7fe fbd2 	bl	810df30 <rproc_virtio_init_vring>
 810f78c:	60f8      	str	r0, [r7, #12]
  if (status != 0)
 810f78e:	68fb      	ldr	r3, [r7, #12]
 810f790:	2b00      	cmp	r3, #0
 810f792:	d001      	beq.n	810f798 <MX_OPENAMP_Init+0x9c>
  {
    return status;
 810f794:	68fb      	ldr	r3, [r7, #12]
 810f796:	e032      	b.n	810f7fe <MX_OPENAMP_Init+0x102>
  }

  /* USER CODE BEGIN  POST_VRING0_INIT */

  /* USER CODE END POST_VRING0_INIT */
  vring_rsc = &rsc_table->vring1;
 810f798:	4b1b      	ldr	r3, [pc, #108]	@ (810f808 <MX_OPENAMP_Init+0x10c>)
 810f79a:	681b      	ldr	r3, [r3, #0]
 810f79c:	3348      	adds	r3, #72	@ 0x48
 810f79e:	617b      	str	r3, [r7, #20]
  status = rproc_virtio_init_vring(vdev, 1, vring_rsc->notifyid,
 810f7a0:	697b      	ldr	r3, [r7, #20]
 810f7a2:	68d8      	ldr	r0, [r3, #12]
                                   (void *)vring_rsc->da, shm_io,
 810f7a4:	697b      	ldr	r3, [r7, #20]
 810f7a6:	681b      	ldr	r3, [r3, #0]
  status = rproc_virtio_init_vring(vdev, 1, vring_rsc->notifyid,
 810f7a8:	461c      	mov	r4, r3
 810f7aa:	4b1a      	ldr	r3, [pc, #104]	@ (810f814 <MX_OPENAMP_Init+0x118>)
 810f7ac:	681b      	ldr	r3, [r3, #0]
                                   vring_rsc->num, vring_rsc->align);
 810f7ae:	697a      	ldr	r2, [r7, #20]
 810f7b0:	6892      	ldr	r2, [r2, #8]
 810f7b2:	6979      	ldr	r1, [r7, #20]
 810f7b4:	6849      	ldr	r1, [r1, #4]
  status = rproc_virtio_init_vring(vdev, 1, vring_rsc->notifyid,
 810f7b6:	9102      	str	r1, [sp, #8]
 810f7b8:	9201      	str	r2, [sp, #4]
 810f7ba:	9300      	str	r3, [sp, #0]
 810f7bc:	4623      	mov	r3, r4
 810f7be:	4602      	mov	r2, r0
 810f7c0:	2101      	movs	r1, #1
 810f7c2:	6938      	ldr	r0, [r7, #16]
 810f7c4:	f7fe fbb4 	bl	810df30 <rproc_virtio_init_vring>
 810f7c8:	60f8      	str	r0, [r7, #12]
  if (status != 0)
 810f7ca:	68fb      	ldr	r3, [r7, #12]
 810f7cc:	2b00      	cmp	r3, #0
 810f7ce:	d001      	beq.n	810f7d4 <MX_OPENAMP_Init+0xd8>
  {
    return status;
 810f7d0:	68fb      	ldr	r3, [r7, #12]
 810f7d2:	e014      	b.n	810f7fe <MX_OPENAMP_Init+0x102>

  /* USER CODE BEGIN  POST_VRING1_INIT */

  /* USER CODE END POST_VRING1_INIT */

  rpmsg_virtio_init_shm_pool(&shpool, (void *)VRING_BUFF_ADDRESS,
 810f7d4:	4b10      	ldr	r3, [pc, #64]	@ (810f818 <MX_OPENAMP_Init+0x11c>)
 810f7d6:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 810f7da:	4619      	mov	r1, r3
                             (size_t)SHM_SIZE);
 810f7dc:	4a0f      	ldr	r2, [pc, #60]	@ (810f81c <MX_OPENAMP_Init+0x120>)
 810f7de:	4b0e      	ldr	r3, [pc, #56]	@ (810f818 <MX_OPENAMP_Init+0x11c>)
 810f7e0:	1ad3      	subs	r3, r2, r3
  rpmsg_virtio_init_shm_pool(&shpool, (void *)VRING_BUFF_ADDRESS,
 810f7e2:	461a      	mov	r2, r3
 810f7e4:	480e      	ldr	r0, [pc, #56]	@ (810f820 <MX_OPENAMP_Init+0x124>)
 810f7e6:	f7ff f85f 	bl	810e8a8 <rpmsg_virtio_init_shm_pool>
  rpmsg_init_vdev(&rvdev, vdev, ns_bind_cb, shm_io, &shpool);
 810f7ea:	4b0a      	ldr	r3, [pc, #40]	@ (810f814 <MX_OPENAMP_Init+0x118>)
 810f7ec:	681b      	ldr	r3, [r3, #0]
 810f7ee:	4a0c      	ldr	r2, [pc, #48]	@ (810f820 <MX_OPENAMP_Init+0x124>)
 810f7f0:	9200      	str	r2, [sp, #0]
 810f7f2:	683a      	ldr	r2, [r7, #0]
 810f7f4:	6939      	ldr	r1, [r7, #16]
 810f7f6:	480b      	ldr	r0, [pc, #44]	@ (810f824 <MX_OPENAMP_Init+0x128>)
 810f7f8:	f7ff facc 	bl	810ed94 <rpmsg_init_vdev>

  /* USER CODE BEGIN POST_RPMSG_INIT */

  /* USER CODE END POST_RPMSG_INIT */

  return 0;
 810f7fc:	2300      	movs	r3, #0
}
 810f7fe:	4618      	mov	r0, r3
 810f800:	371c      	adds	r7, #28
 810f802:	46bd      	mov	sp, r7
 810f804:	bd90      	pop	{r4, r7, pc}
 810f806:	bf00      	nop
 810f808:	10005558 	.word	0x10005558
 810f80c:	10005554 	.word	0x10005554
 810f810:	0810f565 	.word	0x0810f565
 810f814:	10005550 	.word	0x10005550
 810f818:	38000400 	.word	0x38000400
 810f81c:	38010000 	.word	0x38010000
 810f820:	1000555c 	.word	0x1000555c
 810f824:	10005568 	.word	0x10005568

0810f828 <OPENAMP_create_endpoint>:
}

int OPENAMP_create_endpoint(struct rpmsg_endpoint *ept, const char *name,
                            uint32_t dest, rpmsg_ept_cb cb,
                            rpmsg_ns_unbind_cb unbind_cb)
{
 810f828:	b580      	push	{r7, lr}
 810f82a:	b08a      	sub	sp, #40	@ 0x28
 810f82c:	af04      	add	r7, sp, #16
 810f82e:	60f8      	str	r0, [r7, #12]
 810f830:	60b9      	str	r1, [r7, #8]
 810f832:	607a      	str	r2, [r7, #4]
 810f834:	603b      	str	r3, [r7, #0]
  int ret = 0;
 810f836:	2300      	movs	r3, #0
 810f838:	617b      	str	r3, [r7, #20]
  /* USER CODE BEGIN PRE_EP_CREATE */

  /* USER CODE END PRE_EP_CREATE */

  ret = rpmsg_create_ept(ept, &rvdev.rdev, name, RPMSG_ADDR_ANY, dest, cb,
 810f83a:	6a3b      	ldr	r3, [r7, #32]
 810f83c:	9302      	str	r3, [sp, #8]
 810f83e:	683b      	ldr	r3, [r7, #0]
 810f840:	9301      	str	r3, [sp, #4]
 810f842:	687b      	ldr	r3, [r7, #4]
 810f844:	9300      	str	r3, [sp, #0]
 810f846:	f04f 33ff 	mov.w	r3, #4294967295
 810f84a:	68ba      	ldr	r2, [r7, #8]
 810f84c:	4904      	ldr	r1, [pc, #16]	@ (810f860 <OPENAMP_create_endpoint+0x38>)
 810f84e:	68f8      	ldr	r0, [r7, #12]
 810f850:	f7fe fe68 	bl	810e524 <rpmsg_create_ept>
 810f854:	6178      	str	r0, [r7, #20]
		          unbind_cb);

  /* USER CODE BEGIN POST_EP_CREATE */

  /* USER CODE END POST_EP_CREATE */
  return ret;
 810f856:	697b      	ldr	r3, [r7, #20]
}
 810f858:	4618      	mov	r0, r3
 810f85a:	3718      	adds	r7, #24
 810f85c:	46bd      	mov	sp, r7
 810f85e:	bd80      	pop	{r7, pc}
 810f860:	10005568 	.word	0x10005568

0810f864 <OPENAMP_check_for_message>:

void OPENAMP_check_for_message(void)
{
 810f864:	b580      	push	{r7, lr}
 810f866:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MSG_CHECK */

  /* USER CODE END MSG_CHECK */
  MAILBOX_Poll(rvdev.vdev);
 810f868:	4b03      	ldr	r3, [pc, #12]	@ (810f878 <OPENAMP_check_for_message+0x14>)
 810f86a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
 810f86c:	4618      	mov	r0, r3
 810f86e:	f7ff fe5f 	bl	810f530 <MAILBOX_Poll>
}
 810f872:	bf00      	nop
 810f874:	bd80      	pop	{r7, pc}
 810f876:	bf00      	nop
 810f878:	10005568 	.word	0x10005568

0810f87c <resource_table_init>:
#endif
} ;
#endif

void resource_table_init(int RPMsgRole, void **table_ptr, int *length)
{
 810f87c:	b480      	push	{r7}
 810f87e:	b085      	sub	sp, #20
 810f880:	af00      	add	r7, sp, #0
 810f882:	60f8      	str	r0, [r7, #12]
 810f884:	60b9      	str	r1, [r7, #8]
 810f886:	607a      	str	r2, [r7, #4]
	resource_table.vdev.num_of_vrings=VRING_COUNT;
	resource_table.vdev.dfeatures = RPMSG_IPU_C0_FEATURES;
#else

	/* For the slave application let's wait until the resource_table is correctly initialized */
	while(resource_table.vring1.da != VRING_RX_ADDRESS)
 810f888:	bf00      	nop
 810f88a:	4b08      	ldr	r3, [pc, #32]	@ (810f8ac <resource_table_init+0x30>)
 810f88c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
 810f88e:	4a08      	ldr	r2, [pc, #32]	@ (810f8b0 <resource_table_init+0x34>)
 810f890:	4293      	cmp	r3, r2
 810f892:	d1fa      	bne.n	810f88a <resource_table_init+0xe>
#endif
#endif
#endif

  (void)RPMsgRole;
  *length = sizeof(resource_table);
 810f894:	687b      	ldr	r3, [r7, #4]
 810f896:	228c      	movs	r2, #140	@ 0x8c
 810f898:	601a      	str	r2, [r3, #0]
  *table_ptr = (void *)&resource_table;
 810f89a:	68bb      	ldr	r3, [r7, #8]
 810f89c:	4a03      	ldr	r2, [pc, #12]	@ (810f8ac <resource_table_init+0x30>)
 810f89e:	601a      	str	r2, [r3, #0]
}
 810f8a0:	bf00      	nop
 810f8a2:	3714      	adds	r7, #20
 810f8a4:	46bd      	mov	sp, r7
 810f8a6:	f85d 7b04 	ldr.w	r7, [sp], #4
 810f8aa:	4770      	bx	lr
 810f8ac:	38000000 	.word	0x38000000
 810f8b0:	38000400 	.word	0x38000400

0810f8b4 <__assert_func>:
 810f8b4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 810f8b6:	4614      	mov	r4, r2
 810f8b8:	461a      	mov	r2, r3
 810f8ba:	4b09      	ldr	r3, [pc, #36]	@ (810f8e0 <__assert_func+0x2c>)
 810f8bc:	681b      	ldr	r3, [r3, #0]
 810f8be:	4605      	mov	r5, r0
 810f8c0:	68d8      	ldr	r0, [r3, #12]
 810f8c2:	b954      	cbnz	r4, 810f8da <__assert_func+0x26>
 810f8c4:	4b07      	ldr	r3, [pc, #28]	@ (810f8e4 <__assert_func+0x30>)
 810f8c6:	461c      	mov	r4, r3
 810f8c8:	e9cd 3401 	strd	r3, r4, [sp, #4]
 810f8cc:	9100      	str	r1, [sp, #0]
 810f8ce:	462b      	mov	r3, r5
 810f8d0:	4905      	ldr	r1, [pc, #20]	@ (810f8e8 <__assert_func+0x34>)
 810f8d2:	f000 f96f 	bl	810fbb4 <fiprintf>
 810f8d6:	f000 fa9e 	bl	810fe16 <abort>
 810f8da:	4b04      	ldr	r3, [pc, #16]	@ (810f8ec <__assert_func+0x38>)
 810f8dc:	e7f4      	b.n	810f8c8 <__assert_func+0x14>
 810f8de:	bf00      	nop
 810f8e0:	10000548 	.word	0x10000548
 810f8e4:	081113a5 	.word	0x081113a5
 810f8e8:	08111377 	.word	0x08111377
 810f8ec:	0811136a 	.word	0x0811136a

0810f8f0 <malloc>:
 810f8f0:	4b02      	ldr	r3, [pc, #8]	@ (810f8fc <malloc+0xc>)
 810f8f2:	4601      	mov	r1, r0
 810f8f4:	6818      	ldr	r0, [r3, #0]
 810f8f6:	f000 b82d 	b.w	810f954 <_malloc_r>
 810f8fa:	bf00      	nop
 810f8fc:	10000548 	.word	0x10000548

0810f900 <free>:
 810f900:	4b02      	ldr	r3, [pc, #8]	@ (810f90c <free+0xc>)
 810f902:	4601      	mov	r1, r0
 810f904:	6818      	ldr	r0, [r3, #0]
 810f906:	f000 ba8d 	b.w	810fe24 <_free_r>
 810f90a:	bf00      	nop
 810f90c:	10000548 	.word	0x10000548

0810f910 <sbrk_aligned>:
 810f910:	b570      	push	{r4, r5, r6, lr}
 810f912:	4e0f      	ldr	r6, [pc, #60]	@ (810f950 <sbrk_aligned+0x40>)
 810f914:	460c      	mov	r4, r1
 810f916:	6831      	ldr	r1, [r6, #0]
 810f918:	4605      	mov	r5, r0
 810f91a:	b911      	cbnz	r1, 810f922 <sbrk_aligned+0x12>
 810f91c:	f000 fa1e 	bl	810fd5c <_sbrk_r>
 810f920:	6030      	str	r0, [r6, #0]
 810f922:	4621      	mov	r1, r4
 810f924:	4628      	mov	r0, r5
 810f926:	f000 fa19 	bl	810fd5c <_sbrk_r>
 810f92a:	1c43      	adds	r3, r0, #1
 810f92c:	d103      	bne.n	810f936 <sbrk_aligned+0x26>
 810f92e:	f04f 34ff 	mov.w	r4, #4294967295
 810f932:	4620      	mov	r0, r4
 810f934:	bd70      	pop	{r4, r5, r6, pc}
 810f936:	1cc4      	adds	r4, r0, #3
 810f938:	f024 0403 	bic.w	r4, r4, #3
 810f93c:	42a0      	cmp	r0, r4
 810f93e:	d0f8      	beq.n	810f932 <sbrk_aligned+0x22>
 810f940:	1a21      	subs	r1, r4, r0
 810f942:	4628      	mov	r0, r5
 810f944:	f000 fa0a 	bl	810fd5c <_sbrk_r>
 810f948:	3001      	adds	r0, #1
 810f94a:	d1f2      	bne.n	810f932 <sbrk_aligned+0x22>
 810f94c:	e7ef      	b.n	810f92e <sbrk_aligned+0x1e>
 810f94e:	bf00      	nop
 810f950:	100055e4 	.word	0x100055e4

0810f954 <_malloc_r>:
 810f954:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 810f958:	1ccd      	adds	r5, r1, #3
 810f95a:	f025 0503 	bic.w	r5, r5, #3
 810f95e:	3508      	adds	r5, #8
 810f960:	2d0c      	cmp	r5, #12
 810f962:	bf38      	it	cc
 810f964:	250c      	movcc	r5, #12
 810f966:	2d00      	cmp	r5, #0
 810f968:	4606      	mov	r6, r0
 810f96a:	db01      	blt.n	810f970 <_malloc_r+0x1c>
 810f96c:	42a9      	cmp	r1, r5
 810f96e:	d904      	bls.n	810f97a <_malloc_r+0x26>
 810f970:	230c      	movs	r3, #12
 810f972:	6033      	str	r3, [r6, #0]
 810f974:	2000      	movs	r0, #0
 810f976:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 810f97a:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 810fa50 <_malloc_r+0xfc>
 810f97e:	f000 f869 	bl	810fa54 <__malloc_lock>
 810f982:	f8d8 3000 	ldr.w	r3, [r8]
 810f986:	461c      	mov	r4, r3
 810f988:	bb44      	cbnz	r4, 810f9dc <_malloc_r+0x88>
 810f98a:	4629      	mov	r1, r5
 810f98c:	4630      	mov	r0, r6
 810f98e:	f7ff ffbf 	bl	810f910 <sbrk_aligned>
 810f992:	1c43      	adds	r3, r0, #1
 810f994:	4604      	mov	r4, r0
 810f996:	d158      	bne.n	810fa4a <_malloc_r+0xf6>
 810f998:	f8d8 4000 	ldr.w	r4, [r8]
 810f99c:	4627      	mov	r7, r4
 810f99e:	2f00      	cmp	r7, #0
 810f9a0:	d143      	bne.n	810fa2a <_malloc_r+0xd6>
 810f9a2:	2c00      	cmp	r4, #0
 810f9a4:	d04b      	beq.n	810fa3e <_malloc_r+0xea>
 810f9a6:	6823      	ldr	r3, [r4, #0]
 810f9a8:	4639      	mov	r1, r7
 810f9aa:	4630      	mov	r0, r6
 810f9ac:	eb04 0903 	add.w	r9, r4, r3
 810f9b0:	f000 f9d4 	bl	810fd5c <_sbrk_r>
 810f9b4:	4581      	cmp	r9, r0
 810f9b6:	d142      	bne.n	810fa3e <_malloc_r+0xea>
 810f9b8:	6821      	ldr	r1, [r4, #0]
 810f9ba:	1a6d      	subs	r5, r5, r1
 810f9bc:	4629      	mov	r1, r5
 810f9be:	4630      	mov	r0, r6
 810f9c0:	f7ff ffa6 	bl	810f910 <sbrk_aligned>
 810f9c4:	3001      	adds	r0, #1
 810f9c6:	d03a      	beq.n	810fa3e <_malloc_r+0xea>
 810f9c8:	6823      	ldr	r3, [r4, #0]
 810f9ca:	442b      	add	r3, r5
 810f9cc:	6023      	str	r3, [r4, #0]
 810f9ce:	f8d8 3000 	ldr.w	r3, [r8]
 810f9d2:	685a      	ldr	r2, [r3, #4]
 810f9d4:	bb62      	cbnz	r2, 810fa30 <_malloc_r+0xdc>
 810f9d6:	f8c8 7000 	str.w	r7, [r8]
 810f9da:	e00f      	b.n	810f9fc <_malloc_r+0xa8>
 810f9dc:	6822      	ldr	r2, [r4, #0]
 810f9de:	1b52      	subs	r2, r2, r5
 810f9e0:	d420      	bmi.n	810fa24 <_malloc_r+0xd0>
 810f9e2:	2a0b      	cmp	r2, #11
 810f9e4:	d917      	bls.n	810fa16 <_malloc_r+0xc2>
 810f9e6:	1961      	adds	r1, r4, r5
 810f9e8:	42a3      	cmp	r3, r4
 810f9ea:	6025      	str	r5, [r4, #0]
 810f9ec:	bf18      	it	ne
 810f9ee:	6059      	strne	r1, [r3, #4]
 810f9f0:	6863      	ldr	r3, [r4, #4]
 810f9f2:	bf08      	it	eq
 810f9f4:	f8c8 1000 	streq.w	r1, [r8]
 810f9f8:	5162      	str	r2, [r4, r5]
 810f9fa:	604b      	str	r3, [r1, #4]
 810f9fc:	4630      	mov	r0, r6
 810f9fe:	f000 f82f 	bl	810fa60 <__malloc_unlock>
 810fa02:	f104 000b 	add.w	r0, r4, #11
 810fa06:	1d23      	adds	r3, r4, #4
 810fa08:	f020 0007 	bic.w	r0, r0, #7
 810fa0c:	1ac2      	subs	r2, r0, r3
 810fa0e:	bf1c      	itt	ne
 810fa10:	1a1b      	subne	r3, r3, r0
 810fa12:	50a3      	strne	r3, [r4, r2]
 810fa14:	e7af      	b.n	810f976 <_malloc_r+0x22>
 810fa16:	6862      	ldr	r2, [r4, #4]
 810fa18:	42a3      	cmp	r3, r4
 810fa1a:	bf0c      	ite	eq
 810fa1c:	f8c8 2000 	streq.w	r2, [r8]
 810fa20:	605a      	strne	r2, [r3, #4]
 810fa22:	e7eb      	b.n	810f9fc <_malloc_r+0xa8>
 810fa24:	4623      	mov	r3, r4
 810fa26:	6864      	ldr	r4, [r4, #4]
 810fa28:	e7ae      	b.n	810f988 <_malloc_r+0x34>
 810fa2a:	463c      	mov	r4, r7
 810fa2c:	687f      	ldr	r7, [r7, #4]
 810fa2e:	e7b6      	b.n	810f99e <_malloc_r+0x4a>
 810fa30:	461a      	mov	r2, r3
 810fa32:	685b      	ldr	r3, [r3, #4]
 810fa34:	42a3      	cmp	r3, r4
 810fa36:	d1fb      	bne.n	810fa30 <_malloc_r+0xdc>
 810fa38:	2300      	movs	r3, #0
 810fa3a:	6053      	str	r3, [r2, #4]
 810fa3c:	e7de      	b.n	810f9fc <_malloc_r+0xa8>
 810fa3e:	230c      	movs	r3, #12
 810fa40:	6033      	str	r3, [r6, #0]
 810fa42:	4630      	mov	r0, r6
 810fa44:	f000 f80c 	bl	810fa60 <__malloc_unlock>
 810fa48:	e794      	b.n	810f974 <_malloc_r+0x20>
 810fa4a:	6005      	str	r5, [r0, #0]
 810fa4c:	e7d6      	b.n	810f9fc <_malloc_r+0xa8>
 810fa4e:	bf00      	nop
 810fa50:	100055e8 	.word	0x100055e8

0810fa54 <__malloc_lock>:
 810fa54:	4801      	ldr	r0, [pc, #4]	@ (810fa5c <__malloc_lock+0x8>)
 810fa56:	f000 b9ce 	b.w	810fdf6 <__retarget_lock_acquire_recursive>
 810fa5a:	bf00      	nop
 810fa5c:	1000572c 	.word	0x1000572c

0810fa60 <__malloc_unlock>:
 810fa60:	4801      	ldr	r0, [pc, #4]	@ (810fa68 <__malloc_unlock+0x8>)
 810fa62:	f000 b9c9 	b.w	810fdf8 <__retarget_lock_release_recursive>
 810fa66:	bf00      	nop
 810fa68:	1000572c 	.word	0x1000572c

0810fa6c <std>:
 810fa6c:	2300      	movs	r3, #0
 810fa6e:	b510      	push	{r4, lr}
 810fa70:	4604      	mov	r4, r0
 810fa72:	e9c0 3300 	strd	r3, r3, [r0]
 810fa76:	e9c0 3304 	strd	r3, r3, [r0, #16]
 810fa7a:	6083      	str	r3, [r0, #8]
 810fa7c:	8181      	strh	r1, [r0, #12]
 810fa7e:	6643      	str	r3, [r0, #100]	@ 0x64
 810fa80:	81c2      	strh	r2, [r0, #14]
 810fa82:	6183      	str	r3, [r0, #24]
 810fa84:	4619      	mov	r1, r3
 810fa86:	2208      	movs	r2, #8
 810fa88:	305c      	adds	r0, #92	@ 0x5c
 810fa8a:	f000 f906 	bl	810fc9a <memset>
 810fa8e:	4b0d      	ldr	r3, [pc, #52]	@ (810fac4 <std+0x58>)
 810fa90:	6263      	str	r3, [r4, #36]	@ 0x24
 810fa92:	4b0d      	ldr	r3, [pc, #52]	@ (810fac8 <std+0x5c>)
 810fa94:	62a3      	str	r3, [r4, #40]	@ 0x28
 810fa96:	4b0d      	ldr	r3, [pc, #52]	@ (810facc <std+0x60>)
 810fa98:	62e3      	str	r3, [r4, #44]	@ 0x2c
 810fa9a:	4b0d      	ldr	r3, [pc, #52]	@ (810fad0 <std+0x64>)
 810fa9c:	6323      	str	r3, [r4, #48]	@ 0x30
 810fa9e:	4b0d      	ldr	r3, [pc, #52]	@ (810fad4 <std+0x68>)
 810faa0:	6224      	str	r4, [r4, #32]
 810faa2:	429c      	cmp	r4, r3
 810faa4:	d006      	beq.n	810fab4 <std+0x48>
 810faa6:	f103 0268 	add.w	r2, r3, #104	@ 0x68
 810faaa:	4294      	cmp	r4, r2
 810faac:	d002      	beq.n	810fab4 <std+0x48>
 810faae:	33d0      	adds	r3, #208	@ 0xd0
 810fab0:	429c      	cmp	r4, r3
 810fab2:	d105      	bne.n	810fac0 <std+0x54>
 810fab4:	f104 0058 	add.w	r0, r4, #88	@ 0x58
 810fab8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 810fabc:	f000 b99a 	b.w	810fdf4 <__retarget_lock_init_recursive>
 810fac0:	bd10      	pop	{r4, pc}
 810fac2:	bf00      	nop
 810fac4:	0810fc15 	.word	0x0810fc15
 810fac8:	0810fc37 	.word	0x0810fc37
 810facc:	0810fc6f 	.word	0x0810fc6f
 810fad0:	0810fc93 	.word	0x0810fc93
 810fad4:	100055ec 	.word	0x100055ec

0810fad8 <stdio_exit_handler>:
 810fad8:	4a02      	ldr	r2, [pc, #8]	@ (810fae4 <stdio_exit_handler+0xc>)
 810fada:	4903      	ldr	r1, [pc, #12]	@ (810fae8 <stdio_exit_handler+0x10>)
 810fadc:	4803      	ldr	r0, [pc, #12]	@ (810faec <stdio_exit_handler+0x14>)
 810fade:	f000 b87b 	b.w	810fbd8 <_fwalk_sglue>
 810fae2:	bf00      	nop
 810fae4:	1000053c 	.word	0x1000053c
 810fae8:	08110561 	.word	0x08110561
 810faec:	1000054c 	.word	0x1000054c

0810faf0 <cleanup_stdio>:
 810faf0:	6841      	ldr	r1, [r0, #4]
 810faf2:	4b0c      	ldr	r3, [pc, #48]	@ (810fb24 <cleanup_stdio+0x34>)
 810faf4:	4299      	cmp	r1, r3
 810faf6:	b510      	push	{r4, lr}
 810faf8:	4604      	mov	r4, r0
 810fafa:	d001      	beq.n	810fb00 <cleanup_stdio+0x10>
 810fafc:	f000 fd30 	bl	8110560 <_fflush_r>
 810fb00:	68a1      	ldr	r1, [r4, #8]
 810fb02:	4b09      	ldr	r3, [pc, #36]	@ (810fb28 <cleanup_stdio+0x38>)
 810fb04:	4299      	cmp	r1, r3
 810fb06:	d002      	beq.n	810fb0e <cleanup_stdio+0x1e>
 810fb08:	4620      	mov	r0, r4
 810fb0a:	f000 fd29 	bl	8110560 <_fflush_r>
 810fb0e:	68e1      	ldr	r1, [r4, #12]
 810fb10:	4b06      	ldr	r3, [pc, #24]	@ (810fb2c <cleanup_stdio+0x3c>)
 810fb12:	4299      	cmp	r1, r3
 810fb14:	d004      	beq.n	810fb20 <cleanup_stdio+0x30>
 810fb16:	4620      	mov	r0, r4
 810fb18:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 810fb1c:	f000 bd20 	b.w	8110560 <_fflush_r>
 810fb20:	bd10      	pop	{r4, pc}
 810fb22:	bf00      	nop
 810fb24:	100055ec 	.word	0x100055ec
 810fb28:	10005654 	.word	0x10005654
 810fb2c:	100056bc 	.word	0x100056bc

0810fb30 <global_stdio_init.part.0>:
 810fb30:	b510      	push	{r4, lr}
 810fb32:	4b0b      	ldr	r3, [pc, #44]	@ (810fb60 <global_stdio_init.part.0+0x30>)
 810fb34:	4c0b      	ldr	r4, [pc, #44]	@ (810fb64 <global_stdio_init.part.0+0x34>)
 810fb36:	4a0c      	ldr	r2, [pc, #48]	@ (810fb68 <global_stdio_init.part.0+0x38>)
 810fb38:	601a      	str	r2, [r3, #0]
 810fb3a:	4620      	mov	r0, r4
 810fb3c:	2200      	movs	r2, #0
 810fb3e:	2104      	movs	r1, #4
 810fb40:	f7ff ff94 	bl	810fa6c <std>
 810fb44:	f104 0068 	add.w	r0, r4, #104	@ 0x68
 810fb48:	2201      	movs	r2, #1
 810fb4a:	2109      	movs	r1, #9
 810fb4c:	f7ff ff8e 	bl	810fa6c <std>
 810fb50:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
 810fb54:	2202      	movs	r2, #2
 810fb56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 810fb5a:	2112      	movs	r1, #18
 810fb5c:	f7ff bf86 	b.w	810fa6c <std>
 810fb60:	10005724 	.word	0x10005724
 810fb64:	100055ec 	.word	0x100055ec
 810fb68:	0810fad9 	.word	0x0810fad9

0810fb6c <__sfp_lock_acquire>:
 810fb6c:	4801      	ldr	r0, [pc, #4]	@ (810fb74 <__sfp_lock_acquire+0x8>)
 810fb6e:	f000 b942 	b.w	810fdf6 <__retarget_lock_acquire_recursive>
 810fb72:	bf00      	nop
 810fb74:	1000572d 	.word	0x1000572d

0810fb78 <__sfp_lock_release>:
 810fb78:	4801      	ldr	r0, [pc, #4]	@ (810fb80 <__sfp_lock_release+0x8>)
 810fb7a:	f000 b93d 	b.w	810fdf8 <__retarget_lock_release_recursive>
 810fb7e:	bf00      	nop
 810fb80:	1000572d 	.word	0x1000572d

0810fb84 <__sinit>:
 810fb84:	b510      	push	{r4, lr}
 810fb86:	4604      	mov	r4, r0
 810fb88:	f7ff fff0 	bl	810fb6c <__sfp_lock_acquire>
 810fb8c:	6a23      	ldr	r3, [r4, #32]
 810fb8e:	b11b      	cbz	r3, 810fb98 <__sinit+0x14>
 810fb90:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 810fb94:	f7ff bff0 	b.w	810fb78 <__sfp_lock_release>
 810fb98:	4b04      	ldr	r3, [pc, #16]	@ (810fbac <__sinit+0x28>)
 810fb9a:	6223      	str	r3, [r4, #32]
 810fb9c:	4b04      	ldr	r3, [pc, #16]	@ (810fbb0 <__sinit+0x2c>)
 810fb9e:	681b      	ldr	r3, [r3, #0]
 810fba0:	2b00      	cmp	r3, #0
 810fba2:	d1f5      	bne.n	810fb90 <__sinit+0xc>
 810fba4:	f7ff ffc4 	bl	810fb30 <global_stdio_init.part.0>
 810fba8:	e7f2      	b.n	810fb90 <__sinit+0xc>
 810fbaa:	bf00      	nop
 810fbac:	0810faf1 	.word	0x0810faf1
 810fbb0:	10005724 	.word	0x10005724

0810fbb4 <fiprintf>:
 810fbb4:	b40e      	push	{r1, r2, r3}
 810fbb6:	b503      	push	{r0, r1, lr}
 810fbb8:	4601      	mov	r1, r0
 810fbba:	ab03      	add	r3, sp, #12
 810fbbc:	4805      	ldr	r0, [pc, #20]	@ (810fbd4 <fiprintf+0x20>)
 810fbbe:	f853 2b04 	ldr.w	r2, [r3], #4
 810fbc2:	6800      	ldr	r0, [r0, #0]
 810fbc4:	9301      	str	r3, [sp, #4]
 810fbc6:	f000 f9a1 	bl	810ff0c <_vfiprintf_r>
 810fbca:	b002      	add	sp, #8
 810fbcc:	f85d eb04 	ldr.w	lr, [sp], #4
 810fbd0:	b003      	add	sp, #12
 810fbd2:	4770      	bx	lr
 810fbd4:	10000548 	.word	0x10000548

0810fbd8 <_fwalk_sglue>:
 810fbd8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 810fbdc:	4607      	mov	r7, r0
 810fbde:	4688      	mov	r8, r1
 810fbe0:	4614      	mov	r4, r2
 810fbe2:	2600      	movs	r6, #0
 810fbe4:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
 810fbe8:	f1b9 0901 	subs.w	r9, r9, #1
 810fbec:	d505      	bpl.n	810fbfa <_fwalk_sglue+0x22>
 810fbee:	6824      	ldr	r4, [r4, #0]
 810fbf0:	2c00      	cmp	r4, #0
 810fbf2:	d1f7      	bne.n	810fbe4 <_fwalk_sglue+0xc>
 810fbf4:	4630      	mov	r0, r6
 810fbf6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 810fbfa:	89ab      	ldrh	r3, [r5, #12]
 810fbfc:	2b01      	cmp	r3, #1
 810fbfe:	d907      	bls.n	810fc10 <_fwalk_sglue+0x38>
 810fc00:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 810fc04:	3301      	adds	r3, #1
 810fc06:	d003      	beq.n	810fc10 <_fwalk_sglue+0x38>
 810fc08:	4629      	mov	r1, r5
 810fc0a:	4638      	mov	r0, r7
 810fc0c:	47c0      	blx	r8
 810fc0e:	4306      	orrs	r6, r0
 810fc10:	3568      	adds	r5, #104	@ 0x68
 810fc12:	e7e9      	b.n	810fbe8 <_fwalk_sglue+0x10>

0810fc14 <__sread>:
 810fc14:	b510      	push	{r4, lr}
 810fc16:	460c      	mov	r4, r1
 810fc18:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 810fc1c:	f000 f88c 	bl	810fd38 <_read_r>
 810fc20:	2800      	cmp	r0, #0
 810fc22:	bfab      	itete	ge
 810fc24:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
 810fc26:	89a3      	ldrhlt	r3, [r4, #12]
 810fc28:	181b      	addge	r3, r3, r0
 810fc2a:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
 810fc2e:	bfac      	ite	ge
 810fc30:	6563      	strge	r3, [r4, #84]	@ 0x54
 810fc32:	81a3      	strhlt	r3, [r4, #12]
 810fc34:	bd10      	pop	{r4, pc}

0810fc36 <__swrite>:
 810fc36:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 810fc3a:	461f      	mov	r7, r3
 810fc3c:	898b      	ldrh	r3, [r1, #12]
 810fc3e:	05db      	lsls	r3, r3, #23
 810fc40:	4605      	mov	r5, r0
 810fc42:	460c      	mov	r4, r1
 810fc44:	4616      	mov	r6, r2
 810fc46:	d505      	bpl.n	810fc54 <__swrite+0x1e>
 810fc48:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 810fc4c:	2302      	movs	r3, #2
 810fc4e:	2200      	movs	r2, #0
 810fc50:	f000 f860 	bl	810fd14 <_lseek_r>
 810fc54:	89a3      	ldrh	r3, [r4, #12]
 810fc56:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 810fc5a:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
 810fc5e:	81a3      	strh	r3, [r4, #12]
 810fc60:	4632      	mov	r2, r6
 810fc62:	463b      	mov	r3, r7
 810fc64:	4628      	mov	r0, r5
 810fc66:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 810fc6a:	f000 b887 	b.w	810fd7c <_write_r>

0810fc6e <__sseek>:
 810fc6e:	b510      	push	{r4, lr}
 810fc70:	460c      	mov	r4, r1
 810fc72:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 810fc76:	f000 f84d 	bl	810fd14 <_lseek_r>
 810fc7a:	1c43      	adds	r3, r0, #1
 810fc7c:	89a3      	ldrh	r3, [r4, #12]
 810fc7e:	bf15      	itete	ne
 810fc80:	6560      	strne	r0, [r4, #84]	@ 0x54
 810fc82:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
 810fc86:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
 810fc8a:	81a3      	strheq	r3, [r4, #12]
 810fc8c:	bf18      	it	ne
 810fc8e:	81a3      	strhne	r3, [r4, #12]
 810fc90:	bd10      	pop	{r4, pc}

0810fc92 <__sclose>:
 810fc92:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 810fc96:	f000 b82d 	b.w	810fcf4 <_close_r>

0810fc9a <memset>:
 810fc9a:	4402      	add	r2, r0
 810fc9c:	4603      	mov	r3, r0
 810fc9e:	4293      	cmp	r3, r2
 810fca0:	d100      	bne.n	810fca4 <memset+0xa>
 810fca2:	4770      	bx	lr
 810fca4:	f803 1b01 	strb.w	r1, [r3], #1
 810fca8:	e7f9      	b.n	810fc9e <memset+0x4>

0810fcaa <strncmp>:
 810fcaa:	b510      	push	{r4, lr}
 810fcac:	b16a      	cbz	r2, 810fcca <strncmp+0x20>
 810fcae:	3901      	subs	r1, #1
 810fcb0:	1884      	adds	r4, r0, r2
 810fcb2:	f810 2b01 	ldrb.w	r2, [r0], #1
 810fcb6:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 810fcba:	429a      	cmp	r2, r3
 810fcbc:	d103      	bne.n	810fcc6 <strncmp+0x1c>
 810fcbe:	42a0      	cmp	r0, r4
 810fcc0:	d001      	beq.n	810fcc6 <strncmp+0x1c>
 810fcc2:	2a00      	cmp	r2, #0
 810fcc4:	d1f5      	bne.n	810fcb2 <strncmp+0x8>
 810fcc6:	1ad0      	subs	r0, r2, r3
 810fcc8:	bd10      	pop	{r4, pc}
 810fcca:	4610      	mov	r0, r2
 810fccc:	e7fc      	b.n	810fcc8 <strncmp+0x1e>

0810fcce <strncpy>:
 810fcce:	b510      	push	{r4, lr}
 810fcd0:	3901      	subs	r1, #1
 810fcd2:	4603      	mov	r3, r0
 810fcd4:	b132      	cbz	r2, 810fce4 <strncpy+0x16>
 810fcd6:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 810fcda:	f803 4b01 	strb.w	r4, [r3], #1
 810fcde:	3a01      	subs	r2, #1
 810fce0:	2c00      	cmp	r4, #0
 810fce2:	d1f7      	bne.n	810fcd4 <strncpy+0x6>
 810fce4:	441a      	add	r2, r3
 810fce6:	2100      	movs	r1, #0
 810fce8:	4293      	cmp	r3, r2
 810fcea:	d100      	bne.n	810fcee <strncpy+0x20>
 810fcec:	bd10      	pop	{r4, pc}
 810fcee:	f803 1b01 	strb.w	r1, [r3], #1
 810fcf2:	e7f9      	b.n	810fce8 <strncpy+0x1a>

0810fcf4 <_close_r>:
 810fcf4:	b538      	push	{r3, r4, r5, lr}
 810fcf6:	4d06      	ldr	r5, [pc, #24]	@ (810fd10 <_close_r+0x1c>)
 810fcf8:	2300      	movs	r3, #0
 810fcfa:	4604      	mov	r4, r0
 810fcfc:	4608      	mov	r0, r1
 810fcfe:	602b      	str	r3, [r5, #0]
 810fd00:	f7f1 fc60 	bl	81015c4 <_close>
 810fd04:	1c43      	adds	r3, r0, #1
 810fd06:	d102      	bne.n	810fd0e <_close_r+0x1a>
 810fd08:	682b      	ldr	r3, [r5, #0]
 810fd0a:	b103      	cbz	r3, 810fd0e <_close_r+0x1a>
 810fd0c:	6023      	str	r3, [r4, #0]
 810fd0e:	bd38      	pop	{r3, r4, r5, pc}
 810fd10:	10005728 	.word	0x10005728

0810fd14 <_lseek_r>:
 810fd14:	b538      	push	{r3, r4, r5, lr}
 810fd16:	4d07      	ldr	r5, [pc, #28]	@ (810fd34 <_lseek_r+0x20>)
 810fd18:	4604      	mov	r4, r0
 810fd1a:	4608      	mov	r0, r1
 810fd1c:	4611      	mov	r1, r2
 810fd1e:	2200      	movs	r2, #0
 810fd20:	602a      	str	r2, [r5, #0]
 810fd22:	461a      	mov	r2, r3
 810fd24:	f7f1 fc75 	bl	8101612 <_lseek>
 810fd28:	1c43      	adds	r3, r0, #1
 810fd2a:	d102      	bne.n	810fd32 <_lseek_r+0x1e>
 810fd2c:	682b      	ldr	r3, [r5, #0]
 810fd2e:	b103      	cbz	r3, 810fd32 <_lseek_r+0x1e>
 810fd30:	6023      	str	r3, [r4, #0]
 810fd32:	bd38      	pop	{r3, r4, r5, pc}
 810fd34:	10005728 	.word	0x10005728

0810fd38 <_read_r>:
 810fd38:	b538      	push	{r3, r4, r5, lr}
 810fd3a:	4d07      	ldr	r5, [pc, #28]	@ (810fd58 <_read_r+0x20>)
 810fd3c:	4604      	mov	r4, r0
 810fd3e:	4608      	mov	r0, r1
 810fd40:	4611      	mov	r1, r2
 810fd42:	2200      	movs	r2, #0
 810fd44:	602a      	str	r2, [r5, #0]
 810fd46:	461a      	mov	r2, r3
 810fd48:	f7f1 fc03 	bl	8101552 <_read>
 810fd4c:	1c43      	adds	r3, r0, #1
 810fd4e:	d102      	bne.n	810fd56 <_read_r+0x1e>
 810fd50:	682b      	ldr	r3, [r5, #0]
 810fd52:	b103      	cbz	r3, 810fd56 <_read_r+0x1e>
 810fd54:	6023      	str	r3, [r4, #0]
 810fd56:	bd38      	pop	{r3, r4, r5, pc}
 810fd58:	10005728 	.word	0x10005728

0810fd5c <_sbrk_r>:
 810fd5c:	b538      	push	{r3, r4, r5, lr}
 810fd5e:	4d06      	ldr	r5, [pc, #24]	@ (810fd78 <_sbrk_r+0x1c>)
 810fd60:	2300      	movs	r3, #0
 810fd62:	4604      	mov	r4, r0
 810fd64:	4608      	mov	r0, r1
 810fd66:	602b      	str	r3, [r5, #0]
 810fd68:	f7f1 fc60 	bl	810162c <_sbrk>
 810fd6c:	1c43      	adds	r3, r0, #1
 810fd6e:	d102      	bne.n	810fd76 <_sbrk_r+0x1a>
 810fd70:	682b      	ldr	r3, [r5, #0]
 810fd72:	b103      	cbz	r3, 810fd76 <_sbrk_r+0x1a>
 810fd74:	6023      	str	r3, [r4, #0]
 810fd76:	bd38      	pop	{r3, r4, r5, pc}
 810fd78:	10005728 	.word	0x10005728

0810fd7c <_write_r>:
 810fd7c:	b538      	push	{r3, r4, r5, lr}
 810fd7e:	4d07      	ldr	r5, [pc, #28]	@ (810fd9c <_write_r+0x20>)
 810fd80:	4604      	mov	r4, r0
 810fd82:	4608      	mov	r0, r1
 810fd84:	4611      	mov	r1, r2
 810fd86:	2200      	movs	r2, #0
 810fd88:	602a      	str	r2, [r5, #0]
 810fd8a:	461a      	mov	r2, r3
 810fd8c:	f7f1 fbfe 	bl	810158c <_write>
 810fd90:	1c43      	adds	r3, r0, #1
 810fd92:	d102      	bne.n	810fd9a <_write_r+0x1e>
 810fd94:	682b      	ldr	r3, [r5, #0]
 810fd96:	b103      	cbz	r3, 810fd9a <_write_r+0x1e>
 810fd98:	6023      	str	r3, [r4, #0]
 810fd9a:	bd38      	pop	{r3, r4, r5, pc}
 810fd9c:	10005728 	.word	0x10005728

0810fda0 <__errno>:
 810fda0:	4b01      	ldr	r3, [pc, #4]	@ (810fda8 <__errno+0x8>)
 810fda2:	6818      	ldr	r0, [r3, #0]
 810fda4:	4770      	bx	lr
 810fda6:	bf00      	nop
 810fda8:	10000548 	.word	0x10000548

0810fdac <__libc_init_array>:
 810fdac:	b570      	push	{r4, r5, r6, lr}
 810fdae:	4d0d      	ldr	r5, [pc, #52]	@ (810fde4 <__libc_init_array+0x38>)
 810fdb0:	4c0d      	ldr	r4, [pc, #52]	@ (810fde8 <__libc_init_array+0x3c>)
 810fdb2:	1b64      	subs	r4, r4, r5
 810fdb4:	10a4      	asrs	r4, r4, #2
 810fdb6:	2600      	movs	r6, #0
 810fdb8:	42a6      	cmp	r6, r4
 810fdba:	d109      	bne.n	810fdd0 <__libc_init_array+0x24>
 810fdbc:	4d0b      	ldr	r5, [pc, #44]	@ (810fdec <__libc_init_array+0x40>)
 810fdbe:	4c0c      	ldr	r4, [pc, #48]	@ (810fdf0 <__libc_init_array+0x44>)
 810fdc0:	f000 fd52 	bl	8110868 <_init>
 810fdc4:	1b64      	subs	r4, r4, r5
 810fdc6:	10a4      	asrs	r4, r4, #2
 810fdc8:	2600      	movs	r6, #0
 810fdca:	42a6      	cmp	r6, r4
 810fdcc:	d105      	bne.n	810fdda <__libc_init_array+0x2e>
 810fdce:	bd70      	pop	{r4, r5, r6, pc}
 810fdd0:	f855 3b04 	ldr.w	r3, [r5], #4
 810fdd4:	4798      	blx	r3
 810fdd6:	3601      	adds	r6, #1
 810fdd8:	e7ee      	b.n	810fdb8 <__libc_init_array+0xc>
 810fdda:	f855 3b04 	ldr.w	r3, [r5], #4
 810fdde:	4798      	blx	r3
 810fde0:	3601      	adds	r6, #1
 810fde2:	e7f2      	b.n	810fdca <__libc_init_array+0x1e>
 810fde4:	081113e4 	.word	0x081113e4
 810fde8:	081113e4 	.word	0x081113e4
 810fdec:	081113e4 	.word	0x081113e4
 810fdf0:	081113e8 	.word	0x081113e8

0810fdf4 <__retarget_lock_init_recursive>:
 810fdf4:	4770      	bx	lr

0810fdf6 <__retarget_lock_acquire_recursive>:
 810fdf6:	4770      	bx	lr

0810fdf8 <__retarget_lock_release_recursive>:
 810fdf8:	4770      	bx	lr

0810fdfa <memcpy>:
 810fdfa:	440a      	add	r2, r1
 810fdfc:	4291      	cmp	r1, r2
 810fdfe:	f100 33ff 	add.w	r3, r0, #4294967295
 810fe02:	d100      	bne.n	810fe06 <memcpy+0xc>
 810fe04:	4770      	bx	lr
 810fe06:	b510      	push	{r4, lr}
 810fe08:	f811 4b01 	ldrb.w	r4, [r1], #1
 810fe0c:	f803 4f01 	strb.w	r4, [r3, #1]!
 810fe10:	4291      	cmp	r1, r2
 810fe12:	d1f9      	bne.n	810fe08 <memcpy+0xe>
 810fe14:	bd10      	pop	{r4, pc}

0810fe16 <abort>:
 810fe16:	b508      	push	{r3, lr}
 810fe18:	2006      	movs	r0, #6
 810fe1a:	f000 fc85 	bl	8110728 <raise>
 810fe1e:	2001      	movs	r0, #1
 810fe20:	f7f1 fb8c 	bl	810153c <_exit>

0810fe24 <_free_r>:
 810fe24:	b538      	push	{r3, r4, r5, lr}
 810fe26:	4605      	mov	r5, r0
 810fe28:	2900      	cmp	r1, #0
 810fe2a:	d041      	beq.n	810feb0 <_free_r+0x8c>
 810fe2c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 810fe30:	1f0c      	subs	r4, r1, #4
 810fe32:	2b00      	cmp	r3, #0
 810fe34:	bfb8      	it	lt
 810fe36:	18e4      	addlt	r4, r4, r3
 810fe38:	f7ff fe0c 	bl	810fa54 <__malloc_lock>
 810fe3c:	4a1d      	ldr	r2, [pc, #116]	@ (810feb4 <_free_r+0x90>)
 810fe3e:	6813      	ldr	r3, [r2, #0]
 810fe40:	b933      	cbnz	r3, 810fe50 <_free_r+0x2c>
 810fe42:	6063      	str	r3, [r4, #4]
 810fe44:	6014      	str	r4, [r2, #0]
 810fe46:	4628      	mov	r0, r5
 810fe48:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 810fe4c:	f7ff be08 	b.w	810fa60 <__malloc_unlock>
 810fe50:	42a3      	cmp	r3, r4
 810fe52:	d908      	bls.n	810fe66 <_free_r+0x42>
 810fe54:	6820      	ldr	r0, [r4, #0]
 810fe56:	1821      	adds	r1, r4, r0
 810fe58:	428b      	cmp	r3, r1
 810fe5a:	bf01      	itttt	eq
 810fe5c:	6819      	ldreq	r1, [r3, #0]
 810fe5e:	685b      	ldreq	r3, [r3, #4]
 810fe60:	1809      	addeq	r1, r1, r0
 810fe62:	6021      	streq	r1, [r4, #0]
 810fe64:	e7ed      	b.n	810fe42 <_free_r+0x1e>
 810fe66:	461a      	mov	r2, r3
 810fe68:	685b      	ldr	r3, [r3, #4]
 810fe6a:	b10b      	cbz	r3, 810fe70 <_free_r+0x4c>
 810fe6c:	42a3      	cmp	r3, r4
 810fe6e:	d9fa      	bls.n	810fe66 <_free_r+0x42>
 810fe70:	6811      	ldr	r1, [r2, #0]
 810fe72:	1850      	adds	r0, r2, r1
 810fe74:	42a0      	cmp	r0, r4
 810fe76:	d10b      	bne.n	810fe90 <_free_r+0x6c>
 810fe78:	6820      	ldr	r0, [r4, #0]
 810fe7a:	4401      	add	r1, r0
 810fe7c:	1850      	adds	r0, r2, r1
 810fe7e:	4283      	cmp	r3, r0
 810fe80:	6011      	str	r1, [r2, #0]
 810fe82:	d1e0      	bne.n	810fe46 <_free_r+0x22>
 810fe84:	6818      	ldr	r0, [r3, #0]
 810fe86:	685b      	ldr	r3, [r3, #4]
 810fe88:	6053      	str	r3, [r2, #4]
 810fe8a:	4408      	add	r0, r1
 810fe8c:	6010      	str	r0, [r2, #0]
 810fe8e:	e7da      	b.n	810fe46 <_free_r+0x22>
 810fe90:	d902      	bls.n	810fe98 <_free_r+0x74>
 810fe92:	230c      	movs	r3, #12
 810fe94:	602b      	str	r3, [r5, #0]
 810fe96:	e7d6      	b.n	810fe46 <_free_r+0x22>
 810fe98:	6820      	ldr	r0, [r4, #0]
 810fe9a:	1821      	adds	r1, r4, r0
 810fe9c:	428b      	cmp	r3, r1
 810fe9e:	bf04      	itt	eq
 810fea0:	6819      	ldreq	r1, [r3, #0]
 810fea2:	685b      	ldreq	r3, [r3, #4]
 810fea4:	6063      	str	r3, [r4, #4]
 810fea6:	bf04      	itt	eq
 810fea8:	1809      	addeq	r1, r1, r0
 810feaa:	6021      	streq	r1, [r4, #0]
 810feac:	6054      	str	r4, [r2, #4]
 810feae:	e7ca      	b.n	810fe46 <_free_r+0x22>
 810feb0:	bd38      	pop	{r3, r4, r5, pc}
 810feb2:	bf00      	nop
 810feb4:	100055e8 	.word	0x100055e8

0810feb8 <__sfputc_r>:
 810feb8:	6893      	ldr	r3, [r2, #8]
 810feba:	3b01      	subs	r3, #1
 810febc:	2b00      	cmp	r3, #0
 810febe:	b410      	push	{r4}
 810fec0:	6093      	str	r3, [r2, #8]
 810fec2:	da08      	bge.n	810fed6 <__sfputc_r+0x1e>
 810fec4:	6994      	ldr	r4, [r2, #24]
 810fec6:	42a3      	cmp	r3, r4
 810fec8:	db01      	blt.n	810fece <__sfputc_r+0x16>
 810feca:	290a      	cmp	r1, #10
 810fecc:	d103      	bne.n	810fed6 <__sfputc_r+0x1e>
 810fece:	f85d 4b04 	ldr.w	r4, [sp], #4
 810fed2:	f000 bb6d 	b.w	81105b0 <__swbuf_r>
 810fed6:	6813      	ldr	r3, [r2, #0]
 810fed8:	1c58      	adds	r0, r3, #1
 810feda:	6010      	str	r0, [r2, #0]
 810fedc:	7019      	strb	r1, [r3, #0]
 810fede:	4608      	mov	r0, r1
 810fee0:	f85d 4b04 	ldr.w	r4, [sp], #4
 810fee4:	4770      	bx	lr

0810fee6 <__sfputs_r>:
 810fee6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 810fee8:	4606      	mov	r6, r0
 810feea:	460f      	mov	r7, r1
 810feec:	4614      	mov	r4, r2
 810feee:	18d5      	adds	r5, r2, r3
 810fef0:	42ac      	cmp	r4, r5
 810fef2:	d101      	bne.n	810fef8 <__sfputs_r+0x12>
 810fef4:	2000      	movs	r0, #0
 810fef6:	e007      	b.n	810ff08 <__sfputs_r+0x22>
 810fef8:	f814 1b01 	ldrb.w	r1, [r4], #1
 810fefc:	463a      	mov	r2, r7
 810fefe:	4630      	mov	r0, r6
 810ff00:	f7ff ffda 	bl	810feb8 <__sfputc_r>
 810ff04:	1c43      	adds	r3, r0, #1
 810ff06:	d1f3      	bne.n	810fef0 <__sfputs_r+0xa>
 810ff08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

0810ff0c <_vfiprintf_r>:
 810ff0c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 810ff10:	460d      	mov	r5, r1
 810ff12:	b09d      	sub	sp, #116	@ 0x74
 810ff14:	4614      	mov	r4, r2
 810ff16:	4698      	mov	r8, r3
 810ff18:	4606      	mov	r6, r0
 810ff1a:	b118      	cbz	r0, 810ff24 <_vfiprintf_r+0x18>
 810ff1c:	6a03      	ldr	r3, [r0, #32]
 810ff1e:	b90b      	cbnz	r3, 810ff24 <_vfiprintf_r+0x18>
 810ff20:	f7ff fe30 	bl	810fb84 <__sinit>
 810ff24:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 810ff26:	07d9      	lsls	r1, r3, #31
 810ff28:	d405      	bmi.n	810ff36 <_vfiprintf_r+0x2a>
 810ff2a:	89ab      	ldrh	r3, [r5, #12]
 810ff2c:	059a      	lsls	r2, r3, #22
 810ff2e:	d402      	bmi.n	810ff36 <_vfiprintf_r+0x2a>
 810ff30:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 810ff32:	f7ff ff60 	bl	810fdf6 <__retarget_lock_acquire_recursive>
 810ff36:	89ab      	ldrh	r3, [r5, #12]
 810ff38:	071b      	lsls	r3, r3, #28
 810ff3a:	d501      	bpl.n	810ff40 <_vfiprintf_r+0x34>
 810ff3c:	692b      	ldr	r3, [r5, #16]
 810ff3e:	b99b      	cbnz	r3, 810ff68 <_vfiprintf_r+0x5c>
 810ff40:	4629      	mov	r1, r5
 810ff42:	4630      	mov	r0, r6
 810ff44:	f000 fb72 	bl	811062c <__swsetup_r>
 810ff48:	b170      	cbz	r0, 810ff68 <_vfiprintf_r+0x5c>
 810ff4a:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 810ff4c:	07dc      	lsls	r4, r3, #31
 810ff4e:	d504      	bpl.n	810ff5a <_vfiprintf_r+0x4e>
 810ff50:	f04f 30ff 	mov.w	r0, #4294967295
 810ff54:	b01d      	add	sp, #116	@ 0x74
 810ff56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 810ff5a:	89ab      	ldrh	r3, [r5, #12]
 810ff5c:	0598      	lsls	r0, r3, #22
 810ff5e:	d4f7      	bmi.n	810ff50 <_vfiprintf_r+0x44>
 810ff60:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 810ff62:	f7ff ff49 	bl	810fdf8 <__retarget_lock_release_recursive>
 810ff66:	e7f3      	b.n	810ff50 <_vfiprintf_r+0x44>
 810ff68:	2300      	movs	r3, #0
 810ff6a:	9309      	str	r3, [sp, #36]	@ 0x24
 810ff6c:	2320      	movs	r3, #32
 810ff6e:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
 810ff72:	f8cd 800c 	str.w	r8, [sp, #12]
 810ff76:	2330      	movs	r3, #48	@ 0x30
 810ff78:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 8110128 <_vfiprintf_r+0x21c>
 810ff7c:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
 810ff80:	f04f 0901 	mov.w	r9, #1
 810ff84:	4623      	mov	r3, r4
 810ff86:	469a      	mov	sl, r3
 810ff88:	f813 2b01 	ldrb.w	r2, [r3], #1
 810ff8c:	b10a      	cbz	r2, 810ff92 <_vfiprintf_r+0x86>
 810ff8e:	2a25      	cmp	r2, #37	@ 0x25
 810ff90:	d1f9      	bne.n	810ff86 <_vfiprintf_r+0x7a>
 810ff92:	ebba 0b04 	subs.w	fp, sl, r4
 810ff96:	d00b      	beq.n	810ffb0 <_vfiprintf_r+0xa4>
 810ff98:	465b      	mov	r3, fp
 810ff9a:	4622      	mov	r2, r4
 810ff9c:	4629      	mov	r1, r5
 810ff9e:	4630      	mov	r0, r6
 810ffa0:	f7ff ffa1 	bl	810fee6 <__sfputs_r>
 810ffa4:	3001      	adds	r0, #1
 810ffa6:	f000 80a7 	beq.w	81100f8 <_vfiprintf_r+0x1ec>
 810ffaa:	9a09      	ldr	r2, [sp, #36]	@ 0x24
 810ffac:	445a      	add	r2, fp
 810ffae:	9209      	str	r2, [sp, #36]	@ 0x24
 810ffb0:	f89a 3000 	ldrb.w	r3, [sl]
 810ffb4:	2b00      	cmp	r3, #0
 810ffb6:	f000 809f 	beq.w	81100f8 <_vfiprintf_r+0x1ec>
 810ffba:	2300      	movs	r3, #0
 810ffbc:	f04f 32ff 	mov.w	r2, #4294967295
 810ffc0:	e9cd 2305 	strd	r2, r3, [sp, #20]
 810ffc4:	f10a 0a01 	add.w	sl, sl, #1
 810ffc8:	9304      	str	r3, [sp, #16]
 810ffca:	9307      	str	r3, [sp, #28]
 810ffcc:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
 810ffd0:	931a      	str	r3, [sp, #104]	@ 0x68
 810ffd2:	4654      	mov	r4, sl
 810ffd4:	2205      	movs	r2, #5
 810ffd6:	f814 1b01 	ldrb.w	r1, [r4], #1
 810ffda:	4853      	ldr	r0, [pc, #332]	@ (8110128 <_vfiprintf_r+0x21c>)
 810ffdc:	f7f0 f998 	bl	8100310 <memchr>
 810ffe0:	9a04      	ldr	r2, [sp, #16]
 810ffe2:	b9d8      	cbnz	r0, 811001c <_vfiprintf_r+0x110>
 810ffe4:	06d1      	lsls	r1, r2, #27
 810ffe6:	bf44      	itt	mi
 810ffe8:	2320      	movmi	r3, #32
 810ffea:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 810ffee:	0713      	lsls	r3, r2, #28
 810fff0:	bf44      	itt	mi
 810fff2:	232b      	movmi	r3, #43	@ 0x2b
 810fff4:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
 810fff8:	f89a 3000 	ldrb.w	r3, [sl]
 810fffc:	2b2a      	cmp	r3, #42	@ 0x2a
 810fffe:	d015      	beq.n	811002c <_vfiprintf_r+0x120>
 8110000:	9a07      	ldr	r2, [sp, #28]
 8110002:	4654      	mov	r4, sl
 8110004:	2000      	movs	r0, #0
 8110006:	f04f 0c0a 	mov.w	ip, #10
 811000a:	4621      	mov	r1, r4
 811000c:	f811 3b01 	ldrb.w	r3, [r1], #1
 8110010:	3b30      	subs	r3, #48	@ 0x30
 8110012:	2b09      	cmp	r3, #9
 8110014:	d94b      	bls.n	81100ae <_vfiprintf_r+0x1a2>
 8110016:	b1b0      	cbz	r0, 8110046 <_vfiprintf_r+0x13a>
 8110018:	9207      	str	r2, [sp, #28]
 811001a:	e014      	b.n	8110046 <_vfiprintf_r+0x13a>
 811001c:	eba0 0308 	sub.w	r3, r0, r8
 8110020:	fa09 f303 	lsl.w	r3, r9, r3
 8110024:	4313      	orrs	r3, r2
 8110026:	9304      	str	r3, [sp, #16]
 8110028:	46a2      	mov	sl, r4
 811002a:	e7d2      	b.n	810ffd2 <_vfiprintf_r+0xc6>
 811002c:	9b03      	ldr	r3, [sp, #12]
 811002e:	1d19      	adds	r1, r3, #4
 8110030:	681b      	ldr	r3, [r3, #0]
 8110032:	9103      	str	r1, [sp, #12]
 8110034:	2b00      	cmp	r3, #0
 8110036:	bfbb      	ittet	lt
 8110038:	425b      	neglt	r3, r3
 811003a:	f042 0202 	orrlt.w	r2, r2, #2
 811003e:	9307      	strge	r3, [sp, #28]
 8110040:	9307      	strlt	r3, [sp, #28]
 8110042:	bfb8      	it	lt
 8110044:	9204      	strlt	r2, [sp, #16]
 8110046:	7823      	ldrb	r3, [r4, #0]
 8110048:	2b2e      	cmp	r3, #46	@ 0x2e
 811004a:	d10a      	bne.n	8110062 <_vfiprintf_r+0x156>
 811004c:	7863      	ldrb	r3, [r4, #1]
 811004e:	2b2a      	cmp	r3, #42	@ 0x2a
 8110050:	d132      	bne.n	81100b8 <_vfiprintf_r+0x1ac>
 8110052:	9b03      	ldr	r3, [sp, #12]
 8110054:	1d1a      	adds	r2, r3, #4
 8110056:	681b      	ldr	r3, [r3, #0]
 8110058:	9203      	str	r2, [sp, #12]
 811005a:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
 811005e:	3402      	adds	r4, #2
 8110060:	9305      	str	r3, [sp, #20]
 8110062:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 8110138 <_vfiprintf_r+0x22c>
 8110066:	7821      	ldrb	r1, [r4, #0]
 8110068:	2203      	movs	r2, #3
 811006a:	4650      	mov	r0, sl
 811006c:	f7f0 f950 	bl	8100310 <memchr>
 8110070:	b138      	cbz	r0, 8110082 <_vfiprintf_r+0x176>
 8110072:	9b04      	ldr	r3, [sp, #16]
 8110074:	eba0 000a 	sub.w	r0, r0, sl
 8110078:	2240      	movs	r2, #64	@ 0x40
 811007a:	4082      	lsls	r2, r0
 811007c:	4313      	orrs	r3, r2
 811007e:	3401      	adds	r4, #1
 8110080:	9304      	str	r3, [sp, #16]
 8110082:	f814 1b01 	ldrb.w	r1, [r4], #1
 8110086:	4829      	ldr	r0, [pc, #164]	@ (811012c <_vfiprintf_r+0x220>)
 8110088:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
 811008c:	2206      	movs	r2, #6
 811008e:	f7f0 f93f 	bl	8100310 <memchr>
 8110092:	2800      	cmp	r0, #0
 8110094:	d03f      	beq.n	8110116 <_vfiprintf_r+0x20a>
 8110096:	4b26      	ldr	r3, [pc, #152]	@ (8110130 <_vfiprintf_r+0x224>)
 8110098:	bb1b      	cbnz	r3, 81100e2 <_vfiprintf_r+0x1d6>
 811009a:	9b03      	ldr	r3, [sp, #12]
 811009c:	3307      	adds	r3, #7
 811009e:	f023 0307 	bic.w	r3, r3, #7
 81100a2:	3308      	adds	r3, #8
 81100a4:	9303      	str	r3, [sp, #12]
 81100a6:	9b09      	ldr	r3, [sp, #36]	@ 0x24
 81100a8:	443b      	add	r3, r7
 81100aa:	9309      	str	r3, [sp, #36]	@ 0x24
 81100ac:	e76a      	b.n	810ff84 <_vfiprintf_r+0x78>
 81100ae:	fb0c 3202 	mla	r2, ip, r2, r3
 81100b2:	460c      	mov	r4, r1
 81100b4:	2001      	movs	r0, #1
 81100b6:	e7a8      	b.n	811000a <_vfiprintf_r+0xfe>
 81100b8:	2300      	movs	r3, #0
 81100ba:	3401      	adds	r4, #1
 81100bc:	9305      	str	r3, [sp, #20]
 81100be:	4619      	mov	r1, r3
 81100c0:	f04f 0c0a 	mov.w	ip, #10
 81100c4:	4620      	mov	r0, r4
 81100c6:	f810 2b01 	ldrb.w	r2, [r0], #1
 81100ca:	3a30      	subs	r2, #48	@ 0x30
 81100cc:	2a09      	cmp	r2, #9
 81100ce:	d903      	bls.n	81100d8 <_vfiprintf_r+0x1cc>
 81100d0:	2b00      	cmp	r3, #0
 81100d2:	d0c6      	beq.n	8110062 <_vfiprintf_r+0x156>
 81100d4:	9105      	str	r1, [sp, #20]
 81100d6:	e7c4      	b.n	8110062 <_vfiprintf_r+0x156>
 81100d8:	fb0c 2101 	mla	r1, ip, r1, r2
 81100dc:	4604      	mov	r4, r0
 81100de:	2301      	movs	r3, #1
 81100e0:	e7f0      	b.n	81100c4 <_vfiprintf_r+0x1b8>
 81100e2:	ab03      	add	r3, sp, #12
 81100e4:	9300      	str	r3, [sp, #0]
 81100e6:	462a      	mov	r2, r5
 81100e8:	4b12      	ldr	r3, [pc, #72]	@ (8110134 <_vfiprintf_r+0x228>)
 81100ea:	a904      	add	r1, sp, #16
 81100ec:	4630      	mov	r0, r6
 81100ee:	f3af 8000 	nop.w
 81100f2:	4607      	mov	r7, r0
 81100f4:	1c78      	adds	r0, r7, #1
 81100f6:	d1d6      	bne.n	81100a6 <_vfiprintf_r+0x19a>
 81100f8:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
 81100fa:	07d9      	lsls	r1, r3, #31
 81100fc:	d405      	bmi.n	811010a <_vfiprintf_r+0x1fe>
 81100fe:	89ab      	ldrh	r3, [r5, #12]
 8110100:	059a      	lsls	r2, r3, #22
 8110102:	d402      	bmi.n	811010a <_vfiprintf_r+0x1fe>
 8110104:	6da8      	ldr	r0, [r5, #88]	@ 0x58
 8110106:	f7ff fe77 	bl	810fdf8 <__retarget_lock_release_recursive>
 811010a:	89ab      	ldrh	r3, [r5, #12]
 811010c:	065b      	lsls	r3, r3, #25
 811010e:	f53f af1f 	bmi.w	810ff50 <_vfiprintf_r+0x44>
 8110112:	9809      	ldr	r0, [sp, #36]	@ 0x24
 8110114:	e71e      	b.n	810ff54 <_vfiprintf_r+0x48>
 8110116:	ab03      	add	r3, sp, #12
 8110118:	9300      	str	r3, [sp, #0]
 811011a:	462a      	mov	r2, r5
 811011c:	4b05      	ldr	r3, [pc, #20]	@ (8110134 <_vfiprintf_r+0x228>)
 811011e:	a904      	add	r1, sp, #16
 8110120:	4630      	mov	r0, r6
 8110122:	f000 f879 	bl	8110218 <_printf_i>
 8110126:	e7e4      	b.n	81100f2 <_vfiprintf_r+0x1e6>
 8110128:	081113a6 	.word	0x081113a6
 811012c:	081113b0 	.word	0x081113b0
 8110130:	00000000 	.word	0x00000000
 8110134:	0810fee7 	.word	0x0810fee7
 8110138:	081113ac 	.word	0x081113ac

0811013c <_printf_common>:
 811013c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8110140:	4616      	mov	r6, r2
 8110142:	4698      	mov	r8, r3
 8110144:	688a      	ldr	r2, [r1, #8]
 8110146:	690b      	ldr	r3, [r1, #16]
 8110148:	f8dd 9020 	ldr.w	r9, [sp, #32]
 811014c:	4293      	cmp	r3, r2
 811014e:	bfb8      	it	lt
 8110150:	4613      	movlt	r3, r2
 8110152:	6033      	str	r3, [r6, #0]
 8110154:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
 8110158:	4607      	mov	r7, r0
 811015a:	460c      	mov	r4, r1
 811015c:	b10a      	cbz	r2, 8110162 <_printf_common+0x26>
 811015e:	3301      	adds	r3, #1
 8110160:	6033      	str	r3, [r6, #0]
 8110162:	6823      	ldr	r3, [r4, #0]
 8110164:	0699      	lsls	r1, r3, #26
 8110166:	bf42      	ittt	mi
 8110168:	6833      	ldrmi	r3, [r6, #0]
 811016a:	3302      	addmi	r3, #2
 811016c:	6033      	strmi	r3, [r6, #0]
 811016e:	6825      	ldr	r5, [r4, #0]
 8110170:	f015 0506 	ands.w	r5, r5, #6
 8110174:	d106      	bne.n	8110184 <_printf_common+0x48>
 8110176:	f104 0a19 	add.w	sl, r4, #25
 811017a:	68e3      	ldr	r3, [r4, #12]
 811017c:	6832      	ldr	r2, [r6, #0]
 811017e:	1a9b      	subs	r3, r3, r2
 8110180:	42ab      	cmp	r3, r5
 8110182:	dc26      	bgt.n	81101d2 <_printf_common+0x96>
 8110184:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
 8110188:	6822      	ldr	r2, [r4, #0]
 811018a:	3b00      	subs	r3, #0
 811018c:	bf18      	it	ne
 811018e:	2301      	movne	r3, #1
 8110190:	0692      	lsls	r2, r2, #26
 8110192:	d42b      	bmi.n	81101ec <_printf_common+0xb0>
 8110194:	f104 0243 	add.w	r2, r4, #67	@ 0x43
 8110198:	4641      	mov	r1, r8
 811019a:	4638      	mov	r0, r7
 811019c:	47c8      	blx	r9
 811019e:	3001      	adds	r0, #1
 81101a0:	d01e      	beq.n	81101e0 <_printf_common+0xa4>
 81101a2:	6823      	ldr	r3, [r4, #0]
 81101a4:	6922      	ldr	r2, [r4, #16]
 81101a6:	f003 0306 	and.w	r3, r3, #6
 81101aa:	2b04      	cmp	r3, #4
 81101ac:	bf02      	ittt	eq
 81101ae:	68e5      	ldreq	r5, [r4, #12]
 81101b0:	6833      	ldreq	r3, [r6, #0]
 81101b2:	1aed      	subeq	r5, r5, r3
 81101b4:	68a3      	ldr	r3, [r4, #8]
 81101b6:	bf0c      	ite	eq
 81101b8:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 81101bc:	2500      	movne	r5, #0
 81101be:	4293      	cmp	r3, r2
 81101c0:	bfc4      	itt	gt
 81101c2:	1a9b      	subgt	r3, r3, r2
 81101c4:	18ed      	addgt	r5, r5, r3
 81101c6:	2600      	movs	r6, #0
 81101c8:	341a      	adds	r4, #26
 81101ca:	42b5      	cmp	r5, r6
 81101cc:	d11a      	bne.n	8110204 <_printf_common+0xc8>
 81101ce:	2000      	movs	r0, #0
 81101d0:	e008      	b.n	81101e4 <_printf_common+0xa8>
 81101d2:	2301      	movs	r3, #1
 81101d4:	4652      	mov	r2, sl
 81101d6:	4641      	mov	r1, r8
 81101d8:	4638      	mov	r0, r7
 81101da:	47c8      	blx	r9
 81101dc:	3001      	adds	r0, #1
 81101de:	d103      	bne.n	81101e8 <_printf_common+0xac>
 81101e0:	f04f 30ff 	mov.w	r0, #4294967295
 81101e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 81101e8:	3501      	adds	r5, #1
 81101ea:	e7c6      	b.n	811017a <_printf_common+0x3e>
 81101ec:	18e1      	adds	r1, r4, r3
 81101ee:	1c5a      	adds	r2, r3, #1
 81101f0:	2030      	movs	r0, #48	@ 0x30
 81101f2:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
 81101f6:	4422      	add	r2, r4
 81101f8:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
 81101fc:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
 8110200:	3302      	adds	r3, #2
 8110202:	e7c7      	b.n	8110194 <_printf_common+0x58>
 8110204:	2301      	movs	r3, #1
 8110206:	4622      	mov	r2, r4
 8110208:	4641      	mov	r1, r8
 811020a:	4638      	mov	r0, r7
 811020c:	47c8      	blx	r9
 811020e:	3001      	adds	r0, #1
 8110210:	d0e6      	beq.n	81101e0 <_printf_common+0xa4>
 8110212:	3601      	adds	r6, #1
 8110214:	e7d9      	b.n	81101ca <_printf_common+0x8e>
	...

08110218 <_printf_i>:
 8110218:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 811021c:	7e0f      	ldrb	r7, [r1, #24]
 811021e:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
 8110220:	2f78      	cmp	r7, #120	@ 0x78
 8110222:	4691      	mov	r9, r2
 8110224:	4680      	mov	r8, r0
 8110226:	460c      	mov	r4, r1
 8110228:	469a      	mov	sl, r3
 811022a:	f101 0243 	add.w	r2, r1, #67	@ 0x43
 811022e:	d807      	bhi.n	8110240 <_printf_i+0x28>
 8110230:	2f62      	cmp	r7, #98	@ 0x62
 8110232:	d80a      	bhi.n	811024a <_printf_i+0x32>
 8110234:	2f00      	cmp	r7, #0
 8110236:	f000 80d2 	beq.w	81103de <_printf_i+0x1c6>
 811023a:	2f58      	cmp	r7, #88	@ 0x58
 811023c:	f000 80b9 	beq.w	81103b2 <_printf_i+0x19a>
 8110240:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 8110244:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
 8110248:	e03a      	b.n	81102c0 <_printf_i+0xa8>
 811024a:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
 811024e:	2b15      	cmp	r3, #21
 8110250:	d8f6      	bhi.n	8110240 <_printf_i+0x28>
 8110252:	a101      	add	r1, pc, #4	@ (adr r1, 8110258 <_printf_i+0x40>)
 8110254:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
 8110258:	081102b1 	.word	0x081102b1
 811025c:	081102c5 	.word	0x081102c5
 8110260:	08110241 	.word	0x08110241
 8110264:	08110241 	.word	0x08110241
 8110268:	08110241 	.word	0x08110241
 811026c:	08110241 	.word	0x08110241
 8110270:	081102c5 	.word	0x081102c5
 8110274:	08110241 	.word	0x08110241
 8110278:	08110241 	.word	0x08110241
 811027c:	08110241 	.word	0x08110241
 8110280:	08110241 	.word	0x08110241
 8110284:	081103c5 	.word	0x081103c5
 8110288:	081102ef 	.word	0x081102ef
 811028c:	0811037f 	.word	0x0811037f
 8110290:	08110241 	.word	0x08110241
 8110294:	08110241 	.word	0x08110241
 8110298:	081103e7 	.word	0x081103e7
 811029c:	08110241 	.word	0x08110241
 81102a0:	081102ef 	.word	0x081102ef
 81102a4:	08110241 	.word	0x08110241
 81102a8:	08110241 	.word	0x08110241
 81102ac:	08110387 	.word	0x08110387
 81102b0:	6833      	ldr	r3, [r6, #0]
 81102b2:	1d1a      	adds	r2, r3, #4
 81102b4:	681b      	ldr	r3, [r3, #0]
 81102b6:	6032      	str	r2, [r6, #0]
 81102b8:	f104 0642 	add.w	r6, r4, #66	@ 0x42
 81102bc:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 81102c0:	2301      	movs	r3, #1
 81102c2:	e09d      	b.n	8110400 <_printf_i+0x1e8>
 81102c4:	6833      	ldr	r3, [r6, #0]
 81102c6:	6820      	ldr	r0, [r4, #0]
 81102c8:	1d19      	adds	r1, r3, #4
 81102ca:	6031      	str	r1, [r6, #0]
 81102cc:	0606      	lsls	r6, r0, #24
 81102ce:	d501      	bpl.n	81102d4 <_printf_i+0xbc>
 81102d0:	681d      	ldr	r5, [r3, #0]
 81102d2:	e003      	b.n	81102dc <_printf_i+0xc4>
 81102d4:	0645      	lsls	r5, r0, #25
 81102d6:	d5fb      	bpl.n	81102d0 <_printf_i+0xb8>
 81102d8:	f9b3 5000 	ldrsh.w	r5, [r3]
 81102dc:	2d00      	cmp	r5, #0
 81102de:	da03      	bge.n	81102e8 <_printf_i+0xd0>
 81102e0:	232d      	movs	r3, #45	@ 0x2d
 81102e2:	426d      	negs	r5, r5
 81102e4:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 81102e8:	4859      	ldr	r0, [pc, #356]	@ (8110450 <_printf_i+0x238>)
 81102ea:	230a      	movs	r3, #10
 81102ec:	e011      	b.n	8110312 <_printf_i+0xfa>
 81102ee:	6821      	ldr	r1, [r4, #0]
 81102f0:	6833      	ldr	r3, [r6, #0]
 81102f2:	0608      	lsls	r0, r1, #24
 81102f4:	f853 5b04 	ldr.w	r5, [r3], #4
 81102f8:	d402      	bmi.n	8110300 <_printf_i+0xe8>
 81102fa:	0649      	lsls	r1, r1, #25
 81102fc:	bf48      	it	mi
 81102fe:	b2ad      	uxthmi	r5, r5
 8110300:	2f6f      	cmp	r7, #111	@ 0x6f
 8110302:	4853      	ldr	r0, [pc, #332]	@ (8110450 <_printf_i+0x238>)
 8110304:	6033      	str	r3, [r6, #0]
 8110306:	bf14      	ite	ne
 8110308:	230a      	movne	r3, #10
 811030a:	2308      	moveq	r3, #8
 811030c:	2100      	movs	r1, #0
 811030e:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
 8110312:	6866      	ldr	r6, [r4, #4]
 8110314:	60a6      	str	r6, [r4, #8]
 8110316:	2e00      	cmp	r6, #0
 8110318:	bfa2      	ittt	ge
 811031a:	6821      	ldrge	r1, [r4, #0]
 811031c:	f021 0104 	bicge.w	r1, r1, #4
 8110320:	6021      	strge	r1, [r4, #0]
 8110322:	b90d      	cbnz	r5, 8110328 <_printf_i+0x110>
 8110324:	2e00      	cmp	r6, #0
 8110326:	d04b      	beq.n	81103c0 <_printf_i+0x1a8>
 8110328:	4616      	mov	r6, r2
 811032a:	fbb5 f1f3 	udiv	r1, r5, r3
 811032e:	fb03 5711 	mls	r7, r3, r1, r5
 8110332:	5dc7      	ldrb	r7, [r0, r7]
 8110334:	f806 7d01 	strb.w	r7, [r6, #-1]!
 8110338:	462f      	mov	r7, r5
 811033a:	42bb      	cmp	r3, r7
 811033c:	460d      	mov	r5, r1
 811033e:	d9f4      	bls.n	811032a <_printf_i+0x112>
 8110340:	2b08      	cmp	r3, #8
 8110342:	d10b      	bne.n	811035c <_printf_i+0x144>
 8110344:	6823      	ldr	r3, [r4, #0]
 8110346:	07df      	lsls	r7, r3, #31
 8110348:	d508      	bpl.n	811035c <_printf_i+0x144>
 811034a:	6923      	ldr	r3, [r4, #16]
 811034c:	6861      	ldr	r1, [r4, #4]
 811034e:	4299      	cmp	r1, r3
 8110350:	bfde      	ittt	le
 8110352:	2330      	movle	r3, #48	@ 0x30
 8110354:	f806 3c01 	strble.w	r3, [r6, #-1]
 8110358:	f106 36ff 	addle.w	r6, r6, #4294967295
 811035c:	1b92      	subs	r2, r2, r6
 811035e:	6122      	str	r2, [r4, #16]
 8110360:	f8cd a000 	str.w	sl, [sp]
 8110364:	464b      	mov	r3, r9
 8110366:	aa03      	add	r2, sp, #12
 8110368:	4621      	mov	r1, r4
 811036a:	4640      	mov	r0, r8
 811036c:	f7ff fee6 	bl	811013c <_printf_common>
 8110370:	3001      	adds	r0, #1
 8110372:	d14a      	bne.n	811040a <_printf_i+0x1f2>
 8110374:	f04f 30ff 	mov.w	r0, #4294967295
 8110378:	b004      	add	sp, #16
 811037a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 811037e:	6823      	ldr	r3, [r4, #0]
 8110380:	f043 0320 	orr.w	r3, r3, #32
 8110384:	6023      	str	r3, [r4, #0]
 8110386:	4833      	ldr	r0, [pc, #204]	@ (8110454 <_printf_i+0x23c>)
 8110388:	2778      	movs	r7, #120	@ 0x78
 811038a:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
 811038e:	6823      	ldr	r3, [r4, #0]
 8110390:	6831      	ldr	r1, [r6, #0]
 8110392:	061f      	lsls	r7, r3, #24
 8110394:	f851 5b04 	ldr.w	r5, [r1], #4
 8110398:	d402      	bmi.n	81103a0 <_printf_i+0x188>
 811039a:	065f      	lsls	r7, r3, #25
 811039c:	bf48      	it	mi
 811039e:	b2ad      	uxthmi	r5, r5
 81103a0:	6031      	str	r1, [r6, #0]
 81103a2:	07d9      	lsls	r1, r3, #31
 81103a4:	bf44      	itt	mi
 81103a6:	f043 0320 	orrmi.w	r3, r3, #32
 81103aa:	6023      	strmi	r3, [r4, #0]
 81103ac:	b11d      	cbz	r5, 81103b6 <_printf_i+0x19e>
 81103ae:	2310      	movs	r3, #16
 81103b0:	e7ac      	b.n	811030c <_printf_i+0xf4>
 81103b2:	4827      	ldr	r0, [pc, #156]	@ (8110450 <_printf_i+0x238>)
 81103b4:	e7e9      	b.n	811038a <_printf_i+0x172>
 81103b6:	6823      	ldr	r3, [r4, #0]
 81103b8:	f023 0320 	bic.w	r3, r3, #32
 81103bc:	6023      	str	r3, [r4, #0]
 81103be:	e7f6      	b.n	81103ae <_printf_i+0x196>
 81103c0:	4616      	mov	r6, r2
 81103c2:	e7bd      	b.n	8110340 <_printf_i+0x128>
 81103c4:	6833      	ldr	r3, [r6, #0]
 81103c6:	6825      	ldr	r5, [r4, #0]
 81103c8:	6961      	ldr	r1, [r4, #20]
 81103ca:	1d18      	adds	r0, r3, #4
 81103cc:	6030      	str	r0, [r6, #0]
 81103ce:	062e      	lsls	r6, r5, #24
 81103d0:	681b      	ldr	r3, [r3, #0]
 81103d2:	d501      	bpl.n	81103d8 <_printf_i+0x1c0>
 81103d4:	6019      	str	r1, [r3, #0]
 81103d6:	e002      	b.n	81103de <_printf_i+0x1c6>
 81103d8:	0668      	lsls	r0, r5, #25
 81103da:	d5fb      	bpl.n	81103d4 <_printf_i+0x1bc>
 81103dc:	8019      	strh	r1, [r3, #0]
 81103de:	2300      	movs	r3, #0
 81103e0:	6123      	str	r3, [r4, #16]
 81103e2:	4616      	mov	r6, r2
 81103e4:	e7bc      	b.n	8110360 <_printf_i+0x148>
 81103e6:	6833      	ldr	r3, [r6, #0]
 81103e8:	1d1a      	adds	r2, r3, #4
 81103ea:	6032      	str	r2, [r6, #0]
 81103ec:	681e      	ldr	r6, [r3, #0]
 81103ee:	6862      	ldr	r2, [r4, #4]
 81103f0:	2100      	movs	r1, #0
 81103f2:	4630      	mov	r0, r6
 81103f4:	f7ef ff8c 	bl	8100310 <memchr>
 81103f8:	b108      	cbz	r0, 81103fe <_printf_i+0x1e6>
 81103fa:	1b80      	subs	r0, r0, r6
 81103fc:	6060      	str	r0, [r4, #4]
 81103fe:	6863      	ldr	r3, [r4, #4]
 8110400:	6123      	str	r3, [r4, #16]
 8110402:	2300      	movs	r3, #0
 8110404:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
 8110408:	e7aa      	b.n	8110360 <_printf_i+0x148>
 811040a:	6923      	ldr	r3, [r4, #16]
 811040c:	4632      	mov	r2, r6
 811040e:	4649      	mov	r1, r9
 8110410:	4640      	mov	r0, r8
 8110412:	47d0      	blx	sl
 8110414:	3001      	adds	r0, #1
 8110416:	d0ad      	beq.n	8110374 <_printf_i+0x15c>
 8110418:	6823      	ldr	r3, [r4, #0]
 811041a:	079b      	lsls	r3, r3, #30
 811041c:	d413      	bmi.n	8110446 <_printf_i+0x22e>
 811041e:	68e0      	ldr	r0, [r4, #12]
 8110420:	9b03      	ldr	r3, [sp, #12]
 8110422:	4298      	cmp	r0, r3
 8110424:	bfb8      	it	lt
 8110426:	4618      	movlt	r0, r3
 8110428:	e7a6      	b.n	8110378 <_printf_i+0x160>
 811042a:	2301      	movs	r3, #1
 811042c:	4632      	mov	r2, r6
 811042e:	4649      	mov	r1, r9
 8110430:	4640      	mov	r0, r8
 8110432:	47d0      	blx	sl
 8110434:	3001      	adds	r0, #1
 8110436:	d09d      	beq.n	8110374 <_printf_i+0x15c>
 8110438:	3501      	adds	r5, #1
 811043a:	68e3      	ldr	r3, [r4, #12]
 811043c:	9903      	ldr	r1, [sp, #12]
 811043e:	1a5b      	subs	r3, r3, r1
 8110440:	42ab      	cmp	r3, r5
 8110442:	dcf2      	bgt.n	811042a <_printf_i+0x212>
 8110444:	e7eb      	b.n	811041e <_printf_i+0x206>
 8110446:	2500      	movs	r5, #0
 8110448:	f104 0619 	add.w	r6, r4, #25
 811044c:	e7f5      	b.n	811043a <_printf_i+0x222>
 811044e:	bf00      	nop
 8110450:	081113b7 	.word	0x081113b7
 8110454:	081113c8 	.word	0x081113c8

08110458 <__sflush_r>:
 8110458:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
 811045c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8110460:	0716      	lsls	r6, r2, #28
 8110462:	4605      	mov	r5, r0
 8110464:	460c      	mov	r4, r1
 8110466:	d454      	bmi.n	8110512 <__sflush_r+0xba>
 8110468:	684b      	ldr	r3, [r1, #4]
 811046a:	2b00      	cmp	r3, #0
 811046c:	dc02      	bgt.n	8110474 <__sflush_r+0x1c>
 811046e:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
 8110470:	2b00      	cmp	r3, #0
 8110472:	dd48      	ble.n	8110506 <__sflush_r+0xae>
 8110474:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 8110476:	2e00      	cmp	r6, #0
 8110478:	d045      	beq.n	8110506 <__sflush_r+0xae>
 811047a:	2300      	movs	r3, #0
 811047c:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
 8110480:	682f      	ldr	r7, [r5, #0]
 8110482:	6a21      	ldr	r1, [r4, #32]
 8110484:	602b      	str	r3, [r5, #0]
 8110486:	d030      	beq.n	81104ea <__sflush_r+0x92>
 8110488:	6d62      	ldr	r2, [r4, #84]	@ 0x54
 811048a:	89a3      	ldrh	r3, [r4, #12]
 811048c:	0759      	lsls	r1, r3, #29
 811048e:	d505      	bpl.n	811049c <__sflush_r+0x44>
 8110490:	6863      	ldr	r3, [r4, #4]
 8110492:	1ad2      	subs	r2, r2, r3
 8110494:	6b63      	ldr	r3, [r4, #52]	@ 0x34
 8110496:	b10b      	cbz	r3, 811049c <__sflush_r+0x44>
 8110498:	6c23      	ldr	r3, [r4, #64]	@ 0x40
 811049a:	1ad2      	subs	r2, r2, r3
 811049c:	2300      	movs	r3, #0
 811049e:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
 81104a0:	6a21      	ldr	r1, [r4, #32]
 81104a2:	4628      	mov	r0, r5
 81104a4:	47b0      	blx	r6
 81104a6:	1c43      	adds	r3, r0, #1
 81104a8:	89a3      	ldrh	r3, [r4, #12]
 81104aa:	d106      	bne.n	81104ba <__sflush_r+0x62>
 81104ac:	6829      	ldr	r1, [r5, #0]
 81104ae:	291d      	cmp	r1, #29
 81104b0:	d82b      	bhi.n	811050a <__sflush_r+0xb2>
 81104b2:	4a2a      	ldr	r2, [pc, #168]	@ (811055c <__sflush_r+0x104>)
 81104b4:	410a      	asrs	r2, r1
 81104b6:	07d6      	lsls	r6, r2, #31
 81104b8:	d427      	bmi.n	811050a <__sflush_r+0xb2>
 81104ba:	2200      	movs	r2, #0
 81104bc:	6062      	str	r2, [r4, #4]
 81104be:	04d9      	lsls	r1, r3, #19
 81104c0:	6922      	ldr	r2, [r4, #16]
 81104c2:	6022      	str	r2, [r4, #0]
 81104c4:	d504      	bpl.n	81104d0 <__sflush_r+0x78>
 81104c6:	1c42      	adds	r2, r0, #1
 81104c8:	d101      	bne.n	81104ce <__sflush_r+0x76>
 81104ca:	682b      	ldr	r3, [r5, #0]
 81104cc:	b903      	cbnz	r3, 81104d0 <__sflush_r+0x78>
 81104ce:	6560      	str	r0, [r4, #84]	@ 0x54
 81104d0:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 81104d2:	602f      	str	r7, [r5, #0]
 81104d4:	b1b9      	cbz	r1, 8110506 <__sflush_r+0xae>
 81104d6:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 81104da:	4299      	cmp	r1, r3
 81104dc:	d002      	beq.n	81104e4 <__sflush_r+0x8c>
 81104de:	4628      	mov	r0, r5
 81104e0:	f7ff fca0 	bl	810fe24 <_free_r>
 81104e4:	2300      	movs	r3, #0
 81104e6:	6363      	str	r3, [r4, #52]	@ 0x34
 81104e8:	e00d      	b.n	8110506 <__sflush_r+0xae>
 81104ea:	2301      	movs	r3, #1
 81104ec:	4628      	mov	r0, r5
 81104ee:	47b0      	blx	r6
 81104f0:	4602      	mov	r2, r0
 81104f2:	1c50      	adds	r0, r2, #1
 81104f4:	d1c9      	bne.n	811048a <__sflush_r+0x32>
 81104f6:	682b      	ldr	r3, [r5, #0]
 81104f8:	2b00      	cmp	r3, #0
 81104fa:	d0c6      	beq.n	811048a <__sflush_r+0x32>
 81104fc:	2b1d      	cmp	r3, #29
 81104fe:	d001      	beq.n	8110504 <__sflush_r+0xac>
 8110500:	2b16      	cmp	r3, #22
 8110502:	d11e      	bne.n	8110542 <__sflush_r+0xea>
 8110504:	602f      	str	r7, [r5, #0]
 8110506:	2000      	movs	r0, #0
 8110508:	e022      	b.n	8110550 <__sflush_r+0xf8>
 811050a:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 811050e:	b21b      	sxth	r3, r3
 8110510:	e01b      	b.n	811054a <__sflush_r+0xf2>
 8110512:	690f      	ldr	r7, [r1, #16]
 8110514:	2f00      	cmp	r7, #0
 8110516:	d0f6      	beq.n	8110506 <__sflush_r+0xae>
 8110518:	0793      	lsls	r3, r2, #30
 811051a:	680e      	ldr	r6, [r1, #0]
 811051c:	bf08      	it	eq
 811051e:	694b      	ldreq	r3, [r1, #20]
 8110520:	600f      	str	r7, [r1, #0]
 8110522:	bf18      	it	ne
 8110524:	2300      	movne	r3, #0
 8110526:	eba6 0807 	sub.w	r8, r6, r7
 811052a:	608b      	str	r3, [r1, #8]
 811052c:	f1b8 0f00 	cmp.w	r8, #0
 8110530:	dde9      	ble.n	8110506 <__sflush_r+0xae>
 8110532:	6a21      	ldr	r1, [r4, #32]
 8110534:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
 8110536:	4643      	mov	r3, r8
 8110538:	463a      	mov	r2, r7
 811053a:	4628      	mov	r0, r5
 811053c:	47b0      	blx	r6
 811053e:	2800      	cmp	r0, #0
 8110540:	dc08      	bgt.n	8110554 <__sflush_r+0xfc>
 8110542:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8110546:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 811054a:	81a3      	strh	r3, [r4, #12]
 811054c:	f04f 30ff 	mov.w	r0, #4294967295
 8110550:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8110554:	4407      	add	r7, r0
 8110556:	eba8 0800 	sub.w	r8, r8, r0
 811055a:	e7e7      	b.n	811052c <__sflush_r+0xd4>
 811055c:	dfbffffe 	.word	0xdfbffffe

08110560 <_fflush_r>:
 8110560:	b538      	push	{r3, r4, r5, lr}
 8110562:	690b      	ldr	r3, [r1, #16]
 8110564:	4605      	mov	r5, r0
 8110566:	460c      	mov	r4, r1
 8110568:	b913      	cbnz	r3, 8110570 <_fflush_r+0x10>
 811056a:	2500      	movs	r5, #0
 811056c:	4628      	mov	r0, r5
 811056e:	bd38      	pop	{r3, r4, r5, pc}
 8110570:	b118      	cbz	r0, 811057a <_fflush_r+0x1a>
 8110572:	6a03      	ldr	r3, [r0, #32]
 8110574:	b90b      	cbnz	r3, 811057a <_fflush_r+0x1a>
 8110576:	f7ff fb05 	bl	810fb84 <__sinit>
 811057a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 811057e:	2b00      	cmp	r3, #0
 8110580:	d0f3      	beq.n	811056a <_fflush_r+0xa>
 8110582:	6e62      	ldr	r2, [r4, #100]	@ 0x64
 8110584:	07d0      	lsls	r0, r2, #31
 8110586:	d404      	bmi.n	8110592 <_fflush_r+0x32>
 8110588:	0599      	lsls	r1, r3, #22
 811058a:	d402      	bmi.n	8110592 <_fflush_r+0x32>
 811058c:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 811058e:	f7ff fc32 	bl	810fdf6 <__retarget_lock_acquire_recursive>
 8110592:	4628      	mov	r0, r5
 8110594:	4621      	mov	r1, r4
 8110596:	f7ff ff5f 	bl	8110458 <__sflush_r>
 811059a:	6e63      	ldr	r3, [r4, #100]	@ 0x64
 811059c:	07da      	lsls	r2, r3, #31
 811059e:	4605      	mov	r5, r0
 81105a0:	d4e4      	bmi.n	811056c <_fflush_r+0xc>
 81105a2:	89a3      	ldrh	r3, [r4, #12]
 81105a4:	059b      	lsls	r3, r3, #22
 81105a6:	d4e1      	bmi.n	811056c <_fflush_r+0xc>
 81105a8:	6da0      	ldr	r0, [r4, #88]	@ 0x58
 81105aa:	f7ff fc25 	bl	810fdf8 <__retarget_lock_release_recursive>
 81105ae:	e7dd      	b.n	811056c <_fflush_r+0xc>

081105b0 <__swbuf_r>:
 81105b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 81105b2:	460e      	mov	r6, r1
 81105b4:	4614      	mov	r4, r2
 81105b6:	4605      	mov	r5, r0
 81105b8:	b118      	cbz	r0, 81105c2 <__swbuf_r+0x12>
 81105ba:	6a03      	ldr	r3, [r0, #32]
 81105bc:	b90b      	cbnz	r3, 81105c2 <__swbuf_r+0x12>
 81105be:	f7ff fae1 	bl	810fb84 <__sinit>
 81105c2:	69a3      	ldr	r3, [r4, #24]
 81105c4:	60a3      	str	r3, [r4, #8]
 81105c6:	89a3      	ldrh	r3, [r4, #12]
 81105c8:	071a      	lsls	r2, r3, #28
 81105ca:	d501      	bpl.n	81105d0 <__swbuf_r+0x20>
 81105cc:	6923      	ldr	r3, [r4, #16]
 81105ce:	b943      	cbnz	r3, 81105e2 <__swbuf_r+0x32>
 81105d0:	4621      	mov	r1, r4
 81105d2:	4628      	mov	r0, r5
 81105d4:	f000 f82a 	bl	811062c <__swsetup_r>
 81105d8:	b118      	cbz	r0, 81105e2 <__swbuf_r+0x32>
 81105da:	f04f 37ff 	mov.w	r7, #4294967295
 81105de:	4638      	mov	r0, r7
 81105e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 81105e2:	6823      	ldr	r3, [r4, #0]
 81105e4:	6922      	ldr	r2, [r4, #16]
 81105e6:	1a98      	subs	r0, r3, r2
 81105e8:	6963      	ldr	r3, [r4, #20]
 81105ea:	b2f6      	uxtb	r6, r6
 81105ec:	4283      	cmp	r3, r0
 81105ee:	4637      	mov	r7, r6
 81105f0:	dc05      	bgt.n	81105fe <__swbuf_r+0x4e>
 81105f2:	4621      	mov	r1, r4
 81105f4:	4628      	mov	r0, r5
 81105f6:	f7ff ffb3 	bl	8110560 <_fflush_r>
 81105fa:	2800      	cmp	r0, #0
 81105fc:	d1ed      	bne.n	81105da <__swbuf_r+0x2a>
 81105fe:	68a3      	ldr	r3, [r4, #8]
 8110600:	3b01      	subs	r3, #1
 8110602:	60a3      	str	r3, [r4, #8]
 8110604:	6823      	ldr	r3, [r4, #0]
 8110606:	1c5a      	adds	r2, r3, #1
 8110608:	6022      	str	r2, [r4, #0]
 811060a:	701e      	strb	r6, [r3, #0]
 811060c:	6962      	ldr	r2, [r4, #20]
 811060e:	1c43      	adds	r3, r0, #1
 8110610:	429a      	cmp	r2, r3
 8110612:	d004      	beq.n	811061e <__swbuf_r+0x6e>
 8110614:	89a3      	ldrh	r3, [r4, #12]
 8110616:	07db      	lsls	r3, r3, #31
 8110618:	d5e1      	bpl.n	81105de <__swbuf_r+0x2e>
 811061a:	2e0a      	cmp	r6, #10
 811061c:	d1df      	bne.n	81105de <__swbuf_r+0x2e>
 811061e:	4621      	mov	r1, r4
 8110620:	4628      	mov	r0, r5
 8110622:	f7ff ff9d 	bl	8110560 <_fflush_r>
 8110626:	2800      	cmp	r0, #0
 8110628:	d0d9      	beq.n	81105de <__swbuf_r+0x2e>
 811062a:	e7d6      	b.n	81105da <__swbuf_r+0x2a>

0811062c <__swsetup_r>:
 811062c:	b538      	push	{r3, r4, r5, lr}
 811062e:	4b29      	ldr	r3, [pc, #164]	@ (81106d4 <__swsetup_r+0xa8>)
 8110630:	4605      	mov	r5, r0
 8110632:	6818      	ldr	r0, [r3, #0]
 8110634:	460c      	mov	r4, r1
 8110636:	b118      	cbz	r0, 8110640 <__swsetup_r+0x14>
 8110638:	6a03      	ldr	r3, [r0, #32]
 811063a:	b90b      	cbnz	r3, 8110640 <__swsetup_r+0x14>
 811063c:	f7ff faa2 	bl	810fb84 <__sinit>
 8110640:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8110644:	0719      	lsls	r1, r3, #28
 8110646:	d422      	bmi.n	811068e <__swsetup_r+0x62>
 8110648:	06da      	lsls	r2, r3, #27
 811064a:	d407      	bmi.n	811065c <__swsetup_r+0x30>
 811064c:	2209      	movs	r2, #9
 811064e:	602a      	str	r2, [r5, #0]
 8110650:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8110654:	81a3      	strh	r3, [r4, #12]
 8110656:	f04f 30ff 	mov.w	r0, #4294967295
 811065a:	e033      	b.n	81106c4 <__swsetup_r+0x98>
 811065c:	0758      	lsls	r0, r3, #29
 811065e:	d512      	bpl.n	8110686 <__swsetup_r+0x5a>
 8110660:	6b61      	ldr	r1, [r4, #52]	@ 0x34
 8110662:	b141      	cbz	r1, 8110676 <__swsetup_r+0x4a>
 8110664:	f104 0344 	add.w	r3, r4, #68	@ 0x44
 8110668:	4299      	cmp	r1, r3
 811066a:	d002      	beq.n	8110672 <__swsetup_r+0x46>
 811066c:	4628      	mov	r0, r5
 811066e:	f7ff fbd9 	bl	810fe24 <_free_r>
 8110672:	2300      	movs	r3, #0
 8110674:	6363      	str	r3, [r4, #52]	@ 0x34
 8110676:	89a3      	ldrh	r3, [r4, #12]
 8110678:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
 811067c:	81a3      	strh	r3, [r4, #12]
 811067e:	2300      	movs	r3, #0
 8110680:	6063      	str	r3, [r4, #4]
 8110682:	6923      	ldr	r3, [r4, #16]
 8110684:	6023      	str	r3, [r4, #0]
 8110686:	89a3      	ldrh	r3, [r4, #12]
 8110688:	f043 0308 	orr.w	r3, r3, #8
 811068c:	81a3      	strh	r3, [r4, #12]
 811068e:	6923      	ldr	r3, [r4, #16]
 8110690:	b94b      	cbnz	r3, 81106a6 <__swsetup_r+0x7a>
 8110692:	89a3      	ldrh	r3, [r4, #12]
 8110694:	f403 7320 	and.w	r3, r3, #640	@ 0x280
 8110698:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
 811069c:	d003      	beq.n	81106a6 <__swsetup_r+0x7a>
 811069e:	4621      	mov	r1, r4
 81106a0:	4628      	mov	r0, r5
 81106a2:	f000 f883 	bl	81107ac <__smakebuf_r>
 81106a6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 81106aa:	f013 0201 	ands.w	r2, r3, #1
 81106ae:	d00a      	beq.n	81106c6 <__swsetup_r+0x9a>
 81106b0:	2200      	movs	r2, #0
 81106b2:	60a2      	str	r2, [r4, #8]
 81106b4:	6962      	ldr	r2, [r4, #20]
 81106b6:	4252      	negs	r2, r2
 81106b8:	61a2      	str	r2, [r4, #24]
 81106ba:	6922      	ldr	r2, [r4, #16]
 81106bc:	b942      	cbnz	r2, 81106d0 <__swsetup_r+0xa4>
 81106be:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
 81106c2:	d1c5      	bne.n	8110650 <__swsetup_r+0x24>
 81106c4:	bd38      	pop	{r3, r4, r5, pc}
 81106c6:	0799      	lsls	r1, r3, #30
 81106c8:	bf58      	it	pl
 81106ca:	6962      	ldrpl	r2, [r4, #20]
 81106cc:	60a2      	str	r2, [r4, #8]
 81106ce:	e7f4      	b.n	81106ba <__swsetup_r+0x8e>
 81106d0:	2000      	movs	r0, #0
 81106d2:	e7f7      	b.n	81106c4 <__swsetup_r+0x98>
 81106d4:	10000548 	.word	0x10000548

081106d8 <_raise_r>:
 81106d8:	291f      	cmp	r1, #31
 81106da:	b538      	push	{r3, r4, r5, lr}
 81106dc:	4605      	mov	r5, r0
 81106de:	460c      	mov	r4, r1
 81106e0:	d904      	bls.n	81106ec <_raise_r+0x14>
 81106e2:	2316      	movs	r3, #22
 81106e4:	6003      	str	r3, [r0, #0]
 81106e6:	f04f 30ff 	mov.w	r0, #4294967295
 81106ea:	bd38      	pop	{r3, r4, r5, pc}
 81106ec:	6bc2      	ldr	r2, [r0, #60]	@ 0x3c
 81106ee:	b112      	cbz	r2, 81106f6 <_raise_r+0x1e>
 81106f0:	f852 3021 	ldr.w	r3, [r2, r1, lsl #2]
 81106f4:	b94b      	cbnz	r3, 811070a <_raise_r+0x32>
 81106f6:	4628      	mov	r0, r5
 81106f8:	f000 f830 	bl	811075c <_getpid_r>
 81106fc:	4622      	mov	r2, r4
 81106fe:	4601      	mov	r1, r0
 8110700:	4628      	mov	r0, r5
 8110702:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8110706:	f000 b817 	b.w	8110738 <_kill_r>
 811070a:	2b01      	cmp	r3, #1
 811070c:	d00a      	beq.n	8110724 <_raise_r+0x4c>
 811070e:	1c59      	adds	r1, r3, #1
 8110710:	d103      	bne.n	811071a <_raise_r+0x42>
 8110712:	2316      	movs	r3, #22
 8110714:	6003      	str	r3, [r0, #0]
 8110716:	2001      	movs	r0, #1
 8110718:	e7e7      	b.n	81106ea <_raise_r+0x12>
 811071a:	2100      	movs	r1, #0
 811071c:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
 8110720:	4620      	mov	r0, r4
 8110722:	4798      	blx	r3
 8110724:	2000      	movs	r0, #0
 8110726:	e7e0      	b.n	81106ea <_raise_r+0x12>

08110728 <raise>:
 8110728:	4b02      	ldr	r3, [pc, #8]	@ (8110734 <raise+0xc>)
 811072a:	4601      	mov	r1, r0
 811072c:	6818      	ldr	r0, [r3, #0]
 811072e:	f7ff bfd3 	b.w	81106d8 <_raise_r>
 8110732:	bf00      	nop
 8110734:	10000548 	.word	0x10000548

08110738 <_kill_r>:
 8110738:	b538      	push	{r3, r4, r5, lr}
 811073a:	4d07      	ldr	r5, [pc, #28]	@ (8110758 <_kill_r+0x20>)
 811073c:	2300      	movs	r3, #0
 811073e:	4604      	mov	r4, r0
 8110740:	4608      	mov	r0, r1
 8110742:	4611      	mov	r1, r2
 8110744:	602b      	str	r3, [r5, #0]
 8110746:	f7f0 fee9 	bl	810151c <_kill>
 811074a:	1c43      	adds	r3, r0, #1
 811074c:	d102      	bne.n	8110754 <_kill_r+0x1c>
 811074e:	682b      	ldr	r3, [r5, #0]
 8110750:	b103      	cbz	r3, 8110754 <_kill_r+0x1c>
 8110752:	6023      	str	r3, [r4, #0]
 8110754:	bd38      	pop	{r3, r4, r5, pc}
 8110756:	bf00      	nop
 8110758:	10005728 	.word	0x10005728

0811075c <_getpid_r>:
 811075c:	f7f0 bed6 	b.w	810150c <_getpid>

08110760 <__swhatbuf_r>:
 8110760:	b570      	push	{r4, r5, r6, lr}
 8110762:	460c      	mov	r4, r1
 8110764:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8110768:	2900      	cmp	r1, #0
 811076a:	b096      	sub	sp, #88	@ 0x58
 811076c:	4615      	mov	r5, r2
 811076e:	461e      	mov	r6, r3
 8110770:	da0d      	bge.n	811078e <__swhatbuf_r+0x2e>
 8110772:	89a3      	ldrh	r3, [r4, #12]
 8110774:	f013 0f80 	tst.w	r3, #128	@ 0x80
 8110778:	f04f 0100 	mov.w	r1, #0
 811077c:	bf14      	ite	ne
 811077e:	2340      	movne	r3, #64	@ 0x40
 8110780:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
 8110784:	2000      	movs	r0, #0
 8110786:	6031      	str	r1, [r6, #0]
 8110788:	602b      	str	r3, [r5, #0]
 811078a:	b016      	add	sp, #88	@ 0x58
 811078c:	bd70      	pop	{r4, r5, r6, pc}
 811078e:	466a      	mov	r2, sp
 8110790:	f000 f848 	bl	8110824 <_fstat_r>
 8110794:	2800      	cmp	r0, #0
 8110796:	dbec      	blt.n	8110772 <__swhatbuf_r+0x12>
 8110798:	9901      	ldr	r1, [sp, #4]
 811079a:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
 811079e:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
 81107a2:	4259      	negs	r1, r3
 81107a4:	4159      	adcs	r1, r3
 81107a6:	f44f 6380 	mov.w	r3, #1024	@ 0x400
 81107aa:	e7eb      	b.n	8110784 <__swhatbuf_r+0x24>

081107ac <__smakebuf_r>:
 81107ac:	898b      	ldrh	r3, [r1, #12]
 81107ae:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 81107b0:	079d      	lsls	r5, r3, #30
 81107b2:	4606      	mov	r6, r0
 81107b4:	460c      	mov	r4, r1
 81107b6:	d507      	bpl.n	81107c8 <__smakebuf_r+0x1c>
 81107b8:	f104 0347 	add.w	r3, r4, #71	@ 0x47
 81107bc:	6023      	str	r3, [r4, #0]
 81107be:	6123      	str	r3, [r4, #16]
 81107c0:	2301      	movs	r3, #1
 81107c2:	6163      	str	r3, [r4, #20]
 81107c4:	b003      	add	sp, #12
 81107c6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 81107c8:	ab01      	add	r3, sp, #4
 81107ca:	466a      	mov	r2, sp
 81107cc:	f7ff ffc8 	bl	8110760 <__swhatbuf_r>
 81107d0:	9f00      	ldr	r7, [sp, #0]
 81107d2:	4605      	mov	r5, r0
 81107d4:	4639      	mov	r1, r7
 81107d6:	4630      	mov	r0, r6
 81107d8:	f7ff f8bc 	bl	810f954 <_malloc_r>
 81107dc:	b948      	cbnz	r0, 81107f2 <__smakebuf_r+0x46>
 81107de:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 81107e2:	059a      	lsls	r2, r3, #22
 81107e4:	d4ee      	bmi.n	81107c4 <__smakebuf_r+0x18>
 81107e6:	f023 0303 	bic.w	r3, r3, #3
 81107ea:	f043 0302 	orr.w	r3, r3, #2
 81107ee:	81a3      	strh	r3, [r4, #12]
 81107f0:	e7e2      	b.n	81107b8 <__smakebuf_r+0xc>
 81107f2:	89a3      	ldrh	r3, [r4, #12]
 81107f4:	6020      	str	r0, [r4, #0]
 81107f6:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 81107fa:	81a3      	strh	r3, [r4, #12]
 81107fc:	9b01      	ldr	r3, [sp, #4]
 81107fe:	e9c4 0704 	strd	r0, r7, [r4, #16]
 8110802:	b15b      	cbz	r3, 811081c <__smakebuf_r+0x70>
 8110804:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8110808:	4630      	mov	r0, r6
 811080a:	f000 f81d 	bl	8110848 <_isatty_r>
 811080e:	b128      	cbz	r0, 811081c <__smakebuf_r+0x70>
 8110810:	89a3      	ldrh	r3, [r4, #12]
 8110812:	f023 0303 	bic.w	r3, r3, #3
 8110816:	f043 0301 	orr.w	r3, r3, #1
 811081a:	81a3      	strh	r3, [r4, #12]
 811081c:	89a3      	ldrh	r3, [r4, #12]
 811081e:	431d      	orrs	r5, r3
 8110820:	81a5      	strh	r5, [r4, #12]
 8110822:	e7cf      	b.n	81107c4 <__smakebuf_r+0x18>

08110824 <_fstat_r>:
 8110824:	b538      	push	{r3, r4, r5, lr}
 8110826:	4d07      	ldr	r5, [pc, #28]	@ (8110844 <_fstat_r+0x20>)
 8110828:	2300      	movs	r3, #0
 811082a:	4604      	mov	r4, r0
 811082c:	4608      	mov	r0, r1
 811082e:	4611      	mov	r1, r2
 8110830:	602b      	str	r3, [r5, #0]
 8110832:	f7f0 fed3 	bl	81015dc <_fstat>
 8110836:	1c43      	adds	r3, r0, #1
 8110838:	d102      	bne.n	8110840 <_fstat_r+0x1c>
 811083a:	682b      	ldr	r3, [r5, #0]
 811083c:	b103      	cbz	r3, 8110840 <_fstat_r+0x1c>
 811083e:	6023      	str	r3, [r4, #0]
 8110840:	bd38      	pop	{r3, r4, r5, pc}
 8110842:	bf00      	nop
 8110844:	10005728 	.word	0x10005728

08110848 <_isatty_r>:
 8110848:	b538      	push	{r3, r4, r5, lr}
 811084a:	4d06      	ldr	r5, [pc, #24]	@ (8110864 <_isatty_r+0x1c>)
 811084c:	2300      	movs	r3, #0
 811084e:	4604      	mov	r4, r0
 8110850:	4608      	mov	r0, r1
 8110852:	602b      	str	r3, [r5, #0]
 8110854:	f7f0 fed2 	bl	81015fc <_isatty>
 8110858:	1c43      	adds	r3, r0, #1
 811085a:	d102      	bne.n	8110862 <_isatty_r+0x1a>
 811085c:	682b      	ldr	r3, [r5, #0]
 811085e:	b103      	cbz	r3, 8110862 <_isatty_r+0x1a>
 8110860:	6023      	str	r3, [r4, #0]
 8110862:	bd38      	pop	{r3, r4, r5, pc}
 8110864:	10005728 	.word	0x10005728

08110868 <_init>:
 8110868:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 811086a:	bf00      	nop
 811086c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 811086e:	bc08      	pop	{r3}
 8110870:	469e      	mov	lr, r3
 8110872:	4770      	bx	lr

08110874 <_fini>:
 8110874:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8110876:	bf00      	nop
 8110878:	bcf8      	pop	{r3, r4, r5, r6, r7}
 811087a:	bc08      	pop	{r3}
 811087c:	469e      	mov	lr, r3
 811087e:	4770      	bx	lr
